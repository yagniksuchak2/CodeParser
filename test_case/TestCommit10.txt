commit df5025e9705e27b7c7d51a3387060d0026c79881
Author: Liu Liu <i@liuliu.me>
Date:   2012-09-30

    added read raw memory to ccv format support

diff --git a/lib/ccv.h b/lib/ccv.h
index 6fd9887..bce6af6 100644
--- a/lib/ccv.h
+++ b/lib/ccv.h
@@ -58,5 +58,6 @@ enum {
 enum {
-	CCV_GARBAGE   = 0x80000000, // matrix is in cache (not used by any functions)
-	CCV_REUSABLE  = 0x40000000, // matrix can be recycled
-	CCV_UNMANAGED = 0x20000000, // matrix is allocated by user, therefore, cannot be freed by ccv_matrix_free/ccv_matrix_free_immediately
+	CCV_GARBAGE       = 0x80000000, // matrix is in cache (not used by any functions)
+	CCV_REUSABLE      = 0x40000000, // matrix can be recycled
+	CCV_UNMANAGED     = 0x20000000, // matrix is allocated by user, therefore, cannot be freed by ccv_matrix_free/ccv_matrix_free_immediately
+	CCV_NO_DATA_ALLOC = 0x10000000, // matrix is allocated as header only, but with no data section, therefore, you have to free the data section separately
 };
@@ -300,3 +301,3 @@ enum {
 
-int ccv_read_impl(const char* in, ccv_dense_matrix_t** x, int type, int rows, int cols, int scanline);
+int ccv_read_impl(const void* in, ccv_dense_matrix_t** x, int type, int rows, int cols, int scanline);
 #define ccv_read_n(in, x, type, rows, cols, scanline, ...) \
diff --git a/lib/ccv_io.c b/lib/ccv_io.c
index 0239d81..9349c7d 100644
--- a/lib/ccv_io.c
+++ b/lib/ccv_io.c
@@ -76,4 +76,24 @@ static int _ccv_read_raw(ccv_dense_matrix_t** x, void* data, int type, int rows,
 		// there is no conversion that we can apply if it is NO_COPY mode
-		assert((type && 0xFF) == CCV_IO_ANY_RAW);
-		*x = ccv_dense_matrix_new(rows, cols, type, data, 0);
+		// NO_COPY mode generate an "unreusable" matrix, which requires you to
+		// manually release its data block (which is, in fact the same data
+		// block you passed in)
+		int ctype = CCV_8U | CCV_C1;
+		switch (type & 0xFF)
+		{
+			case CCV_IO_RGB_RAW:
+			case CCV_IO_BGR_RAW:
+				ctype = CCV_8U | CCV_C3;
+				break;
+			case CCV_IO_RGBA_RAW:
+			case CCV_IO_ARGB_RAW:
+			case CCV_IO_BGRA_RAW:
+			case CCV_IO_ABGR_RAW:
+				ctype = CCV_8U | CCV_C4;
+				break;
+			case CCV_IO_GRAY_RAW:
+			default:
+				/* default one */
+				break;
+		}
+		*x = ccv_dense_matrix_new(rows, cols, ctype | CCV_NO_DATA_ALLOC, data, 0);
 		(*x)->step = scanline;
@@ -86,10 +106,15 @@ static int _ccv_read_raw(ccv_dense_matrix_t** x, void* data, int type, int rows,
 			case CCV_IO_RGBA_RAW:
+				_ccv_read_rgba_raw(x, data, type, rows, cols, scanline);
 				break;
 			case CCV_IO_ARGB_RAW:
+				_ccv_read_argb_raw(x, data, type, rows, cols, scanline);
 				break;
 			case CCV_IO_BGR_RAW:
+				_ccv_read_bgr_raw(x, data, type, rows, cols, scanline);
 				break;
 			case CCV_IO_BGRA_RAW:
+				_ccv_read_bgra_raw(x, data, type, rows, cols, scanline);
 				break;
 			case CCV_IO_ABGR_RAW:
+				_ccv_read_abgr_raw(x, data, type, rows, cols, scanline);
 				break;
@@ -105,3 +130,3 @@ static int _ccv_read_raw(ccv_dense_matrix_t** x, void* data, int type, int rows,
 
-int ccv_read_impl(const char* in, ccv_dense_matrix_t** x, int type, int rows, int cols, int scanline)
+int ccv_read_impl(const void* in, ccv_dense_matrix_t** x, int type, int rows, int cols, int scanline)
 {
@@ -110,3 +135,4 @@ int ccv_read_impl(const char* in, ccv_dense_matrix_t** x, int type, int rows, in
 	{
-		fd = fopen(in, "rb");
+		assert(rows == 0 && cols == 0 && scanline == 0);
+		fd = fopen((const char*)in, "rb");
 		if (!fd)
@@ -115,3 +141,3 @@ int ccv_read_impl(const char* in, ccv_dense_matrix_t** x, int type, int rows, in
 	} else if (type & CCV_IO_ANY_STREAM) {
-		assert(rows > 8);
+		assert(rows > 8 && cols == 0 && scanline == 0);
 		assert((type & 0xFF) == CCV_IO_DEFLATE_STREAM); // deflate stream (compressed stream) is not supported yet
@@ -120,2 +146,3 @@ int ccv_read_impl(const char* in, ccv_dense_matrix_t** x, int type, int rows, in
 			return CCV_IO_ERROR;
+		// mimicking itself as a "file"
 		type = (type & ~0x10) | 0x20;
diff --git a/lib/ccv_memory.c b/lib/ccv_memory.c
index 6f79662..2962246 100644
--- a/lib/ccv_memory.c
+++ b/lib/ccv_memory.c
@@ -18,3 +18,3 @@ ccv_dense_matrix_t* ccv_dense_matrix_new(int rows, int cols, int type, void* dat
 	ccv_dense_matrix_t* mat;
-	if (ccv_cache_opt && sig != 0)
+	if (ccv_cache_opt && sig != 0 && !data && !(type & CCV_NO_DATA_ALLOC))
 	{
@@ -30,6 +30,14 @@ ccv_dense_matrix_t* ccv_dense_matrix_new(int rows, int cols, int type, void* dat
 	}
-	mat = (ccv_dense_matrix_t*)(data ? data : ccmalloc(ccv_compute_dense_matrix_size(rows, cols, type)));
+	if (type & CCV_NO_DATA_ALLOC)
+	{
+		mat = (ccv_dense_matrix_t*)ccmalloc(sizeof(ccv_dense_matrix_t));
+		mat->type = (CCV_GET_CHANNEL(type) | CCV_GET_DATA_TYPE(type) | CCV_MATRIX_DENSE | CCV_NO_DATA_ALLOC) & ~CCV_GARBAGE;
+		mat->data.u8 = data;
+	} else {
+		mat = (ccv_dense_matrix_t*)(data ? data : ccmalloc(ccv_compute_dense_matrix_size(rows, cols, type)));
+		mat->type = (CCV_GET_CHANNEL(type) | CCV_GET_DATA_TYPE(type) | CCV_MATRIX_DENSE) & ~CCV_GARBAGE;
+		mat->type |= data ? CCV_UNMANAGED : CCV_REUSABLE; // it still could be reusable because the signature could be derived one.
+		mat->data.u8 = (unsigned char*)(mat + 1);
+	}
 	mat->sig = sig;
-	mat->type = (CCV_GET_CHANNEL(type) | CCV_GET_DATA_TYPE(type) | CCV_MATRIX_DENSE) & ~CCV_GARBAGE;
-	mat->type |= data ? CCV_UNMANAGED : CCV_REUSABLE; // it still could be reusable because the signature could be derived one.
 	mat->rows = rows;
@@ -38,3 +46,2 @@ ccv_dense_matrix_t* ccv_dense_matrix_new(int rows, int cols, int type, void* dat
 	mat->refcount = 1;
-	mat->data.u8 = (unsigned char*)(mat + 1);
 	return mat;
@@ -163,3 +170,6 @@ void ccv_matrix_free(ccv_matrix_t* mat)
 		dmt->refcount = 0;
-		if (!ccv_cache_opt || !(dmt->type & CCV_REUSABLE) || dmt->sig == 0)
+		if (!ccv_cache_opt || // e don't enable cache
+			!(dmt->type & CCV_REUSABLE) || // or this is not a reusable piece
+			dmt->sig == 0 || // or this doesn't have valid signature
+			(dmt->type & CCV_NO_DATA_ALLOC)) // or this matrix is allocated as header-only, therefore we cannot cache it
 			ccfree(dmt);
diff --git a/lib/io/_ccv_io_raw.c b/lib/io/_ccv_io_raw.c
index 1c66149..28ff8d9 100644
--- a/lib/io/_ccv_io_raw.c
+++ b/lib/io/_ccv_io_raw.c
@@ -5,19 +5,312 @@ static void _ccv_read_rgb_raw(ccv_dense_matrix_t** x, const void* data, int type
 	int i, j;
-	unsigned char* x_ptr = dx->data.u8;
-	unsigned char* a_ptr = (unsigned char*)data;
-	if (type & CCV_IO_GRAY)
+	switch (type & 0xF00)
 	{
-		for (i = 0; i < rows; i++)
+		case CCV_IO_GRAY:
 		{
-			for (j = 0; j < cols; j++)
-				x_ptr[j] = (unsigned char)((a_ptr[j * 3] * 6969 + a_ptr[j * 3 + 1] * 23434 + a_ptr[j * 3 + 2] * 2365) >> 15);
-			a_ptr += scanline;
-			x_ptr += dx->step;
+			unsigned char* g = dx->data.u8;
+			unsigned char* rgb = (unsigned char*)data;
+			int rgb_padding = scanline - cols * 3;
+			assert(rgb_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					g[j] = (unsigned char)((rgb[0] * 6969 + rgb[1] * 23434 + rgb[2] * 2365) >> 15), rgb += 3;
+				rgb += rgb_padding;
+				g += dx->step;
+			}
+			break;
+		} 
+		case CCV_IO_RGB_COLOR:
+		default:
+		{
+			unsigned char* x_ptr = dx->data.u8;
+			unsigned char* a_ptr = (unsigned char*)data;
+			assert(scanline >= cols * 3);
+			for (i = 0; i < rows; i++)
+			{
+				memcpy(x_ptr, a_ptr, cols * 3);
+				a_ptr += scanline;
+				x_ptr += dx->step;
+			}
+			break;
+		}
+	}
+}
+
+static void _ccv_read_rgba_raw(ccv_dense_matrix_t** x, const void* data, int type, int rows, int cols, int scanline)
+{
+	int ctype = (type & 0xF00) ? CCV_8U | ((type & 0xF00) >> 8) : CCV_8U | CCV_C3;
+	ccv_dense_matrix_t* dx = *x = ccv_dense_matrix_new(rows, cols, ctype, 0, 0);
+	int i, j;
+	switch (type & 0xF00)
+	{
+		case CCV_IO_GRAY:
+		{
+			unsigned char* g = dx->data.u8;
+			unsigned char* rgba = (unsigned char*)data;
+			int rgba_padding = scanline - cols * 4;
+			assert(rgba_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					g[j] = (unsigned char)((rgba[0] * 6969 + rgba[1] * 23434 + rgba[2] * 2365) >> 15), rgba += 4;
+				rgba += rgba_padding;
+				g += dx->step;
+			}
+			break;
+		}
+		case CCV_IO_RGB_COLOR:
+		{
+			unsigned char* rgb = dx->data.u8;
+			int rgb_padding = dx->step - cols * 3;
+			assert(rgb_padding >= 0);
+			unsigned char* rgba = (unsigned char*)data;
+			int rgba_padding = scanline - cols * 4;
+			assert(rgba_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					rgb[0] = rgba[0], rgb[1] = rgba[1], rgb[2] = rgba[2],
+						rgb += 3, rgba += 4;
+				rgba += rgba_padding;
+				rgb += rgb_padding;
+			}
+			break;
+		}
+		default:
+		{
+			unsigned char* x_ptr = dx->data.u8;
+			unsigned char* a_ptr = (unsigned char*)data;
+			assert(scanline >= cols * 4);
+			for (i = 0; i < rows; i++)
+			{
+				memcpy(x_ptr, a_ptr, cols * 4);
+				a_ptr += scanline;
+				x_ptr += dx->step;
+			}
+			break;
+		}
+	}
+}
+
+static void _ccv_read_argb_raw(ccv_dense_matrix_t** x, const void* data, int type, int rows, int cols, int scanline)
+{
+	int ctype = (type & 0xF00) ? CCV_8U | ((type & 0xF00) >> 8) : CCV_8U | CCV_C3;
+	ccv_dense_matrix_t* dx = *x = ccv_dense_matrix_new(rows, cols, ctype, 0, 0);
+	int i, j;
+	switch (type & 0xF00)
+	{
+		case CCV_IO_GRAY:
+		{
+			unsigned char* g = dx->data.u8;
+			unsigned char* argb = (unsigned char*)data;
+			int argb_padding = scanline - cols * 4;
+			assert(argb_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					g[j] = (unsigned char)((argb[1] * 6969 + argb[2] * 23434 + argb[3] * 2365) >> 15), argb += 4;
+				argb += argb_padding;
+				g += dx->step;
+			}
+			break;
+		}
+		case CCV_IO_RGB_COLOR:
+		{
+			unsigned char* rgb = dx->data.u8;
+			int rgb_padding = dx->step - cols * 3;
+			assert(rgb_padding >= 0);
+			unsigned char* argb = (unsigned char*)data;
+			int argb_padding = scanline - cols * 4;
+			assert(argb_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					rgb[0] = argb[1], rgb[1] = argb[2], rgb[2] = argb[3],
+						rgb += 3, argb += 4;
+				argb += argb_padding;
+				rgb += rgb_padding;
+			}
+			break;
+		}
+		default:
+		{
+			unsigned char* x_ptr = dx->data.u8;
+			unsigned char* a_ptr = (unsigned char*)data;
+			assert(scanline >= cols * 4);
+			for (i = 0; i < rows; i++)
+			{
+				memcpy(x_ptr, a_ptr, cols * 4);
+				a_ptr += scanline;
+				x_ptr += dx->step;
+			}
+			break;
+		}
+	}
+}
+
+static void _ccv_read_bgr_raw(ccv_dense_matrix_t** x, const void* data, int type, int rows, int cols, int scanline)
+{
+	int ctype = (type & 0xF00) ? CCV_8U | ((type & 0xF00) >> 8) : CCV_8U | CCV_C3;
+	ccv_dense_matrix_t* dx = *x = ccv_dense_matrix_new(rows, cols, ctype, 0, 0);
+	int i, j;
+	switch (type & 0xF00)
+	{
+		case CCV_IO_GRAY:
+		{
+			unsigned char* g = dx->data.u8;
+			unsigned char* bgr = (unsigned char*)data;
+			int bgr_padding = scanline - cols * 3;
+			assert(bgr_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					g[j] = (unsigned char)((bgr[2] * 6969 + bgr[1] * 23434 + bgr[0] * 2365) >> 15), bgr += 3;
+				bgr += bgr_padding;
+				g += dx->step;
+			}
+			break;
+		}
+		case CCV_IO_RGB_COLOR:
+		{
+			unsigned char* rgb = dx->data.u8;
+			int rgb_padding = dx->step - cols * 3;
+			assert(rgb_padding >= 0);
+			unsigned char* bgr = (unsigned char*)data;
+			int bgr_padding = scanline - cols * 3;
+			assert(bgr_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					rgb[0] = bgr[2], rgb[1] = bgr[1], rgb[2] = bgr[0],
+						rgb += 3, bgr += 3;
+				bgr += bgr_padding;
+				rgb += rgb_padding;
+			}
+			break;
+		}
+		default:
+		{
+			unsigned char* x_ptr = dx->data.u8;
+			unsigned char* a_ptr = (unsigned char*)data;
+			assert(scanline >= cols * 3);
+			for (i = 0; i < rows; i++)
+			{
+				memcpy(x_ptr, a_ptr, cols * 3);
+				a_ptr += scanline;
+				x_ptr += dx->step;
+			}
+			break;
+		}
+	}
+}
+
+static void _ccv_read_bgra_raw(ccv_dense_matrix_t** x, const void* data, int type, int rows, int cols, int scanline)
+{
+	int ctype = (type & 0xF00) ? CCV_8U | ((type & 0xF00) >> 8) : CCV_8U | CCV_C3;
+	ccv_dense_matrix_t* dx = *x = ccv_dense_matrix_new(rows, cols, ctype, 0, 0);
+	int i, j;
+	switch (type & 0xF00)
+	{
+		case CCV_IO_GRAY:
+		{
+			unsigned char* g = dx->data.u8;
+			unsigned char* bgra = (unsigned char*)data;
+			int bgra_padding = scanline - cols * 4;
+			assert(bgra_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					g[j] = (unsigned char)((bgra[2] * 6969 + bgra[1] * 23434 + bgra[0] * 2365) >> 15), bgra += 4;
+				bgra += bgra_padding;
+				g += dx->step;
+			}
+			break;
+		}
+		case CCV_IO_RGB_COLOR:
+		{
+			unsigned char* rgb = dx->data.u8;
+			int rgb_padding = dx->step - cols * 3;
+			assert(rgb_padding >= 0);
+			unsigned char* bgra = (unsigned char*)data;
+			int bgra_padding = scanline - cols * 4;
+			assert(bgra_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					rgb[0] = bgra[2], rgb[1] = bgra[1], rgb[2] = bgra[0],
+						rgb += 3, bgra += 4;
+				bgra += bgra_padding;
+				rgb += rgb_padding;
+			}
+			break;
+		}
+		default:
+		{
+			unsigned char* x_ptr = dx->data.u8;
+			unsigned char* a_ptr = (unsigned char*)data;
+			assert(scanline >= cols * 4);
+			for (i = 0; i < rows; i++)
+			{
+				memcpy(x_ptr, a_ptr, cols * 4);
+				a_ptr += scanline;
+				x_ptr += dx->step;
+			}
+			break;
+		}
+	}
+}
+
+static void _ccv_read_abgr_raw(ccv_dense_matrix_t** x, const void* data, int type, int rows, int cols, int scanline)
+{
+	int ctype = (type & 0xF00) ? CCV_8U | ((type & 0xF00) >> 8) : CCV_8U | CCV_C3;
+	ccv_dense_matrix_t* dx = *x = ccv_dense_matrix_new(rows, cols, ctype, 0, 0);
+	int i, j;
+	switch (type & 0xF00)
+	{
+		case CCV_IO_GRAY:
+		{
+			unsigned char* g = dx->data.u8;
+			unsigned char* abgr = (unsigned char*)data;
+			int abgr_padding = scanline - cols * 4;
+			assert(abgr_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					g[j] = (unsigned char)((abgr[3] * 6969 + abgr[2] * 23434 + abgr[1] * 2365) >> 15), abgr += 4;
+				abgr += abgr_padding;
+				g += dx->step;
+			}
+			break;
+		}
+		case CCV_IO_RGB_COLOR:
+		{
+			unsigned char* rgb = dx->data.u8;
+			int rgb_padding = dx->step - cols * 3;
+			assert(rgb_padding >= 0);
+			unsigned char* abgr = (unsigned char*)data;
+			int abgr_padding = scanline - cols * 4;
+			assert(abgr_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					rgb[0] = abgr[3], rgb[1] = abgr[2], rgb[2] = abgr[1],
+						rgb += 3, abgr += 4;
+				abgr += abgr_padding;
+				rgb += rgb_padding;
+			}
+			break;
 		}
-	} else {
-		for (i = 0; i < rows; i++)
+		default:
 		{
-			memcpy(x_ptr, a_ptr, cols * 3);
-			a_ptr += scanline;
-			x_ptr += dx->step;
+			unsigned char* x_ptr = dx->data.u8;
+			unsigned char* a_ptr = (unsigned char*)data;
+			assert(scanline >= cols * 4);
+			for (i = 0; i < rows; i++)
+			{
+				memcpy(x_ptr, a_ptr, cols * 4);
+				a_ptr += scanline;
+				x_ptr += dx->step;
+			}
+			break;
 		}
@@ -31,19 +324,32 @@ static void _ccv_read_gray_raw(ccv_dense_matrix_t** x, const void* data, int typ
 	int i, j;
-	unsigned char* x_ptr = dx->data.u8;
-	unsigned char* a_ptr = (unsigned char*)data;
-	if (type & CCV_IO_GRAY)
+	switch (type & 0xF00)
 	{
-		for (i = 0; i < rows; i++)
+		case CCV_IO_RGB_COLOR:
 		{
-			memcpy(x_ptr, a_ptr, cols);
-			a_ptr += scanline;
-			x_ptr += dx->step;
+			unsigned char* rgb = dx->data.u8;
+			unsigned char* g = (unsigned char*)data;
+			int rgb_padding = dx->step - cols * 3;
+			assert(rgb_padding >= 0);
+			for (i = 0; i < rows; i++)
+			{
+				for (j = 0; j < cols; j++)
+					rgb[0] = rgb[1] = rgb[2] = g[j], rgb += 3;
+				g += scanline;
+				rgb += rgb_padding;
+			}
+			break;
 		}
-	} else {
-		for (i = 0; i < rows; i++)
+		case CCV_IO_GRAY:
+		default:
 		{
-			for (j = 0; j < cols; j++)
-				x_ptr[j * 3] = x_ptr[j * 3 + 1] = x_ptr[j * 3 + 2] = a_ptr[j];
-			a_ptr += scanline;
-			x_ptr += dx->step;
+			unsigned char* x_ptr = dx->data.u8;
+			unsigned char* a_ptr = (unsigned char*)data;
+			assert(scanline >= cols);
+			for (i = 0; i < rows; i++)
+			{
+				memcpy(x_ptr, a_ptr, cols);
+				a_ptr += scanline;
+				x_ptr += dx->step;
+			}
+			break;
 		}
diff --git a/test/functional/io.tests.c b/test/functional/io.tests.c
new file mode 100644
index 0000000..77b0d4f
--- /dev/null
+++ b/test/functional/io.tests.c
@@ -0,0 +1,337 @@
+#include "ccv.h"
+#include "case.h"
+#include "ccv_case.h"
+
+TEST_CASE("read raw memory, rgb => gray")
+{
+	unsigned char rgb[] = {
+		10, 20, 30, 40, 50, 60, 70,
+		80, 90, 15, 25, 35, 45, 55,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(rgb, &x, CCV_IO_RGB_RAW | CCV_IO_GRAY, 2, 2, 7);
+	unsigned char hx1[] = {
+		18, 48,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 2, "1st row when reading raw rgb ordered memory block into grayscale matrix doesn't match");
+	unsigned char hx2[] = {
+		82, 33,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 2, "2nd row when reading raw rgb ordered memory block into grayscale matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, rgb => rgb")
+{
+	unsigned char rgb[] = {
+		10, 20, 30, 40, 50, 60, 70,
+		80, 90, 15, 25, 35, 45, 55,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(rgb, &x, CCV_IO_RGB_RAW | CCV_IO_RGB_COLOR, 2, 2, 7);
+	REQUIRE_ARRAY_EQ(unsigned char, rgb, x->data.u8, 6, "1st row when reading raw rgb ordered memory block into rgb matrix doesn't match");
+	REQUIRE_ARRAY_EQ(unsigned char, rgb + 7, x->data.u8 + x->step, 6, "2nd row when reading raw rgb ordered memory block into rgb matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, rgba => rgb")
+{
+	unsigned char rgba[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(rgba, &x, CCV_IO_RGBA_RAW | CCV_IO_RGB_COLOR, 2, 2, 9);
+	unsigned char hx1[] = {
+		10, 20, 30, 50, 60, 70,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 6, "1st row when reading raw rgba memory block into rgb matrix doesn't match");
+	unsigned char hx2[] = {
+		15, 25, 35, 55, 65, 75,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 6, "2nd row when reading raw rgba memory block into rgb matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, rgba => gray")
+{
+	unsigned char rgba[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(rgba, &x, CCV_IO_RGBA_RAW | CCV_IO_GRAY, 2, 2, 9);
+	unsigned char hx1[] = {
+		18, 58,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 2, "1st row when reading raw rgba memory block into grayscale matrix doesn't match");
+	unsigned char hx2[] = {
+		23, 63,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 2, "2nd row when reading raw rgba memory block into grayscale matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, rgba => rgba")
+{
+	unsigned char rgba[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(rgba, &x, CCV_IO_RGBA_RAW, 2, 2, 9);
+	REQUIRE_ARRAY_EQ(unsigned char, rgba, x->data.u8, 8, "1st row when reading raw rgba memory block into rgba matrix doesn't match");
+	REQUIRE_ARRAY_EQ(unsigned char, rgba + 9, x->data.u8 + x->step, 8, "2nd row when reading raw rgba memory block into rgba matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, argb => rgb")
+{
+	unsigned char argb[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(argb, &x, CCV_IO_ARGB_RAW | CCV_IO_RGB_COLOR, 2, 2, 9);
+	unsigned char hx1[] = {
+		20, 30, 40, 60, 70, 80,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 6, "1st row when reading raw argb memory block into rgb matrix doesn't match");
+	unsigned char hx2[] = {
+		25, 35, 45, 65, 75, 85,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 6, "2nd row when reading raw argb memory block into rgb matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, argb => gray")
+{
+	unsigned char argb[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(argb, &x, CCV_IO_ARGB_RAW | CCV_IO_GRAY, 2, 2, 9);
+	unsigned char hx1[] = {
+		28, 68,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 2, "1st row when reading raw argb memory block into grayscale matrix doesn't match");
+	unsigned char hx2[] = {
+		33, 73,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 2, "2nd row when reading raw argb memory block into grayscale matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, argb => argb")
+{
+	unsigned char argb[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(argb, &x, CCV_IO_ARGB_RAW, 2, 2, 9);
+	REQUIRE_ARRAY_EQ(unsigned char, argb, x->data.u8, 8, "1st row when reading raw argb memory block into argb matrix doesn't match");
+	REQUIRE_ARRAY_EQ(unsigned char, argb + 9, x->data.u8 + x->step, 8, "2nd row when reading raw argb memory block into argb matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, bgr => gray")
+{
+	unsigned char bgr[] = {
+		10, 20, 30, 40, 50, 60, 70,
+		80, 90, 15, 25, 35, 45, 55,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(bgr, &x, CCV_IO_BGR_RAW | CCV_IO_GRAY, 2, 2, 7);
+	unsigned char hx1[] = {
+		21, 51,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 2, "1st row when reading raw bgr ordered memory block into grayscale matrix doesn't match");
+	unsigned char hx2[] = {
+		73, 36,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 2, "2nd row when reading raw bgr ordered memory block into grayscale matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, bgr => rgb")
+{
+	unsigned char bgr[] = {
+		10, 20, 30, 40, 50, 60, 70,
+		80, 90, 15, 25, 35, 45, 55,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(bgr, &x, CCV_IO_BGR_RAW | CCV_IO_RGB_COLOR, 2, 2, 7);
+	unsigned char hx1[] = {
+		30, 20, 10, 60, 50, 40,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 6, "1st row when reading raw bgr ordered memory block into rgb matrix doesn't match");
+	unsigned char hx2[] = {
+		15, 90, 80, 45, 35, 25,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 6, "2nd row when reading raw bgr ordered memory block into rgb matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, bgr => bgr")
+{
+	unsigned char bgr[] = {
+		10, 20, 30, 40, 50, 60, 70,
+		80, 90, 15, 25, 35, 45, 55,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(bgr, &x, CCV_IO_BGR_RAW, 2, 2, 7);
+	REQUIRE_ARRAY_EQ(unsigned char, bgr, x->data.u8, 6, "1st row when reading raw bgr ordered memory block into rgb matrix doesn't match");
+	REQUIRE_ARRAY_EQ(unsigned char, bgr + 7, x->data.u8 + x->step, 6, "2nd row when reading raw bgr ordered memory block into rgb matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, bgra => rgb")
+{
+	unsigned char bgra[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(bgra, &x, CCV_IO_BGRA_RAW | CCV_IO_RGB_COLOR, 2, 2, 9);
+	unsigned char hx1[] = {
+		30, 20, 10, 70, 60, 50,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 6, "1st row when reading raw bgra memory block into rgb matrix doesn't match");
+	unsigned char hx2[] = {
+		35, 25, 15, 75, 65, 55,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 6, "2nd row when reading raw bgra memory block into rgb matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, bgra => gray")
+{
+	unsigned char bgra[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(bgra, &x, CCV_IO_BGRA_RAW | CCV_IO_GRAY, 2, 2, 9);
+	unsigned char hx1[] = {
+		21, 61,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 2, "1st row when reading raw bgra memory block into grayscale matrix doesn't match");
+	unsigned char hx2[] = {
+		26, 66,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 2, "2nd row when reading raw bgra memory block into grayscale matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, bgra => bgra")
+{
+	unsigned char bgra[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(bgra, &x, CCV_IO_BGRA_RAW, 2, 2, 9);
+	REQUIRE_ARRAY_EQ(unsigned char, bgra, x->data.u8, 8, "1st row when reading raw bgra memory block into bgra matrix doesn't match");
+	REQUIRE_ARRAY_EQ(unsigned char, bgra + 9, x->data.u8 + x->step, 8, "2nd row when reading raw bgra memory block into bgra matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, abgr => rgb")
+{
+	unsigned char abgr[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(abgr, &x, CCV_IO_ABGR_RAW | CCV_IO_RGB_COLOR, 2, 2, 9);
+	unsigned char hx1[] = {
+		40, 30, 20, 80, 70, 60,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 6, "1st row when reading raw abgr memory block into rgb matrix doesn't match");
+	unsigned char hx2[] = {
+		45, 35, 25, 85, 75, 65,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 6, "2nd row when reading raw abgr memory block into rgb matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, abgr => gray")
+{
+	unsigned char abgr[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(abgr, &x, CCV_IO_ABGR_RAW | CCV_IO_GRAY, 2, 2, 9);
+	unsigned char hx1[] = {
+		31, 71,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 2, "1st row when reading raw abgr memory block into grayscale matrix doesn't match");
+	unsigned char hx2[] = {
+		36, 76,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 2, "2nd row when reading raw abgr memory block into grayscale matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, abgr => abgr")
+{
+	unsigned char abgr[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(abgr, &x, CCV_IO_ABGR_RAW, 2, 2, 9);
+	REQUIRE_ARRAY_EQ(unsigned char, abgr, x->data.u8, 8, "1st row when reading raw abgr memory block into abgr matrix doesn't match");
+	REQUIRE_ARRAY_EQ(unsigned char, abgr + 9, x->data.u8 + x->step, 8, "2nd row when reading raw abgr memory block into abgr matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, gray => rgb")
+{
+	unsigned char g[] = {
+		10, 20, 30, 40, 50,
+		15, 25, 35, 45, 55,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(g, &x, CCV_IO_GRAY_RAW | CCV_IO_RGB_COLOR, 2, 2, 5);
+	unsigned char hx1[] = {
+		10, 10, 10, 20, 20, 20,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx1, x->data.u8, 6, "1st row when reading raw grayscale memory block into rgb matrix doesn't match");
+	unsigned char hx2[] = {
+		15, 15, 15, 25, 25, 25,
+	};
+	REQUIRE_ARRAY_EQ(unsigned char, hx2, x->data.u8 + x->step, 6, "2nd row when reading raw grayscale memory block into rgb matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory, gray => gray")
+{
+	unsigned char g[] = {
+		10, 20, 30, 40, 50,
+		15, 25, 35, 45, 55,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(g, &x, CCV_IO_GRAY_RAW | CCV_IO_GRAY, 2, 2, 5);
+	REQUIRE_ARRAY_EQ(unsigned char, g, x->data.u8, 2, "1st row when reading raw grayscale memory block into grayscale matrix doesn't match");
+	REQUIRE_ARRAY_EQ(unsigned char, g + 5, x->data.u8 + x->step, 2, "2nd row when reading raw grayscale memory block into grayscale matrix doesn't match");
+	ccv_matrix_free(x);
+}
+
+TEST_CASE("read raw memory with no copy mode")
+{
+	unsigned char rgb[] = {
+		10, 20, 30, 40, 50, 60, 70, 80, 90,
+		15, 25, 35, 45, 55, 65, 75, 85, 95,
+	};
+	ccv_dense_matrix_t* x = 0;
+	ccv_read(rgb, &x, CCV_IO_ANY_RAW | CCV_IO_NO_COPY, 2, 2, 9);
+	REQUIRE_EQ(9, x->step, "its step value should be equal to the passing scanline value in no copy mode");
+	REQUIRE(rgb == x->data.u8, "its data section should point to the same memory region");
+	ccv_matrix_free(x);
+}
+
+#include "case_main.h"
