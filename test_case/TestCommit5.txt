commit 4e9cb43928abbddd5d683cb5d9d66c72b3bbf88e
Author: Lars Op den Kamp <lars@opdenkamp.eu>
Date:   2012-09-01

    [pvr] added PVR support to XBMC (taken from https://github.com/opdenkamp/xbmc/commit/c576c080532a0e4c4ffc7babd57782f80a6951ba)
    add-ons are not included, but can be found here: https://github.com/opdenkamp/xbmc-pvr-addons

diff --git a/addons/library.xbmc.addon/dlfcn-win32.cpp b/addons/library.xbmc.addon/dlfcn-win32.cpp
new file mode 100644
index 0000000..5839921
--- /dev/null
+++ b/addons/library.xbmc.addon/dlfcn-win32.cpp
@@ -0,0 +1,263 @@
+/*
+ * dlfcn-win32
+ * Copyright (c) 2007 Ramiro Polla
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <windows.h>
+#include <stdio.h>
+
+#include "dlfcn-win32.h"
+
+/* Note:
+ * MSDN says these functions are not thread-safe. We make no efforts to have
+ * any kind of thread safety.
+ */
+
+/* I have no special reason to have set MAX_GLOBAL_OBJECTS to this value. Any
+ * comments are welcome.
+ */
+#define MAX_OBJECTS 255
+
+static HMODULE global_objects[MAX_OBJECTS];
+
+/* This function adds an object to the list of global objects.
+ * The implementation is very simple and slow.
+ * TODO: should failing this function be enough to fail the call to dlopen( )?
+ */
+static void global_object_add( HMODULE hModule )
+{
+    int i;
+
+    for( i = 0 ; i < MAX_OBJECTS ; i++ )
+    {
+        if( !global_objects[i] )
+        {
+            global_objects[i] = hModule;
+            break;
+        }
+    }
+}
+
+static void global_object_rem( HMODULE hModule )
+{
+    int i;
+
+    for( i = 0 ; i < MAX_OBJECTS ; i++ )
+    {
+        if( global_objects[i] == hModule )
+        {
+            global_objects[i] = 0;
+            break;
+        }
+    }
+}
+
+/* Argument to last function. Used in dlerror( ) */
+static char last_name[MAX_PATH];
+
+static int copy_string( char *dest, int dest_size, const char *src )
+{
+    int i = 0;
+
+    if( src && dest )
+    {
+        for( i = 0 ; i < dest_size-1 ; i++ )
+        {
+            if( !src[i] )
+                break;
+            else
+                dest[i] = src[i];
+        }
+    }
+    dest[i] = '\0';
+
+    return i;
+}
+
+void *dlopen( const char *file, int mode )
+{
+    HMODULE hModule;
+    UINT uMode;
+
+    /* Do not let Windows display the critical-error-handler message box */
+    uMode = SetErrorMode( SEM_FAILCRITICALERRORS );
+
+    if( file == 0 )
+    {
+        /* Save NULL pointer for error message */
+        _snprintf_s( last_name, MAX_PATH, MAX_PATH, "0x%p", file );
+
+        /* POSIX says that if the value of file is 0, a handle on a global
+         * symbol object must be provided. That object must be able to access
+         * all symbols from the original program file, and any objects loaded
+         * with the RTLD_GLOBAL flag.
+         * The return value from GetModuleHandle( ) allows us to retrieve
+         * symbols only from the original program file. For objects loaded with
+         * the RTLD_GLOBAL flag, we create our own list later on.
+         */
+        hModule = GetModuleHandle( NULL );
+    }
+    else
+    {
+        char lpFileName[MAX_PATH];
+        int i;
+
+        /* MSDN says backslashes *must* be used instead of forward slashes. */
+        for( i = 0 ; i < sizeof(lpFileName)-1 ; i++ )
+        {
+            if( !file[i] )
+                break;
+            else if( file[i] == '/' )
+                lpFileName[i] = '\\';
+            else
+                lpFileName[i] = file[i];
+        }
+        lpFileName[i] = '\0';
+
+        /* Save file name for error message */
+        copy_string( last_name, sizeof(last_name), lpFileName );
+
+        /* POSIX says the search path is implementation-defined.
+         * LOAD_WITH_ALTERED_SEARCH_PATH is used to make it behave more closely
+         * to UNIX's search paths (start with system folders instead of current
+         * folder).
+         */
+        hModule = LoadLibraryEx( (LPSTR) lpFileName, NULL,
+                                 LOAD_WITH_ALTERED_SEARCH_PATH );
+        /* If the object was loaded with RTLD_GLOBAL, add it to list of global
+         * objects, so that its symbols may be retrieved even if the handle for
+         * the original program file is passed. POSIX says that if the same
+         * file is specified in multiple invocations, and any of them are
+         * RTLD_GLOBAL, even if any further invocations use RTLD_LOCAL, the
+         * symbols will remain global.
+         */
+
+        if( hModule && (mode & RTLD_GLOBAL) )
+            global_object_add( hModule );
+    }
+
+    /* Return to previous state of the error-mode bit flags. */
+    SetErrorMode( uMode );
+
+    return (void *) hModule;
+}
+
+int dlclose( void *handle )
+{
+    HMODULE hModule = (HMODULE) handle;
+    BOOL ret;
+
+    /* Save handle for error message */
+    _snprintf_s( last_name, MAX_PATH, MAX_PATH, "0x%p", handle );
+
+    ret = FreeLibrary( hModule );
+
+    /* If the object was loaded with RTLD_GLOBAL, remove it from list of global
+     * objects.
+     */
+    if( ret )
+        global_object_rem( hModule );
+
+    /* dlclose's return value in inverted in relation to FreeLibrary's. */
+    ret = !ret;
+
+    return (int) ret;
+}
+
+void *dlsym( void *handle, const char *name )
+{
+    FARPROC symbol;
+    HMODULE myhandle = (HMODULE) handle;
+
+    /* Save symbol name for error message */
+    copy_string( last_name, sizeof(last_name), name );
+
+    symbol = GetProcAddress( myhandle, name );
+#if 0
+    if( symbol == NULL )
+    {
+        HMODULE hModule;
+
+        /* If the handle for the original program file is passed, also search
+         * in all globally loaded objects.
+         */
+
+        hModule = GetModuleHandle( NULL );
+
+        if( hModule == handle )
+        {
+            int i;
+           
+            for( i = 0 ; i < MAX_OBJECTS ; i++ )
+            {
+                if( global_objects[i] != 0 )
+                {
+                    symbol = GetProcAddress( global_objects[i], name );
+                    if( symbol != NULL )
+                        break;
+                }
+            }
+        }
+
+
+        CloseHandle( hModule );
+    }
+#endif
+    return (void*) symbol;
+}
+
+char *dlerror( void )
+{
+    DWORD dwMessageId;
+    /* POSIX says this function doesn't have to be thread-safe, so we use one
+     * static buffer.
+     * MSDN says the buffer cannot be larger than 64K bytes, so we set it to
+     * the limit.
+     */
+    static char lpBuffer[65535];
+    DWORD ret;
+
+    dwMessageId = GetLastError( );
+   
+    if( dwMessageId == 0 )
+        return NULL;
+
+    /* Format error message to:
+     * "<argument to function that failed>": <Windows localized error message>
+     */
+    ret  = copy_string( lpBuffer, sizeof(lpBuffer), "\"" );
+    ret += copy_string( lpBuffer+ret, sizeof(lpBuffer)-ret, last_name );
+    ret += copy_string( lpBuffer+ret, sizeof(lpBuffer)-ret, "\": " );
+    ret += FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwMessageId,
+                          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
+                          lpBuffer+ret, sizeof(lpBuffer)-ret, NULL );
+
+    if( ret > 1 )
+    {
+        /* POSIX says the string must not have trailing <newline> */
+        if( lpBuffer[ret-2] == '\r' && lpBuffer[ret-1] == '\n' )
+            lpBuffer[ret-2] = '\0';
+    }
+
+    /* POSIX says that invoking dlerror( ) a second time, immediately following
+     * a prior invocation, shall result in NULL being returned.
+     */
+    SetLastError(0);
+
+    return lpBuffer;
+}
+
diff --git a/lib/addons/library.xbmc.addon/libXBMC_addon.cpp b/lib/addons/library.xbmc.addon/libXBMC_addon.cpp
new file mode 100644
index 0000000..8d8f026
--- /dev/null
+++ b/lib/addons/library.xbmc.addon/libXBMC_addon.cpp
@@ -0,0 +1,128 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string>
+#include "../../../addons/library.xbmc.addon/libXBMC_addon.h"
+#include "../../../xbmc/addons/AddonCallbacks.h"
+
+#ifdef _WIN32
+#include <windows.h>
+#define DLLEXPORT __declspec(dllexport)
+#else
+#define DLLEXPORT
+#endif
+
+
+using namespace std;
+using namespace ADDON;
+
+AddonCB *m_Handle = NULL;
+CB_AddOnLib *m_cb = NULL;
+
+extern "C"
+{
+
+DLLEXPORT int XBMC_register_me(void *hdl)
+{
+  if (!hdl)
+    fprintf(stderr, "libXBMC_addon-ERROR: XBMC_register_me is called with NULL handle !!!\n");
+  else
+  {
+    m_Handle = (AddonCB*) hdl;
+    m_cb     = m_Handle->AddOnLib_RegisterMe(m_Handle->addonData);
+    if (!m_cb)
+      fprintf(stderr, "libXBMC_addon-ERROR: XBMC_register_me can't get callback table from XBMC !!!\n");
+    else
+      return 1;
+  }
+  return 0;
+}
+
+DLLEXPORT void XBMC_unregister_me()
+{
+  if (m_Handle && m_cb)
+    m_Handle->AddOnLib_UnRegisterMe(m_Handle->addonData, m_cb);
+}
+
+DLLEXPORT void XBMC_log(const addon_log_t loglevel, const char *format, ... )
+{
+  if (m_cb == NULL)
+    return;
+
+  char buffer[16384];
+  va_list args;
+  va_start (args, format);
+  vsprintf (buffer, format, args);
+  va_end (args);
+  m_cb->Log(m_Handle->addonData, loglevel, buffer);
+}
+
+DLLEXPORT bool XBMC_get_setting(const char* settingName, void *settingValue)
+{
+  if (m_cb == NULL)
+    return false;
+
+  return m_cb->GetSetting(m_Handle->addonData, settingName, settingValue);
+}
+
+DLLEXPORT void XBMC_queue_notification(const queue_msg_t type, const char *format, ... )
+{
+  if (m_cb == NULL)
+    return;
+
+  char buffer[16384];
+  va_list args;
+  va_start (args, format);
+  vsprintf (buffer, format, args);
+  va_end (args);
+  m_cb->QueueNotification(m_Handle->addonData, type, buffer);
+}
+
+DLLEXPORT void XBMC_unknown_to_utf8(string &str)
+{
+  if (m_cb == NULL)
+    return;
+
+  string buffer = m_cb->UnknownToUTF8(str.c_str());
+  str = buffer;
+}
+
+DLLEXPORT const char* XBMC_get_localized_string(int dwCode)
+{
+  if (m_cb == NULL)
+    return "";
+
+  return m_cb->GetLocalizedString(m_Handle->addonData, dwCode);
+}
+
+DLLEXPORT const char* XBMC_get_dvd_menu_language()
+{
+  if (m_cb == NULL)
+    return "";
+
+  string buffer = m_cb->GetDVDMenuLanguage(m_Handle->addonData);
+  return buffer.c_str();
+}
+
+};
diff --git a/lib/addons/library.xbmc.gui/libXBMC_gui.cpp b/lib/addons/library.xbmc.gui/libXBMC_gui.cpp
new file mode 100644
index 0000000..752c248
--- /dev/null
+++ b/lib/addons/library.xbmc.gui/libXBMC_gui.cpp
@@ -0,0 +1,555 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string>
+#include "../../../addons/library.xbmc.gui/libXBMC_gui.h"
+#include "addons/AddonCallbacks.h"
+
+#ifdef _WIN32
+#include <windows.h>
+#define DLLEXPORT __declspec(dllexport)
+#else
+#define DLLEXPORT
+#endif
+
+using namespace std;
+
+AddonCB *m_Handle = NULL;
+CB_GUILib *m_cb   = NULL;
+
+extern "C"
+{
+
+DLLEXPORT int GUI_register_me(void *hdl)
+{
+  if (!hdl)
+    fprintf(stderr, "libXBMC_gui-ERROR: GUILib_register_me is called with NULL handle !!!\n");
+  else
+  {
+    m_Handle = (AddonCB*) hdl;
+    m_cb     = m_Handle->GUILib_RegisterMe(m_Handle->addonData);
+    if (!m_cb)
+      fprintf(stderr, "libXBMC_gui-ERROR: GUILib_register_me can't get callback table from XBMC !!!\n");
+    else
+      return 1;
+  }
+  return 0;
+}
+
+DLLEXPORT void GUI_unregister_me()
+{
+  if (m_Handle && m_cb)
+    m_Handle->GUILib_UnRegisterMe(m_Handle->addonData, m_cb);
+}
+
+DLLEXPORT void GUI_lock()
+{
+  m_cb->Lock();
+}
+
+DLLEXPORT void GUI_unlock()
+{
+  m_cb->Unlock();
+}
+
+DLLEXPORT int GUI_get_screen_height()
+{
+  return m_cb->GetScreenHeight();
+}
+
+DLLEXPORT int GUI_get_screen_width()
+{
+  return m_cb->GetScreenWidth();
+}
+
+DLLEXPORT int GUI_get_video_resolution()
+{
+  return m_cb->GetVideoResolution();
+}
+
+DLLEXPORT CAddonGUIWindow* GUI_Window_create(const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog)
+{
+  return new CAddonGUIWindow(xmlFilename, defaultSkin, forceFallback, asDialog);
+}
+
+DLLEXPORT void GUI_Window_destroy(CAddonGUIWindow* p)
+{
+  delete p;
+}
+
+DLLEXPORT bool GUI_Window_OnClick(GUIHANDLE handle, int controlId)
+{
+  CAddonGUIWindow *window = (CAddonGUIWindow*) handle;
+  return window->OnClick(controlId);
+}
+
+DLLEXPORT bool GUI_Window_OnFocus(GUIHANDLE handle, int controlId)
+{
+  CAddonGUIWindow *window = (CAddonGUIWindow*) handle;
+  return window->OnFocus(controlId);
+}
+
+DLLEXPORT bool GUI_Window_OnInit(GUIHANDLE handle)
+{
+  CAddonGUIWindow *window = (CAddonGUIWindow*) handle;
+  return window->OnInit();
+}
+
+DLLEXPORT bool GUI_Window_OnAction(GUIHANDLE handle, int actionId)
+{
+  CAddonGUIWindow *window = (CAddonGUIWindow*) handle;
+  return window->OnAction(actionId);
+}
+
+
+CAddonGUIWindow::CAddonGUIWindow(const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog)
+{
+  CBOnInit = NULL;
+  CBOnClick = NULL;
+  CBOnFocus = NULL;
+  if (m_Handle && m_cb)
+  {
+    m_WindowHandle = m_cb->Window_New(m_Handle->addonData, xmlFilename, defaultSkin, forceFallback, asDialog);
+    if (!m_WindowHandle)
+      fprintf(stderr, "libXBMC_gui-ERROR: cGUIWindow can't create window class from XBMC !!!\n");
+
+    m_cb->Window_SetCallbacks(m_Handle->addonData, m_WindowHandle, this, GUI_Window_OnInit, GUI_Window_OnClick, GUI_Window_OnFocus, GUI_Window_OnAction);
+  }
+}
+
+CAddonGUIWindow::~CAddonGUIWindow()
+{
+  if (m_Handle && m_cb && m_WindowHandle)
+  {
+    m_cb->Window_Delete(m_Handle->addonData, m_WindowHandle);
+    m_WindowHandle = NULL;
+  }
+}
+
+bool CAddonGUIWindow::Show()
+{
+  return m_cb->Window_Show(m_Handle->addonData, m_WindowHandle);
+}
+
+void CAddonGUIWindow::Close()
+{
+  m_cb->Window_Close(m_Handle->addonData, m_WindowHandle);
+}
+
+void CAddonGUIWindow::DoModal()
+{
+  m_cb->Window_DoModal(m_Handle->addonData, m_WindowHandle);
+}
+
+bool CAddonGUIWindow::OnInit()
+{
+  if (!CBOnInit)
+    return false;
+
+  return CBOnInit(m_cbhdl);
+}
+
+bool CAddonGUIWindow::OnClick(int controlId)
+{
+  if (!CBOnClick)
+    return false;
+
+  return CBOnClick(m_cbhdl, controlId);
+}
+
+bool CAddonGUIWindow::OnFocus(int controlId)
+{
+  if (!CBOnFocus)
+    return false;
+
+  return CBOnFocus(m_cbhdl, controlId);
+}
+
+bool CAddonGUIWindow::OnAction(int actionId)
+{
+  if (!CBOnAction)
+    return false;
+
+  return CBOnAction(m_cbhdl, actionId);
+}
+
+bool CAddonGUIWindow::SetFocusId(int iControlId)
+{
+  return m_cb->Window_SetFocusId(m_Handle->addonData, m_WindowHandle, iControlId);
+}
+
+int CAddonGUIWindow::GetFocusId()
+{
+  return m_cb->Window_GetFocusId(m_Handle->addonData, m_WindowHandle);
+}
+
+bool CAddonGUIWindow::SetCoordinateResolution(int res)
+{
+  return m_cb->Window_SetCoordinateResolution(m_Handle->addonData, m_WindowHandle, res);
+}
+
+void CAddonGUIWindow::SetProperty(const char *key, const char *value)
+{
+  m_cb->Window_SetProperty(m_Handle->addonData, m_WindowHandle, key, value);
+}
+
+void CAddonGUIWindow::SetPropertyInt(const char *key, int value)
+{
+  m_cb->Window_SetPropertyInt(m_Handle->addonData, m_WindowHandle, key, value);
+}
+
+void CAddonGUIWindow::SetPropertyBool(const char *key, bool value)
+{
+  m_cb->Window_SetPropertyBool(m_Handle->addonData, m_WindowHandle, key, value);
+}
+
+void CAddonGUIWindow::SetPropertyDouble(const char *key, double value)
+{
+  m_cb->Window_SetPropertyDouble(m_Handle->addonData, m_WindowHandle, key, value);
+}
+
+const char *CAddonGUIWindow::GetProperty(const char *key) const
+{
+  return m_cb->Window_GetProperty(m_Handle->addonData, m_WindowHandle, key);
+}
+
+int CAddonGUIWindow::GetPropertyInt(const char *key) const
+{
+  return m_cb->Window_GetPropertyInt(m_Handle->addonData, m_WindowHandle, key);
+}
+
+bool CAddonGUIWindow::GetPropertyBool(const char *key) const
+{
+  return m_cb->Window_GetPropertyBool(m_Handle->addonData, m_WindowHandle, key);
+}
+
+double CAddonGUIWindow::GetPropertyDouble(const char *key) const
+{
+  return m_cb->Window_GetPropertyDouble(m_Handle->addonData, m_WindowHandle, key);
+}
+
+void CAddonGUIWindow::ClearProperties()
+{
+  m_cb->Window_ClearProperties(m_Handle->addonData, m_WindowHandle);
+}
+
+int CAddonGUIWindow::GetListSize()
+{
+  return m_cb->Window_GetListSize(m_Handle->addonData, m_WindowHandle);
+}
+
+void CAddonGUIWindow::ClearList()
+{
+  m_cb->Window_ClearList(m_Handle->addonData, m_WindowHandle);
+}
+
+GUIHANDLE CAddonGUIWindow::AddStringItem(const char *name, int itemPosition)
+{
+  return m_cb->Window_AddStringItem(m_Handle->addonData, m_WindowHandle, name, itemPosition);
+}
+
+void CAddonGUIWindow::AddItem(GUIHANDLE item, int itemPosition)
+{
+  m_cb->Window_AddItem(m_Handle->addonData, m_WindowHandle, item, itemPosition);
+}
+
+void CAddonGUIWindow::AddItem(CAddonListItem *item, int itemPosition)
+{
+  m_cb->Window_AddItem(m_Handle->addonData, m_WindowHandle, item->m_ListItemHandle, itemPosition);
+}
+
+void CAddonGUIWindow::RemoveItem(int itemPosition)
+{
+  m_cb->Window_RemoveItem(m_Handle->addonData, m_WindowHandle, itemPosition);
+}
+
+GUIHANDLE CAddonGUIWindow::GetListItem(int listPos)
+{
+  return m_cb->Window_GetListItem(m_Handle->addonData, m_WindowHandle, listPos);
+}
+
+void CAddonGUIWindow::SetCurrentListPosition(int listPos)
+{
+  m_cb->Window_SetCurrentListPosition(m_Handle->addonData, m_WindowHandle, listPos);
+}
+
+int CAddonGUIWindow::GetCurrentListPosition()
+{
+  return m_cb->Window_GetCurrentListPosition(m_Handle->addonData, m_WindowHandle);
+}
+
+void CAddonGUIWindow::SetControlLabel(int controlId, const char *label)
+{
+  m_cb->Window_SetControlLabel(m_Handle->addonData, m_WindowHandle, controlId, label);
+}
+
+///-------------------------------------
+/// cGUISpinControl
+
+DLLEXPORT CAddonGUISpinControl* GUI_control_get_spin(CAddonGUIWindow *window, int controlId)
+{
+  return new CAddonGUISpinControl(window, controlId);
+}
+
+DLLEXPORT void GUI_control_release_spin(CAddonGUISpinControl* p)
+{
+  delete p;
+}
+
+CAddonGUISpinControl::CAddonGUISpinControl(CAddonGUIWindow *window, int controlId)
+ : m_Window(window)
+ , m_ControlId(controlId)
+{
+  m_SpinHandle = m_cb->Window_GetControl_Spin(m_Handle->addonData, m_Window->m_WindowHandle, controlId);
+}
+
+void CAddonGUISpinControl::SetVisible(bool yesNo)
+{
+  if (m_SpinHandle)
+    m_cb->Control_Spin_SetVisible(m_Handle->addonData, m_SpinHandle, yesNo);
+}
+
+void CAddonGUISpinControl::SetText(const char *label)
+{
+  if (m_SpinHandle)
+    m_cb->Control_Spin_SetText(m_Handle->addonData, m_SpinHandle, label);
+}
+
+void CAddonGUISpinControl::Clear()
+{
+  if (m_SpinHandle)
+    m_cb->Control_Spin_Clear(m_Handle->addonData, m_SpinHandle);
+}
+
+void CAddonGUISpinControl::AddLabel(const char *label, int iValue)
+{
+  if (m_SpinHandle)
+    m_cb->Control_Spin_AddLabel(m_Handle->addonData, m_SpinHandle, label, iValue);
+}
+
+int CAddonGUISpinControl::GetValue()
+{
+  if (!m_SpinHandle)
+    return -1;
+
+  return m_cb->Control_Spin_GetValue(m_Handle->addonData, m_SpinHandle);
+}
+
+void CAddonGUISpinControl::SetValue(int iValue)
+{
+  if (m_SpinHandle)
+    m_cb->Control_Spin_SetValue(m_Handle->addonData, m_SpinHandle, iValue);
+}
+
+///-------------------------------------
+/// cGUIRadioButton
+
+DLLEXPORT CAddonGUIRadioButton* GUI_control_get_radiobutton(CAddonGUIWindow *window, int controlId)
+{
+  return new CAddonGUIRadioButton(window, controlId);
+}
+
+DLLEXPORT void GUI_control_release_radiobutton(CAddonGUIRadioButton* p)
+{
+  delete p;
+}
+
+CAddonGUIRadioButton::CAddonGUIRadioButton(CAddonGUIWindow *window, int controlId)
+ : m_Window(window)
+ , m_ControlId(controlId)
+{
+  m_ButtonHandle = m_cb->Window_GetControl_RadioButton(m_Handle->addonData, m_Window->m_WindowHandle, controlId);
+}
+
+void CAddonGUIRadioButton::SetVisible(bool yesNo)
+{
+  if (m_ButtonHandle)
+    m_cb->Control_RadioButton_SetVisible(m_Handle->addonData, m_ButtonHandle, yesNo);
+}
+
+void CAddonGUIRadioButton::SetText(const char *label)
+{
+  if (m_ButtonHandle)
+    m_cb->Control_RadioButton_SetText(m_Handle->addonData, m_ButtonHandle, label);
+}
+
+void CAddonGUIRadioButton::SetSelected(bool yesNo)
+{
+  if (m_ButtonHandle)
+    m_cb->Control_RadioButton_SetSelected(m_Handle->addonData, m_ButtonHandle, yesNo);
+}
+
+bool CAddonGUIRadioButton::IsSelected()
+{
+  if (!m_ButtonHandle)
+    return false;
+
+  return m_cb->Control_RadioButton_IsSelected(m_Handle->addonData, m_ButtonHandle);
+}
+
+
+///-------------------------------------
+/// cGUIProgressControl
+
+DLLEXPORT CAddonGUIProgressControl* GUI_control_get_progress(CAddonGUIWindow *window, int controlId)
+{
+  return new CAddonGUIProgressControl(window, controlId);
+}
+
+DLLEXPORT void GUI_control_release_progress(CAddonGUIProgressControl* p)
+{
+  delete p;
+}
+
+CAddonGUIProgressControl::CAddonGUIProgressControl(CAddonGUIWindow *window, int controlId)
+ : m_Window(window)
+ , m_ControlId(controlId)
+{
+  m_ProgressHandle = m_cb->Window_GetControl_Progress(m_Handle->addonData, m_Window->m_WindowHandle, controlId);
+}
+
+void CAddonGUIProgressControl::SetPercentage(float fPercent)
+{
+  if (m_ProgressHandle)
+    m_cb->Control_Progress_SetPercentage(m_Handle->addonData, m_ProgressHandle, fPercent);
+}
+
+float CAddonGUIProgressControl::GetPercentage() const
+{
+  if (!m_ProgressHandle)
+    return 0.0;
+
+  return m_cb->Control_Progress_GetPercentage(m_Handle->addonData, m_ProgressHandle);
+}
+
+void CAddonGUIProgressControl::SetInfo(int iInfo)
+{
+  if (m_ProgressHandle)
+    m_cb->Control_Progress_SetInfo(m_Handle->addonData, m_ProgressHandle, iInfo);
+}
+
+int CAddonGUIProgressControl::GetInfo() const
+{
+  if (!m_ProgressHandle)
+    return -1;
+
+  return m_cb->Control_Progress_GetInfo(m_Handle->addonData, m_ProgressHandle);
+}
+
+string CAddonGUIProgressControl::GetDescription() const
+{
+  if (!m_ProgressHandle)
+    return "";
+
+  return m_cb->Control_Progress_GetDescription(m_Handle->addonData, m_ProgressHandle);
+}
+
+
+///-------------------------------------
+/// cListItem
+
+DLLEXPORT CAddonListItem* GUI_ListItem_create(const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path)
+{
+  return new CAddonListItem(label, label2, iconImage, thumbnailImage, path);
+}
+
+DLLEXPORT void GUI_ListItem_destroy(CAddonListItem* p)
+{
+  delete p;
+}
+
+
+CAddonListItem::CAddonListItem(const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path)
+{
+  m_ListItemHandle = m_cb->ListItem_Create(m_Handle->addonData, label, label2, iconImage, thumbnailImage, path);
+}
+
+const char *CAddonListItem::GetLabel()
+{
+  if (!m_ListItemHandle)
+    return "";
+
+  return m_cb->ListItem_GetLabel(m_Handle->addonData, m_ListItemHandle);
+}
+
+void CAddonListItem::SetLabel(const char *label)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetLabel(m_Handle->addonData, m_ListItemHandle, label);
+}
+
+const char *CAddonListItem::GetLabel2()
+{
+  if (!m_ListItemHandle)
+    return "";
+
+  return m_cb->ListItem_GetLabel2(m_Handle->addonData, m_ListItemHandle);
+}
+
+void CAddonListItem::SetLabel2(const char *label)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetLabel2(m_Handle->addonData, m_ListItemHandle, label);
+}
+
+void CAddonListItem::SetIconImage(const char *image)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetIconImage(m_Handle->addonData, m_ListItemHandle, image);
+}
+
+void CAddonListItem::SetThumbnailImage(const char *image)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetThumbnailImage(m_Handle->addonData, m_ListItemHandle, image);
+}
+
+void CAddonListItem::SetInfo(const char *Info)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetInfo(m_Handle->addonData, m_ListItemHandle, Info);
+}
+
+void CAddonListItem::SetProperty(const char *key, const char *value)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetProperty(m_Handle->addonData, m_ListItemHandle, key, value);
+}
+
+const char *CAddonListItem::GetProperty(const char *key) const
+{
+  if (!m_ListItemHandle)
+    return "";
+
+  return m_cb->ListItem_GetProperty(m_Handle->addonData, m_ListItemHandle, key);
+}
+
+void CAddonListItem::SetPath(const char *Path)
+{
+  if (m_ListItemHandle)
+    m_cb->ListItem_SetPath(m_Handle->addonData, m_ListItemHandle, Path);
+}
+
+
+};
diff --git a/lib/addons/library.xbmc.pvr/libXBMC_pvr.cpp b/lib/addons/library.xbmc.pvr/libXBMC_pvr.cpp
new file mode 100644
index 0000000..8ef4b59
--- /dev/null
+++ b/lib/addons/library.xbmc.pvr/libXBMC_pvr.cpp
@@ -0,0 +1,181 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#define USE_DEMUX // enable including of the demuxer packet structure
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string>
+#include "../../../addons/library.xbmc.pvr/libXBMC_pvr.h"
+#include "addons/AddonCallbacks.h"
+#include "cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h"
+
+#ifdef _WIN32
+#include <windows.h>
+#define DLLEXPORT __declspec(dllexport)
+#else
+#define DLLEXPORT
+#endif
+
+using namespace std;
+
+AddonCB *m_Handle = NULL;
+CB_PVRLib *m_cb   = NULL;
+
+extern "C"
+{
+
+DLLEXPORT int PVR_register_me(void *hdl)
+{
+  if (!hdl)
+    fprintf(stderr, "libXBMC_pvr-ERROR: PVRLib_register_me is called with NULL handle !!!\n");
+  else
+  {
+    m_Handle = (AddonCB*) hdl;
+    m_cb     = m_Handle->PVRLib_RegisterMe(m_Handle->addonData);
+    if (!m_cb)
+      fprintf(stderr, "libXBMC_pvr-ERROR: PVRLib_register_me can't get callback table from XBMC !!!\n");
+    else
+      return 1;
+  }
+  return 0;
+}
+
+DLLEXPORT void PVR_unregister_me()
+{
+  if (m_Handle && m_cb)
+    m_Handle->PVRLib_UnRegisterMe(m_Handle->addonData, m_cb);
+}
+
+DLLEXPORT void PVR_transfer_epg_entry(const ADDON_HANDLE handle, const EPG_TAG *epgentry)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferEpgEntry(m_Handle->addonData, handle, epgentry);
+}
+
+DLLEXPORT void PVR_transfer_channel_entry(const ADDON_HANDLE handle, const PVR_CHANNEL *chan)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferChannelEntry(m_Handle->addonData, handle, chan);
+}
+
+DLLEXPORT void PVR_transfer_timer_entry(const ADDON_HANDLE handle, const PVR_TIMER *timer)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferTimerEntry(m_Handle->addonData, handle, timer);
+}
+
+DLLEXPORT void PVR_transfer_recording_entry(const ADDON_HANDLE handle, const PVR_RECORDING *recording)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferRecordingEntry(m_Handle->addonData, handle, recording);
+}
+
+DLLEXPORT void PVR_add_menu_hook(PVR_MENUHOOK *hook)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->AddMenuHook(m_Handle->addonData, hook);
+}
+
+DLLEXPORT void PVR_recording(const char *Name, const char *FileName, bool On)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->Recording(m_Handle->addonData, Name, FileName, On);
+}
+
+DLLEXPORT void PVR_trigger_channel_update()
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TriggerChannelUpdate(m_Handle->addonData);
+}
+
+DLLEXPORT void PVR_trigger_channel_groups_update()
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TriggerChannelGroupsUpdate(m_Handle->addonData);
+}
+
+DLLEXPORT void PVR_trigger_timer_update()
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TriggerTimerUpdate(m_Handle->addonData);
+}
+
+DLLEXPORT void PVR_trigger_recording_update()
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TriggerRecordingUpdate(m_Handle->addonData);
+}
+
+DLLEXPORT void PVR_free_demux_packet(DemuxPacket* pPacket)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->FreeDemuxPacket(m_Handle->addonData, pPacket);
+}
+
+DLLEXPORT DemuxPacket* PVR_allocate_demux_packet(int iDataSize)
+{
+  if (m_cb == NULL)
+    return NULL;
+
+  return m_cb->AllocateDemuxPacket(m_Handle->addonData, iDataSize);
+}
+
+DLLEXPORT void PVR_transfer_channel_group(const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP *group)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferChannelGroup(m_Handle->addonData, handle, group);
+}
+
+DLLEXPORT void PVR_transfer_channel_group_member(const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP_MEMBER *member)
+{
+  if (m_cb == NULL)
+    return;
+
+  m_cb->TransferChannelGroupMember(m_Handle->addonData, handle, member);
+}
+
+};
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 861d0d1..93f76a1 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -239,2 +239,3 @@
 #include "dialogs/GUIDialogProgress.h"
+#include "dialogs/GUIDialogExtendedProgressBar.h"
 #include "dialogs/GUIDialogSelect.h"
@@ -262,2 +263,20 @@
 #endif
+
+/* PVR related include Files */
+#include "pvr/PVRManager.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/windows/GUIWindowPVR.h"
+#include "pvr/dialogs/GUIDialogPVRChannelManager.h"
+#include "pvr/dialogs/GUIDialogPVRChannelsOSD.h"
+#include "pvr/dialogs/GUIDialogPVRCutterOSD.h"
+#include "pvr/dialogs/GUIDialogPVRDirectorOSD.h"
+#include "pvr/dialogs/GUIDialogPVRGroupManager.h"
+#include "pvr/dialogs/GUIDialogPVRGuideInfo.h"
+#include "pvr/dialogs/GUIDialogPVRGuideOSD.h"
+#include "pvr/dialogs/GUIDialogPVRGuideSearch.h"
+#include "pvr/dialogs/GUIDialogPVRRecordingInfo.h"
+#include "pvr/dialogs/GUIDialogPVRTimerSettings.h"
+
+#include "epg/EpgContainer.h"
+
 #include "video/dialogs/GUIDialogFullScreenInfo.h"
@@ -342,2 +361,4 @@ using namespace JSONRPC;
 using namespace ANNOUNCEMENT;
+using namespace PVR;
+using namespace EPG;
 using namespace PERIPHERALS;
@@ -380,2 +401,3 @@ CApplication::CApplication(void)
   m_iPlaySpeed = 1;
+  m_bInhibitIdleShutdown = false;
   m_bScreenSave = false;
@@ -1230,2 +1252,3 @@ bool CApplication::Initialize()
     g_windowManager.Add(new CGUIDialogProgress);           // window id = 101
+    g_windowManager.Add(new CGUIDialogExtendedProgressBar);     // window id = 148
     g_windowManager.Add(new CGUIDialogKeyboardGeneric);    // window id = 103
@@ -1283,2 +1306,16 @@ bool CApplication::Initialize()
 
+    /* Load PVR related Windows and Dialogs */
+    g_windowManager.Add(new CGUIWindowPVR);                    // window id = 600
+    g_windowManager.Add(new CGUIDialogPVRGuideInfo);           // window id = 601
+    g_windowManager.Add(new CGUIDialogPVRRecordingInfo);       // window id = 602
+    g_windowManager.Add(new CGUIDialogPVRTimerSettings);       // window id = 603
+    g_windowManager.Add(new CGUIDialogPVRGroupManager);        // window id = 604
+    g_windowManager.Add(new CGUIDialogPVRChannelManager);      // window id = 605
+    g_windowManager.Add(new CGUIDialogPVRGuideSearch);         // window id = 606
+    g_windowManager.Add(new CGUIDialogPVRChannelsOSD);         // window id = 609
+    g_windowManager.Add(new CGUIDialogPVRGuideOSD);            // window id = 610
+    g_windowManager.Add(new CGUIDialogPVRDirectorOSD);         // window id = 611
+    g_windowManager.Add(new CGUIDialogPVRCutterOSD);           // window id = 612
+    g_windowManager.Add(new CGUIDialogTeletext);               // window id = 613
+
     g_windowManager.Add(new CGUIDialogSelect);             // window id = 2000
@@ -1312,2 +1349,5 @@ bool CApplication::Initialize()
 
+    StartEPGManager();
+    StartPVRManager();
+
     if (g_advancedSettings.m_splashImage)
@@ -1784,2 +1824,26 @@ void CApplication::StopZeroconf()
 
+void CApplication::StartPVRManager()
+{
+  if (g_guiSettings.GetBool("pvrmanager.enabled"))
+    g_PVRManager.Start();
+}
+
+void CApplication::StartEPGManager(void)
+{
+  g_EpgContainer.Start();
+}
+
+void CApplication::StopPVRManager()
+{
+  CLog::Log(LOGINFO, "stopping PVRManager");
+  if (g_PVRManager.IsPlaying())
+    StopPlaying();
+  g_PVRManager.Stop();
+}
+
+void CApplication::StopEPGManager(void)
+{
+  g_EpgContainer.Stop();
+}
+
 void CApplication::DimLCDOnPlayback(bool dim)
@@ -2724,3 +2788,3 @@ bool CApplication::OnAction(const CAction &action)
 
-  if ( IsPlaying())
+  if (IsPlaying() && !CurrentFileItem().IsLiveTV())
   {
@@ -3446,7 +3510,20 @@ bool CApplication::Cleanup()
 
+    /* Delete PVR related windows and dialogs */
+    g_windowManager.Delete(WINDOW_PVR);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_GUIDE_INFO);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_RECORDING_INFO);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_TIMER_SETTING);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_GROUP_MANAGER);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_CHANNEL_MANAGER);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_GUIDE_SEARCH);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_CHANNEL_SCAN);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_UPDATE_PROGRESS);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_CHANNELS);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_GUIDE);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_DIRECTOR);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_CUTTER);
     g_windowManager.Delete(WINDOW_DIALOG_OSD_TELETEXT);
-    g_windowManager.Delete(WINDOW_DIALOG_TEXT_VIEWER);
 
+    g_windowManager.Delete(WINDOW_DIALOG_TEXT_VIEWER);
     g_windowManager.Delete(WINDOW_DIALOG_PLAY_EJECT);
-
     g_windowManager.Delete(WINDOW_STARTUP_ANIM);
@@ -3466,2 +3543,3 @@ bool CApplication::Cleanup()
     g_windowManager.Delete(WINDOW_SLIDESHOW);
+    g_windowManager.Delete(WINDOW_ADDON_BROWSER);
 
@@ -3480,2 +3558,3 @@ bool CApplication::Cleanup()
     g_windowManager.Remove(WINDOW_SETTINGS_APPEARANCE);
+    g_windowManager.Remove(WINDOW_SETTINGS_MYPVR);
     g_windowManager.Remove(WINDOW_DIALOG_KAI_TOAST);
@@ -3597,2 +3676,4 @@ void CApplication::Stop(int exitCode)
 
+    StopPVRManager();
+    StopEPGManager();
     StopServices();
@@ -4191,2 +4272,5 @@ bool CApplication::PlayFile(const CFileItem& item, bool bRestart)
 #endif
+
+    if (item.HasPVRChannelInfoTag())
+      g_playlistPlayer.SetCurrentPlaylist(PLAYLIST_NONE);
   }
@@ -4485,3 +4569,3 @@ void CApplication::SaveFileState(bool bForeground /* = false */)
 {
-  if (!g_settings.GetCurrentProfile().canWriteDatabases())
+  if (m_progressTrackingItem->IsPVRChannel() || !g_settings.GetCurrentProfile().canWriteDatabases())
     return;
@@ -4582,2 +4666,5 @@ void CApplication::StopPlaying()
 
+    if (g_PVRManager.IsPlayingTV() || g_PVRManager.IsPlayingRadio())
+      g_PVRManager.SaveCurrentChannelSettings();
+
     if (m_pPlayer)
@@ -4803,3 +4890,3 @@ void CApplication::ActivateScreenSaver(bool forceType /*= false */)
     // set to Dim in the case of a dialog on screen or playing video
-    if (g_windowManager.HasModalDialog() || (IsPlayingVideo() && g_guiSettings.GetBool("screensaver.usedimonpause")))
+    if (g_windowManager.HasModalDialog() || (IsPlayingVideo() && g_guiSettings.GetBool("screensaver.usedimonpause")) || g_PVRManager.IsRunningChannelScan())
     {
@@ -4842,3 +4929,4 @@ void CApplication::CheckShutdown()
   // first check if we should reset the timer
-  bool resetTimer = false;
+  bool resetTimer = m_bInhibitIdleShutdown;
+
   if (IsPlaying() || IsPaused()) // is something playing?
@@ -4855,2 +4943,5 @@ void CApplication::CheckShutdown()
 
+  if (g_guiSettings.GetBool("pvrmanager.enabled") &&  !g_PVRManager.IsIdle())
+    resetTimer = true;
+
   if (resetTimer)
@@ -4871,2 +4962,12 @@ void CApplication::CheckShutdown()
 
+void CApplication::InhibitIdleShutdown(bool inhibit)
+{
+  m_bInhibitIdleShutdown = inhibit;
+}
+
+bool CApplication::IsIdleShutdownInhibited() const
+{
+  return m_bInhibitIdleShutdown;
+}
+
 bool CApplication::OnMessage(CGUIMessage& message)
@@ -5915,3 +6016,4 @@ void CApplication::SaveCurrentFileSettings()
 {
-  if (m_itemCurrentFile->IsVideo())
+  // don't store settings for PVR in video database
+  if (m_itemCurrentFile->IsVideo() && !m_itemCurrentFile->IsPVRChannel())
   {
@@ -5926,2 +6028,6 @@ void CApplication::SaveCurrentFileSettings()
   }
+  else if (m_itemCurrentFile->IsPVRChannel())
+  {
+    g_PVRManager.SaveCurrentChannelSettings();
+  }
 }
diff --git a/xbmc/ApplicationMessenger.cpp b/xbmc/ApplicationMessenger.cpp
index aa23a65..81a89f5 100644
--- a/xbmc/ApplicationMessenger.cpp
+++ b/xbmc/ApplicationMessenger.cpp
@@ -54,2 +54,4 @@
 #endif
+#include "addons/AddonCallbacks.h"
+#include "addons/AddonCallbacksGUI.h"
 #include "storage/MediaManager.h"
@@ -71,2 +73,5 @@
 
+#include "pvr/PVRManager.h"
+
+using namespace PVR;
 using namespace std;
@@ -255,3 +260,3 @@ void CApplicationMessenger::ProcessMessage(ThreadMessage *pMsg)
 
-      case TMSG_POWERDOWN:
+    case TMSG_POWERDOWN:
       {
@@ -270,2 +275,3 @@ void CApplicationMessenger::ProcessMessage(ThreadMessage *pMsg)
       {
+        g_PVRManager.SetWakeupCommand();
         g_powerManager.Hibernate();
@@ -276,2 +282,3 @@ void CApplicationMessenger::ProcessMessage(ThreadMessage *pMsg)
       {
+        g_PVRManager.SetWakeupCommand();
         g_powerManager.Suspend();
@@ -296,2 +303,8 @@ void CApplicationMessenger::ProcessMessage(ThreadMessage *pMsg)
 
+    case TMSG_INHIBITIDLESHUTDOWN:
+      {
+        g_application.InhibitIdleShutdown((bool)pMsg->dwParam1);
+      }
+      break;
+
     case TMSG_MEDIA_PLAY:
@@ -702,2 +715,11 @@ void CApplicationMessenger::ProcessMessage(ThreadMessage *pMsg)
 
+    case TMSG_GUI_ADDON_DIALOG:
+      {
+        if (pMsg->lpVoid)
+        { // TODO: This is ugly - really these python dialogs should just be normal XBMC dialogs
+          ((ADDON::CGUIAddonWindowDialog *) pMsg->lpVoid)->Show_Internal(pMsg->dwParam2 > 0);
+        }
+      }
+      break;
+
     case TMSG_GUI_PYTHON_DIALOG:
@@ -923,6 +945,6 @@ void CApplicationMessenger::PlayFile(const CFileItem &item, bool bRestart /*= fa
 
-void CApplicationMessenger::MediaStop()
+void CApplicationMessenger::MediaStop(bool bWait /* = true */)
 {
   ThreadMessage tMsg = {TMSG_MEDIA_STOP};
-  SendMessage(tMsg, true);
+  SendMessage(tMsg, bWait);
 }
@@ -1131,2 +1153,8 @@ void CApplicationMessenger::RestartApp()
 
+void CApplicationMessenger::InhibitIdleShutdown(bool inhibit)
+{
+  ThreadMessage tMsg = {TMSG_INHIBITIDLESHUTDOWN, (DWORD)inhibit};
+  SendMessage(tMsg);
+}
+
 void CApplicationMessenger::NetworkMessage(DWORD dwMessage, DWORD dwParam)
diff --git a/xbmc/DatabaseManager.cpp b/xbmc/DatabaseManager.cpp
index a23ce08..2f34415 100644
--- a/xbmc/DatabaseManager.cpp
+++ b/xbmc/DatabaseManager.cpp
@@ -28,2 +28,4 @@
 #include "video/VideoDatabase.h"
+#include "pvr/PVRDatabase.h"
+#include "epg/EpgDatabase.h"
 #include "settings/AdvancedSettings.h"
@@ -31,2 +33,4 @@
 using namespace std;
+using namespace EPG;
+using namespace PVR;
 
@@ -57,2 +61,4 @@ void CDatabaseManager::Initialize(bool addonsOnly)
   { CVideoDatabase db; UpdateDatabase(db, &g_advancedSettings.m_databaseVideo); }
+  { CPVRDatabase db; UpdateDatabase(db, &g_advancedSettings.m_databaseTV); }
+  { CEpgDatabase db; UpdateDatabase(db, &g_advancedSettings.m_databaseEpg); }
   CLog::Log(LOGDEBUG, "%s, updating databases... DONE", __FUNCTION__);
diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index f35fed4..8512e4d 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -39,2 +39,7 @@
 #include "utils/TuxBoxUtil.h"
+#include "epg/Epg.h"
+#include "pvr/channels/PVRChannel.h"
+#include "pvr/recordings/PVRRecording.h"
+#include "pvr/timers/PVRTimerInfoTag.h"
+#include "utils/Observer.h"
 #include "video/VideoInfoTag.h"
@@ -60,2 +65,4 @@ using namespace PLAYLIST;
 using namespace MUSIC_INFO;
+using namespace PVR;
+using namespace EPG;
 
@@ -65,2 +72,6 @@ CFileItem::CFileItem(const CSong& song)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -81,2 +92,6 @@ CFileItem::CFileItem(const CStdString &path, const CAlbum& album)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -97,2 +112,6 @@ CFileItem::CFileItem(const CMusicInfoTag& music)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -110,2 +129,6 @@ CFileItem::CFileItem(const CVideoInfoTag& movie)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -129,2 +152,124 @@ CFileItem::CFileItem(const CVideoInfoTag& movie)
 
+CFileItem::CFileItem(const CEpgInfoTag& tag)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+
+  Reset();
+
+  m_strPath = tag.Path();
+  m_bIsFolder = false;
+  *GetEPGInfoTag() = tag;
+  SetLabel(tag.Title());
+  m_strLabel2 = tag.Plot();
+  m_dateTime = tag.StartAsLocalTime();
+
+  if (!tag.Icon().IsEmpty())
+  {
+    SetThumbnailImage(tag.Icon());
+    SetIconImage(tag.Icon());
+  }
+}
+
+CFileItem::CFileItem(const CPVRChannel& channel)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+
+  Reset();
+  CEpgInfoTag epgNow;
+  bool bHasEpgNow = channel.GetEPGNow(epgNow);
+
+  m_strPath = channel.Path();
+  m_bIsFolder = false;
+  *GetPVRChannelInfoTag() = channel;
+  SetLabel(channel.ChannelName());
+  m_strLabel2 = bHasEpgNow ? epgNow.Title() :
+      g_guiSettings.GetBool("epg.hidenoinfoavailable") ?
+        StringUtils::EmptyString :
+        g_localizeStrings.Get(19055); // no information available
+
+  if (channel.IsRadio() && bHasEpgNow)
+  {
+    CMusicInfoTag* musictag = GetMusicInfoTag();
+    if (musictag)
+    {
+      musictag->SetURL(channel.Path());
+      musictag->SetTitle(m_strLabel2);
+      musictag->SetArtist(channel.ChannelName());
+      musictag->SetAlbumArtist(channel.ChannelName());
+      if (bHasEpgNow)
+        musictag->SetGenre(epgNow.Genre());
+      musictag->SetDuration(bHasEpgNow ? epgNow.GetDuration() : 3600);
+      musictag->SetLoaded(true);
+      musictag->SetComment("");
+      musictag->SetLyrics("");
+    }
+  }
+
+  if (!channel.IconPath().IsEmpty())
+  {
+    SetThumbnailImage(channel.IconPath());
+    SetIconImage(channel.IconPath());
+  }
+
+  SetProperty("channelid", channel.ChannelID());
+  SetProperty("path", channel.Path());
+}
+
+CFileItem::CFileItem(const CPVRRecording& record)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_epgInfoTag   = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+
+  Reset();
+
+  m_strPath = record.m_strFileNameAndPath;
+  m_bIsFolder = false;
+  *GetPVRRecordingInfoTag() = record;
+  SetLabel(record.m_strTitle);
+  m_strLabel2 = record.m_strPlot;
+}
+
+CFileItem::CFileItem(const CPVRTimerInfoTag& timer)
+{
+  m_musicInfoTag = NULL;
+  m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
+  m_pictureInfoTag = NULL;
+
+  Reset();
+
+  m_strPath = timer.Path();
+  m_bIsFolder = false;
+  *GetPVRTimerInfoTag() = timer;
+  SetLabel(timer.Title());
+  m_strLabel2 = timer.Summary();
+  m_dateTime = timer.StartAsLocalTime();
+
+  if (!timer.ChannelIcon().IsEmpty())
+  {
+    SetThumbnailImage(timer.ChannelIcon());
+    SetIconImage(timer.ChannelIcon());
+  }
+}
+
 CFileItem::CFileItem(const CArtist& artist)
@@ -133,2 +278,6 @@ CFileItem::CFileItem(const CArtist& artist)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -146,2 +295,6 @@ CFileItem::CFileItem(const CGenre& genre)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -159,2 +312,6 @@ CFileItem::CFileItem(const CFileItem& item): CGUIListItem()
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -167,2 +324,6 @@ CFileItem::CFileItem(const CGUIListItem& item)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -178,2 +339,6 @@ CFileItem::CFileItem(void)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -187,2 +352,6 @@ CFileItem::CFileItem(const CStdString& strLabel)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -196,2 +365,6 @@ CFileItem::CFileItem(const CStdString& strPath, bool bIsFolder)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -209,2 +382,6 @@ CFileItem::CFileItem(const CMediaSource& share)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -234,2 +411,6 @@ CFileItem::~CFileItem(void)
   delete m_videoInfoTag;
+  delete m_epgInfoTag;
+  delete m_pvrChannelInfoTag;
+  delete m_pvrRecordingInfoTag;
+  delete m_pvrTimerInfoTag;
   delete m_pictureInfoTag;
@@ -238,2 +419,6 @@ CFileItem::~CFileItem(void)
   m_videoInfoTag = NULL;
+  m_epgInfoTag = NULL;
+  m_pvrChannelInfoTag = NULL;
+  m_pvrRecordingInfoTag = NULL;
+  m_pvrTimerInfoTag = NULL;
   m_pictureInfoTag = NULL;
@@ -277,2 +462,58 @@ const CFileItem& CFileItem::operator=(const CFileItem& item)
 
+  if (item.HasEPGInfoTag())
+  {
+    m_epgInfoTag = GetEPGInfoTag();
+    if (m_epgInfoTag)
+      *m_epgInfoTag = *item.m_epgInfoTag;
+  }
+  else
+  {
+    if (m_epgInfoTag)
+      delete m_epgInfoTag;
+
+    m_epgInfoTag = NULL;
+  }
+
+  if (item.HasPVRChannelInfoTag())
+  {
+    m_pvrChannelInfoTag = GetPVRChannelInfoTag();
+    if (m_pvrChannelInfoTag)
+      *m_pvrChannelInfoTag = *item.m_pvrChannelInfoTag;
+  }
+  else
+  {
+    if (m_pvrChannelInfoTag)
+      delete m_pvrChannelInfoTag;
+
+    m_pvrChannelInfoTag = NULL;
+  }
+
+  if (item.HasPVRRecordingInfoTag())
+  {
+    m_pvrRecordingInfoTag = GetPVRRecordingInfoTag();
+    if (m_pvrRecordingInfoTag)
+      *m_pvrRecordingInfoTag = *item.m_pvrRecordingInfoTag;
+  }
+  else
+  {
+    if (m_pvrRecordingInfoTag)
+      delete m_pvrRecordingInfoTag;
+
+    m_pvrRecordingInfoTag = NULL;
+  }
+
+  if (item.HasPVRTimerInfoTag())
+  {
+    m_pvrTimerInfoTag = GetPVRTimerInfoTag();
+    if (m_pvrTimerInfoTag)
+      *m_pvrTimerInfoTag = *item.m_pvrTimerInfoTag;
+  }
+  else
+  {
+    if (m_pvrTimerInfoTag)
+      delete m_pvrTimerInfoTag;
+
+    m_pvrTimerInfoTag = NULL;
+  }
+
   if (item.HasPictureInfoTag())
@@ -341,2 +582,10 @@ void CFileItem::Reset()
   m_videoInfoTag=NULL;
+  delete m_epgInfoTag;
+  m_epgInfoTag=NULL;
+  delete m_pvrChannelInfoTag;
+  m_pvrChannelInfoTag=NULL;
+  delete m_pvrRecordingInfoTag;
+  m_pvrRecordingInfoTag=NULL;
+  delete m_pvrTimerInfoTag;
+  m_pvrTimerInfoTag=NULL;
   delete m_pictureInfoTag;
@@ -490,2 +739,5 @@ void CFileItem::ToSortable(SortItem &sortable)
     GetPictureInfoTag()->ToSortable(sortable);
+
+  if (HasPVRChannelInfoTag())
+    GetPVRChannelInfoTag()->ToSortable(sortable);
 }
@@ -533,2 +785,3 @@ bool CFileItem::IsVideo() const
   if (HasPictureInfoTag()) return false;
+  if (IsPVRRecording())  return true;
 
@@ -557,2 +810,26 @@ bool CFileItem::IsVideo() const
 
+bool CFileItem::IsEPG() const
+{
+  if (HasEPGInfoTag()) return true; /// is this enough?
+  return false;
+}
+
+bool CFileItem::IsPVRChannel() const
+{
+  if (HasPVRChannelInfoTag()) return true; /// is this enough?
+  return false;
+}
+
+bool CFileItem::IsPVRRecording() const
+{
+  if (HasPVRRecordingInfoTag()) return true; /// is this enough?
+  return false;
+}
+
+bool CFileItem::IsPVRTimer() const
+{
+  if (HasPVRTimerInfoTag()) return true; /// is this enough?
+  return false;
+}
+
 bool CFileItem::IsDiscStub() const
@@ -884,2 +1161,7 @@ bool CFileItem::IsVTP() const
 
+bool CFileItem::IsPVR() const
+{
+  return CUtil::IsPVR(m_strPath);
+}
+
 bool CFileItem::IsLiveTV() const
@@ -948,3 +1230,15 @@ void CFileItem::FillInDefaultIcon()
        */
-      if ( IsAudio() )
+      if (IsPVRChannel())
+      {
+        if (GetPVRChannelInfoTag()->IsRadio())
+          SetIconImage("DefaultAudio.png");
+        else
+          SetIconImage("DefaultVideo.png");
+      }
+      else if ( IsLiveTV() )
+      {
+        // Live TV Channel
+        SetIconImage("DefaultVideo.png");
+      }
+      else if ( IsAudio() )
       {
@@ -958,2 +1252,10 @@ void CFileItem::FillInDefaultIcon()
       }
+      else if (IsPVRRecording())
+      {
+        SetIconImage("DefaultVideo.png");
+      }
+      else if (IsPVRTimer())
+      {
+        SetIconImage("DefaultVideo.png");
+      }
       else if ( IsPicture() )
@@ -1035,2 +1337,8 @@ void CFileItem::SetLabel(const CStdString &strLabel)
 
+void CFileItem::SetLabel2(const CStdString &strLabel)
+{
+  m_strLabel2 = strLabel;
+}
+
+
 void CFileItem::SetFileSizeLabel()
@@ -1600,2 +1908,5 @@ void CFileItemList::Sort(SORT_METHOD sortMethod, SortOrder sortOrder)
     break;    
+  case SORT_METHOD_CHANNEL:
+    sortBy = SortByChannel;
+    break;
   default:
@@ -2382,2 +2693,4 @@ bool CFileItemList::AlwaysCache() const
     return CVideoDatabaseDirectory::CanCache(GetPath());
+  if (IsEPG())
+    return true; // always cache
   return false;
@@ -2850,2 +3163,34 @@ CVideoInfoTag* CFileItem::GetVideoInfoTag()
 
+CEpgInfoTag* CFileItem::GetEPGInfoTag()
+{
+  if (!m_epgInfoTag)
+    m_epgInfoTag = new CEpgInfoTag;
+
+  return m_epgInfoTag;
+}
+
+CPVRChannel* CFileItem::GetPVRChannelInfoTag()
+{
+  if (!m_pvrChannelInfoTag)
+    m_pvrChannelInfoTag = new CPVRChannel;
+
+  return m_pvrChannelInfoTag;
+}
+
+CPVRRecording* CFileItem::GetPVRRecordingInfoTag()
+{
+  if (!m_pvrRecordingInfoTag)
+    m_pvrRecordingInfoTag = new CPVRRecording;
+
+  return m_pvrRecordingInfoTag;
+}
+
+CPVRTimerInfoTag* CFileItem::GetPVRTimerInfoTag()
+{
+  if (!m_pvrTimerInfoTag)
+    m_pvrTimerInfoTag = new CPVRTimerInfoTag;
+
+  return m_pvrTimerInfoTag;
+}
+
 CPictureInfoTag* CFileItem::GetPictureInfoTag()
diff --git a/xbmc/GUIInfoManager.cpp b/xbmc/GUIInfoManager.cpp
index 9478471..542d76d 100644
--- a/xbmc/GUIInfoManager.cpp
+++ b/xbmc/GUIInfoManager.cpp
@@ -69,2 +69,8 @@
 
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "epg/EpgInfoTag.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/recordings/PVRRecording.h"
+
 #include "addons/AddonManager.h"
@@ -80,5 +86,8 @@ using namespace MUSIC_INFO;
 using namespace ADDON;
+using namespace PVR;
 using namespace INFO;
+using namespace EPG;
 
-CGUIInfoManager::CGUIInfoManager(void)
+CGUIInfoManager::CGUIInfoManager(void) :
+    Observable()
 {
@@ -259,2 +268,4 @@ const infomap system_labels[] =  {{ "hasnetwork",       SYSTEM_ETHERNET_LINK_ACT
                                   { "alarmpos",         SYSTEM_ALARM_POS },
+                                  { "isinhibit",        SYSTEM_ISINHIBIT },
+                                  { "hasshutdown",      SYSTEM_HAS_SHUTDOWN },
                                   { "haspvr",           SYSTEM_HAS_PVR }};
@@ -338,3 +349,7 @@ const infomap musicplayer[] =    {{ "title",            MUSICPLAYER_TITLE },
                                   { "playcount",        MUSICPLAYER_PLAYCOUNT },
-                                  { "lastplayed",       MUSICPLAYER_LASTPLAYED }};
+                                  { "lastplayed",       MUSICPLAYER_LASTPLAYED },
+                                  { "channelname",      MUSICPLAYER_CHANNEL_NAME },
+                                  { "channelnumber",    MUSICPLAYER_CHANNEL_NUMBER },
+                                  { "channelgroup",     MUSICPLAYER_CHANNEL_GROUP }
+};
 
@@ -380,3 +395,16 @@ const infomap videoplayer[] =    {{ "title",            VIDEOPLAYER_TITLE },
                                   { "hassubtitles",     VIDEOPLAYER_HASSUBTITLES },
-                                  { "subtitlesenabled", VIDEOPLAYER_SUBTITLESENABLED }};
+                                  { "subtitlesenabled", VIDEOPLAYER_SUBTITLESENABLED },
+                                  { "endtime",          VIDEOPLAYER_ENDTIME },
+                                  { "nexttitle",        VIDEOPLAYER_NEXT_TITLE },
+                                  { "nextgenre",        VIDEOPLAYER_NEXT_GENRE },
+                                  { "nextplot",         VIDEOPLAYER_NEXT_PLOT },
+                                  { "nextplotoutline",  VIDEOPLAYER_NEXT_PLOT_OUTLINE },
+                                  { "nextstarttime",    VIDEOPLAYER_NEXT_STARTTIME },
+                                  { "nextendtime",      VIDEOPLAYER_NEXT_ENDTIME },
+                                  { "nextduration",     VIDEOPLAYER_NEXT_DURATION },
+                                  { "channelname",      VIDEOPLAYER_CHANNEL_NAME },
+                                  { "channelnumber",    VIDEOPLAYER_CHANNEL_NUMBER },
+                                  { "channelgroup",     VIDEOPLAYER_CHANNEL_GROUP },
+                                  { "hasepg",           VIDEOPLAYER_HAS_EPG },
+                                  { "parentalrating",   VIDEOPLAYER_PARENTAL_RATING }};
 
@@ -495,2 +523,22 @@ const infomap listitem_labels[]= {{ "thumb",            LISTITEM_THUMB },
                                   { "discnumber",       LISTITEM_DISC_NUMBER },
+                                  { "starttime",        LISTITEM_STARTTIME },
+                                  { "endtime",          LISTITEM_ENDTIME },
+                                  { "startdate",        LISTITEM_STARTDATE },
+                                  { "enddate",          LISTITEM_ENDDATE },
+                                  { "nexttitle",        LISTITEM_NEXT_TITLE },
+                                  { "nextgenre",        LISTITEM_NEXT_GENRE },
+                                  { "nextplot",         LISTITEM_NEXT_PLOT },
+                                  { "nextplotoutline",  LISTITEM_NEXT_PLOT_OUTLINE },
+                                  { "nextstarttime",    LISTITEM_NEXT_STARTTIME },
+                                  { "nextendtime",      LISTITEM_NEXT_ENDTIME },
+                                  { "nextstartdate",    LISTITEM_NEXT_STARTDATE },
+                                  { "nextenddate",      LISTITEM_NEXT_ENDDATE },
+                                  { "channelname",      LISTITEM_CHANNEL_NAME },
+                                  { "channelnumber",    LISTITEM_CHANNEL_NUMBER },
+                                  { "channelgroup",     LISTITEM_CHANNEL_GROUP },
+                                  { "hasepg",           LISTITEM_HAS_EPG },
+                                  { "hastimer",         LISTITEM_HASTIMER },
+                                  { "isrecording",      LISTITEM_ISRECORDING },
+                                  { "isencrypted",      LISTITEM_ISENCRYPTED },
+                                  { "progress",         LISTITEM_PROGRESS },
                                   { "dateadded",        LISTITEM_DATE_ADDED },
@@ -534,2 +582,47 @@ const infomap playlist[] =       {{ "length",           PLAYLIST_LENGTH },
 
+const infomap pvr[] =            {{ "isrecording",              PVR_IS_RECORDING },
+                                  { "hastimer",                 PVR_HAS_TIMER },
+                                  { "hasnonrecordingtimer",     PVR_HAS_NONRECORDING_TIMER },
+                                  { "nowrecordingtitle",        PVR_NOW_RECORDING_TITLE },
+                                  { "nowrecordingdatetime",     PVR_NOW_RECORDING_DATETIME },
+                                  { "nowrecordingchannel",      PVR_NOW_RECORDING_CHANNEL },
+                                  { "nowrecordingchannelicon",  PVR_NOW_RECORDING_CHAN_ICO },
+                                  { "nextrecordingtitle",       PVR_NEXT_RECORDING_TITLE },
+                                  { "nextrecordingdatetime",    PVR_NEXT_RECORDING_DATETIME },
+                                  { "nextrecordingchannel",     PVR_NEXT_RECORDING_CHANNEL },
+                                  { "nextrecordingchannelicon", PVR_NEXT_RECORDING_CHAN_ICO },
+                                  { "backendname",              PVR_BACKEND_NAME },
+                                  { "backendversion",           PVR_BACKEND_VERSION },
+                                  { "backendhost",              PVR_BACKEND_HOST },
+                                  { "backenddiskspace",         PVR_BACKEND_DISKSPACE },
+                                  { "backendchannels",          PVR_BACKEND_CHANNELS },
+                                  { "backendtimers",            PVR_BACKEND_TIMERS },
+                                  { "backendrecordings",        PVR_BACKEND_RECORDINGS },
+                                  { "backendnumber",            PVR_BACKEND_NUMBER },
+                                  { "hasepg",                   PVR_HAS_EPG },
+                                  { "hastxt",                   PVR_HAS_TXT },
+                                  { "hasdirector",              PVR_HAS_DIRECTOR },
+                                  { "totaldiscspace",           PVR_TOTAL_DISKSPACE },
+                                  { "nexttimer",                PVR_NEXT_TIMER },
+                                  { "isplayingtv",              PVR_IS_PLAYING_TV },
+                                  { "isplayingradio",           PVR_IS_PLAYING_RADIO },
+                                  { "isplayingrecording",       PVR_IS_PLAYING_RECORDING },
+                                  { "duration",                 PVR_PLAYING_DURATION },
+                                  { "time",                     PVR_PLAYING_TIME },
+                                  { "progress",                 PVR_PLAYING_PROGRESS },
+                                  { "actstreamclient",          PVR_ACTUAL_STREAM_CLIENT },
+                                  { "actstreamdevice",          PVR_ACTUAL_STREAM_DEVICE },
+                                  { "actstreamstatus",          PVR_ACTUAL_STREAM_STATUS },
+                                  { "actstreamsignal",          PVR_ACTUAL_STREAM_SIG },
+                                  { "actstreamsnr",             PVR_ACTUAL_STREAM_SNR },
+                                  { "actstreamber",             PVR_ACTUAL_STREAM_BER },
+                                  { "actstreamunc",             PVR_ACTUAL_STREAM_UNC },
+                                  { "actstreamvideobitrate",    PVR_ACTUAL_STREAM_VIDEO_BR },
+                                  { "actstreamaudiobitrate",    PVR_ACTUAL_STREAM_AUDIO_BR },
+                                  { "actstreamdolbybitrate",    PVR_ACTUAL_STREAM_DOLBY_BR },
+                                  { "actstreamprogrsignal",     PVR_ACTUAL_STREAM_SIG_PROGR },
+                                  { "actstreamprogrsnr",        PVR_ACTUAL_STREAM_SNR_PROGR },
+                                  { "actstreamisencrypted",     PVR_ACTUAL_STREAM_ENCRYPTED },
+                                  { "actstreamencryptionname",  PVR_ACTUAL_STREAM_CRYPTION }};
+
 const infomap slideshow[] =      {{ "ispaused",         SLIDESHOW_ISPAUSED },
@@ -1018,2 +1111,10 @@ int CGUIInfoManager::TranslateSingleString(const CStdString &strCondition)
     }
+    else if (cat.name == "pvr")
+    {
+      for (size_t i = 0; i < sizeof(pvr) / sizeof(infomap); i++)
+      {
+        if (prop.name == pvr[i].str)
+          return pvr[i].val;
+      }
+    }
   }
@@ -1136,2 +1237,38 @@ CStdString CGUIInfoManager::GetLabel(int info, int contextWindow, CStdString *fa
   {
+  case PVR_NEXT_RECORDING_CHANNEL:
+  case PVR_NEXT_RECORDING_CHAN_ICO:
+  case PVR_NEXT_RECORDING_DATETIME:
+  case PVR_NEXT_RECORDING_TITLE:
+  case PVR_NOW_RECORDING_CHANNEL:
+  case PVR_NOW_RECORDING_CHAN_ICO:
+  case PVR_NOW_RECORDING_DATETIME:
+  case PVR_NOW_RECORDING_TITLE:
+  case PVR_BACKEND_NAME:
+  case PVR_BACKEND_VERSION:
+  case PVR_BACKEND_HOST:
+  case PVR_BACKEND_DISKSPACE:
+  case PVR_BACKEND_CHANNELS:
+  case PVR_BACKEND_TIMERS:
+  case PVR_BACKEND_RECORDINGS:
+  case PVR_BACKEND_NUMBER:
+  case PVR_TOTAL_DISKSPACE:
+  case PVR_NEXT_TIMER:
+  case PVR_PLAYING_DURATION:
+  case PVR_PLAYING_TIME:
+  case PVR_PLAYING_PROGRESS:
+  case PVR_ACTUAL_STREAM_CLIENT:
+  case PVR_ACTUAL_STREAM_DEVICE:
+  case PVR_ACTUAL_STREAM_STATUS:
+  case PVR_ACTUAL_STREAM_SIG:
+  case PVR_ACTUAL_STREAM_SNR:
+  case PVR_ACTUAL_STREAM_SIG_PROGR:
+  case PVR_ACTUAL_STREAM_SNR_PROGR:
+  case PVR_ACTUAL_STREAM_BER:
+  case PVR_ACTUAL_STREAM_UNC:
+  case PVR_ACTUAL_STREAM_VIDEO_BR:
+  case PVR_ACTUAL_STREAM_AUDIO_BR:
+  case PVR_ACTUAL_STREAM_DOLBY_BR:
+  case PVR_ACTUAL_STREAM_CRYPTION:
+    g_PVRManager.TranslateCharInfo(info, strLabel);
+    break;
   case WEATHER_CONDITIONS:
@@ -1236,2 +1373,5 @@ CStdString CGUIInfoManager::GetLabel(int info, int contextWindow, CStdString *fa
   case MUSICPLAYER_LYRICS:
+  case MUSICPLAYER_CHANNEL_NAME:
+  case MUSICPLAYER_CHANNEL_NUMBER:
+  case MUSICPLAYER_CHANNEL_GROUP:
   case MUSICPLAYER_PLAYCOUNT:
@@ -1266,2 +1406,15 @@ CStdString CGUIInfoManager::GetLabel(int info, int contextWindow, CStdString *fa
   case VIDEOPLAYER_TRAILER:
+  case VIDEOPLAYER_STARTTIME:
+  case VIDEOPLAYER_ENDTIME:
+  case VIDEOPLAYER_NEXT_TITLE:
+  case VIDEOPLAYER_NEXT_GENRE:
+  case VIDEOPLAYER_NEXT_PLOT:
+  case VIDEOPLAYER_NEXT_PLOT_OUTLINE:
+  case VIDEOPLAYER_NEXT_STARTTIME:
+  case VIDEOPLAYER_NEXT_ENDTIME:
+  case VIDEOPLAYER_NEXT_DURATION:
+  case VIDEOPLAYER_CHANNEL_NAME:
+  case VIDEOPLAYER_CHANNEL_NUMBER:
+  case VIDEOPLAYER_CHANNEL_GROUP:
+  case VIDEOPLAYER_PARENTAL_RATING:
   case VIDEOPLAYER_PLAYCOUNT:
@@ -1778,2 +1931,7 @@ bool CGUIInfoManager::GetInt(int &value, int info, int contextWindow, const CGUI
       return true;
+    case PVR_PLAYING_PROGRESS:
+    case PVR_ACTUAL_STREAM_SIG_PROGR:
+    case PVR_ACTUAL_STREAM_SNR_PROGR:
+      value = g_PVRManager.TranslateIntInfo(info);
+      return true;
     case SYSTEM_BATTERY_LEVEL:
@@ -1959,3 +2117,3 @@ bool CGUIInfoManager::GetBool(int condition1, int contextWindow, const CGUIListI
   else if (condition == SYSTEM_HAS_PVR)
-    bReturn = false;
+    bReturn = true;
   else if (condition == SYSTEM_ISMASTER)
@@ -1966,2 +2124,6 @@ bool CGUIInfoManager::GetBool(int condition1, int contextWindow, const CGUIListI
     bReturn = g_application.IsStandAlone();
+  else if (condition == SYSTEM_ISINHIBIT)
+    bReturn = g_application.IsIdleShutdownInhibited();
+  else if (condition == SYSTEM_HAS_SHUTDOWN)
+    bReturn = (g_guiSettings.GetInt("powermanagement.shutdowntime") > 0);
   else if (condition == SYSTEM_LOGGEDON)
@@ -1974,2 +2136,5 @@ bool CGUIInfoManager::GetBool(int condition1, int contextWindow, const CGUIListI
     bReturn = g_weatherManager.IsFetched();
+  else if (condition >= PVR_CONDITIONS_START && condition <= PVR_CONDITIONS_END)
+    bReturn = g_PVRManager.TranslateBoolInfo(condition);
+
   else if (condition == SYSTEM_INTERNET_STATE)
@@ -2032,3 +2197,4 @@ bool CGUIInfoManager::GetBool(int condition1, int contextWindow, const CGUIListI
   else if (condition == VIDEOPLAYER_HAS_INFO)
-    bReturn = (m_currentFile->HasVideoInfoTag() && !m_currentFile->GetVideoInfoTag()->IsEmpty());
+    bReturn = ((m_currentFile->HasVideoInfoTag() && !m_currentFile->GetVideoInfoTag()->IsEmpty()) ||
+               (m_currentFile->HasPVRChannelInfoTag()  && !m_currentFile->GetPVRChannelInfoTag()->IsEmpty()));
   else if (condition >= CONTAINER_SCROLL_PREVIOUS && condition <= CONTAINER_SCROLL_NEXT)
@@ -2230,2 +2396,9 @@ bool CGUIInfoManager::GetBool(int condition1, int contextWindow, const CGUIListI
     break;
+    case VIDEOPLAYER_HAS_EPG:
+      if (m_currentFile->HasPVRChannelInfoTag())
+      {
+        CEpgInfoTag epgTag;
+        bReturn = m_currentFile->GetPVRChannelInfoTag()->GetEPGNow(epgTag);
+      }
+    break;
     default: // default, use integer value different from 0 as true
@@ -2570,2 +2743,4 @@ bool CGUIInfoManager::GetMultiInfoBool(const GUIInfo &info, int contextWindow, c
             strContent = "livetv";
+          if (m_currentFile->HasPVRChannelInfoTag())
+            strContent = "livetv";
           bReturn = m_stringParameters[info.GetData1()].Equals(strContent);
@@ -3312,2 +3487,27 @@ CStdString CGUIInfoManager::GetMusicTagLabel(int info, const CFileItem *item)
     return GetItemLabel(item, LISTITEM_DURATION);
+  case MUSICPLAYER_CHANNEL_NAME:
+    {
+      CPVRChannel* channeltag = m_currentFile->GetPVRChannelInfoTag();
+      if (channeltag)
+        return channeltag->ChannelName();
+    }
+    break;
+  case MUSICPLAYER_CHANNEL_NUMBER:
+    {
+      CPVRChannel* channeltag = m_currentFile->GetPVRChannelInfoTag();
+      if (channeltag)
+      {
+        CStdString strNumber;
+        strNumber.Format("%i", channeltag->ChannelNumber());
+        return strNumber;
+      }
+    }
+    break;
+  case MUSICPLAYER_CHANNEL_GROUP:
+    {
+      CPVRChannel* channeltag = m_currentFile->GetPVRChannelInfoTag();
+      if (channeltag && channeltag->IsRadio())
+        return g_PVRManager.GetPlayingGroup(true)->GroupName();
+    }
+    break;
   case MUSICPLAYER_PLAYCOUNT:
@@ -3327,2 +3527,11 @@ CStdString CGUIInfoManager::GetVideoLabel(int item)
   {
+    if (m_currentFile->HasPVRChannelInfoTag())
+    {
+      CEpgInfoTag tag;
+      return m_currentFile->GetPVRChannelInfoTag()->GetEPGNow(tag) ?
+          tag.Title() :
+          g_guiSettings.GetBool("epg.hidenoinfoavailable") ?
+              StringUtils::EmptyString :
+              g_localizeStrings.Get(19055); // no information available
+    }
     if (m_currentFile->HasVideoInfoTag() && !m_currentFile->GetVideoInfoTag()->m_strTitle.IsEmpty())
@@ -3346,2 +3555,77 @@ CStdString CGUIInfoManager::GetVideoLabel(int item)
   }
+  else if (m_currentFile->HasPVRChannelInfoTag())
+  {
+    CPVRChannel* tag = m_currentFile->GetPVRChannelInfoTag();
+    CEpgInfoTag epgTag;
+
+    switch (item)
+    {
+    /* Now playing infos */
+    case VIDEOPLAYER_ORIGINALTITLE:
+      return tag->GetEPGNow(epgTag) ?
+          epgTag.Title() :
+          g_guiSettings.GetBool("epg.hidenoinfoavailable") ?
+              StringUtils::EmptyString :
+              g_localizeStrings.Get(19055); // no information available
+    case VIDEOPLAYER_GENRE:
+      return tag->GetEPGNow(epgTag) ? StringUtils::Join(epgTag.Genre(), g_advancedSettings.m_videoItemSeparator) : StringUtils::EmptyString;
+    case VIDEOPLAYER_PLOT:
+      return tag->GetEPGNow(epgTag) ? epgTag.Plot() : StringUtils::EmptyString;
+    case VIDEOPLAYER_PLOT_OUTLINE:
+      return tag->GetEPGNow(epgTag) ? epgTag.PlotOutline() : StringUtils::EmptyString;
+    case VIDEOPLAYER_STARTTIME:
+      return tag->GetEPGNow(epgTag) ? epgTag.StartAsLocalTime().GetAsLocalizedTime("", false) : CDateTime::GetCurrentDateTime().GetAsLocalizedTime("", false);
+    case VIDEOPLAYER_ENDTIME:
+      return tag->GetEPGNow(epgTag) ? epgTag.EndAsLocalTime().GetAsLocalizedTime("", false) : CDateTime::GetCurrentDateTime().GetAsLocalizedTime("", false);
+
+    /* Next playing infos */
+    case VIDEOPLAYER_NEXT_TITLE:
+      return tag->GetEPGNext(epgTag) ?
+          epgTag.Title() :
+          g_guiSettings.GetBool("epg.hidenoinfoavailable") ?
+              StringUtils::EmptyString :
+              g_localizeStrings.Get(19055); // no information available
+    case VIDEOPLAYER_NEXT_GENRE:
+      return tag->GetEPGNext(epgTag) ? StringUtils::Join(epgTag.Genre(), g_advancedSettings.m_videoItemSeparator) : StringUtils::EmptyString;
+    case VIDEOPLAYER_NEXT_PLOT:
+      return tag->GetEPGNext(epgTag) ? epgTag.Plot() : StringUtils::EmptyString;
+    case VIDEOPLAYER_NEXT_PLOT_OUTLINE:
+      return tag->GetEPGNext(epgTag) ? epgTag.PlotOutline() : StringUtils::EmptyString;
+    case VIDEOPLAYER_NEXT_STARTTIME:
+      return tag->GetEPGNext(epgTag) ? epgTag.StartAsLocalTime().GetAsLocalizedTime("", false) : CDateTime::GetCurrentDateTime().GetAsLocalizedTime("", false);
+    case VIDEOPLAYER_NEXT_ENDTIME:
+      return tag->GetEPGNext(epgTag) ? epgTag.EndAsLocalTime().GetAsLocalizedTime("", false) : CDateTime::GetCurrentDateTime().GetAsLocalizedTime("", false);
+    case VIDEOPLAYER_NEXT_DURATION:
+      {
+        CStdString duration;
+        if (tag->GetEPGNext(epgTag) && epgTag.GetDuration() > 0)
+          duration = StringUtils::SecondsToTimeString(epgTag.GetDuration());
+        return duration;
+      }
+
+    case VIDEOPLAYER_PARENTAL_RATING:
+      {
+        CStdString rating;
+        if (tag->GetEPGNow(epgTag) && epgTag.ParentalRating() > 0)
+          rating.Format("%i", epgTag.ParentalRating());
+        return rating;
+      }
+      break;
+
+    /* General channel infos */
+    case VIDEOPLAYER_CHANNEL_NAME:
+      return tag->ChannelName();
+    case VIDEOPLAYER_CHANNEL_NUMBER:
+      {
+        CStdString strNumber;
+        strNumber.Format("%i", tag->ChannelNumber());
+        return strNumber;
+      }
+    case VIDEOPLAYER_CHANNEL_GROUP:
+      {
+        if (tag && !tag->IsRadio())
+          return g_PVRManager.GetPlayingGroup(false)->GroupName();
+      }
+    }
+  }
   else if (m_currentFile->HasVideoInfoTag())
@@ -3539,2 +3823,5 @@ void CGUIInfoManager::SetCurrentItem(CFileItem &item)
     SetCurrentMovie(item);
+
+  SetChanged();
+  NotifyObservers(ObservableMessageCurrentItem, true);
 }
@@ -3592,7 +3879,11 @@ void CGUIInfoManager::SetCurrentMovie(CFileItem &item)
 
-  CVideoDatabase dbs;
-  if (dbs.Open())
+  /* also call GetMovieInfo() when a VideoInfoTag is already present or additional info won't be present in the tag */
+  if (!m_currentFile->HasPVRChannelInfoTag())
   {
-    dbs.LoadVideoInfo(item.GetPath(), *m_currentFile->GetVideoInfoTag());
-    dbs.Close();
+    CVideoDatabase dbs;
+    if (dbs.Open())
+    {
+      dbs.LoadVideoInfo(item.GetPath(), *m_currentFile->GetVideoInfoTag());
+      dbs.Close();
+    }
   }
@@ -3836,2 +4127,23 @@ bool CGUIInfoManager::GetItemInt(int &value, const CGUIListItem *item, int info)
   {
+    case LISTITEM_PROGRESS:
+    {
+      value = 0;
+      if (item->IsFileItem())
+      {
+        const CFileItem *pItem = (const CFileItem *)item;
+        if (pItem && pItem->HasPVRChannelInfoTag())
+        {
+          CEpgInfoTag epgNow;
+          if (pItem->GetPVRChannelInfoTag()->GetEPGNow(epgNow))
+            value = (int) epgNow.ProgressPercentage();
+        }
+        else if (pItem && pItem->HasEPGInfoTag())
+        {
+          value = (int) pItem->GetEPGInfoTag()->ProgressPercentage();
+        }
+      }
+
+      return true;
+    }
+    break;
   case LISTITEM_PERCENT_PLAYED:
@@ -3871,2 +4183,17 @@ CStdString CGUIInfoManager::GetItemLabel(const CFileItem *item, int info, CStdSt
   case LISTITEM_TITLE:
+    if (item->HasPVRChannelInfoTag())
+    {
+      CEpgInfoTag epgTag;
+      return item->GetPVRChannelInfoTag()->GetEPGNow(epgTag) ?
+          epgTag.Title() :
+          g_guiSettings.GetBool("epg.hidenoinfoavailable") ?
+              StringUtils::EmptyString :
+              g_localizeStrings.Get(19055); // no information available
+    }
+    if (item->HasPVRRecordingInfoTag())
+      return item->GetPVRRecordingInfoTag()->m_strTitle;
+    if (item->HasEPGInfoTag())
+      return item->GetEPGInfoTag()->Title();
+    if (item->HasPVRTimerInfoTag())
+      return item->GetPVRTimerInfoTag()->Title();
     if (item->HasVideoInfoTag())
@@ -3966,2 +4293,11 @@ CStdString CGUIInfoManager::GetItemLabel(const CFileItem *item, int info, CStdSt
       return StringUtils::Join(item->GetMusicInfoTag()->GetGenre(), g_advancedSettings.m_musicItemSeparator);
+    if (item->HasPVRChannelInfoTag())
+    {
+      CEpgInfoTag epgTag;
+      return item->GetPVRChannelInfoTag()->GetEPGNow(epgTag) ? StringUtils::Join(epgTag.Genre(), g_advancedSettings.m_videoItemSeparator) : StringUtils::EmptyString;
+    }
+    if (item->HasPVRRecordingInfoTag())
+      return StringUtils::Join(item->GetPVRRecordingInfoTag()->m_genre, g_advancedSettings.m_videoItemSeparator);
+    if (item->HasEPGInfoTag())
+      return StringUtils::Join(item->GetEPGInfoTag()->Genre(), g_advancedSettings.m_videoItemSeparator);
     break;
@@ -3987,2 +4323,13 @@ CStdString CGUIInfoManager::GetItemLabel(const CFileItem *item, int info, CStdSt
   case LISTITEM_DATE:
+    if (item->HasEPGInfoTag())
+      return item->GetEPGInfoTag()->StartAsLocalTime().GetAsLocalizedDateTime(false, false);
+    if (item->HasPVRChannelInfoTag())
+    {
+      CEpgInfoTag epgTag;
+      return item->GetPVRChannelInfoTag()->GetEPGNow(epgTag) ? epgTag.StartAsLocalTime().GetAsLocalizedDateTime(false, false) : CDateTime::GetCurrentDateTime().GetAsLocalizedDateTime(false, false);
+    }
+    if (item->HasPVRRecordingInfoTag())
+      return item->GetPVRRecordingInfoTag()->RecordingTimeAsLocalTime().GetAsLocalizedDateTime(false, false);
+    if (item->HasPVRTimerInfoTag())
+      return item->GetPVRTimerInfoTag()->Summary();
     if (item->m_dateTime.IsValid())
@@ -4027,3 +4374,21 @@ CStdString CGUIInfoManager::GetItemLabel(const CFileItem *item, int info, CStdSt
       CStdString duration;
-      if (item->HasVideoInfoTag())
+      if (item->HasPVRChannelInfoTag())
+      {
+        const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+        CEpgInfoTag tag;
+        if (channel && channel->GetEPGNow(tag))
+          return StringUtils::SecondsToTimeString(tag.GetDuration());
+        return StringUtils::EmptyString;
+      }
+      else if (item->HasPVRRecordingInfoTag())
+      {
+        if (item->GetPVRRecordingInfoTag()->GetDuration() > 0)
+          duration = StringUtils::SecondsToTimeString(item->GetPVRRecordingInfoTag()->GetDuration());
+      }
+      else if (item->HasEPGInfoTag())
+      {
+        if (item->GetEPGInfoTag()->GetDuration() > 0)
+          duration = StringUtils::SecondsToTimeString(item->GetEPGInfoTag()->GetDuration());
+      }
+      else if (item->HasVideoInfoTag())
       {
@@ -4032,3 +4397,3 @@ CStdString CGUIInfoManager::GetItemLabel(const CFileItem *item, int info, CStdSt
       }
-      if (item->HasMusicInfoTag())
+      else if (item->HasMusicInfoTag())
       {
@@ -4040,2 +4405,14 @@ CStdString CGUIInfoManager::GetItemLabel(const CFileItem *item, int info, CStdSt
   case LISTITEM_PLOT:
+    if (item->HasPVRChannelInfoTag())
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNow(tag))
+        return tag.Plot();
+      return StringUtils::EmptyString;
+    }
+    if (item->HasEPGInfoTag())
+      return item->GetEPGInfoTag()->Plot();
+    if (item->HasPVRRecordingInfoTag())
+      return item->GetPVRRecordingInfoTag()->m_strPlot;
     if (item->HasVideoInfoTag())
@@ -4050,2 +4427,14 @@ CStdString CGUIInfoManager::GetItemLabel(const CFileItem *item, int info, CStdSt
   case LISTITEM_PLOT_OUTLINE:
+    if (item->HasPVRChannelInfoTag())
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNow(tag))
+        return tag.PlotOutline();
+      return StringUtils::EmptyString;
+    }
+    if (item->HasEPGInfoTag())
+      return item->GetEPGInfoTag()->PlotOutline();
+    if (item->HasPVRRecordingInfoTag())
+      return item->GetPVRRecordingInfoTag()->m_strPlotOutline;
     if (item->HasVideoInfoTag())
@@ -4080,2 +4469,4 @@ CStdString CGUIInfoManager::GetItemLabel(const CFileItem *item, int info, CStdSt
   case LISTITEM_COMMENT:
+    if (item->HasPVRTimerInfoTag())
+      return item->GetPVRTimerInfoTag()->GetStatus();
     if (item->HasMusicInfoTag())
@@ -4225,2 +4616,169 @@ CStdString CGUIInfoManager::GetItemLabel(const CFileItem *item, int info, CStdSt
     break;
+  case LISTITEM_STARTTIME:
+    if (item->HasPVRChannelInfoTag())
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNow(tag))
+        return tag.StartAsLocalTime().GetAsLocalizedTime("", false);
+      return CDateTime::GetCurrentDateTime().GetAsLocalizedTime("", false);
+    }
+    if (item->HasEPGInfoTag())
+      return item->GetEPGInfoTag()->StartAsLocalTime().GetAsLocalizedTime("", false);
+    if (item->HasPVRTimerInfoTag())
+      return item->GetPVRTimerInfoTag()->StartAsLocalTime().GetAsLocalizedTime("", false);
+    if (item->HasPVRRecordingInfoTag())
+      return item->GetPVRRecordingInfoTag()->RecordingTimeAsLocalTime().GetAsLocalizedTime("", false);
+    if (item->m_dateTime.IsValid())
+      return item->m_dateTime.GetAsLocalizedTime("", false);
+    break;
+  case LISTITEM_ENDTIME:
+    if (item->HasPVRChannelInfoTag())
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNow(tag))
+        return tag.EndAsLocalTime().GetAsLocalizedTime("", false);
+      return CDateTime::GetCurrentDateTime().GetAsLocalizedTime("", false);
+    }
+    if (item->HasEPGInfoTag())
+      return item->GetEPGInfoTag()->EndAsLocalTime().GetAsLocalizedTime("", false);
+    if (item->HasPVRTimerInfoTag())
+      return item->GetPVRTimerInfoTag()->EndAsLocalTime().GetAsLocalizedTime("", false);
+    break;
+  case LISTITEM_STARTDATE:
+    if (item->HasPVRChannelInfoTag())
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNow(tag))
+        return tag.StartAsLocalTime().GetAsLocalizedDate(true);
+      return CDateTime::GetCurrentDateTime().GetAsLocalizedDate(true);
+    }
+    if (item->HasEPGInfoTag())
+      return item->GetEPGInfoTag()->StartAsLocalTime().GetAsLocalizedDate(true);
+    if (item->HasPVRTimerInfoTag())
+      return item->GetPVRTimerInfoTag()->StartAsLocalTime().GetAsLocalizedDate(true);
+    if (item->HasPVRRecordingInfoTag())
+      return item->GetPVRRecordingInfoTag()->RecordingTimeAsLocalTime().GetAsLocalizedDate(true);
+    if (item->m_dateTime.IsValid())
+      return item->m_dateTime.GetAsLocalizedDate(true);
+    break;
+  case LISTITEM_ENDDATE:
+    if (item->HasPVRChannelInfoTag())
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNow(tag))
+        return tag.EndAsLocalTime().GetAsLocalizedDate(true);
+      return CDateTime::GetCurrentDateTime().GetAsLocalizedDate(true);
+    }
+    if (item->HasEPGInfoTag())
+      return item->GetEPGInfoTag()->EndAsLocalTime().GetAsLocalizedDate(true);
+    if (item->HasPVRTimerInfoTag())
+      return item->GetPVRTimerInfoTag()->EndAsLocalTime().GetAsLocalizedDate(true);
+    break;
+  case LISTITEM_CHANNEL_NUMBER:
+    {
+      CStdString number;
+      if (item->HasPVRChannelInfoTag())
+        number.Format("%i", item->GetPVRChannelInfoTag()->ChannelNumber());
+      if (item->HasEPGInfoTag() && item->GetEPGInfoTag()->HasPVRChannel())
+        number.Format("%i", item->GetEPGInfoTag()->PVRChannelNumber());
+      if (item->HasPVRTimerInfoTag())
+        number.Format("%i", item->GetPVRTimerInfoTag()->ChannelNumber());
+
+      return number;
+    }
+    break;
+  case LISTITEM_CHANNEL_NAME:
+    if (item->HasPVRChannelInfoTag())
+      return item->GetPVRChannelInfoTag()->ChannelName();
+    if (item->HasEPGInfoTag() && item->GetEPGInfoTag()->HasPVRChannel())
+      return item->GetEPGInfoTag()->PVRChannelName();
+    if (item->HasPVRRecordingInfoTag())
+      return item->GetPVRRecordingInfoTag()->m_strChannelName;
+    if (item->HasPVRTimerInfoTag())
+      return item->GetPVRTimerInfoTag()->ChannelName();
+    break;
+  case LISTITEM_NEXT_STARTTIME:
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNext(tag))
+        return tag.StartAsLocalTime().GetAsLocalizedTime("", false);
+    }
+    return CDateTime::GetCurrentDateTime().GetAsLocalizedTime("", false);
+  case LISTITEM_NEXT_ENDTIME:
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNext(tag))
+        return tag.EndAsLocalTime().GetAsLocalizedTime("", false);
+    }
+    return CDateTime::GetCurrentDateTime().GetAsLocalizedTime("", false);
+  case LISTITEM_NEXT_STARTDATE:
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNext(tag))
+        return tag.StartAsLocalTime().GetAsLocalizedDate(true);
+    }
+    return CDateTime::GetCurrentDateTime().GetAsLocalizedDate(true);
+  case LISTITEM_NEXT_ENDDATE:
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNext(tag))
+        return tag.EndAsLocalTime().GetAsLocalizedDate(true);
+    }
+    return CDateTime::GetCurrentDateTime().GetAsLocalizedDate(true);
+  case LISTITEM_NEXT_PLOT:
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNext(tag))
+        return tag.Plot();
+    }
+    return StringUtils::EmptyString;
+  case LISTITEM_NEXT_PLOT_OUTLINE:
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNext(tag))
+        return tag.PlotOutline();
+    }
+    return StringUtils::EmptyString;
+  case LISTITEM_NEXT_DURATION:
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNext(tag))
+        return StringUtils::SecondsToTimeString(tag.GetDuration());
+    }
+    return StringUtils::EmptyString;
+  case LISTITEM_NEXT_GENRE:
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNext(tag))
+        return StringUtils::Join(tag.Genre(), g_advancedSettings.m_videoItemSeparator);
+    }
+    return StringUtils::EmptyString;
+  case LISTITEM_NEXT_TITLE:
+    {
+      const CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+      CEpgInfoTag tag;
+      if (channel && channel->GetEPGNext(tag))
+        return tag.Title();
+    }
+    return StringUtils::EmptyString;
+  case LISTITEM_PARENTALRATING:
+    {
+      CStdString rating;
+      if (item->HasEPGInfoTag() && item->GetEPGInfoTag()->ParentalRating() > 0)
+        rating.Format("%i", item->GetEPGInfoTag()->ParentalRating());
+      return rating;
+    }
+    break;
   case LISTITEM_PERCENT_PLAYED:
@@ -4326,2 +4884,61 @@ bool CGUIInfoManager::GetItemBool(const CGUIListItem *item, int condition) const
     return (item->IsFileItem() && ((const CFileItem *)item)->HasVideoInfoTag() && ((const CFileItem *)item)->GetVideoInfoTag()->m_resumePoint.timeInSeconds > 0);
+  else if (item->IsFileItem())
+  {
+    const CFileItem *pItem = (const CFileItem *)item;
+    if (condition == LISTITEM_ISRECORDING)
+    {
+      if (!g_PVRManager.IsStarted())
+        return false;
+
+      if (pItem->HasPVRChannelInfoTag())
+      {
+        return pItem->GetPVRChannelInfoTag()->IsRecording();
+      }
+      else if (pItem->HasPVRTimerInfoTag())
+      {
+        const CPVRTimerInfoTag *timer = pItem->GetPVRTimerInfoTag();
+        if (timer)
+          return timer->IsRecording();
+      }
+      else if (pItem->HasEPGInfoTag())
+      {
+        CFileItemPtr timer = g_PVRTimers->GetTimerForEpgTag(pItem);
+        if (timer && timer->HasPVRTimerInfoTag())
+          return timer->GetPVRTimerInfoTag()->IsRecording();
+      }
+    }
+    else if (condition == LISTITEM_HASTIMER)
+    {
+      if (pItem->HasEPGInfoTag())
+      {
+        CFileItemPtr timer = g_PVRTimers->GetTimerForEpgTag(pItem);
+        if (timer && timer->HasPVRTimerInfoTag())
+          return timer->GetPVRTimerInfoTag()->IsActive();
+      }
+    }
+    else if (condition == LISTITEM_HAS_EPG)
+    {
+      if (pItem->HasPVRChannelInfoTag())
+      {
+        CEpgInfoTag epgTag;
+        return pItem->GetPVRChannelInfoTag()->GetEPGNow(epgTag);
+      }
+      else
+      {
+        return pItem->HasEPGInfoTag();
+      }
+    }
+    else if (condition == LISTITEM_ISENCRYPTED)
+    {
+      if (pItem->HasPVRChannelInfoTag())
+      {
+        return pItem->GetPVRChannelInfoTag()->IsEncrypted();
+      }
+      else if (pItem->HasEPGInfoTag() && pItem->GetEPGInfoTag()->HasPVRChannel())
+      {
+        return pItem->GetEPGInfoTag()->ChannelTag()->IsEncrypted();
+      }
+    }
+  }
+
   return false;
diff --git a/xbmc/GUIViewControl.cpp b/xbmc/GUIViewControl.cpp
index ce0b945..b741922 100644
--- a/xbmc/GUIViewControl.cpp
+++ b/xbmc/GUIViewControl.cpp
@@ -64,3 +64,3 @@ void CGUIViewControl::SetParentWindow(int window)
 
-void CGUIViewControl::SetCurrentView(int viewMode)
+void CGUIViewControl::SetCurrentView(int viewMode, bool bRefresh /* = false */)
 {
@@ -101,3 +101,3 @@ void CGUIViewControl::SetCurrentView(int viewMode)
 
-  if (pNewView == previousView)
+  if (!bRefresh && pNewView == previousView)
     return; // no need to actually update anything (other than visibility above)
@@ -126,4 +126,5 @@ void CGUIViewControl::SetCurrentView(int viewMode)
 
-  // Update our view control
-  UpdateViewAsControl(((CGUIBaseContainer *)pNewView)->GetLabel());
+  // Update our view control only if we are not in the TV Window
+  if (m_parentWindow != WINDOW_PVR)
+    UpdateViewAsControl(((CGUIBaseContainer *)pNewView)->GetLabel());
 }
diff --git a/xbmc/GUIViewState.cpp b/xbmc/GUIViewState.cpp
index a4d8203..35d0964 100644
--- a/xbmc/GUIViewState.cpp
+++ b/xbmc/GUIViewState.cpp
@@ -22,2 +22,3 @@
 #include "GUIViewState.h"
+#include "pvr/windows/GUIViewStatePVR.h"
 #include "addons/GUIViewStateAddonBrowser.h"
@@ -51,2 +52,3 @@ using namespace std;
 using namespace ADDON;
+using namespace PVR;
 
@@ -130,2 +132,5 @@ CGUIViewState* CGUIViewState::GetViewState(int windowId, const CFileItemList& it
 
+  if (windowId==WINDOW_PVR)
+    return new CGUIViewStatePVR(items);
+
   if (windowId==WINDOW_PICTURES)
diff --git a/xbmc/URL.cpp b/xbmc/URL.cpp
index a1e8085..fc1a06a 100644
--- a/xbmc/URL.cpp
+++ b/xbmc/URL.cpp
@@ -172,2 +172,3 @@ void CURL::Parse(const CStdString& strURL1)
 
+  //TODO fix all Addon paths
   CStdString strProtocol2 = GetTranslatedProtocol();
@@ -185,2 +186,3 @@ void CURL::Parse(const CStdString& strURL1)
     || strProtocol2.Equals("plugin")
+    || strProtocol2.Equals("addons")
     || strProtocol2.Equals("hdhomerun")
@@ -310,2 +312,3 @@ void CURL::Parse(const CStdString& strURL1)
     || m_strProtocol.CompareNoCase("lastfm") == 0
+    || m_strProtocol.CompareNoCase("pvr") == 0
     || m_strProtocol.Left(3).CompareNoCase("mem") == 0)
diff --git a/xbmc/Util.cpp b/xbmc/Util.cpp
index f45b161..00acb43 100644
--- a/xbmc/Util.cpp
+++ b/xbmc/Util.cpp
@@ -43,2 +43,3 @@
 #include "addons/Addon.h"
+#include "filesystem/PVRDirectory.h"
 #include "filesystem/Directory.h"
@@ -558,2 +559,35 @@ void CUtil::GetHomePath(CStdString& strPath, const CStdString& strTarget)
 
+bool CUtil::IsPVR(const CStdString& strFile)
+{
+  return strFile.Left(4).Equals("pvr:");
+}
+
+bool CUtil::IsHTSP(const CStdString& strFile)
+{
+  return strFile.Left(5).Equals("htsp:");
+}
+
+bool CUtil::IsLiveTV(const CStdString& strFile)
+{
+  if (strFile.Left(14).Equals("pvr://channels"))
+    return true;
+
+  if(URIUtils::IsTuxBox(strFile)
+  || URIUtils::IsVTP(strFile)
+  || URIUtils::IsHDHomeRun(strFile)
+  || URIUtils::IsHTSP(strFile)
+  || strFile.Left(4).Equals("sap:"))
+    return true;
+
+  if (URIUtils::IsMythTV(strFile) && CMythDirectory::IsLiveTV(strFile))
+    return true;
+
+  return false;
+}
+
+bool CUtil::IsTVRecording(const CStdString& strFile)
+{
+  return strFile.Left(15).Equals("pvr://recording");
+}
+
 bool CUtil::IsPicture(const CStdString& strFile)
@@ -1868,2 +1902,4 @@ bool CUtil::SupportsFileOperations(const CStdString& strPath)
     return true;
+  if (CUtil::IsTVRecording(strPath))
+    return CPVRDirectory::SupportsFileOperations(strPath);
   if (URIUtils::IsNfs(strPath))
diff --git a/xbmc/XBDateTime.cpp b/xbmc/XBDateTime.cpp
index fca04e0..2d7d3bd 100644
--- a/xbmc/XBDateTime.cpp
+++ b/xbmc/XBDateTime.cpp
@@ -866,2 +866,41 @@ CStdString CDateTime::GetAsDBDateTime() const
 
+CStdString CDateTime::GetAsSaveString() const
+{
+  SYSTEMTIME st;
+  GetAsSystemTime(st);
+
+  CStdString date;
+  date.Format("%04i%02i%02i_%02i%02i%02i", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
+
+  return date;
+}
+
+void CDateTime::SetFromUTCDateTime(const CDateTime &dateTime)
+{
+  TIME_ZONE_INFORMATION tz;
+  CDateTime tmp(dateTime);
+
+  switch(GetTimeZoneInformation(&tz))
+  {
+    case TIME_ZONE_ID_DAYLIGHT:
+        tmp -= CDateTimeSpan(0, 0, tz.Bias + tz.DaylightBias, 0);
+        break;
+    case TIME_ZONE_ID_STANDARD:
+        tmp -= CDateTimeSpan(0, 0, tz.Bias + tz.StandardBias, 0);
+        break;
+    case TIME_ZONE_ID_UNKNOWN:
+        tmp -= CDateTimeSpan(0, 0, tz.Bias, 0);
+        break;
+  }
+
+  m_time = tmp.m_time;
+  m_state = tmp.m_state;
+}
+
+void CDateTime::SetFromUTCDateTime(const time_t &dateTime)
+{
+  CDateTime tmp(dateTime);
+  SetFromUTCDateTime(tmp);
+}
+
 void CDateTime::SetFromW3CDate(const CStdString &dateTime)
diff --git a/xbmc/addons/Addon.cpp b/xbmc/addons/Addon.cpp
index ddb28c0..55504cb 100644
--- a/xbmc/addons/Addon.cpp
+++ b/xbmc/addons/Addon.cpp
@@ -82,3 +82,3 @@ static const TypeMapping types[] =
    {"xbmc.addon.repository",             ADDON_REPOSITORY,          24011, "DefaultAddonRepository.png" },
-   {"pvrclient",                         ADDON_PVRDLL,                  0, "" },
+   {"xbmc.pvrclient",                    ADDON_PVRDLL,              24019, "" },
    {"xbmc.addon.video",                  ADDON_VIDEO,                1037, "DefaultAddonVideo.png" },
@@ -292,2 +292,5 @@ void CAddon::BuildLibName(const cp_extension_t *extension)
       break;
+    case ADDON_PVRDLL:
+      ext = ADDON_PVRDLL_EXT;
+      break;
     case ADDON_SCRIPT:
@@ -327,2 +330,3 @@ void CAddon::BuildLibName(const cp_extension_t *extension)
       case ADDON_SCRAPER_LIBRARY:
+      case ADDON_PVRDLL:
       case ADDON_PLUGIN:
diff --git a/xbmc/addons/AddonCallbacks.cpp b/xbmc/addons/AddonCallbacks.cpp
new file mode 100644
index 0000000..3cbb416
--- /dev/null
+++ b/xbmc/addons/AddonCallbacks.cpp
@@ -0,0 +1,142 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Addon.h"
+#include "AddonCallbacks.h"
+#include "AddonCallbacksAddon.h"
+#include "AddonCallbacksGUI.h"
+#include "AddonCallbacksPVR.h"
+#include "filesystem/SpecialProtocol.h"
+#include "utils/log.h"
+
+namespace ADDON
+{
+
+CAddonCallbacks::CAddonCallbacks(CAddon* addon)
+{
+  m_addon       = addon;
+  m_callbacks   = new AddonCB;
+  m_helperAddon = NULL;
+  m_helperGUI   = NULL;
+  m_helperPVR   = NULL;
+
+  m_callbacks->libBasePath           = strdup(CSpecialProtocol::TranslatePath("special://xbmcbin/addons"));
+  m_callbacks->addonData             = this;
+  m_callbacks->AddOnLib_RegisterMe   = CAddonCallbacks::AddOnLib_RegisterMe;
+  m_callbacks->AddOnLib_UnRegisterMe = CAddonCallbacks::AddOnLib_UnRegisterMe;
+  m_callbacks->GUILib_RegisterMe     = CAddonCallbacks::GUILib_RegisterMe;
+  m_callbacks->GUILib_UnRegisterMe   = CAddonCallbacks::GUILib_UnRegisterMe;
+  m_callbacks->PVRLib_RegisterMe     = CAddonCallbacks::PVRLib_RegisterMe;
+  m_callbacks->PVRLib_UnRegisterMe   = CAddonCallbacks::PVRLib_UnRegisterMe;
+}
+
+CAddonCallbacks::~CAddonCallbacks()
+{
+  delete m_helperAddon;
+  m_helperAddon = NULL;
+  delete m_helperGUI;
+  m_helperGUI = NULL;
+  delete m_helperPVR;
+  m_helperPVR = NULL;
+  free((char*)m_callbacks->libBasePath);
+  delete m_callbacks;
+  m_callbacks = NULL;
+}
+
+CB_AddOnLib* CAddonCallbacks::AddOnLib_RegisterMe(void *addonData)
+{
+  CAddonCallbacks* addon = (CAddonCallbacks*) addonData;
+  if (addon == NULL)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacks - %s - called with a null pointer", __FUNCTION__);
+    return NULL;
+  }
+
+  addon->m_helperAddon = new CAddonCallbacksAddon(addon->m_addon);
+  return addon->m_helperAddon->GetCallbacks();
+}
+
+void CAddonCallbacks::AddOnLib_UnRegisterMe(void *addonData, CB_AddOnLib *cbTable)
+{
+  CAddonCallbacks* addon = (CAddonCallbacks*) addonData;
+  if (addon == NULL)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacks - %s - called with a null pointer", __FUNCTION__);
+    return;
+  }
+
+  delete addon->m_helperAddon;
+  addon->m_helperAddon = NULL;
+}
+
+CB_GUILib* CAddonCallbacks::GUILib_RegisterMe(void *addonData)
+{
+  CAddonCallbacks* addon = (CAddonCallbacks*) addonData;
+  if (addon == NULL)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacks - %s - called with a null pointer", __FUNCTION__);
+    return NULL;
+  }
+
+  addon->m_helperGUI = new CAddonCallbacksGUI(addon->m_addon);
+  return addon->m_helperGUI->GetCallbacks();
+}
+
+void CAddonCallbacks::GUILib_UnRegisterMe(void *addonData, CB_GUILib *cbTable)
+{
+  CAddonCallbacks* addon = (CAddonCallbacks*) addonData;
+  if (addon == NULL)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacks - %s - called with a null pointer", __FUNCTION__);
+    return;
+  }
+
+  delete addon->m_helperGUI;
+  addon->m_helperGUI = NULL;
+}
+
+CB_PVRLib* CAddonCallbacks::PVRLib_RegisterMe(void *addonData)
+{
+  CAddonCallbacks* addon = (CAddonCallbacks*) addonData;
+  if (addon == NULL)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacks - %s - called with a null pointer", __FUNCTION__);
+    return NULL;
+  }
+
+  addon->m_helperPVR = new CAddonCallbacksPVR(addon->m_addon);
+  return addon->m_helperPVR->GetCallbacks();
+}
+
+void CAddonCallbacks::PVRLib_UnRegisterMe(void *addonData, CB_PVRLib *cbTable)
+{
+  CAddonCallbacks* addon = (CAddonCallbacks*) addonData;
+  if (addon == NULL)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacks - %s - called with a null pointer", __FUNCTION__);
+    return;
+  }
+
+  delete addon->m_helperPVR;
+  addon->m_helperPVR = NULL;
+}
+
+}; /* namespace ADDON */
diff --git a/xbmc/addons/AddonCallbacksAddon.cpp b/xbmc/addons/AddonCallbacksAddon.cpp
new file mode 100644
index 0000000..bb80156
--- /dev/null
+++ b/xbmc/addons/AddonCallbacksAddon.cpp
@@ -0,0 +1,250 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Application.h"
+#include "Addon.h"
+#include "AddonCallbacksAddon.h"
+#include "utils/log.h"
+#include "LangInfo.h"
+#include "dialogs/GUIDialogKaiToast.h"
+
+namespace ADDON
+{
+
+CAddonCallbacksAddon::CAddonCallbacksAddon(CAddon* addon)
+{
+  m_addon     = addon;
+  m_callbacks = new CB_AddOnLib;
+
+  /* write XBMC addon-on specific add-on function addresses to the callback table */
+  m_callbacks->Log                = AddOnLog;
+  m_callbacks->QueueNotification  = QueueNotification;
+  m_callbacks->GetSetting         = GetAddonSetting;
+  m_callbacks->UnknownToUTF8      = UnknownToUTF8;
+  m_callbacks->GetLocalizedString = GetLocalizedString;
+  m_callbacks->GetDVDMenuLanguage = GetDVDMenuLanguage;
+}
+
+CAddonCallbacksAddon::~CAddonCallbacksAddon()
+{
+  /* delete the callback table */
+  delete m_callbacks;
+}
+
+void CAddonCallbacksAddon::AddOnLog(void *addonData, const addon_log_t addonLogLevel, const char *strMessage)
+{
+  CAddonCallbacks* addon = (CAddonCallbacks*) addonData;
+  if (addon == NULL || strMessage == NULL)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - called with a null pointer", __FUNCTION__);
+    return;
+  }
+
+  CAddonCallbacksAddon* addonHelper = addon->GetHelperAddon();
+
+  try
+  {
+    int xbmcLogLevel = LOGNONE;
+    switch (addonLogLevel)
+    {
+      case LOG_ERROR:
+        xbmcLogLevel = LOGERROR;
+        break;
+      case LOG_INFO:
+        xbmcLogLevel = LOGINFO;
+        break;
+      case LOG_NOTICE:
+        xbmcLogLevel = LOGNOTICE;
+        break;
+      case LOG_DEBUG:
+      default:
+        xbmcLogLevel = LOGDEBUG;
+        break;
+    }
+
+    CStdString strXbmcMessage;
+    strXbmcMessage.Format("AddOnLog: %s: %s", addonHelper->m_addon->Name().c_str(), strMessage);
+    CLog::Log(xbmcLogLevel, "%s", strXbmcMessage.c_str());
+  }
+  catch (std::exception &e)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - exception '%s' caught in call in add-on '%s'. please contact the developer of this addon: %s",
+        __FUNCTION__, e.what(), addonHelper->m_addon->Name().c_str(), addonHelper->m_addon->Author().c_str());
+  }
+}
+
+void CAddonCallbacksAddon::QueueNotification(void *addonData, const queue_msg_t type, const char *strMessage)
+{
+  CAddonCallbacks* addon = (CAddonCallbacks*) addonData;
+  if (addon == NULL || strMessage == NULL)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - called with a null pointer", __FUNCTION__);
+    return;
+  }
+
+  CAddonCallbacksAddon* addonHelper = addon->GetHelperAddon();
+
+  try
+  {
+    switch (type)
+    {
+      case QUEUE_WARNING:
+        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Warning, addonHelper->m_addon->Name(), strMessage, 3000, true);
+        CLog::Log(LOGDEBUG, "CAddonCallbacksAddon - %s - %s - Warning Message: '%s'", __FUNCTION__, addonHelper->m_addon->Name().c_str(), strMessage);
+        break;
+
+      case QUEUE_ERROR:
+        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, addonHelper->m_addon->Name(), strMessage, 3000, true);
+        CLog::Log(LOGDEBUG, "CAddonCallbacksAddon - %s - %s - Error Message : '%s'", __FUNCTION__, addonHelper->m_addon->Name().c_str(), strMessage);
+        break;
+
+      case QUEUE_INFO:
+      default:
+        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, addonHelper->m_addon->Name(), strMessage, 3000, false);
+        CLog::Log(LOGDEBUG, "CAddonCallbacksAddon - %s - %s - Info Message : '%s'", __FUNCTION__, addonHelper->m_addon->Name().c_str(), strMessage);
+        break;
+    }
+  }
+  catch (std::exception &e)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - exception '%s' caught in call in add-on '%s'. please contact the developer of this addon: %s",
+        __FUNCTION__, e.what(), addonHelper->m_addon->Name().c_str(), addonHelper->m_addon->Author().c_str());
+  }
+}
+
+bool CAddonCallbacksAddon::GetAddonSetting(void *addonData, const char *strSettingName, void *settingValue)
+{
+  CAddonCallbacks* addon = (CAddonCallbacks*) addonData;
+  if (addon == NULL || strSettingName == NULL || settingValue == NULL)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - called with a null pointer", __FUNCTION__);
+    return false;
+  }
+
+  CAddonCallbacksAddon* addonHelper = addon->GetHelperAddon();
+
+  try
+  {
+    CLog::Log(LOGDEBUG, "CAddonCallbacksAddon - %s - add-on '%s' requests setting '%s'", __FUNCTION__, addonHelper->m_addon->Name().c_str(), strSettingName);
+
+    if (!addonHelper->m_addon->ReloadSettings())
+    {
+      CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - could't get settings for add-on '%s'", __FUNCTION__, addonHelper->m_addon->Name().c_str());
+      return false;
+    }
+
+    const TiXmlElement *category = addonHelper->m_addon->GetSettingsXML()->FirstChildElement("category");
+    if (!category) // add a default one...
+      category = addonHelper->m_addon->GetSettingsXML();
+
+    while (category)
+    {
+      const TiXmlElement *setting = category->FirstChildElement("setting");
+      while (setting)
+      {
+        const char *id = setting->Attribute("id");
+        const char *type = setting->Attribute("type");
+
+        if (strcmpi(id, strSettingName) == 0 && type)
+        {
+          if (strcmpi(type, "text")   == 0 || strcmpi(type, "ipaddress") == 0 ||
+              strcmpi(type, "folder") == 0 || strcmpi(type, "action")    == 0 ||
+              strcmpi(type, "music")  == 0 || strcmpi(type, "pictures")  == 0 ||
+              strcmpi(type, "folder") == 0 || strcmpi(type, "programs")  == 0 ||
+              strcmpi(type, "file")  == 0 || strcmpi(type, "fileenum")  == 0)
+          {
+            strcpy((char*) settingValue, addonHelper->m_addon->GetSetting(id).c_str());
+            return true;
+          }
+          else if (strcmpi(type, "number") == 0 || strcmpi(type, "enum") == 0 ||
+                   strcmpi(type, "labelenum") == 0)
+          {
+            *(int*) settingValue = (int) atoi(addonHelper->m_addon->GetSetting(id));
+            return true;
+          }
+          else if (strcmpi(type, "bool") == 0)
+          {
+            *(bool*) settingValue = (bool) (addonHelper->m_addon->GetSetting(id) == "true" ? true : false);
+            return true;
+          }
+        }
+        setting = setting->NextSiblingElement("setting");
+      }
+      category = category->NextSiblingElement("category");
+    }
+    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - can't find setting '%s' in '%s'", __FUNCTION__, strSettingName, addonHelper->m_addon->Name().c_str());
+  }
+  catch (std::exception &e)
+  {
+    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - exception '%s' caught in call in add-on '%s'. please contact the developer of this addon: %s",
+        __FUNCTION__, e.what(), addonHelper->m_addon->Name().c_str(), addonHelper->m_addon->Author().c_str());
+  }
+
+  return false;
+}
+
+char* CAddonCallbacksAddon::UnknownToUTF8(const char *strSource)
+{
+  CStdString string;
+  if (strSource != NULL)
+    g_charsetConverter.unknownToUTF8(strSource, string);
+  else
+    string = "";
+  char *buffer = (char*) malloc (string.length()+1);
+  strcpy(buffer, string.c_str());
+  return buffer;
+}
+
+const char* CAddonCallbacksAddon::GetLocalizedString(const void* addonData, long dwCode)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || g_application.m_bStop)
+    return NULL;
+
+  CAddonCallbacksAddon* addonHelper = helper->GetHelperAddon();
+
+  CStdString string;
+  if (dwCode >= 30000 && dwCode <= 30999)
+    string = addonHelper->m_addon->GetString(dwCode).c_str();
+  else if (dwCode >= 32000 && dwCode <= 32999)
+    string = addonHelper->m_addon->GetString(dwCode).c_str();
+  else
+    string = g_localizeStrings.Get(dwCode).c_str();
+
+  char *buffer = (char*) malloc (string.length()+1);
+  strcpy(buffer, string.c_str());
+  return buffer;
+}
+
+const char* CAddonCallbacksAddon::GetDVDMenuLanguage(const void* addonData)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return NULL;
+
+  CStdString string = g_langInfo.GetDVDMenuLanguage();
+
+  char *buffer = (char*) malloc (string.length()+1);
+  strcpy(buffer, string.c_str());
+  return buffer;
+}
+
+}; /* namespace ADDON */
diff --git a/xbmc/addons/AddonCallbacksGUI.cpp b/xbmc/addons/AddonCallbacksGUI.cpp
new file mode 100644
index 0000000..742d877
--- /dev/null
+++ b/xbmc/addons/AddonCallbacksGUI.cpp
@@ -0,0 +1,1542 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include "Addon.h"
+#include "AddonCallbacksGUI.h"
+#include "utils/log.h"
+#include "Skin.h"
+#include "FileItem.h"
+#include "filesystem/File.h"
+#include "utils/URIUtils.h"
+#include "utils/TimeUtils.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/TextureManager.h"
+#include "settings/GUISettings.h"
+#include "guilib/GUISpinControlEx.h"
+#include "guilib/GUIRadioButtonControl.h"
+#include "guilib/GUISettingsSliderControl.h"
+#include "guilib/GUIEditControl.h"
+#include "guilib/GUIProgressControl.h"
+
+#define CONTROL_BTNVIEWASICONS  2
+#define CONTROL_BTNSORTBY       3
+#define CONTROL_BTNSORTASC      4
+#define CONTROL_LABELFILES      12
+
+using namespace std;
+
+namespace ADDON
+{
+
+static int iXBMCGUILockRef = 0;
+
+CAddonCallbacksGUI::CAddonCallbacksGUI(CAddon* addon)
+{
+  m_addon     = addon;
+  m_callbacks = new CB_GUILib;
+
+  /* GUI Helper functions */
+  m_callbacks->Lock                           = CAddonCallbacksGUI::Lock;
+  m_callbacks->Unlock                         = CAddonCallbacksGUI::Unlock;
+  m_callbacks->GetScreenHeight                = CAddonCallbacksGUI::GetScreenHeight;
+  m_callbacks->GetScreenWidth                 = CAddonCallbacksGUI::GetScreenWidth;
+  m_callbacks->GetVideoResolution             = CAddonCallbacksGUI::GetVideoResolution;
+  m_callbacks->Window_New                     = CAddonCallbacksGUI::Window_New;
+  m_callbacks->Window_Delete                  = CAddonCallbacksGUI::Window_Delete;
+  m_callbacks->Window_SetCallbacks            = CAddonCallbacksGUI::Window_SetCallbacks;
+  m_callbacks->Window_Show                    = CAddonCallbacksGUI::Window_Show;
+  m_callbacks->Window_Close                   = CAddonCallbacksGUI::Window_Close;
+  m_callbacks->Window_DoModal                 = CAddonCallbacksGUI::Window_DoModal;
+  m_callbacks->Window_SetFocusId              = CAddonCallbacksGUI::Window_SetFocusId;
+  m_callbacks->Window_GetFocusId              = CAddonCallbacksGUI::Window_GetFocusId;
+  m_callbacks->Window_SetCoordinateResolution = CAddonCallbacksGUI::Window_SetCoordinateResolution;
+  m_callbacks->Window_SetProperty             = CAddonCallbacksGUI::Window_SetProperty;
+  m_callbacks->Window_SetPropertyInt          = CAddonCallbacksGUI::Window_SetPropertyInt;
+  m_callbacks->Window_SetPropertyBool         = CAddonCallbacksGUI::Window_SetPropertyBool;
+  m_callbacks->Window_SetPropertyDouble       = CAddonCallbacksGUI::Window_SetPropertyDouble;
+  m_callbacks->Window_GetProperty             = CAddonCallbacksGUI::Window_GetProperty;
+  m_callbacks->Window_GetPropertyInt          = CAddonCallbacksGUI::Window_GetPropertyInt;
+  m_callbacks->Window_GetPropertyBool         = CAddonCallbacksGUI::Window_GetPropertyBool;
+  m_callbacks->Window_GetPropertyDouble       = CAddonCallbacksGUI::Window_GetPropertyDouble;
+  m_callbacks->Window_ClearProperties         = CAddonCallbacksGUI::Window_ClearProperties;
+
+  m_callbacks->Window_GetListSize             = CAddonCallbacksGUI::Window_GetListSize;
+  m_callbacks->Window_ClearList               = CAddonCallbacksGUI::Window_ClearList;
+  m_callbacks->Window_AddItem                 = CAddonCallbacksGUI::Window_AddItem;
+  m_callbacks->Window_AddStringItem           = CAddonCallbacksGUI::Window_AddStringItem;
+  m_callbacks->Window_RemoveItem              = CAddonCallbacksGUI::Window_RemoveItem;
+  m_callbacks->Window_GetListItem             = CAddonCallbacksGUI::Window_GetListItem;
+  m_callbacks->Window_SetCurrentListPosition  = CAddonCallbacksGUI::Window_SetCurrentListPosition;
+  m_callbacks->Window_GetCurrentListPosition  = CAddonCallbacksGUI::Window_GetCurrentListPosition;
+
+  m_callbacks->Window_GetControl_Spin         = CAddonCallbacksGUI::Window_GetControl_Spin;
+  m_callbacks->Window_GetControl_Button       = CAddonCallbacksGUI::Window_GetControl_Button;
+  m_callbacks->Window_GetControl_RadioButton  = CAddonCallbacksGUI::Window_GetControl_RadioButton;
+  m_callbacks->Window_GetControl_Edit         = CAddonCallbacksGUI::Window_GetControl_Edit;
+  m_callbacks->Window_GetControl_Progress     = CAddonCallbacksGUI::Window_GetControl_Progress;
+
+  m_callbacks->Window_SetControlLabel         = CAddonCallbacksGUI::Window_SetControlLabel;
+
+  m_callbacks->Control_Spin_SetVisible        = CAddonCallbacksGUI::Control_Spin_SetVisible;
+  m_callbacks->Control_Spin_SetText           = CAddonCallbacksGUI::Control_Spin_SetText;
+  m_callbacks->Control_Spin_Clear             = CAddonCallbacksGUI::Control_Spin_Clear;
+  m_callbacks->Control_Spin_AddLabel          = CAddonCallbacksGUI::Control_Spin_AddLabel;
+  m_callbacks->Control_Spin_GetValue          = CAddonCallbacksGUI::Control_Spin_GetValue;
+  m_callbacks->Control_Spin_SetValue          = CAddonCallbacksGUI::Control_Spin_SetValue;
+
+  m_callbacks->Control_RadioButton_SetVisible = CAddonCallbacksGUI::Control_RadioButton_SetVisible;
+  m_callbacks->Control_RadioButton_SetText    = CAddonCallbacksGUI::Control_RadioButton_SetText;
+  m_callbacks->Control_RadioButton_SetSelected= CAddonCallbacksGUI::Control_RadioButton_SetSelected;
+  m_callbacks->Control_RadioButton_IsSelected = CAddonCallbacksGUI::Control_RadioButton_IsSelected;
+
+  m_callbacks->Control_Progress_SetPercentage = CAddonCallbacksGUI::Control_Progress_SetPercentage;
+  m_callbacks->Control_Progress_GetPercentage = CAddonCallbacksGUI::Control_Progress_GetPercentage;
+  m_callbacks->Control_Progress_SetInfo       = CAddonCallbacksGUI::Control_Progress_SetInfo;
+  m_callbacks->Control_Progress_GetInfo       = CAddonCallbacksGUI::Control_Progress_GetInfo;
+  m_callbacks->Control_Progress_GetDescription= CAddonCallbacksGUI::Control_Progress_GetDescription;
+
+  m_callbacks->ListItem_Create                = CAddonCallbacksGUI::ListItem_Create;
+  m_callbacks->ListItem_GetLabel              = CAddonCallbacksGUI::ListItem_GetLabel;
+  m_callbacks->ListItem_SetLabel              = CAddonCallbacksGUI::ListItem_SetLabel;
+  m_callbacks->ListItem_GetLabel2             = CAddonCallbacksGUI::ListItem_GetLabel2;
+  m_callbacks->ListItem_SetLabel2             = CAddonCallbacksGUI::ListItem_SetLabel2;
+  m_callbacks->ListItem_SetIconImage          = CAddonCallbacksGUI::ListItem_SetIconImage;
+  m_callbacks->ListItem_SetThumbnailImage     = CAddonCallbacksGUI::ListItem_SetThumbnailImage;
+  m_callbacks->ListItem_SetInfo               = CAddonCallbacksGUI::ListItem_SetInfo;
+  m_callbacks->ListItem_SetProperty           = CAddonCallbacksGUI::ListItem_SetProperty;
+  m_callbacks->ListItem_GetProperty           = CAddonCallbacksGUI::ListItem_GetProperty;
+  m_callbacks->ListItem_SetPath               = CAddonCallbacksGUI::ListItem_SetPath;
+}
+
+CAddonCallbacksGUI::~CAddonCallbacksGUI()
+{
+  delete m_callbacks;
+}
+
+void CAddonCallbacksGUI::Lock()
+{
+  if (iXBMCGUILockRef == 0) g_graphicsContext.Lock();
+  iXBMCGUILockRef++;
+}
+
+void CAddonCallbacksGUI::Unlock()
+{
+  if (iXBMCGUILockRef > 0)
+  {
+    iXBMCGUILockRef--;
+    if (iXBMCGUILockRef == 0) g_graphicsContext.Unlock();
+  }
+}
+
+int CAddonCallbacksGUI::GetScreenHeight()
+{
+  return g_graphicsContext.GetHeight();
+}
+
+int CAddonCallbacksGUI::GetScreenWidth()
+{
+  return g_graphicsContext.GetWidth();
+}
+
+int CAddonCallbacksGUI::GetVideoResolution()
+{
+  return (int)g_graphicsContext.GetVideoResolution();
+}
+
+GUIHANDLE CAddonCallbacksGUI::Window_New(void *addonData, const char *xmlFilename, const char *defaultSkin, bool forceFallback, bool asDialog)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return NULL;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  RESOLUTION_INFO res;
+  CStdString strSkinPath;
+  if (!forceFallback)
+  {
+    /* Check to see if the XML file exists in current skin. If not use
+       fallback path to find a skin for the addon */
+    strSkinPath = g_SkinInfo->GetSkinPath(xmlFilename, &res);
+
+    if (!XFILE::CFile::Exists(strSkinPath))
+    {
+      /* Check for the matching folder for the skin in the fallback skins folder */
+      CStdString basePath;
+      URIUtils::AddFileToFolder(guiHelper->m_addon->Path(), "resources", basePath);
+      URIUtils::AddFileToFolder(basePath, "skins", basePath);
+      URIUtils::AddFileToFolder(basePath, URIUtils::GetFileName(g_SkinInfo->Path()), basePath);
+      strSkinPath = g_SkinInfo->GetSkinPath(xmlFilename, &res, basePath);
+      if (!XFILE::CFile::Exists(strSkinPath))
+      {
+        /* Finally fallback to the DefaultSkin as it didn't exist in either the
+           XBMC Skin folder or the fallback skin folder */
+        forceFallback = true;
+      }
+    }
+  }
+
+  if (forceFallback)
+  {
+    //FIXME make this static method of current skin?
+    CStdString str("none");
+    AddonProps props(str, ADDON_SKIN, str, str);
+    CSkinInfo skinInfo(props);
+    CStdString basePath;
+    URIUtils::AddFileToFolder(guiHelper->m_addon->Path(), "resources", basePath);
+    URIUtils::AddFileToFolder(basePath, "skins", basePath);
+    URIUtils::AddFileToFolder(basePath, defaultSkin, basePath);
+    props.path = basePath;
+
+    skinInfo.Start();
+    strSkinPath = skinInfo.GetSkinPath(xmlFilename, &res, basePath);
+
+    if (!XFILE::CFile::Exists(strSkinPath))
+    {
+      CLog::Log(LOGERROR, "Window_New: %s/%s - XML File '%s' for Window is missing, contact Developer '%s' of this AddOn", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str(), strSkinPath.c_str(), guiHelper->m_addon->Author().c_str());
+      return NULL;
+    }
+  }
+  // window id's 14000 - 14100 are reserved for addons
+  // get first window id that is not in use
+  int id = WINDOW_ADDON_START;
+  // if window 14099 is in use it means addon can't create more windows
+  Lock();
+  if (g_windowManager.GetWindow(WINDOW_ADDON_END))
+  {
+    Unlock();
+    CLog::Log(LOGERROR, "Window_New: %s/%s - maximum number of windows reached", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return NULL;
+  }
+  while(id < WINDOW_ADDON_END && g_windowManager.GetWindow(id) != NULL) id++;
+  Unlock();
+
+  CGUIWindow *window;
+  if (!asDialog)
+    window = new CGUIAddonWindow(id, strSkinPath, guiHelper->m_addon);
+  else
+    window = new CGUIAddonWindowDialog(id, strSkinPath, guiHelper->m_addon);
+
+  Lock();
+  g_windowManager.Add(window);
+  Unlock();
+
+  window->SetCoordsRes(res);
+
+  return window;
+}
+
+void CAddonCallbacksGUI::Window_Delete(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_Show: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return;
+
+  Lock();
+  // first change to an existing window
+  if (g_windowManager.GetActiveWindow() == pAddonWindow->m_iWindowId && !g_application.m_bStop)
+  {
+    if(g_windowManager.GetWindow(pAddonWindow->m_iOldWindowId))
+      g_windowManager.ActivateWindow(pAddonWindow->m_iOldWindowId);
+    else // old window does not exist anymore, switch to home
+      g_windowManager.ActivateWindow(WINDOW_HOME);
+  }
+  // Free any window properties
+  pAddonWindow->ClearProperties();
+  // free the window's resources and unload it (free all guicontrols)
+  pAddonWindow->FreeResources(true);
+
+  g_windowManager.Remove(pAddonWindow->GetID());
+  delete pAddonWindow;
+  Unlock();
+}
+
+void CAddonCallbacksGUI::Window_SetCallbacks(void *addonData, GUIHANDLE handle, GUIHANDLE clienthandle, bool (*initCB)(GUIHANDLE), bool (*clickCB)(GUIHANDLE, int), bool (*focusCB)(GUIHANDLE, int), bool (*onActionCB)(GUIHANDLE handle, int))
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+
+  Lock();
+  pAddonWindow->m_clientHandle  = clienthandle;
+  pAddonWindow->CBOnInit        = initCB;
+  pAddonWindow->CBOnClick       = clickCB;
+  pAddonWindow->CBOnFocus       = focusCB;
+  pAddonWindow->CBOnAction      = onActionCB;
+  Unlock();
+}
+
+bool CAddonCallbacksGUI::Window_Show(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return false;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_Show: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return false;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return false;
+
+  if (pAddonWindow->m_iOldWindowId != pAddonWindow->m_iWindowId && pAddonWindow->m_iWindowId != g_windowManager.GetActiveWindow())
+    pAddonWindow->m_iOldWindowId = g_windowManager.GetActiveWindow();
+
+  Lock();
+  if (pAddonWindow->IsDialog())
+    ((CGUIAddonWindowDialog*)pAddonWindow)->Show();
+  else
+    g_windowManager.ActivateWindow(pAddonWindow->m_iWindowId);
+  Unlock();
+
+  return true;
+}
+
+bool CAddonCallbacksGUI::Window_Close(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return false;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_Close: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return false;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return false;
+
+  pAddonWindow->m_bModal = false;
+  if (pAddonWindow->IsDialog())
+    ((CGUIAddonWindowDialog*)pAddonWindow)->PulseActionEvent();
+  else
+    ((CGUIAddonWindow*)pAddonWindow)->PulseActionEvent();
+
+  Lock();
+  // if it's a dialog, we have to close it a bit different
+  if (pAddonWindow->IsDialog())
+    ((CGUIAddonWindowDialog*)pAddonWindow)->Show(false);
+  else
+    g_windowManager.ActivateWindow(pAddonWindow->m_iOldWindowId);
+  pAddonWindow->m_iOldWindowId = 0;
+
+  Unlock();
+
+  return true;
+}
+
+bool CAddonCallbacksGUI::Window_DoModal(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return false;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_DoModal: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return false;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return false;
+
+  pAddonWindow->m_bModal = true;
+
+  if (pAddonWindow->m_iWindowId != g_windowManager.GetActiveWindow())
+    Window_Show(addonData, handle);
+
+  return true;
+}
+
+bool CAddonCallbacksGUI::Window_SetFocusId(void *addonData, GUIHANDLE handle, int iControlId)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return false;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_SetFocusId: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return false;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return false;
+
+  if(!pWindow->GetControl(iControlId))
+  {
+    CLog::Log(LOGERROR, "Window_SetFocusId: %s/%s - Control does not exist in window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return false;
+  }
+
+  Lock();
+  CGUIMessage msg = CGUIMessage(GUI_MSG_SETFOCUS, pAddonWindow->m_iWindowId, iControlId);
+  pWindow->OnMessage(msg);
+  Unlock();
+
+  return true;
+}
+
+int CAddonCallbacksGUI::Window_GetFocusId(void *addonData, GUIHANDLE handle)
+{
+  int iControlId = -1;
+
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return iControlId;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_GetFocusId: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return iControlId;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return iControlId;
+
+  Lock();
+  iControlId = pWindow->GetFocusedControlID();
+  Unlock();
+
+  if (iControlId == -1)
+  {
+    CLog::Log(LOGERROR, "Window_GetFocusId: %s/%s - No control in this window has focus", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return iControlId;
+  }
+
+  return iControlId;
+}
+
+bool CAddonCallbacksGUI::Window_SetCoordinateResolution(void *addonData, GUIHANDLE handle, int res)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return false;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "SetCoordinateResolution: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return false;
+  }
+
+  if (res < RES_HDTV_1080i || res > RES_AUTORES)
+  {
+    CLog::Log(LOGERROR, "SetCoordinateResolution: %s/%s - Invalid resolution", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return false;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return false;
+
+  pWindow->SetCoordsRes((RESOLUTION)res);
+
+  return true;
+}
+
+void CAddonCallbacksGUI::Window_SetProperty(void *addonData, GUIHANDLE handle, const char *key, const char *value)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_SetProperty: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return;
+
+  CStdString lowerKey = key;
+
+  Lock();
+  pWindow->SetProperty(lowerKey.ToLower(), value);
+  Unlock();
+}
+
+void CAddonCallbacksGUI::Window_SetPropertyInt(void *addonData, GUIHANDLE handle, const char *key, int value)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_SetPropertyInt: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return;
+
+  CStdString lowerKey = key;
+
+  Lock();
+  pWindow->SetProperty(lowerKey.ToLower(), value);
+  Unlock();
+}
+
+void CAddonCallbacksGUI::Window_SetPropertyBool(void *addonData, GUIHANDLE handle, const char *key, bool value)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_SetPropertyBool: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return;
+
+  CStdString lowerKey = key;
+
+  Lock();
+  pWindow->SetProperty(lowerKey.ToLower(), value);
+  Unlock();
+}
+
+void CAddonCallbacksGUI::Window_SetPropertyDouble(void *addonData, GUIHANDLE handle, const char *key, double value)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_SetPropertyDouble: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return;
+
+  CStdString lowerKey = key;
+
+  Lock();
+  pWindow->SetProperty(lowerKey.ToLower(), value);
+  Unlock();
+}
+
+const char* CAddonCallbacksGUI::Window_GetProperty(void *addonData, GUIHANDLE handle, const char *key)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return NULL;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_GetProperty: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return NULL;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return NULL;
+
+  Lock();
+  CStdString lowerKey = key;
+  string value = pWindow->GetProperty(lowerKey.ToLower()).asString();
+  Unlock();
+
+  return value.c_str();
+}
+
+int CAddonCallbacksGUI::Window_GetPropertyInt(void *addonData, GUIHANDLE handle, const char *key)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return -1;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_GetPropertyInt: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return -1;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return -1;
+
+  Lock();
+  CStdString lowerKey = key;
+  int value = pWindow->GetProperty(lowerKey.ToLower()).asInteger();
+  Unlock();
+
+  return value;
+}
+
+bool CAddonCallbacksGUI::Window_GetPropertyBool(void *addonData, GUIHANDLE handle, const char *key)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return false;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_GetPropertyBool: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return false;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return false;
+
+  Lock();
+  CStdString lowerKey = key;
+  bool value = pWindow->GetProperty(lowerKey.ToLower()).asBoolean();
+  Unlock();
+
+  return value;
+}
+
+double CAddonCallbacksGUI::Window_GetPropertyDouble(void *addonData, GUIHANDLE handle, const char *key)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return 0.0;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_GetPropertyDouble: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return 0.0;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return 0.0;
+
+  Lock();
+  CStdString lowerKey = key;
+  double value = pWindow->GetProperty(lowerKey.ToLower()).asDouble();
+  Unlock();
+
+  return value;
+}
+
+void CAddonCallbacksGUI::Window_ClearProperties(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+
+  if (!handle)
+  {
+    CLog::Log(LOGERROR, "Window_ClearProperties: %s/%s - No Window", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return;
+  }
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIWindow      *pWindow      = (CGUIWindow*)g_windowManager.GetWindow(pAddonWindow->m_iWindowId);
+  if (!pWindow)
+    return;
+
+  Lock();
+  pWindow->ClearProperties();
+  Unlock();
+}
+
+int CAddonCallbacksGUI::Window_GetListSize(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return -1;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+
+  Lock();
+  int listSize = pAddonWindow->GetListSize();
+  Unlock();
+
+  return listSize;
+}
+
+void CAddonCallbacksGUI::Window_ClearList(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+
+  Lock();
+  pAddonWindow->ClearList();
+  Unlock();
+
+  return;
+}
+
+GUIHANDLE CAddonCallbacksGUI::Window_AddItem(void *addonData, GUIHANDLE handle, GUIHANDLE item, int itemPosition)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle || !item)
+    return NULL;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CFileItemPtr pItem((CFileItem*)item);
+  Lock();
+  pAddonWindow->AddItem(pItem, itemPosition);
+  Unlock();
+
+  return item;
+}
+
+GUIHANDLE CAddonCallbacksGUI::Window_AddStringItem(void *addonData, GUIHANDLE handle, const char *itemName, int itemPosition)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle || !itemName)
+    return NULL;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CFileItemPtr item(new CFileItem(itemName));
+  Lock();
+  pAddonWindow->AddItem(item, itemPosition);
+  Unlock();
+
+  return item.get();
+}
+
+void CAddonCallbacksGUI::Window_RemoveItem(void *addonData, GUIHANDLE handle, int itemPosition)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+
+  Lock();
+  pAddonWindow->RemoveItem(itemPosition);
+  Unlock();
+
+  return;
+}
+
+GUIHANDLE CAddonCallbacksGUI::Window_GetListItem(void *addonData, GUIHANDLE handle, int listPos)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return NULL;
+
+  CAddonCallbacksGUI* guiHelper = helper->GetHelperGUI();
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+
+  Lock();
+  CFileItemPtr fi = pAddonWindow->GetListItem(listPos);
+  if (fi == NULL)
+  {
+    Unlock();
+    CLog::Log(LOGERROR, "Window_GetListItem: %s/%s - Index out of range", TranslateType(guiHelper->m_addon->Type()).c_str(), guiHelper->m_addon->Name().c_str());
+    return NULL;
+  }
+  Unlock();
+
+  return fi.get();
+}
+
+void CAddonCallbacksGUI::Window_SetCurrentListPosition(void *addonData, GUIHANDLE handle, int listPos)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+
+  Lock();
+  pAddonWindow->SetCurrentListPosition(listPos);
+  Unlock();
+
+  return;
+}
+
+int CAddonCallbacksGUI::Window_GetCurrentListPosition(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return -1;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+
+  Lock();
+  int listPos = pAddonWindow->GetCurrentListPosition();
+  Unlock();
+
+  return listPos;
+}
+
+GUIHANDLE CAddonCallbacksGUI::Window_GetControl_Spin(void *addonData, GUIHANDLE handle, int controlId)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return NULL;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIControl* pGUIControl = (CGUIControl*)pAddonWindow->GetControl(controlId);
+  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_SPINEX)
+    return NULL;
+
+  return pGUIControl;
+}
+
+GUIHANDLE CAddonCallbacksGUI::Window_GetControl_Button(void *addonData, GUIHANDLE handle, int controlId)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return NULL;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIControl* pGUIControl = (CGUIControl*)pAddonWindow->GetControl(controlId);
+  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_BUTTON)
+    return NULL;
+
+  return pGUIControl;
+}
+
+GUIHANDLE CAddonCallbacksGUI::Window_GetControl_RadioButton(void *addonData, GUIHANDLE handle, int controlId)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return NULL;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIControl* pGUIControl = (CGUIControl*)pAddonWindow->GetControl(controlId);
+  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_RADIO)
+    return NULL;
+
+  return pGUIControl;
+}
+
+GUIHANDLE CAddonCallbacksGUI::Window_GetControl_Edit(void *addonData, GUIHANDLE handle, int controlId)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return NULL;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIControl* pGUIControl = (CGUIControl*)pAddonWindow->GetControl(controlId);
+  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_EDIT)
+    return NULL;
+
+  return pGUIControl;
+}
+
+GUIHANDLE CAddonCallbacksGUI::Window_GetControl_Progress(void *addonData, GUIHANDLE handle, int controlId)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return NULL;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+  CGUIControl* pGUIControl = (CGUIControl*)pAddonWindow->GetControl(controlId);
+  if (pGUIControl && pGUIControl->GetControlType() != CGUIControl::GUICONTROL_PROGRESS)
+    return NULL;
+
+  return pGUIControl;
+}
+
+void CAddonCallbacksGUI::Window_SetControlLabel(void *addonData, GUIHANDLE handle, int controlId, const char *label)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  CGUIAddonWindow *pAddonWindow = (CGUIAddonWindow*)handle;
+
+  CGUIMessage msg(GUI_MSG_LABEL_SET, pAddonWindow->m_iWindowId, controlId);
+  msg.SetLabel(label);
+  pAddonWindow->OnMessage(msg);
+}
+
+void CAddonCallbacksGUI::Control_Spin_SetVisible(void *addonData, GUIHANDLE spinhandle, bool yesNo)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !spinhandle)
+    return;
+
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx*)spinhandle;
+  pSpin->SetVisible(yesNo);
+}
+
+void CAddonCallbacksGUI::Control_Spin_SetText(void *addonData, GUIHANDLE spinhandle, const char *label)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !spinhandle)
+    return;
+
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx*)spinhandle;
+  pSpin->SetText(label);
+}
+
+void CAddonCallbacksGUI::Control_Spin_Clear(void *addonData, GUIHANDLE spinhandle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !spinhandle)
+    return;
+
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx*)spinhandle;
+  pSpin->Clear();
+}
+
+void CAddonCallbacksGUI::Control_Spin_AddLabel(void *addonData, GUIHANDLE spinhandle, const char *label, int iValue)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !spinhandle)
+    return;
+
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx*)spinhandle;
+  pSpin->AddLabel(label, iValue);
+}
+
+int CAddonCallbacksGUI::Control_Spin_GetValue(void *addonData, GUIHANDLE spinhandle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !spinhandle)
+    return -1;
+
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx*)spinhandle;
+  return pSpin->GetValue();
+}
+
+void CAddonCallbacksGUI::Control_Spin_SetValue(void *addonData, GUIHANDLE spinhandle, int iValue)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !spinhandle)
+    return;
+
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx*)spinhandle;
+  pSpin->SetValue(iValue);
+}
+
+void CAddonCallbacksGUI::Control_RadioButton_SetVisible(void *addonData, GUIHANDLE handle, bool yesNo)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  CGUIRadioButtonControl *pRadioButton = (CGUIRadioButtonControl*)handle;
+  pRadioButton->SetVisible(yesNo);
+}
+
+void CAddonCallbacksGUI::Control_RadioButton_SetText(void *addonData, GUIHANDLE handle, const char *label)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  CGUIRadioButtonControl *pRadioButton = (CGUIRadioButtonControl*)handle;
+  pRadioButton->SetLabel(label);
+}
+
+void CAddonCallbacksGUI::Control_RadioButton_SetSelected(void *addonData, GUIHANDLE handle, bool yesNo)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  CGUIRadioButtonControl *pRadioButton = (CGUIRadioButtonControl*)handle;
+  pRadioButton->SetSelected(yesNo);
+}
+
+bool CAddonCallbacksGUI::Control_RadioButton_IsSelected(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return false;
+
+  CGUIRadioButtonControl *pRadioButton = (CGUIRadioButtonControl*)handle;
+  return pRadioButton->IsSelected();
+}
+
+void CAddonCallbacksGUI::Control_Progress_SetPercentage(void *addonData, GUIHANDLE handle, float fPercent)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  CGUIProgressControl *pControl = (CGUIProgressControl*)handle;
+  pControl->SetPercentage(fPercent);
+}
+
+float CAddonCallbacksGUI::Control_Progress_GetPercentage(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return 0.0;
+
+  CGUIProgressControl *pControl = (CGUIProgressControl*)handle;
+  return pControl->GetPercentage();
+}
+
+void CAddonCallbacksGUI::Control_Progress_SetInfo(void *addonData, GUIHANDLE handle, int iInfo)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  CGUIProgressControl *pControl = (CGUIProgressControl*)handle;
+  pControl->SetInfo(iInfo);
+}
+
+int CAddonCallbacksGUI::Control_Progress_GetInfo(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return -1;
+
+  CGUIProgressControl *pControl = (CGUIProgressControl*)handle;
+  return pControl->GetInfo();
+}
+
+const char* CAddonCallbacksGUI::Control_Progress_GetDescription(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return NULL;
+
+  CGUIProgressControl *pControl = (CGUIProgressControl*)handle;
+  CStdString string = pControl->GetDescription();
+
+  char *buffer = (char*) malloc (string.length()+1);
+  strcpy(buffer, string.c_str());
+  return buffer;
+}
+
+GUIHANDLE CAddonCallbacksGUI::ListItem_Create(void *addonData, const char *label, const char *label2, const char *iconImage, const char *thumbnailImage, const char *path)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper)
+    return NULL;
+
+  // create CFileItem
+  CFileItem *pItem = new CFileItem();
+  if (!pItem)
+    return NULL;
+
+  if (label)
+    pItem->SetLabel(label);
+  if (label2)
+    pItem->SetLabel2(label2);
+  if (iconImage)
+    pItem->SetIconImage(iconImage);
+  if (thumbnailImage)
+    pItem->SetThumbnailImage(thumbnailImage);
+  if (path)
+    pItem->SetPath(path);
+
+  return pItem;
+}
+
+const char* CAddonCallbacksGUI::ListItem_GetLabel(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return NULL;
+
+  CStdString string = ((CFileItem*)handle)->GetLabel();
+  char *buffer = (char*) malloc (string.length()+1);
+  strcpy(buffer, string.c_str());
+  return buffer;
+}
+
+void CAddonCallbacksGUI::ListItem_SetLabel(void *addonData, GUIHANDLE handle, const char *label)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  ((CFileItem*)handle)->SetLabel(label);
+}
+
+const char* CAddonCallbacksGUI::ListItem_GetLabel2(void *addonData, GUIHANDLE handle)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return NULL;
+
+  CStdString string = ((CFileItem*)handle)->GetLabel2();
+
+  char *buffer = (char*) malloc (string.length()+1);
+  strcpy(buffer, string.c_str());
+  return buffer;
+}
+
+void CAddonCallbacksGUI::ListItem_SetLabel2(void *addonData, GUIHANDLE handle, const char *label)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  ((CFileItem*)handle)->SetLabel2(label);
+}
+
+void CAddonCallbacksGUI::ListItem_SetIconImage(void *addonData, GUIHANDLE handle, const char *image)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  ((CFileItem*)handle)->SetIconImage(image);
+}
+
+void CAddonCallbacksGUI::ListItem_SetThumbnailImage(void *addonData, GUIHANDLE handle, const char *image)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  ((CFileItem*)handle)->SetThumbnailImage(image);
+}
+
+void CAddonCallbacksGUI::ListItem_SetInfo(void *addonData, GUIHANDLE handle, const char *info)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+}
+
+void CAddonCallbacksGUI::ListItem_SetProperty(void *addonData, GUIHANDLE handle, const char *key, const char *value)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  ((CFileItem*)handle)->SetProperty(key, value);
+}
+
+const char* CAddonCallbacksGUI::ListItem_GetProperty(void *addonData, GUIHANDLE handle, const char *key)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return NULL;
+
+  string string = ((CFileItem*)handle)->GetProperty(key).asString();
+  char *buffer = (char*) malloc (string.length()+1);
+  strcpy(buffer, string.c_str());
+  return buffer;
+}
+
+void CAddonCallbacksGUI::ListItem_SetPath(void *addonData, GUIHANDLE handle, const char *path)
+{
+  CAddonCallbacks* helper = (CAddonCallbacks*) addonData;
+  if (!helper || !handle)
+    return;
+
+  ((CFileItem*)handle)->SetPath(path);
+}
+
+
+
+
+
+
+
+CGUIAddonWindow::CGUIAddonWindow(int id, CStdString strXML, CAddon* addon)
+ : CGUIMediaWindow(id, strXML)
+ , m_iWindowId(id)
+ , m_iOldWindowId(0)
+ , m_bModal(false)
+ , m_bIsDialog(false)
+ , m_actionEvent(true)
+ , m_addon(addon)
+{
+  m_loadOnDemand  = false;
+  CBOnInit        = NULL;
+  CBOnFocus       = NULL;
+  CBOnClick       = NULL;
+  CBOnAction      = NULL;
+}
+
+CGUIAddonWindow::~CGUIAddonWindow(void)
+{
+}
+
+bool CGUIAddonWindow::OnAction(const CAction &action)
+{
+  // do the base class window first, and the call to python after this
+  bool ret = CGUIWindow::OnAction(action);  // we don't currently want the mediawindow actions here
+  if (CBOnAction)
+  {
+    CBOnAction(m_clientHandle, action.GetID());
+  }
+  return ret;
+}
+
+bool CGUIAddonWindow::OnMessage(CGUIMessage& message)
+{
+  // TODO: We shouldn't be dropping down to CGUIWindow in any of this ideally.
+  //       We have to make up our minds about what python should be doing and
+  //       what this side of things should be doing
+  switch (message.GetMessage())
+  {
+    case GUI_MSG_WINDOW_DEINIT:
+    {
+      return CGUIMediaWindow::OnMessage(message);
+    }
+    break;
+
+    case GUI_MSG_WINDOW_INIT:
+    {
+      CGUIMediaWindow::OnMessage(message);
+      if (CBOnInit)
+        CBOnInit(m_clientHandle);
+
+      return true;
+    }
+    break;
+
+    case GUI_MSG_SETFOCUS:
+    {
+      if (m_viewControl.HasControl(message.GetControlId()) && m_viewControl.GetCurrentControl() != (int)message.GetControlId())
+      {
+        m_viewControl.SetFocused();
+        return true;
+      }
+      // check if our focused control is one of our category buttons
+      int iControl = message.GetControlId();
+      if (CBOnFocus)
+      {
+        CBOnFocus(m_clientHandle, iControl);
+      }
+    }
+    break;
+    case GUI_MSG_CLICKED:
+    {
+      int iControl=message.GetSenderId();
+      // Handle Sort/View internally. Scripters shouldn't use ID 2, 3 or 4.
+      if (iControl == CONTROL_BTNSORTASC) // sort asc
+      {
+        CLog::Log(LOGINFO, "WindowXML: Internal asc/dsc button not implemented");
+        /*if (m_guiState.get())
+          m_guiState->SetNextSortOrder();
+        UpdateFileList();*/
+        return true;
+      }
+      else if (iControl == CONTROL_BTNSORTBY) // sort by
+      {
+        CLog::Log(LOGINFO, "WindowXML: Internal sort button not implemented");
+        /*if (m_guiState.get())
+          m_guiState->SetNextSortMethod();
+        UpdateFileList();*/
+        return true;
+      }
+
+      if (CBOnClick && iControl && iControl != (int)this->GetID())
+      {
+        CGUIControl* controlClicked = (CGUIControl*)this->GetControl(iControl);
+
+        // The old python way used to check list AND SELECITEM method or if its a button, checkmark.
+        // Its done this way for now to allow other controls without a python version like togglebutton to still raise a onAction event
+        if (controlClicked) // Will get problems if we the id is not on the window and we try to do GetControlType on it. So check to make sure it exists
+        {
+          if ((controlClicked->IsContainer() && (message.GetParam1() == ACTION_SELECT_ITEM ||
+                                                 message.GetParam1() == ACTION_MOUSE_LEFT_CLICK)) ||
+                                                 !controlClicked->IsContainer())
+          {
+            CBOnClick(m_clientHandle, iControl);
+          }
+          else if (controlClicked->IsContainer() && message.GetParam1() == ACTION_MOUSE_RIGHT_CLICK)
+          {
+//            PyXBMCAction* inf = new PyXBMCAction;
+//            inf->pObject = Action_FromAction(CAction(ACTION_CONTEXT_MENU));
+//            inf->pCallbackWindow = pCallbackWindow;
+//
+//            // aquire lock?
+//            PyXBMC_AddPendingCall(Py_XBMC_Event_OnAction, inf);
+//            PulseActionEvent();
+          }
+          return true;
+        }
+      }
+    }
+    break;
+  }
+
+  return CGUIMediaWindow::OnMessage(message);
+}
+
+void CGUIAddonWindow::AllocResources(bool forceLoad /*= FALSE */)
+{
+  CStdString tmpDir;
+  URIUtils::GetDirectory(GetProperty("xmlfile").asString(), tmpDir);
+  CStdString fallbackMediaPath;
+  URIUtils::GetParentPath(tmpDir, fallbackMediaPath);
+  URIUtils::RemoveSlashAtEnd(fallbackMediaPath);
+  m_mediaDir = fallbackMediaPath;
+
+  //CLog::Log(LOGDEBUG, "CGUIPythonWindowXML::AllocResources called: %s", fallbackMediaPath.c_str());
+  g_TextureManager.AddTexturePath(m_mediaDir);
+  CGUIMediaWindow::AllocResources(forceLoad);
+  g_TextureManager.RemoveTexturePath(m_mediaDir);
+}
+
+void CGUIAddonWindow::FreeResources(bool forceUnLoad /*= FALSE */)
+{
+  // Unload temporary language strings
+  ClearAddonStrings();
+
+  CGUIMediaWindow::FreeResources(forceUnLoad);
+}
+
+void CGUIAddonWindow::Render()
+{
+  g_TextureManager.AddTexturePath(m_mediaDir);
+  CGUIMediaWindow::Render();
+  g_TextureManager.RemoveTexturePath(m_mediaDir);
+}
+
+void CGUIAddonWindow::Update()
+{
+}
+
+void CGUIAddonWindow::AddItem(CFileItemPtr fileItem, int itemPosition)
+{
+  if (itemPosition == -1 || itemPosition > m_vecItems->Size())
+  {
+    m_vecItems->Add(fileItem);
+  }
+  else if (itemPosition <  -1 &&  !(itemPosition-1 < m_vecItems->Size()))
+  {
+    m_vecItems->AddFront(fileItem,0);
+  }
+  else
+  {
+    m_vecItems->AddFront(fileItem,itemPosition);
+  }
+  m_viewControl.SetItems(*m_vecItems);
+  UpdateButtons();
+}
+
+void CGUIAddonWindow::RemoveItem(int itemPosition)
+{
+  m_vecItems->Remove(itemPosition);
+  m_viewControl.SetItems(*m_vecItems);
+  UpdateButtons();
+}
+
+int CGUIAddonWindow::GetCurrentListPosition()
+{
+  return m_viewControl.GetSelectedItem();
+}
+
+void CGUIAddonWindow::SetCurrentListPosition(int item)
+{
+  m_viewControl.SetSelectedItem(item);
+}
+
+int CGUIAddonWindow::GetListSize()
+{
+  return m_vecItems->Size();
+}
+
+CFileItemPtr CGUIAddonWindow::GetListItem(int position)
+{
+  if (position < 0 || position >= m_vecItems->Size()) return CFileItemPtr();
+  return m_vecItems->Get(position);
+}
+
+void CGUIAddonWindow::ClearList()
+{
+  ClearFileItems();
+
+  m_viewControl.SetItems(*m_vecItems);
+  UpdateButtons();
+}
+
+void CGUIAddonWindow::GetContextButtons(int itemNumber, CContextButtons &buttons)
+{
+  // maybe on day we can make an easy way to do this context menu
+  // with out this method overriding the MediaWindow version, it will display 'Add to Favorites'
+}
+
+void CGUIAddonWindow::WaitForActionEvent(unsigned int timeout)
+{
+  m_actionEvent.WaitMSec(timeout);
+  m_actionEvent.Reset();
+}
+
+void CGUIAddonWindow::PulseActionEvent()
+{
+  m_actionEvent.Set();
+}
+
+void CGUIAddonWindow::ClearAddonStrings()
+{
+  // Unload temporary language strings
+  g_localizeStrings.ClearBlock(m_addon->Path());
+}
+
+bool CGUIAddonWindow::OnClick(int iItem)
+{
+  // Hook Over calling  CGUIMediaWindow::OnClick(iItem) results in it trying to PLAY the file item
+  // which if its not media is BAD and 99 out of 100 times undesireable.
+  return false;
+}
+
+// SetupShares();
+/*
+ CGUIMediaWindow::OnWindowLoaded() calls SetupShares() so override it
+and just call UpdateButtons();
+*/
+void CGUIAddonWindow::SetupShares()
+{
+  UpdateButtons();
+}
+
+
+CGUIAddonWindowDialog::CGUIAddonWindowDialog(int id, CStdString strXML, CAddon* addon)
+: CGUIAddonWindow(id,strXML,addon)
+{
+  m_bRunning = false;
+  m_loadOnDemand = false;
+  m_bIsDialog = true;
+}
+
+CGUIAddonWindowDialog::~CGUIAddonWindowDialog(void)
+{
+}
+
+bool CGUIAddonWindowDialog::OnMessage(CGUIMessage &message)
+{
+  if (message.GetMessage() == GUI_MSG_WINDOW_DEINIT)
+  {
+    CGUIWindow *pWindow = g_windowManager.GetWindow(g_windowManager.GetActiveWindow());
+    if (pWindow)
+      g_windowManager.ShowOverlay(pWindow->GetOverlayState());
+    return CGUIWindow::OnMessage(message);
+  }
+  return CGUIAddonWindow::OnMessage(message);
+}
+
+void CGUIAddonWindowDialog::Show(bool show /* = true */)
+{
+  unsigned int iCount = g_graphicsContext.exit();
+  ThreadMessage tMsg = {TMSG_GUI_ADDON_DIALOG, 1, show ? 1 : 0};
+  tMsg.lpVoid = this;
+  CApplicationMessenger::Get().SendMessage(tMsg, true);
+  g_graphicsContext.restore(iCount);
+}
+
+void CGUIAddonWindowDialog::Show_Internal(bool show /* = true */)
+{
+  if (show)
+  {
+    m_bModal = true;
+    m_bRunning = true;
+    g_windowManager.RouteToWindow(this);
+
+    // active this window...
+    CGUIMessage msg(GUI_MSG_WINDOW_INIT, 0, 0, WINDOW_INVALID, m_iWindowId);
+    OnMessage(msg);
+
+    while (m_bRunning && !g_application.m_bStop)
+    {
+      g_windowManager.Process(CTimeUtils::GetFrameTime());
+    }
+  }
+  else // hide
+  {
+    m_bRunning = false;
+
+    CGUIMessage msg(GUI_MSG_WINDOW_DEINIT,0,0);
+    OnMessage(msg);
+
+    g_windowManager.RemoveDialog(GetID());
+  }
+}
+
+}; /* namespace ADDON */
diff --git a/xbmc/addons/AddonCallbacksPVR.cpp b/xbmc/addons/AddonCallbacksPVR.cpp
new file mode 100644
index 0000000..e6f54f1
--- /dev/null
+++ b/xbmc/addons/AddonCallbacksPVR.cpp
@@ -0,0 +1,273 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Application.h"
+#include "AddonCallbacksPVR.h"
+#include "settings/AdvancedSettings.h"
+#include "utils/log.h"
+#include "dialogs/GUIDialogKaiToast.h"
+
+#include "epg/Epg.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/channels/PVRChannelGroupInternal.h"
+#include "pvr/addons/PVRClient.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/timers/PVRTimerInfoTag.h"
+
+using namespace PVR;
+using namespace EPG;
+
+namespace ADDON
+{
+
+CAddonCallbacksPVR::CAddonCallbacksPVR(CAddon* addon)
+{
+  m_addon     = addon;
+  m_callbacks = new CB_PVRLib;
+
+  /* write XBMC PVR specific add-on function addresses to callback table */
+  m_callbacks->TransferEpgEntry           = PVRTransferEpgEntry;
+  m_callbacks->TransferChannelEntry       = PVRTransferChannelEntry;
+  m_callbacks->TransferTimerEntry         = PVRTransferTimerEntry;
+  m_callbacks->TransferRecordingEntry     = PVRTransferRecordingEntry;
+  m_callbacks->AddMenuHook                = PVRAddMenuHook;
+  m_callbacks->Recording                  = PVRRecording;
+  m_callbacks->TriggerChannelUpdate       = PVRTriggerChannelUpdate;
+  m_callbacks->TriggerChannelGroupsUpdate = PVRTriggerChannelGroupsUpdate;
+  m_callbacks->TriggerTimerUpdate         = PVRTriggerTimerUpdate;
+  m_callbacks->TriggerRecordingUpdate     = PVRTriggerRecordingUpdate;
+  m_callbacks->FreeDemuxPacket            = PVRFreeDemuxPacket;
+  m_callbacks->AllocateDemuxPacket        = PVRAllocateDemuxPacket;
+  m_callbacks->TransferChannelGroup       = PVRTransferChannelGroup;
+  m_callbacks->TransferChannelGroupMember = PVRTransferChannelGroupMember;
+}
+
+CAddonCallbacksPVR::~CAddonCallbacksPVR()
+{
+  /* delete the callback table */
+  delete m_callbacks;
+}
+
+CPVRClient *CAddonCallbacksPVR::GetPVRClient(void *addonData)
+{
+  CAddonCallbacks *addon = static_cast<CAddonCallbacks *>(addonData);
+  if (!addon || !addon->GetHelperPVR())
+  {
+    CLog::Log(LOGERROR, "PVR - %s - called with a null pointer", __FUNCTION__);
+    return NULL;
+  }
+
+  return dynamic_cast<CPVRClient *>(addon->GetHelperPVR()->m_addon);
+}
+
+void CAddonCallbacksPVR::PVRTransferChannelGroup(void *addonData, const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP *group)
+{
+  CPVRChannelGroups *xbmcGroups = static_cast<CPVRChannelGroups *>(handle->dataAddress);
+  if (!handle || !group || !xbmcGroups)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid handler data", __FUNCTION__);
+    return;
+  }
+
+  if (strlen(group->strGroupName) == 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - empty group name", __FUNCTION__);
+    return;
+  }
+
+  /* transfer this entry to the groups container */
+  CPVRChannelGroup transferGroup(*group);
+  xbmcGroups->UpdateFromClient(transferGroup);
+}
+
+void CAddonCallbacksPVR::PVRTransferChannelGroupMember(void *addonData, const ADDON_HANDLE handle, const PVR_CHANNEL_GROUP_MEMBER *member)
+{
+  CPVRClient *client      = GetPVRClient(addonData);
+  CPVRChannelGroup *group = static_cast<CPVRChannelGroup *>(handle->dataAddress);
+  if (!handle || !member || !client || !group)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid handler data", __FUNCTION__);
+    return;
+  }
+
+  CPVRChannelPtr channel  = g_PVRChannelGroups->GetByUniqueID(member->iChannelUniqueId, client->GetID());
+  if (!channel)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - cannot find group '%s' or channel '%d'", __FUNCTION__, member->strGroupName, member->iChannelUniqueId);
+  }
+  else if (group->IsRadio() == channel->IsRadio())
+  {
+    /* transfer this entry to the group */
+    group->AddToGroup(*channel, member->iChannelNumber, false);
+  }
+}
+
+void CAddonCallbacksPVR::PVRTransferEpgEntry(void *addonData, const ADDON_HANDLE handle, const EPG_TAG *epgentry)
+{
+  CEpg *xbmcEpg = static_cast<CEpg *>(handle->dataAddress);
+  if (!handle || !xbmcEpg)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid handler data", __FUNCTION__);
+    return;
+  }
+
+  /* transfer this entry to the epg */
+  xbmcEpg->UpdateEntry(epgentry, handle->dataIdentifier == 1 /* update db */);
+}
+
+void CAddonCallbacksPVR::PVRTransferChannelEntry(void *addonData, const ADDON_HANDLE handle, const PVR_CHANNEL *channel)
+{
+  CPVRClient *client                     = GetPVRClient(addonData);
+  CPVRChannelGroupInternal *xbmcChannels = static_cast<CPVRChannelGroupInternal *>(handle->dataAddress);
+  if (!handle || !channel || !client || !xbmcChannels)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid handler data", __FUNCTION__);
+    return;
+  }
+
+  /* transfer this entry to the internal channels group */
+  CPVRChannel transferChannel(*channel, client->GetID());
+  xbmcChannels->UpdateFromClient(transferChannel);
+}
+
+void CAddonCallbacksPVR::PVRTransferRecordingEntry(void *addonData, const ADDON_HANDLE handle, const PVR_RECORDING *recording)
+{
+  CPVRClient *client             = GetPVRClient(addonData);
+  CPVRRecordings *xbmcRecordings = static_cast<CPVRRecordings *>(handle->dataAddress);
+  if (!handle || !recording || !client || !xbmcRecordings)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid handler data", __FUNCTION__);
+    return;
+  }
+
+  /* transfer this entry to the recordings container */
+  CPVRRecording transferRecording(*recording, client->GetID());
+  xbmcRecordings->UpdateFromClient(transferRecording);
+}
+
+void CAddonCallbacksPVR::PVRTransferTimerEntry(void *addonData, const ADDON_HANDLE handle, const PVR_TIMER *timer)
+{
+  CPVRClient *client     = GetPVRClient(addonData);
+  CPVRTimers *xbmcTimers = static_cast<CPVRTimers *>(handle->dataAddress);
+  if (!handle || !timer || !client || !xbmcTimers)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid handler data", __FUNCTION__);
+    return;
+  }
+
+  CPVRChannelPtr channel = g_PVRChannelGroups->GetByUniqueID(timer->iClientChannelUid, client->GetID());
+  if (!channel)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - cannot find channel %d on client %d", __FUNCTION__, timer->iClientChannelUid, client->GetID());
+    return;
+  }
+
+  /* transfer this entry to the timers container */
+  CPVRTimerInfoTag transferTimer(*timer, channel, client->GetID());
+  xbmcTimers->UpdateFromClient(transferTimer);
+}
+
+void CAddonCallbacksPVR::PVRAddMenuHook(void *addonData, PVR_MENUHOOK *hook)
+{
+  CPVRClient *client = GetPVRClient(addonData);
+  if (!hook || !client)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid handler data", __FUNCTION__);
+    return;
+  }
+
+  PVR_MENUHOOKS *hooks = client->GetMenuHooks();
+  if (hooks)
+  {
+    PVR_MENUHOOK hookInt;
+    hookInt.iHookId            = hook->iHookId;
+    hookInt.iLocalizedStringId = hook->iLocalizedStringId;
+
+    /* add this new hook */
+    hooks->push_back(hookInt);
+  }
+}
+
+void CAddonCallbacksPVR::PVRRecording(void *addonData, const char *strName, const char *strFileName, bool bOnOff)
+{
+  CPVRClient *client = GetPVRClient(addonData);
+  if (!client || !strFileName)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid handler data", __FUNCTION__);
+    return;
+  }
+
+  CStdString strLine1;
+  if (bOnOff)
+    strLine1.Format(g_localizeStrings.Get(19197), client->Name());
+  else
+    strLine1.Format(g_localizeStrings.Get(19198), client->Name());
+
+  CStdString strLine2;
+  if (strName)
+    strLine2 = strName;
+  else if (strFileName)
+    strLine2 = strFileName;
+
+  /* display a notification for 5 seconds */
+  CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, strLine1, strLine2, 5000, false);
+
+  CLog::Log(LOGDEBUG, "PVR - %s - recording %s on client '%s'. name='%s' filename='%s'",
+      __FUNCTION__, bOnOff ? "started" : "finished", client->Name().c_str(), strName, strFileName);
+}
+
+void CAddonCallbacksPVR::PVRTriggerChannelUpdate(void *addonData)
+{
+  /* update the channels table in the next iteration of the pvrmanager's main loop */
+  g_PVRManager.TriggerChannelsUpdate();
+}
+
+void CAddonCallbacksPVR::PVRTriggerTimerUpdate(void *addonData)
+{
+  /* update the timers table in the next iteration of the pvrmanager's main loop */
+  g_PVRManager.TriggerTimersUpdate();
+}
+
+void CAddonCallbacksPVR::PVRTriggerRecordingUpdate(void *addonData)
+{
+  /* update the recordings table in the next iteration of the pvrmanager's main loop */
+  g_PVRManager.TriggerRecordingsUpdate();
+}
+
+void CAddonCallbacksPVR::PVRTriggerChannelGroupsUpdate(void *addonData)
+{
+  /* update all channel groups in the next iteration of the pvrmanager's main loop */
+  g_PVRManager.TriggerChannelGroupsUpdate();
+}
+
+void CAddonCallbacksPVR::PVRFreeDemuxPacket(void *addonData, DemuxPacket* pPacket)
+{
+  CDVDDemuxUtils::FreeDemuxPacket(pPacket);
+}
+
+DemuxPacket* CAddonCallbacksPVR::PVRAllocateDemuxPacket(void *addonData, int iDataSize)
+{
+  return CDVDDemuxUtils::AllocateDemuxPacket(iDataSize);
+}
+
+}; /* namespace ADDON */
diff --git a/xbmc/addons/AddonDatabase.cpp b/xbmc/addons/AddonDatabase.cpp
index 743e7ac..5a7bdab 100644
--- a/xbmc/addons/AddonDatabase.cpp
+++ b/xbmc/addons/AddonDatabase.cpp
@@ -159,2 +159,5 @@ int CAddonDatabase::AddAddon(const AddonPtr& addon,
     }
+    // these need to be configured
+    if (addon->Type() == ADDON_PVRDLL)
+      DisableAddon(addon->ID(), true);
     return idAddon;
@@ -652,2 +655,10 @@ bool CAddonDatabase::IsAddonDisabled(const CStdString &addonID)
 
+bool CAddonDatabase::IsSystemPVRAddonEnabled(const CStdString &addonID)
+{
+  CStdString strWhereClause = PrepareSQL("addonID = '%s'", addonID.c_str());
+  CStdString strEnabled = GetSingleValue("pvrenabled", "id", strWhereClause);
+
+  return !strEnabled.IsEmpty();
+}
+
 CStdString CAddonDatabase::IsAddonBroken(const CStdString &addonID)
diff --git a/xbmc/addons/AddonManager.cpp b/xbmc/addons/AddonManager.cpp
index 3ab9e9f..9539011 100644
--- a/xbmc/addons/AddonManager.cpp
+++ b/xbmc/addons/AddonManager.cpp
@@ -39,2 +39,6 @@
 #endif
+#ifdef HAS_PVRCLIENTS
+#include "DllPVRClient.h"
+#include "pvr/addons/PVRClient.h"
+#endif
 //#ifdef HAS_SCRAPERS
@@ -46,2 +50,4 @@
 #include "Service.h"
+#include "pvr/PVRManager.h"
+#include "pvr/addons/PVRClients.h"
 #include "Util.h"
@@ -49,2 +55,3 @@
 using namespace std;
+using namespace PVR;
 
@@ -110,2 +117,3 @@ AddonPtr CAddonMgr::Factory(const cp_extension_t *props)
     case ADDON_SCREENSAVER:
+    case ADDON_PVRDLL:
       { // begin temporary platform handling for Dlls
@@ -146,2 +154,8 @@ AddonPtr CAddonMgr::Factory(const cp_extension_t *props)
         }
+        else if (type == ADDON_PVRDLL)
+        {
+#ifdef HAS_PVRCLIENTS
+          return AddonPtr(new CPVRClient(props));
+#endif
+        }
         else
@@ -392,5 +406,22 @@ bool CAddonMgr::GetAddons(const TYPE &type, VECADDONS &addons, bool enabled /* =
   {
-    AddonPtr addon(Factory(exts[i]));
-    if (addon && m_database.IsAddonDisabled(addon->ID()) != enabled)
-      addons.push_back(addon);
+    const cp_extension_t *props = exts[i];
+    if (m_database.IsAddonDisabled(props->plugin->identifier) != enabled)
+    {
+      // get a pointer to a running pvrclient if it's already started, or we won't be able to change settings
+      if (TranslateType(props->ext_point_id) == ADDON_PVRDLL &&
+          enabled &&
+          g_PVRManager.IsStarted())
+      {
+        AddonPtr pvrAddon;
+        if (g_PVRClients->GetClient(props->plugin->identifier, pvrAddon))
+        {
+          addons.push_back(pvrAddon);
+          continue;
+        }
+      }
+
+      AddonPtr addon(Factory(props));
+      if (addon)
+        addons.push_back(addon);
+    }
   }
@@ -410,4 +441,15 @@ bool CAddonMgr::GetAddon(const CStdString &str, AddonPtr &addon, const TYPE &typ
     m_cpluff->release_info(m_cp_context, cpaddon);
-    if (addon.get() && enabledOnly && m_database.IsAddonDisabled(addon->ID()))
-      return false;
+
+    if (addon && addon.get())
+    {
+      if (enabledOnly && m_database.IsAddonDisabled(addon->ID()))
+        return false;
+
+      if (addon->Type() == ADDON_PVRDLL && g_PVRManager.IsStarted())
+      {
+        AddonPtr pvrAddon;
+        if (g_PVRClients->GetClient(addon->ID(), pvrAddon))
+          addon = pvrAddon;
+      }
+    }
     return NULL != addon.get();
@@ -499,5 +541,11 @@ void CAddonMgr::FindAddons()
 {
-  CSingleLock lock(m_critSection);
-  if (m_cpluff && m_cp_context)
-    m_cpluff->scan_plugins(m_cp_context, CP_SP_UPGRADE);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_cpluff && m_cp_context)
+    {
+      m_cpluff->scan_plugins(m_cp_context, CP_SP_UPGRADE);
+      SetChanged();
+    }
+  }
+  NotifyObservers(ObservableMessageAddons);
 }
@@ -507,3 +555,7 @@ void CAddonMgr::RemoveAddon(const CStdString& ID)
   if (m_cpluff && m_cp_context)
+  {
     m_cpluff->uninstall_plugin(m_cp_context,ID.c_str());
+    SetChanged();
+    NotifyObservers(ObservableMessageAddons);
+  }
 }
@@ -564,2 +616,4 @@ AddonPtr CAddonMgr::AddonFromProps(AddonProps& addonProps)
       return AddonPtr(new CAddonLibrary(addonProps));
+    case ADDON_PVRDLL:
+      return AddonPtr(new CPVRClient(addonProps));
     case ADDON_REPOSITORY:
diff --git a/xbmc/addons/AddonStatusHandler.cpp b/xbmc/addons/AddonStatusHandler.cpp
index 032d620..0d990b3 100644
--- a/xbmc/addons/AddonStatusHandler.cpp
+++ b/xbmc/addons/AddonStatusHandler.cpp
@@ -28,2 +28,4 @@
 #include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "settings/GUISettings.h"
 #include "utils/log.h"
@@ -88,15 +90,24 @@ void CAddonStatusHandler::Process()
   {
-    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
-    if (!pDialog) return;
+    if (m_addon->Type() == ADDON_PVRDLL)
+    {
+      if (!g_guiSettings.GetBool("pvrmanager.hideconnectionlostwarning"))
+        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, m_addon->Name().c_str(), g_localizeStrings.Get(36030)); // connection lost
+      // TODO handle disconnects after the add-on's been initialised
+    }
+    else
+    {
+      CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+      if (!pDialog) return;
 
-    pDialog->SetHeading(heading);
-    pDialog->SetLine(1, 24070);
-    pDialog->SetLine(2, 24073);
+      pDialog->SetHeading(heading);
+      pDialog->SetLine(1, 24070);
+      pDialog->SetLine(2, 24073);
 
-    //send message and wait for user input
-    ThreadMessage tMsg = {TMSG_DIALOG_DOMODAL, WINDOW_DIALOG_YES_NO, g_windowManager.GetActiveWindow()};
-    CApplicationMessenger::Get().SendMessage(tMsg, true);
+      //send message and wait for user input
+      ThreadMessage tMsg = {TMSG_DIALOG_DOMODAL, WINDOW_DIALOG_YES_NO, g_windowManager.GetActiveWindow()};
+      CApplicationMessenger::Get().SendMessage(tMsg, true);
 
-    if (pDialog->IsConfirmed())
-      CAddonMgr::Get().GetCallbackForType(m_addon->Type())->RequestRestart(m_addon, false);
+      if (pDialog->IsConfirmed())
+        CAddonMgr::Get().GetCallbackForType(m_addon->Type())->RequestRestart(m_addon, false);
+    }
   }
diff --git a/xbmc/addons/GUIDialogAddonInfo.cpp b/xbmc/addons/GUIDialogAddonInfo.cpp
index c3bf5a3..2db656a 100644
--- a/xbmc/addons/GUIDialogAddonInfo.cpp
+++ b/xbmc/addons/GUIDialogAddonInfo.cpp
@@ -39,2 +39,3 @@
 #include "addons/AddonInstaller.h"
+#include "Application.h"
 
@@ -140,3 +141,5 @@ void CGUIDialogAddonInfo::UpdateControls()
   // TODO: System addons should be able to be disabled
-  bool canDisable = isInstalled && !isSystem && !m_localAddon->IsInUse();
+  // TODO: the following line will have to be changed later, when the PVR add-ons are no longer part of our source tree
+  bool isPVR = isInstalled && m_localAddon->Type() == ADDON_PVRDLL;
+  bool canDisable = isInstalled && (!isSystem || isPVR) && !m_localAddon->IsInUse();
   bool canInstall = !isInstalled && m_item->GetProperty("Addon.Broken").empty();
@@ -144,3 +147,3 @@ void CGUIDialogAddonInfo::UpdateControls()
 
-  CONTROL_ENABLE_ON_CONDITION(CONTROL_BTN_INSTALL, canDisable || canInstall);
+  CONTROL_ENABLE_ON_CONDITION(CONTROL_BTN_INSTALL, (canDisable || canInstall) && !isPVR);
   SET_CONTROL_LABEL(CONTROL_BTN_INSTALL, isInstalled ? 24037 : 24038);
@@ -210,2 +213,3 @@ void CGUIDialogAddonInfo::OnEnable(bool enable)
 
+  CStdString xbmcPath = CSpecialProtocol::TranslatePath("special://xbmc/addons");
   CAddonDatabase database;
@@ -213,2 +217,7 @@ void CGUIDialogAddonInfo::OnEnable(bool enable)
   database.DisableAddon(m_localAddon->ID(), !enable);
+  database.Close();
+
+  if (m_localAddon->Type() == ADDON_PVRDLL && enable)
+    g_application.StartPVRManager();
+
   SetItem(m_item);
diff --git a/xbmc/addons/Skin.cpp b/xbmc/addons/Skin.cpp
index 4c9b306..cb89309 100644
--- a/xbmc/addons/Skin.cpp
+++ b/xbmc/addons/Skin.cpp
@@ -204,2 +204,3 @@ bool CSkinInfo::LoadStartupWindows(const cp_extension_t *ext)
   m_startupWindows.push_back(CStartupWindow(WINDOW_HOME, "513"));
+  m_startupWindows.push_back(CStartupWindow(WINDOW_PVR, "19180"));
   m_startupWindows.push_back(CStartupWindow(WINDOW_PROGRAMS, "0"));
diff --git a/xbmc/cores/DllLoader/DllLoaderContainer.cpp b/xbmc/cores/DllLoader/DllLoaderContainer.cpp
index 88111fd..a0eeea1 100644
--- a/xbmc/cores/DllLoader/DllLoaderContainer.cpp
+++ b/xbmc/cores/DllLoader/DllLoaderContainer.cpp
@@ -243,3 +243,3 @@ LibraryLoader* DllLoaderContainer::LoadDll(const char* sName, bool bLoadSymbols)
   if (strstr(sName, ".so") != NULL || strstr(sName, ".vis") != NULL || strstr(sName, ".xbs") != NULL
-      || strstr(sName, ".mvis") != NULL || strstr(sName, ".dylib") != NULL || strstr(sName, ".framework") != NULL)
+      || strstr(sName, ".mvis") != NULL || strstr(sName, ".dylib") != NULL || strstr(sName, ".framework") != NULL || strstr(sName, ".pvr") != NULL)
     pLoader = new SoLoader(sName, bLoadSymbols);
diff --git a/xbmc/cores/DllLoader/Win32DllLoader.cpp b/xbmc/cores/DllLoader/Win32DllLoader.cpp
index a7e17a9..b66cdbb 100644
--- a/xbmc/cores/DllLoader/Win32DllLoader.cpp
+++ b/xbmc/cores/DllLoader/Win32DllLoader.cpp
@@ -333,2 +333,5 @@ bool Win32DllLoader::NeedsHooking(const char *dllName)
   HMODULE hModule = GetModuleHandleW(strdllNameW.c_str());
+  if (hModule == NULL)
+    return false;
+
   wchar_t filepathW[MAX_PATH];
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 4780802..b925b91 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -562,3 +562,4 @@ bool CVDPAU::Supports(EINTERLACEMETHOD method)
   if(method == VS_INTERLACEMETHOD_VDPAU_BOB
-  || method == VS_INTERLACEMETHOD_AUTO)
+  || method == VS_INTERLACEMETHOD_AUTO
+  || method == VS_INTERLACEMETHOD_AUTO_ION)
     return true;
@@ -688,4 +689,17 @@ void CVDPAU::SetDeinterlacing()
   {
-    if (method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL
-    ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF)
+    if (method == VS_INTERLACEMETHOD_AUTO_ION)
+    {
+      if (vid_height <= 576)
+      {
+        VdpBool enabled[]={1,1,0};
+        vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
+      }
+      else if (vid_height > 576)
+      {
+        VdpBool enabled[]={1,0,0};
+        vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
+      }
+    }
+    else if (method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL
+         ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF)
     {
@@ -1418,3 +1432,4 @@ int CVDPAU::Decode(AVCodecContext *avctx, AVFrame *pFrame)
     {
-      if((method == VS_INTERLACEMETHOD_VDPAU_BOB
+      if((method == VS_INTERLACEMETHOD_AUTO_ION
+      ||  method == VS_INTERLACEMETHOD_VDPAU_BOB
       ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL
@@ -1425,3 +1440,4 @@ int CVDPAU::Decode(AVCodecContext *avctx, AVFrame *pFrame)
       {
-        if(method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF
+        if((method == VS_INTERLACEMETHOD_AUTO_ION && vid_height > 576)
+        || method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF
         || method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL_HALF
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 8e50008..8c4165b 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -37,2 +37,3 @@
 #endif
+#include "DVDInputStreams/DVDInputStreamPVRManager.h"
 #include "DVDDemuxUtils.h"
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp
index 90566f5..36ed0a5 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxHTSP.cpp
@@ -286,2 +286,3 @@ void CDVDDemuxHTSP::SubscriptionStart (htsmsg_t *m)
       CDemuxStreamSubtitle* s;
+      CDemuxStreamTeletext* t;
     } st;
@@ -322,2 +323,5 @@ void CDVDDemuxHTSP::SubscriptionStart (htsmsg_t *m)
       st.s->codec = CODEC_ID_TEXT;
+    } else if(!strcmp(type, "TELETEXT")) {
+      st.t = new CDemuxStreamTeletext();
+      st.t->codec = CODEC_ID_DVB_TELETEXT;
     } else {
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
new file mode 100644
index 0000000..a8d2f54
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
@@ -0,0 +1,321 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "DVDInputStreams/DVDInputStream.h"
+#include "DVDDemuxPVRClient.h"
+#include "DVDDemuxUtils.h"
+#include "utils/log.h"
+#include "pvr/PVRManager.h"
+#include "pvr/addons/PVRClients.h"
+
+using namespace PVR;
+
+void CDemuxStreamVideoPVRClient::GetStreamInfo(std::string& strInfo)
+{
+  switch (codec)
+  {
+    case CODEC_ID_MPEG2VIDEO:
+      strInfo = "mpeg2video";
+      break;
+    case CODEC_ID_H264:
+      strInfo = "h264";
+      break;
+    default:
+      break;
+  }
+}
+
+void CDemuxStreamAudioPVRClient::GetStreamInfo(std::string& strInfo)
+{
+  switch (codec)
+  {
+    case CODEC_ID_AC3:
+      strInfo = "ac3";
+      break;
+    case CODEC_ID_EAC3:
+      strInfo = "eac3";
+      break;
+    case CODEC_ID_MP2:
+      strInfo = "mpeg2audio";
+      break;
+    case CODEC_ID_AAC:
+      strInfo = "aac";
+      break;
+    case CODEC_ID_DTS:
+      strInfo = "dts";
+      break;
+    default:
+      break;
+  }
+}
+
+void CDemuxStreamSubtitlePVRClient::GetStreamInfo(std::string& strInfo)
+{
+}
+
+CDVDDemuxPVRClient::CDVDDemuxPVRClient() : CDVDDemux()
+{
+  m_pInput = NULL;
+  for (int i = 0; i < MAX_STREAMS; i++) m_streams[i] = NULL;
+}
+
+CDVDDemuxPVRClient::~CDVDDemuxPVRClient()
+{
+  Dispose();
+}
+
+bool CDVDDemuxPVRClient::Open(CDVDInputStream* pInput)
+{
+  Abort();
+  m_pInput = pInput;
+  if (!g_PVRClients->GetPlayingClient(m_pvrClient))
+    return false;
+
+  RequestStreams();
+  return true;
+}
+
+void CDVDDemuxPVRClient::Dispose()
+{
+  for (int i = 0; i < MAX_STREAMS; i++)
+  {
+    if (m_streams[i])
+    {
+      if (m_streams[i]->ExtraData)
+        delete[] (BYTE*)(m_streams[i]->ExtraData);
+      delete m_streams[i];
+    }
+    m_streams[i] = NULL;
+  }
+  m_pInput = NULL;
+}
+
+void CDVDDemuxPVRClient::Reset()
+{
+  if(m_pInput && g_PVRManager.IsStarted())
+    m_pvrClient->DemuxReset();
+
+  CDVDInputStream* pInputStream = m_pInput;
+  Dispose();
+  Open(pInputStream);
+}
+
+void CDVDDemuxPVRClient::Abort()
+{
+  if(m_pInput)
+    m_pvrClient->DemuxAbort();
+}
+
+void CDVDDemuxPVRClient::Flush()
+{
+  if(m_pInput && g_PVRManager.IsStarted())
+    m_pvrClient->DemuxFlush();
+}
+
+DemuxPacket* CDVDDemuxPVRClient::Read()
+{
+  if (!g_PVRManager.IsStarted())
+    return CDVDDemuxUtils::AllocateDemuxPacket(0);
+
+  DemuxPacket* pPacket = m_pvrClient->DemuxRead();
+  if (!pPacket)
+  {
+    if (m_pInput)
+      m_pInput->Close();
+    return NULL;
+  }
+
+  if (pPacket->iStreamId == DMX_SPECIALID_STREAMINFO)
+  {
+    UpdateStreams((PVR_STREAM_PROPERTIES*)pPacket->pData);
+    CDVDDemuxUtils::FreeDemuxPacket(pPacket);
+    return CDVDDemuxUtils::AllocateDemuxPacket(0);
+  }
+  else if (pPacket->iStreamId == DMX_SPECIALID_STREAMCHANGE)
+  {
+    Reset();
+  }
+
+  return pPacket;
+}
+
+CDemuxStream* CDVDDemuxPVRClient::GetStream(int iStreamId)
+{
+  if (iStreamId < 0 || iStreamId >= MAX_STREAMS) return NULL;
+    return m_streams[iStreamId];
+}
+
+void CDVDDemuxPVRClient::RequestStreams()
+{
+  if (!g_PVRManager.IsStarted())
+    return;
+
+  PVR_STREAM_PROPERTIES props;
+  m_pvrClient->GetStreamProperties(&props);
+
+  for (unsigned int i = 0; i < props.iStreamCount; ++i)
+  {
+    if (props.stream[i].iCodecType == AVMEDIA_TYPE_AUDIO)
+    {
+      CDemuxStreamAudioPVRClient* st = new CDemuxStreamAudioPVRClient(this);
+      st->iChannels       = props.stream[i].iChannels;
+      st->iSampleRate     = props.stream[i].iSampleRate;
+      st->iBlockAlign     = props.stream[i].iBlockAlign;
+      st->iBitRate        = props.stream[i].iBitRate;
+      st->iBitsPerSample  = props.stream[i].iBitsPerSample;
+      m_streams[props.stream[i].iStreamIndex] = st;
+    }
+    else if (props.stream[i].iCodecType == AVMEDIA_TYPE_VIDEO)
+    {
+      CDemuxStreamVideoPVRClient* st = new CDemuxStreamVideoPVRClient(this);
+      st->iFpsScale       = props.stream[i].iFPSScale;
+      st->iFpsRate        = props.stream[i].iFPSRate;
+      st->iHeight         = props.stream[i].iHeight;
+      st->iWidth          = props.stream[i].iWidth;
+      st->fAspect         = props.stream[i].fAspect;
+      m_streams[props.stream[i].iStreamIndex] = st;
+    }
+    else if (props.stream[i].iCodecId == CODEC_ID_DVB_TELETEXT)
+    {
+      m_streams[props.stream[i].iStreamIndex] = new CDemuxStreamTeletext();
+    }
+    else if (props.stream[i].iCodecType == AVMEDIA_TYPE_SUBTITLE)
+    {
+      CDemuxStreamSubtitlePVRClient* st = new CDemuxStreamSubtitlePVRClient(this);
+      st->identifier      = props.stream[i].iIdentifier;
+      m_streams[props.stream[i].iStreamIndex] = st;
+    }
+    else
+      m_streams[props.stream[i].iStreamIndex] = new CDemuxStream();
+
+    m_streams[props.stream[i].iStreamIndex]->codec       = (CodecID)props.stream[i].iCodecId;
+    m_streams[props.stream[i].iStreamIndex]->iId         = props.stream[i].iStreamIndex;
+    m_streams[props.stream[i].iStreamIndex]->iPhysicalId = props.stream[i].iPhysicalId;
+    m_streams[props.stream[i].iStreamIndex]->language[0] = props.stream[i].strLanguage[0];
+    m_streams[props.stream[i].iStreamIndex]->language[1] = props.stream[i].strLanguage[1];
+    m_streams[props.stream[i].iStreamIndex]->language[2] = props.stream[i].strLanguage[2];
+    m_streams[props.stream[i].iStreamIndex]->language[3] = props.stream[i].strLanguage[3];
+
+    CLog::Log(LOGDEBUG,"CDVDDemuxPVRClient::RequestStreams(): added stream %d:%d with codec_id %d",
+        m_streams[props.stream[i].iStreamIndex]->iId,
+        m_streams[props.stream[i].iStreamIndex]->iPhysicalId,
+        m_streams[props.stream[i].iStreamIndex]->codec);
+  }
+}
+
+void CDVDDemuxPVRClient::UpdateStreams(PVR_STREAM_PROPERTIES *props)
+{
+  bool bGotVideoStream(false);
+
+  for (unsigned int i = 0; i < props->iStreamCount; ++i)
+  {
+    if (m_streams[props->stream[i].iStreamIndex] == NULL ||
+        m_streams[props->stream[i].iStreamIndex]->codec != (CodecID)props->stream[i].iCodecId)
+    {
+      CLog::Log(LOGERROR,"Invalid stream inside UpdateStreams");
+      continue;
+    }
+
+    if (m_streams[props->stream[i].iStreamIndex]->type == STREAM_AUDIO)
+    {
+      CDemuxStreamAudioPVRClient* st = (CDemuxStreamAudioPVRClient*) m_streams[props->stream[i].iStreamIndex];
+      st->iChannels       = props->stream[i].iChannels;
+      st->iSampleRate     = props->stream[i].iSampleRate;
+      st->iBlockAlign     = props->stream[i].iBlockAlign;
+      st->iBitRate        = props->stream[i].iBitRate;
+      st->iBitsPerSample  = props->stream[i].iBitsPerSample;
+    }
+    else if (m_streams[props->stream[i].iStreamIndex]->type == STREAM_VIDEO)
+    {
+      if (bGotVideoStream)
+      {
+        CLog::Log(LOGDEBUG, "CDVDDemuxPVRClient - %s - skip video stream", __FUNCTION__);
+        continue;
+      }
+
+      CDemuxStreamVideoPVRClient* st = (CDemuxStreamVideoPVRClient*) m_streams[props->stream[i].iStreamIndex];
+      if (st->iWidth <= 0 || st->iHeight <= 0)
+      {
+        CLog::Log(LOGWARNING, "CDVDDemuxPVRClient - %s - invalid stream data", __FUNCTION__);
+        continue;
+      }
+
+      st->iFpsScale       = props->stream[i].iFPSScale;
+      st->iFpsRate        = props->stream[i].iFPSRate;
+      st->iHeight         = props->stream[i].iHeight;
+      st->iWidth          = props->stream[i].iWidth;
+      st->fAspect         = props->stream[i].fAspect;
+      bGotVideoStream = true;
+    }
+    else if (m_streams[props->stream[i].iStreamIndex]->type == STREAM_SUBTITLE)
+    {
+      CDemuxStreamSubtitlePVRClient* st = (CDemuxStreamSubtitlePVRClient*) m_streams[props->stream[i].iStreamIndex];
+      st->identifier      = props->stream[i].iIdentifier;
+    }
+
+    m_streams[props->stream[i].iStreamIndex]->language[0] = props->stream[i].strLanguage[0];
+    m_streams[props->stream[i].iStreamIndex]->language[1] = props->stream[i].strLanguage[1];
+    m_streams[props->stream[i].iStreamIndex]->language[2] = props->stream[i].strLanguage[2];
+    m_streams[props->stream[i].iStreamIndex]->language[3] = props->stream[i].strLanguage[3];
+
+    CLog::Log(LOGDEBUG,"CDVDDemuxPVRClient::UpdateStreams(): update stream %d:%d with codec_id %d",
+        m_streams[props->stream[i].iStreamIndex]->iId,
+        m_streams[props->stream[i].iStreamIndex]->iPhysicalId,
+        m_streams[props->stream[i].iStreamIndex]->codec);
+  }
+}
+
+int CDVDDemuxPVRClient::GetNrOfStreams()
+{
+  int i = 0;
+  while (i < MAX_STREAMS && m_streams[i]) i++;
+  return i;
+}
+
+std::string CDVDDemuxPVRClient::GetFileName()
+{
+  if(m_pInput)
+    return m_pInput->GetFileName();
+  else
+    return "";
+}
+
+void CDVDDemuxPVRClient::GetStreamCodecName(int iStreamId, CStdString &strName)
+{
+  CDemuxStream *stream = GetStream(iStreamId);
+  if (stream)
+  {
+    if (stream->codec == CODEC_ID_AC3)
+      strName = "ac3";
+    else if (stream->codec == CODEC_ID_MP2)
+      strName = "mp2";
+    else if (stream->codec == CODEC_ID_AAC)
+      strName = "aac";
+    else if (stream->codec == CODEC_ID_DTS)
+      strName = "dca";
+    else if (stream->codec == CODEC_ID_MPEG2VIDEO)
+      strName = "mpeg2video";
+    else if (stream->codec == CODEC_ID_H264)
+      strName = "h264";
+    else if (stream->codec == CODEC_ID_EAC3)
+      strName = "eac3";
+  }
+}
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
index 7021661..47537eb 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
@@ -26,2 +26,3 @@
 #include "DVDInputStreams/DVDInputStreamHttp.h"
+#include "DVDInputStreams/DVDInputStreamPVRManager.h"
 
@@ -32,4 +33,8 @@
 #endif
+#include "DVDDemuxPVRClient.h"
+#include "pvr/PVRManager.h"
+#include "pvr/addons/PVRClients.h"
 
 using namespace std;
+using namespace PVR;
 
@@ -64,2 +69,36 @@ CDVDDemux* CDVDFactoryDemuxer::CreateDemuxer(CDVDInputStream* pInputStream)
 
+  if (pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+  {
+    CDVDInputStreamPVRManager* pInputStreamPVR = (CDVDInputStreamPVRManager*)pInputStream;
+    CDVDInputStream* pOtherStream = pInputStreamPVR->GetOtherStream();
+    if(pOtherStream)
+    {
+      /* Used for MediaPortal PVR addon (uses PVR otherstream for playback of rtsp streams) */
+      if (pOtherStream->IsStreamType(DVDSTREAM_TYPE_FFMPEG))
+      {
+        auto_ptr<CDVDDemuxFFmpeg> demuxer(new CDVDDemuxFFmpeg());
+        if(demuxer->Open(pOtherStream))
+          return demuxer.release();
+        else
+          return NULL;
+      }
+    }
+
+    std::string filename = pInputStream->GetFileName();
+    /* Use PVR demuxer only for live streams */
+    if (filename.substr(0, 14) == "pvr://channels")
+    {
+      boost::shared_ptr<CPVRClient> client;
+      if (g_PVRClients->GetPlayingClient(client) &&
+          client->HandlesDemuxing())
+      {
+        auto_ptr<CDVDDemuxPVRClient> demuxer(new CDVDDemuxPVRClient());
+        if(demuxer->Open(pInputStream))
+          return demuxer.release();
+        else
+          return NULL;
+      }
+    }
+  }
+
   auto_ptr<CDVDDemuxFFmpeg> demuxer(new CDVDDemuxFFmpeg());
diff --git a/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp
index e9fce7f..22b0864 100644
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.cpp
@@ -28,2 +28,3 @@
 #include "DVDInputStreamFFmpeg.h"
+#include "DVDInputStreamPVRManager.h"
 #include "DVDInputStreamTV.h"
@@ -54,2 +55,4 @@ CDVDInputStream* CDVDFactoryInputStream::CreateInputStream(IDVDPlayer* pPlayer,
   }
+  else if(file.substr(0, 6) == "pvr://")
+    return new CDVDInputStreamPVRManager(pPlayer);
 #ifdef HAVE_LIBBLURAY
diff --git a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp
index 33ea884..a72c89f 100644
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamHTSP.cpp
@@ -197,3 +197,3 @@ bool CDVDInputStreamHTSP::GetChannels(SChannelV &channels, SChannelV::iterator &
 
-bool CDVDInputStreamHTSP::NextChannel()
+bool CDVDInputStreamHTSP::NextChannel(bool preview/* = false*/)
 {
@@ -211,3 +211,3 @@ bool CDVDInputStreamHTSP::NextChannel()
 
-bool CDVDInputStreamHTSP::PrevChannel()
+bool CDVDInputStreamHTSP::PrevChannel(bool preview/* = false*/)
 {
@@ -225,3 +225,3 @@ bool CDVDInputStreamHTSP::PrevChannel()
 
-bool CDVDInputStreamHTSP::SelectChannel(unsigned int channel)
+bool CDVDInputStreamHTSP::SelectChannelByNumber(unsigned int channel)
 {
@@ -255,5 +255,5 @@ int CDVDInputStreamHTSP::GetTotalTime()
 {
-  if(m_event.id == 0)
-    return 0;
-  return (m_event.stop - m_event.start) * 1000;
+    if(m_event.id == 0)
+        return 0;
+    return (m_event.stop - m_event.start) * 1000;
 }
diff --git a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
new file mode 100644
index 0000000..19adc44
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
@@ -0,0 +1,381 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "DVDFactoryInputStream.h"
+#include "DVDInputStreamPVRManager.h"
+#include "filesystem/PVRFile.h"
+#include "URL.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannel.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "pvr/addons/PVRClients.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "settings/GUISettings.h"
+
+using namespace XFILE;
+using namespace PVR;
+
+/************************************************************************
+ * Description: Class constructor, initialize member variables
+ *              public class is CDVDInputStream
+ */
+CDVDInputStreamPVRManager::CDVDInputStreamPVRManager(IDVDPlayer* pPlayer) : CDVDInputStream(DVDSTREAM_TYPE_PVRMANAGER)
+{
+  m_pPlayer         = pPlayer;
+  m_pFile           = NULL;
+  m_pRecordable     = NULL;
+  m_pLiveTV         = NULL;
+  m_pOtherStream    = NULL;
+  m_eof             = true;
+  m_bReopened       = false;
+  m_iScanTimeout    = 0;
+}
+
+/************************************************************************
+ * Description: Class destructor
+ */
+CDVDInputStreamPVRManager::~CDVDInputStreamPVRManager()
+{
+  Close();
+}
+
+void CDVDInputStreamPVRManager::ResetScanTimeout(unsigned int iTimeoutMs)
+{
+  m_iScanTimeout = iTimeoutMs > 0 ?
+      XbmcThreads::SystemClockMillis() + iTimeoutMs :
+      0;
+}
+
+bool CDVDInputStreamPVRManager::IsEOF()
+{
+  // don't mark as eof while within the scan timeout
+  if (m_iScanTimeout && XbmcThreads::SystemClockMillis() < m_iScanTimeout)
+    return false;
+
+  if (m_pOtherStream)
+    return m_pOtherStream->IsEOF();
+  else
+    return !m_pFile || m_eof;
+}
+
+bool CDVDInputStreamPVRManager::Open(const char* strFile, const std::string& content)
+{
+  /* Open PVR File for both cases, to have access to ILiveTVInterface and
+   * IRecordable
+   */
+  m_pFile       = new CPVRFile;
+  m_pLiveTV     = ((CPVRFile*)m_pFile)->GetLiveTV();
+  m_pRecordable = ((CPVRFile*)m_pFile)->GetRecordable();
+
+  CURL url(strFile);
+  if (!CDVDInputStream::Open(strFile, content)) return false;
+  if (!m_pFile->Open(url))
+  {
+    delete m_pFile;
+    m_pFile = NULL;
+    m_pLiveTV = NULL;
+    m_pRecordable = NULL;
+    return false;
+  }
+  m_eof = false;
+
+  /*
+   * Translate the "pvr://....." entry.
+   * The PVR Client can use http or whatever else is supported by DVDPlayer.
+   * to access streams.
+   * If after translation the file protocol is still "pvr://" use this class
+   * to read the stream data over the CPVRFile class and the PVR Library itself.
+   * Otherwise call CreateInputStream again with the translated filename and looks again
+   * for the right protocol stream handler and swap every call to this input stream
+   * handler.
+   */
+  std::string transFile = XFILE::CPVRFile::TranslatePVRFilename(strFile);
+  if(transFile.substr(0, 6) != "pvr://")
+  {
+    m_pOtherStream = CDVDFactoryInputStream::CreateInputStream(m_pPlayer, transFile, content);
+    if (!m_pOtherStream)
+    {
+      CLog::Log(LOGERROR, "CDVDInputStreamPVRManager::Open - unable to create input stream for [%s]", transFile.c_str());
+      return false;
+    }
+    else
+      m_pOtherStream->SetFileItem(m_item);
+
+    if (!m_pOtherStream->Open(transFile.c_str(), content))
+    {
+      CLog::Log(LOGERROR, "CDVDInputStreamPVRManager::Open - error opening [%s]", transFile.c_str());
+      delete m_pFile;
+      m_pFile = NULL;
+      m_pLiveTV = NULL;
+      m_pRecordable = NULL;
+      delete m_pOtherStream;
+      m_pOtherStream = NULL;
+      return false;
+    }
+  }
+
+  ResetScanTimeout((unsigned int) g_guiSettings.GetInt("pvrplayback.scantime") * 1000);
+  m_content = content;
+  CLog::Log(LOGDEBUG, "CDVDInputStreamPVRManager::Open - stream opened: %s", transFile.c_str());
+
+  return true;
+}
+
+// close file and reset everyting
+void CDVDInputStreamPVRManager::Close()
+{
+  if (m_pOtherStream)
+  {
+    m_pOtherStream->Close();
+    delete m_pOtherStream;
+  }
+
+  if (m_pFile)
+  {
+    m_pFile->Close();
+    delete m_pFile;
+  }
+
+  CDVDInputStream::Close();
+
+  m_pPlayer         = NULL;
+  m_pFile           = NULL;
+  m_pLiveTV         = NULL;
+  m_pRecordable     = NULL;
+  m_pOtherStream    = NULL;
+  m_eof             = true;
+
+  CLog::Log(LOGDEBUG, "CDVDInputStreamPVRManager::Close - stream closed");
+}
+
+int CDVDInputStreamPVRManager::Read(BYTE* buf, int buf_size)
+{
+  if(!m_pFile) return -1;
+
+  if (m_pOtherStream)
+  {
+    return m_pOtherStream->Read(buf, buf_size);
+  }
+  else
+  {
+    unsigned int ret = m_pFile->Read(buf, buf_size);
+
+    /* we currently don't support non completing reads */
+    if( ret <= 0 ) m_eof = true;
+
+    return (int)(ret & 0xFFFFFFFF);
+  }
+}
+
+int64_t CDVDInputStreamPVRManager::Seek(int64_t offset, int whence)
+{
+  if (!m_pFile)
+    return -1;
+
+  if (whence == SEEK_POSSIBLE)
+    return m_pFile->IoControl(IOCTRL_SEEK_POSSIBLE, NULL);
+
+  if (m_pOtherStream)
+  {
+    return m_pOtherStream->Seek(offset, whence);
+  }
+  else
+  {
+    int64_t ret = m_pFile->Seek(offset, whence);
+
+    /* if we succeed, we are not eof anymore */
+    if( ret >= 0 ) m_eof = false;
+
+    return ret;
+  }
+}
+
+int64_t CDVDInputStreamPVRManager::GetLength()
+{
+  if(!m_pFile) return -1;
+
+  if (m_pOtherStream)
+    return m_pOtherStream->GetLength();
+  else
+    return m_pFile->GetLength();
+}
+
+int CDVDInputStreamPVRManager::GetTotalTime()
+{
+  if (m_pLiveTV)
+    return m_pLiveTV->GetTotalTime();
+  return 0;
+}
+
+int CDVDInputStreamPVRManager::GetTime()
+{
+  if (m_pLiveTV)
+    return m_pLiveTV->GetStartTime();
+  return 0;
+}
+
+bool CDVDInputStreamPVRManager::NextChannel(bool preview/* = false*/)
+{
+  PVR_CLIENT client;
+  if (!preview && !SupportsChannelSwitch())
+  {
+    CPVRChannelPtr channel;
+    g_PVRManager.GetCurrentChannel(channel);
+    CFileItemPtr item = g_PVRChannelGroups->Get(channel->IsRadio())->GetSelectedGroup()->GetByChannelUp(*channel);
+    if (item.get())
+      return CloseAndOpen(item->GetPath().c_str());
+  }
+  else if (m_pLiveTV)
+    return m_pLiveTV->NextChannel(preview);
+  return false;
+}
+
+bool CDVDInputStreamPVRManager::PrevChannel(bool preview/* = false*/)
+{
+  PVR_CLIENT client;
+  if (!preview && !SupportsChannelSwitch())
+  {
+    CPVRChannelPtr channel;
+    g_PVRManager.GetCurrentChannel(channel);
+    CFileItemPtr item = g_PVRChannelGroups->Get(channel->IsRadio())->GetSelectedGroup()->GetByChannelDown(*channel);
+    if (item.get())
+      return CloseAndOpen(item->GetPath().c_str());
+  }
+  else if (m_pLiveTV)
+    return m_pLiveTV->PrevChannel(preview);
+  return false;
+}
+
+bool CDVDInputStreamPVRManager::SelectChannelByNumber(unsigned int iChannelNumber)
+{
+  PVR_CLIENT client;
+  if (!SupportsChannelSwitch())
+  {
+    CPVRChannelPtr channel;
+    g_PVRManager.GetCurrentChannel(channel);
+    CFileItemPtr item = g_PVRChannelGroups->Get(channel->IsRadio())->GetSelectedGroup()->GetByChannelNumber(iChannelNumber);
+    if (item.get())
+      return CloseAndOpen(item->GetPath().c_str());
+  }
+  else if (m_pLiveTV)
+    return m_pLiveTV->SelectChannel(iChannelNumber);
+
+  return false;
+}
+
+bool CDVDInputStreamPVRManager::SelectChannel(const CPVRChannel &channel)
+{
+  PVR_CLIENT client;
+  if (!SupportsChannelSwitch())
+  {
+    CFileItem item(channel);
+    return CloseAndOpen(item.GetPath().c_str());
+  }
+  else if (m_pLiveTV)
+  {
+    return m_pLiveTV->SelectChannel(channel.ChannelNumber());
+  }
+
+  return false;
+}
+
+bool CDVDInputStreamPVRManager::GetSelectedChannel(CPVRChannelPtr& channel) const
+{
+  return g_PVRManager.GetCurrentChannel(channel);
+}
+
+bool CDVDInputStreamPVRManager::UpdateItem(CFileItem& item)
+{
+  if (m_pLiveTV)
+    return m_pLiveTV->UpdateItem(item);
+  return false;
+}
+
+CDVDInputStream::ENextStream CDVDInputStreamPVRManager::NextStream()
+{
+  if(!m_pFile) return NEXTSTREAM_NONE;
+
+  if(m_bReopened)
+  {
+    m_bReopened = false;
+    m_eof       = false;
+    return NEXTSTREAM_RETRY;
+  }
+
+  if (m_pOtherStream)
+    return m_pOtherStream->NextStream();
+  else if(m_pFile->SkipNext())
+  {
+    m_eof = false;
+    return NEXTSTREAM_OPEN;
+  }
+
+  return NEXTSTREAM_NONE;
+}
+
+bool CDVDInputStreamPVRManager::CanRecord()
+{
+  if (m_pRecordable)
+    return m_pRecordable->CanRecord();
+  return false;
+}
+
+bool CDVDInputStreamPVRManager::IsRecording()
+{
+  if (m_pRecordable)
+    return m_pRecordable->IsRecording();
+  return false;
+}
+
+bool CDVDInputStreamPVRManager::Record(bool bOnOff)
+{
+  if (m_pRecordable)
+    return m_pRecordable->Record(bOnOff);
+  return false;
+}
+
+CStdString CDVDInputStreamPVRManager::GetInputFormat()
+{
+  if (!m_pOtherStream && g_PVRManager.IsStarted())
+    return g_PVRClients->GetCurrentInputFormat();
+  return StringUtils::EmptyString;
+}
+
+bool CDVDInputStreamPVRManager::CloseAndOpen(const char* strFile)
+{
+  Close();
+
+  if (Open(strFile, m_content))
+  {
+    m_bReopened = true;
+    return true;
+  }
+
+  return false;
+}
+
+bool CDVDInputStreamPVRManager::SupportsChannelSwitch(void) const
+{
+  PVR_CLIENT client;
+  return g_PVRClients->GetPlayingClient(client) &&
+         client->HandlesInputStream();
+}
diff --git a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp
index 5183dbb..773de51 100644
--- a/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp
+++ b/xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreamTV.cpp
@@ -24,2 +24,4 @@
 #include "filesystem/VTPFile.h"
+#include "pvr/channels/PVRChannel.h"
+#include "filesystem/VTPFile.h"
 #include "filesystem/SlingboxFile.h"
@@ -139,3 +141,3 @@ int CDVDInputStreamTV::GetStartTime()
 
-bool CDVDInputStreamTV::NextChannel()
+bool CDVDInputStreamTV::NextChannel(bool preview/* = false*/)
 {
@@ -145,3 +147,3 @@ bool CDVDInputStreamTV::NextChannel()
 
-bool CDVDInputStreamTV::PrevChannel()
+bool CDVDInputStreamTV::PrevChannel(bool preview/* = false*/)
 {
@@ -151,3 +153,3 @@ bool CDVDInputStreamTV::PrevChannel()
 
-bool CDVDInputStreamTV::SelectChannel(unsigned int channel)
+bool CDVDInputStreamTV::SelectChannelByNumber(unsigned int channel)
 {
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index eaad1eb..0fc6c24 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -30,2 +30,3 @@
 #include "DVDInputStreams/DVDInputStreamTV.h"
+#include "DVDInputStreams/DVDInputStreamPVRManager.h"
 
@@ -70,2 +71,7 @@
 #include "utils/StreamDetails.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannel.h"
+#include "pvr/windows/GUIWindowPVR.h"
+#include "filesystem/PVRFile.h"
+#include "video/dialogs/GUIDialogFullScreenInfo.h"
 #include "utils/StreamUtils.h"
@@ -79,4 +85,6 @@
 #include "LangInfo.h"
+#include "ApplicationMessenger.h"
 
 using namespace std;
+using namespace PVR;
 
@@ -595,2 +603,3 @@ retry:
   if (!m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD)
+  &&  !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER)
   &&  !m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV)
@@ -633,2 +642,3 @@ retry:
   m_errorCount = 0;
+  m_iChannelEntryTimeOut = 0;
 
@@ -650,3 +660,7 @@ bool CDVDPlayer::OpenDemuxStream()
       m_pDemuxer = CDVDFactoryDemuxer::CreateDemuxer(m_pInputStream);
-      if(!m_pDemuxer && m_pInputStream->NextStream() != CDVDInputStream::NEXTSTREAM_NONE)
+      if(!m_pDemuxer && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+      {
+        continue;
+      }
+      else if(!m_pDemuxer && m_pInputStream->NextStream() != CDVDInputStream::NEXTSTREAM_NONE)
       {
@@ -759,2 +773,11 @@ bool CDVDPlayer::ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream)
     {
+      if(packet->iStreamId == DMX_SPECIALID_STREAMCHANGE)
+      {
+        // reset the caching state for pvr streams
+        if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+          SetCaching(CACHESTATE_PVR);
+        CDVDDemuxUtils::FreeDemuxPacket(packet);
+        return true;
+      }
+
       UpdateCorrection(packet, m_offset_pts);
@@ -881,2 +904,26 @@ bool CDVDPlayer::IsBetterStream(CCurrentStream& current, CDemuxStream* stream)
   }
+  else if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+  {
+    if(stream->source == current.source &&
+       stream->iId    == current.id)
+      return false;
+
+    if(stream->disabled)
+      return false;
+
+    if(stream->type != current.type)
+      return false;
+
+    if(current.type == STREAM_AUDIO    && stream->iPhysicalId == m_dvd.iSelectedAudioStream)
+      return true;
+
+    if(current.type == STREAM_SUBTITLE && stream->iPhysicalId == m_dvd.iSelectedSPUStream)
+      return true;
+
+    if(current.type == STREAM_TELETEXT)
+      return true;
+
+    if(current.id < 0)
+      return true;
+  }
   else
@@ -1004,2 +1051,6 @@ void CDVDPlayer::Process()
 
+  // make sure all selected stream have data on startup
+  if (CachePVRStream())
+    SetCaching(CACHESTATE_PVR);
+
   // make sure application know our info
@@ -1014,3 +1065,4 @@ void CDVDPlayer::Process()
 
-  SetCaching(CACHESTATE_FLUSH);
+  if (!CachePVRStream())
+    SetCaching(CACHESTATE_FLUSH);
 
@@ -1050,2 +1102,6 @@ void CDVDPlayer::Process()
       OpenDefaultStreams();
+
+      if (CachePVRStream())
+        SetCaching(CACHESTATE_PVR);
+
       UpdateApplication(0);
@@ -1063,5 +1119,8 @@ void CDVDPlayer::Process()
 
+    if (CheckDelayedChannelEntry())
+      continue;
+
     // if the queues are full, no need to read more
-    if ((!m_dvdPlayerAudio.AcceptsData() && m_CurrentAudio.id >= 0)
-    ||  (!m_dvdPlayerVideo.AcceptsData() && m_CurrentVideo.id >= 0))
+    if ((!m_dvdPlayerAudio.AcceptsData() && m_CurrentAudio.id >= 0) ||
+        (!m_dvdPlayerVideo.AcceptsData() && m_CurrentVideo.id >= 0))
     {
@@ -1131,2 +1190,11 @@ void CDVDPlayer::Process()
       }
+      else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+      {
+        CDVDInputStreamPVRManager* pStream = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream);
+        if (pStream->IsEOF())
+          break;
+
+        Sleep(100);
+        continue;
+      }
 
@@ -1190,2 +1258,19 @@ void CDVDPlayer::Process()
 
+bool CDVDPlayer::CheckDelayedChannelEntry(void)
+{
+  bool bReturn(false);
+
+  if (m_iChannelEntryTimeOut > 0 && XbmcThreads::SystemClockMillis() >= m_iChannelEntryTimeOut)
+  {
+    CFileItem currentFile(g_application.CurrentFileItem());
+    CPVRChannel *currentChannel = currentFile.GetPVRChannelInfoTag();
+    SwitchChannel(*currentChannel);
+
+    bReturn = true;
+    m_iChannelEntryTimeOut = 0;
+  }
+
+  return bReturn;
+}
+
 void CDVDPlayer::ProcessPacket(CDemuxStream* pStream, DemuxPacket* pPacket)
@@ -1440,2 +1525,36 @@ void CDVDPlayer::HandlePlaySpeed()
 
+  if (caching == CACHESTATE_PVR)
+  {
+    bool bGotAudio(m_pDemuxer->GetNrOfAudioStreams() > 0);
+    bool bGotVideo(m_pDemuxer->GetNrOfVideoStreams() > 0);
+    bool bAudioLevelOk(m_dvdPlayerAudio.GetLevel() > g_advancedSettings.m_iPVRMinAudioCacheLevel);
+    bool bVideoLevelOk(m_dvdPlayerVideo.GetLevel() > g_advancedSettings.m_iPVRMinVideoCacheLevel);
+    bool bAudioFull(!m_dvdPlayerAudio.AcceptsData());
+    bool bVideoFull(!m_dvdPlayerVideo.AcceptsData());
+
+    if (/* if all streams got at least g_advancedSettings.m_iPVRMinCacheLevel in their buffers, we're done */
+        ((bGotVideo || bGotAudio) && (!bGotAudio || bAudioLevelOk) && (!bGotVideo || bVideoLevelOk)) ||
+        /* or if one of the buffers is full */
+        (bAudioFull || bVideoFull))
+    {
+      CLog::Log(LOGDEBUG, "set caching from pvr to done. audio (%d) = %d. video (%d) = %d",
+          bGotAudio, m_dvdPlayerAudio.GetLevel(),
+          bGotVideo, m_dvdPlayerVideo.GetLevel());
+
+      CFileItem currentItem(g_application.CurrentFileItem());
+      if (currentItem.HasPVRChannelInfoTag())
+        g_PVRManager.LoadCurrentChannelSettings();
+
+      caching = CACHESTATE_DONE;
+    }
+    else
+    {
+      /* ensure that automatically started players are stopped while caching */
+      if (m_CurrentAudio.started)
+        m_dvdPlayerAudio.SetSpeed(DVD_PLAYSPEED_PAUSE);
+      if (m_CurrentVideo.started)
+        m_dvdPlayerVideo.SetSpeed(DVD_PLAYSPEED_PAUSE);
+    }
+  }
+
   if(caching == CACHESTATE_PLAY)
@@ -1503,2 +1622,13 @@ bool CDVDPlayer::CheckStartCaching(CCurrentStream& current)
   {
+    if (CachePVRStream())
+    {
+      if ((current.type == STREAM_AUDIO && current.started && m_dvdPlayerAudio.GetLevel() == 0) ||
+         (current.type == STREAM_VIDEO && current.started && m_dvdPlayerVideo.GetLevel() == 0))
+      {
+        CLog::Log(LOGDEBUG, "%s stream stalled. start buffering", current.type == STREAM_AUDIO ? "audio" : "video");
+        SetCaching(CACHESTATE_PVR);
+      }
+      return true;
+    }
+
     // don't start caching if it's only a single stream that has run dry
@@ -1508,12 +1638,6 @@ bool CDVDPlayer::CheckStartCaching(CCurrentStream& current)
 
-    if(m_pInputStream->IsStreamType(DVDSTREAM_TYPE_HTSP)
-    || m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
-      SetCaching(CACHESTATE_INIT);
+    if(current.inited)
+      SetCaching(CACHESTATE_FULL);
     else
-    {
-      if(current.inited)
-        SetCaching(CACHESTATE_FULL);
-      else
-        SetCaching(CACHESTATE_INIT);
-    }
+      SetCaching(CACHESTATE_INIT);
     return true;
@@ -1864,2 +1988,7 @@ void CDVDPlayer::OnExit()
 
+    if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) && g_PVRManager.IsPlayingRecording())
+    {
+      g_PVRManager.UpdateCurrentLastPlayedPosition(m_State.time / 1000);
+    }
+
     // destroy the inputstream
@@ -2056,4 +2185,5 @@ void CDVDPlayer::HandleMessages()
       {
-        if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
-          static_cast<CDVDInputStreamTV*>(m_pInputStream)->Record(*(CDVDMsgBool*)pMsg);
+        CDVDInputStream::IChannel* input = dynamic_cast<CDVDInputStream::IChannel*>(m_pInputStream);
+        if(input)
+          input->Record(*(CDVDMsgBool*)pMsg);
       }
@@ -2099,5 +2229,29 @@ void CDVDPlayer::HandleMessages()
       }
-      else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_NEXT) ||
-               pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREV) ||
-              (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_SELECT) && m_messenger.GetPacketCount(CDVDMsg::PLAYER_CHANNEL_SELECT) == 0))
+      else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_SELECT_NUMBER) && m_messenger.GetPacketCount(CDVDMsg::PLAYER_CHANNEL_SELECT_NUMBER) == 0)
+      {
+        FlushBuffers(false);
+        CDVDInputStream::IChannel* input = dynamic_cast<CDVDInputStream::IChannel*>(m_pInputStream);
+        if(input && input->SelectChannelByNumber(static_cast<CDVDMsgInt*>(pMsg)->m_value))
+        {
+          SAFE_DELETE(m_pDemuxer);
+        }else
+        {
+          CLog::Log(LOGWARNING, "%s - failed to switch channel. playback stopped", __FUNCTION__);
+          CApplicationMessenger::Get().MediaStop(false);
+        }
+      }
+      else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_SELECT) && m_messenger.GetPacketCount(CDVDMsg::PLAYER_CHANNEL_SELECT) == 0)
+      {
+        FlushBuffers(false);
+        CDVDInputStream::IChannel* input = dynamic_cast<CDVDInputStream::IChannel*>(m_pInputStream);
+        if(input && input->SelectChannel(static_cast<CDVDMsgType <CPVRChannel> *>(pMsg)->m_value))
+        {
+          SAFE_DELETE(m_pDemuxer);
+        }else
+        {
+          CLog::Log(LOGWARNING, "%s - failed to switch channel. playback stopped", __FUNCTION__);
+          CApplicationMessenger::Get().MediaStop(false);
+        }
+      }
+      else if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_NEXT) || pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_PREV))
       {
@@ -2106,19 +2260,36 @@ void CDVDPlayer::HandleMessages()
         {
-          g_infoManager.SetDisplayAfterSeek(100000);
-
-          bool result;
-          if (pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_SELECT))
-            result = input->SelectChannel(static_cast<CDVDMsgInt*>(pMsg)->m_value);
-          else if(pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_NEXT))
-            result = input->NextChannel();
-          else
-            result = input->PrevChannel();
+          bool bSwitchSuccessful(false);
+          bool bShowPreview(g_guiSettings.GetInt("pvrplayback.channelentrytimeout") > 0);
 
-          if(result)
+          if (!bShowPreview)
           {
+            g_infoManager.SetDisplayAfterSeek(100000);
             FlushBuffers(false);
-            SAFE_DELETE(m_pDemuxer);
           }
 
-          g_infoManager.SetDisplayAfterSeek();
+          if(pMsg->IsType(CDVDMsg::PLAYER_CHANNEL_NEXT))
+            bSwitchSuccessful = input->NextChannel(bShowPreview);
+          else
+            bSwitchSuccessful = input->PrevChannel(bShowPreview);
+
+          if(bSwitchSuccessful)
+          {
+            if (bShowPreview)
+            {
+              UpdateApplication(0);
+              m_iChannelEntryTimeOut = XbmcThreads::SystemClockMillis() + g_guiSettings.GetInt("pvrplayback.channelentrytimeout");
+            }
+            else
+            {
+              m_iChannelEntryTimeOut = 0;
+              SAFE_DELETE(m_pDemuxer);
+
+              g_infoManager.SetDisplayAfterSeek();
+            }
+          }
+          else
+          {
+            CLog::Log(LOGWARNING, "%s - failed to switch channel. playback stopped", __FUNCTION__);
+            CApplicationMessenger::Get().MediaStop(false);
+          }
         }
@@ -2163,3 +2334,4 @@ void CDVDPlayer::SetCaching(ECacheState state)
   if(state == CACHESTATE_FULL
-  || state == CACHESTATE_INIT)
+  || state == CACHESTATE_INIT
+  || state == CACHESTATE_PVR)
   {
@@ -2170,2 +2342,5 @@ void CDVDPlayer::SetCaching(ECacheState state)
     m_dvdPlayerVideo.SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
+
+    if (state == CACHESTATE_PVR)
+      m_pInputStream->ResetScanTimeout((unsigned int) g_guiSettings.GetInt("pvrplayback.scantime") * 1000);
   }
@@ -2178,2 +2353,3 @@ void CDVDPlayer::SetCaching(ECacheState state)
     m_dvdPlayerVideo.SetSpeed(m_playSpeed);
+    m_pInputStream->ResetScanTimeout(0);
   }
@@ -2192,3 +2368,3 @@ void CDVDPlayer::Pause()
 {
-  if(m_playSpeed != DVD_PLAYSPEED_PAUSE && m_caching == CACHESTATE_FULL)
+  if(m_playSpeed != DVD_PLAYSPEED_PAUSE && (m_caching == CACHESTATE_FULL || m_caching == CACHESTATE_PVR))
   {
@@ -2213,3 +2389,3 @@ bool CDVDPlayer::IsPaused() const
 {
-  return (m_playSpeed == DVD_PLAYSPEED_PAUSE) || m_caching == CACHESTATE_FULL;
+  return m_playSpeed == DVD_PLAYSPEED_PAUSE || m_caching == CACHESTATE_FULL || m_caching == CACHESTATE_PVR;
 }
@@ -3204,2 +3380,17 @@ int CDVDPlayer::OnDVDNavResult(void* pData, int iMessage)
 
+bool CDVDPlayer::ShowPVRChannelInfo(void)
+{
+  bool bReturn(false);
+
+  if (g_guiSettings.GetBool("pvrmenu.infoswitch"))
+  {
+    int iTimeout = g_guiSettings.GetBool("pvrmenu.infotimeout") ? g_guiSettings.GetInt("pvrmenu.infotime") : 0;
+    g_PVRManager.ShowPlayerInfo(iTimeout);
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
 bool CDVDPlayer::OnAction(const CAction &action)
@@ -3386,2 +3577,3 @@ bool CDVDPlayer::OnAction(const CAction &action)
     {
+      case ACTION_MOVE_UP:
       case ACTION_NEXT_ITEM:
@@ -3389,2 +3581,3 @@ bool CDVDPlayer::OnAction(const CAction &action)
         g_infoManager.SetDisplayAfterSeek();
+        ShowPVRChannelInfo();
         return true;
@@ -3392,2 +3585,3 @@ bool CDVDPlayer::OnAction(const CAction &action)
 
+      case ACTION_MOVE_DOWN:
       case ACTION_PREV_ITEM:
@@ -3395,2 +3589,3 @@ bool CDVDPlayer::OnAction(const CAction &action)
         g_infoManager.SetDisplayAfterSeek();
+        ShowPVRChannelInfo();
         return true;
@@ -3402,4 +3597,5 @@ bool CDVDPlayer::OnAction(const CAction &action)
         int channel = action.GetAmount();
-        m_messenger.Put(new CDVDMsgInt(CDVDMsg::PLAYER_CHANNEL_SELECT, channel));
+        m_messenger.Put(new CDVDMsgInt(CDVDMsg::PLAYER_CHANNEL_SELECT_NUMBER, channel));
         g_infoManager.SetDisplayAfterSeek();
+        ShowPVRChannelInfo();
         return true;
@@ -3636,5 +3832,10 @@ void CDVDPlayer::UpdatePlayState(double timeout)
     }
+    else if (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+    {
+      state.canrecord = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream)->CanRecord();
+      state.recording = static_cast<CDVDInputStreamPVRManager*>(m_pInputStream)->IsRecording();
+    }
 
     CDVDInputStream::IDisplayTime* pDisplayTime = dynamic_cast<CDVDInputStream::IDisplayTime*>(m_pInputStream);
-    if (pDisplayTime)
+    if (pDisplayTime && pDisplayTime->GetTotalTime() > 0)
     {
@@ -3760,3 +3961,4 @@ bool CDVDPlayer::Record(bool bOnOff)
 {
-  if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV))
+  if (m_pInputStream && (m_pInputStream->IsStreamType(DVDSTREAM_TYPE_TV) ||
+                         m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER)) )
   {
@@ -3842 +4044,31 @@ CStdString CDVDPlayer::GetPlayingTitle()
 }
+
+bool CDVDPlayer::SwitchChannel(const CPVRChannel &channel)
+{
+  if (!g_PVRManager.CheckParentalLock(channel))
+    return false;
+
+  /* set GUI info */
+  if (!g_PVRManager.PerformChannelSwitch(channel, true))
+    return false;
+
+  UpdateApplication(0);
+  UpdatePlayState(0);
+
+  /* make sure the pvr window is updated */
+  CGUIWindowPVR *pWindow = (CGUIWindowPVR *) g_windowManager.GetWindow(WINDOW_PVR);
+  if (pWindow)
+    pWindow->SetInvalid();
+
+  /* select the new channel */
+  m_messenger.Put(new CDVDMsgType<CPVRChannel>(CDVDMsg::PLAYER_CHANNEL_SELECT, channel));
+
+  return true;
+}
+
+bool CDVDPlayer::CachePVRStream(void) const
+{
+  return m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER) &&
+      !g_PVRManager.IsPlayingRecording() &&
+      g_advancedSettings.m_bPVRCacheInDvdPlayer;
+}
diff --git a/xbmc/cores/dvdplayer/Edl.cpp b/xbmc/cores/dvdplayer/Edl.cpp
index f7b1326..dd368ba 100644
--- a/xbmc/cores/dvdplayer/Edl.cpp
+++ b/xbmc/cores/dvdplayer/Edl.cpp
@@ -115,4 +115,5 @@ bool CEdl::ReadEditDecisionLists(const CStdString& strMovie, const float fFrameR
    */
-  if (URIUtils::IsHD(strMovie)
-  ||  URIUtils::IsSmb(strMovie))
+  if ((URIUtils::IsHD(strMovie) ||  URIUtils::IsSmb(strMovie)) &&
+      !URIUtils::IsPVRRecording(strMovie) &&
+      !URIUtils::IsInternetStream(strMovie))
   {
diff --git a/xbmc/cores/paplayer/CodecFactory.cpp b/xbmc/cores/paplayer/CodecFactory.cpp
index bc30c63..52d8d37 100644
--- a/xbmc/cores/paplayer/CodecFactory.cpp
+++ b/xbmc/cores/paplayer/CodecFactory.cpp
@@ -67,3 +67,4 @@ ICodec* CodecFactory::CreateCodec(const CStdString& strFileType)
   else if (strFileType.Equals("dts") || strFileType.Equals("ac3") ||
-           strFileType.Equals("m4a") || strFileType.Equals("aac"))
+           strFileType.Equals("m4a") || strFileType.Equals("aac") ||
+           strFileType.Equals("pvr"))
     return new DVDPlayerCodec();
diff --git a/xbmc/dialogs/GUIDialogExtendedProgressBar.cpp b/xbmc/dialogs/GUIDialogExtendedProgressBar.cpp
new file mode 100644
index 0000000..8a8c0bf
--- /dev/null
+++ b/xbmc/dialogs/GUIDialogExtendedProgressBar.cpp
@@ -0,0 +1,172 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogExtendedProgressBar.h"
+#include "guilib/GUIProgressControl.h"
+#include "guilib/GUISliderControl.h"
+#include "threads/SingleLock.h"
+#include "threads/SystemClock.h"
+
+#define CONTROL_LABELHEADER       30
+#define CONTROL_LABELTITLE        31
+#define CONTROL_PROGRESS          32
+
+#define ITEM_SWITCH_TIME_MS       2000
+
+using namespace std;
+
+string CGUIDialogProgressBarHandle::Text(void) const
+{
+  CSingleLock lock(m_critSection);
+  string retVal(m_strText);
+  return retVal;
+}
+
+void CGUIDialogProgressBarHandle::SetText(const string &strText)
+{
+  CSingleLock lock(m_critSection);
+  m_strText = strText;
+}
+
+void CGUIDialogProgressBarHandle::SetProgress(int currentItem, int itemCount)
+{
+  float fPercentage = (float)((currentItem*100)/itemCount);
+  if (fPercentage > 100.0F)
+    fPercentage = 100.0F;
+
+  m_fPercentage = fPercentage;
+}
+
+CGUIDialogExtendedProgressBar::CGUIDialogExtendedProgressBar(void)
+  : CGUIDialog(WINDOW_DIALOG_EXT_PROGRESS, "DialogExtendedProgressBar.xml")
+{
+  m_loadOnDemand    = false;
+  m_iLastSwitchTime = 0;
+  m_iCurrentItem    = 0;
+}
+
+CGUIDialogProgressBarHandle *CGUIDialogExtendedProgressBar::GetHandle(const string &strTitle)
+{
+  CGUIDialogProgressBarHandle *handle = new CGUIDialogProgressBarHandle(strTitle);
+  {
+    CSingleLock lock(m_critSection);
+    m_handles.push_back(handle);
+  }
+
+  Show();
+
+  return handle;
+}
+
+bool CGUIDialogExtendedProgressBar::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+  case GUI_MSG_WINDOW_INIT:
+    {
+      m_iLastSwitchTime = XbmcThreads::SystemClockMillis();
+      CGUIDialog::OnMessage(message);
+
+      UpdateState(0);
+      return true;
+    }
+    break;
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogExtendedProgressBar::Process(unsigned int currentTime, CDirtyRegionList &dirtyregions)
+{
+  if (m_active)
+    UpdateState(currentTime);
+
+  CGUIDialog::Process(currentTime, dirtyregions);
+}
+
+void CGUIDialogExtendedProgressBar::UpdateState(unsigned int currentTime)
+{
+  bool   bNoItemsLeft(false);
+  string strHeader;
+  string strTitle;
+  float  fProgress(-1.0f);
+
+  {
+    CSingleLock lock(m_critSection);
+
+    // delete finished items
+    for (int iPtr = m_handles.size() - 1; iPtr >= 0; iPtr--)
+    {
+      if (m_handles.at(iPtr)->IsFinished())
+      {
+        delete m_handles.at(iPtr);
+        m_handles.erase(m_handles.begin() + iPtr);
+
+        // current item deleted, back one
+        if ((int)m_iCurrentItem == iPtr && m_iCurrentItem > 0)
+          m_iCurrentItem--;
+      }
+    }
+
+    // update the current item ptr
+    if (currentTime > m_iLastSwitchTime &&
+        currentTime - m_iLastSwitchTime >= ITEM_SWITCH_TIME_MS)
+    {
+      m_iLastSwitchTime = currentTime;
+
+      // select next item
+      if (++m_iCurrentItem > m_handles.size() - 1)
+        m_iCurrentItem = 0;
+    }
+
+    if (m_iCurrentItem < m_handles.size())
+    {
+      CGUIDialogProgressBarHandle *handle = m_handles.at(m_iCurrentItem);
+      if (handle)
+      {
+        strTitle  = handle->Text();
+        strHeader = handle->Title();
+        fProgress = handle->Percentage();
+      }
+    }
+    else
+    {
+      bNoItemsLeft = true;
+    }
+  }
+
+  if (bNoItemsLeft)
+  {
+    Close(true, 0, true, false);
+  }
+  else
+  {
+    SET_CONTROL_LABEL(CONTROL_LABELHEADER, strHeader);
+    SET_CONTROL_LABEL(CONTROL_LABELTITLE, strTitle);
+
+    if (fProgress > -1.0f)
+    {
+      SET_CONTROL_VISIBLE(CONTROL_PROGRESS);
+      CGUIProgressControl* pProgressCtrl=(CGUIProgressControl*)GetControl(CONTROL_PROGRESS);
+      if (pProgressCtrl) pProgressCtrl->SetPercentage(fProgress);
+    }
+  }
+}
diff --git a/xbmc/dialogs/GUIDialogMediaSource.cpp b/xbmc/dialogs/GUIDialogMediaSource.cpp
index 9534548..3272071 100644
--- a/xbmc/dialogs/GUIDialogMediaSource.cpp
+++ b/xbmc/dialogs/GUIDialogMediaSource.cpp
@@ -30,2 +30,4 @@
 #include "filesystem/Directory.h"
+#include "filesystem/PluginDirectory.h"
+#include "filesystem/PVRDirectory.h"
 #include "GUIDialogYesNo.h"
@@ -298,2 +300,10 @@ void CGUIDialogMediaSource::OnPathBrowse(int item)
     extraShares.push_back(share1);
+
+    // add the recordings dir as needed
+    if (CPVRDirectory::HasRecordings())
+    {
+      share1.strPath = "pvr://recordings/";
+      share1.strName = g_localizeStrings.Get(19017); // TV Recordings
+      extraShares.push_back(share1);
+    }
   }
diff --git a/xbmc/dialogs/GUIDialogNumeric.cpp b/xbmc/dialogs/GUIDialogNumeric.cpp
index fa82a0d..9d20e9e 100644
--- a/xbmc/dialogs/GUIDialogNumeric.cpp
+++ b/xbmc/dialogs/GUIDialogNumeric.cpp
@@ -340,2 +340,4 @@ void CGUIDialogNumeric::OnNumber(unsigned int num)
 {
+  ResetAutoClose();
+
   if (m_mode == INPUT_NUMBER || m_mode == INPUT_PASSWORD)
@@ -678,3 +680,3 @@ bool CGUIDialogNumeric::ShowAndGetIPAddress(CStdString &IPAddress, const CStdStr
 
-bool CGUIDialogNumeric::ShowAndGetNumber(CStdString& strInput, const CStdString &strHeading)
+bool CGUIDialogNumeric::ShowAndGetNumber(CStdString& strInput, const CStdString &strHeading, unsigned int iAutoCloseTimeoutMs /* = 0 */)
 {
@@ -685,5 +687,8 @@ bool CGUIDialogNumeric::ShowAndGetNumber(CStdString& strInput, const CStdString
   pDialog->SetMode(INPUT_NUMBER, (void *)&strInput);
+  if (iAutoCloseTimeoutMs)
+    pDialog->SetAutoClose(iAutoCloseTimeoutMs);
+
   pDialog->DoModal();
 
-  if (!pDialog->IsConfirmed() || pDialog->IsCanceled())
+  if (!pDialog->IsAutoClosed() && (!pDialog->IsConfirmed() || pDialog->IsCanceled()))
     return false;
diff --git a/xbmc/dialogs/GUIDialogSeekBar.cpp b/xbmc/dialogs/GUIDialogSeekBar.cpp
index 8fa7e8d..1f4570f 100644
--- a/xbmc/dialogs/GUIDialogSeekBar.cpp
+++ b/xbmc/dialogs/GUIDialogSeekBar.cpp
@@ -25,4 +25,10 @@
 #include "GUIInfoManager.h"
+#include "utils/TimeUtils.h"
+#include "FileItem.h"
+#include "settings/GUISettings.h"
 #include "utils/SeekHandler.h"
 
+#define SEEK_BAR_DISPLAY_TIME 2000L
+#define SEEK_BAR_SEEK_TIME     500L
+
 #define POPUP_SEEK_SLIDER       401
diff --git a/xbmc/epg/Epg.cpp b/xbmc/epg/Epg.cpp
new file mode 100644
index 0000000..5f5dc78
--- /dev/null
+++ b/xbmc/epg/Epg.cpp
@@ -0,0 +1,960 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "guilib/LocalizeStrings.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "utils/TimeUtils.h"
+
+#include "EpgDatabase.h"
+#include "EpgContainer.h"
+#include "pvr/PVRManager.h"
+#include "pvr/addons/PVRClients.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "utils/StringUtils.h"
+
+#include "../addons/include/xbmc_pvr_types.h" // TODO extract the epg specific stuff
+
+using namespace PVR;
+using namespace EPG;
+using namespace std;
+
+CEpg::CEpg(int iEpgID, const CStdString &strName /* = "" */, const CStdString &strScraperName /* = "" */, bool bLoadedFromDb /* = false */) :
+    m_bChanged(!bLoadedFromDb),
+    m_bTagsChanged(false),
+    m_bLoaded(false),
+    m_bUpdatePending(false),
+    m_iEpgID(iEpgID),
+    m_strName(strName),
+    m_strScraperName(strScraperName)
+{
+  CPVRChannelPtr empty;
+  m_pvrChannel = empty;
+}
+
+CEpg::CEpg(CPVRChannelPtr channel, bool bLoadedFromDb /* = false */) :
+    m_bChanged(!bLoadedFromDb),
+    m_bTagsChanged(false),
+    m_bLoaded(false),
+    m_bUpdatePending(false),
+    m_iEpgID(channel->EpgID()),
+    m_strName(channel->ChannelName()),
+    m_strScraperName(channel->EPGScraper()),
+    m_pvrChannel(channel)
+{
+}
+
+CEpg::CEpg(void) :
+    m_bChanged(false),
+    m_bTagsChanged(false),
+    m_bLoaded(false),
+    m_bUpdatePending(false),
+    m_iEpgID(0)
+{
+  CPVRChannelPtr empty;
+  m_pvrChannel = empty;
+}
+
+CEpg::~CEpg(void)
+{
+  Clear();
+}
+
+CEpg &CEpg::operator =(const CEpg &right)
+{
+  m_bChanged          = right.m_bChanged;
+  m_bTagsChanged      = right.m_bTagsChanged;
+  m_bLoaded           = right.m_bLoaded;
+  m_bUpdatePending    = right.m_bUpdatePending;
+  m_iEpgID            = right.m_iEpgID;
+  m_strName           = right.m_strName;
+  m_strScraperName    = right.m_strScraperName;
+  m_nowActiveStart    = right.m_nowActiveStart;
+  m_lastScanTime      = right.m_lastScanTime;
+  m_pvrChannel        = right.m_pvrChannel;
+
+  for (map<CDateTime, CEpgInfoTagPtr>::const_iterator it = right.m_tags.begin(); it != right.m_tags.end(); it++)
+    m_tags.insert(make_pair(it->first, new CEpgInfoTag(*it->second)));
+
+  return *this;
+}
+
+/** @name Public methods */
+//@{
+
+void CEpg::SetName(const CStdString &strName)
+{
+  CSingleLock lock(m_critSection);
+
+  if (!m_strName.Equals(strName))
+  {
+    m_bChanged = true;
+    m_strName = strName;
+  }
+}
+
+void CEpg::SetScraperName(const CStdString &strScraperName)
+{
+  CSingleLock lock(m_critSection);
+
+  if (!m_strScraperName.Equals(strScraperName))
+  {
+    m_bChanged = true;
+    m_strScraperName = strScraperName;
+  }
+}
+
+void CEpg::SetUpdatePending(bool bUpdatePending /* = true */)
+{
+  {
+    CSingleLock lock(m_critSection);
+    m_bUpdatePending = bUpdatePending;
+  }
+
+  if (bUpdatePending)
+    g_EpgContainer.SetHasPendingUpdates(true);
+}
+
+void CEpg::ForceUpdate(void)
+{
+  SetUpdatePending();
+}
+
+bool CEpg::HasValidEntries(void) const
+{
+  CSingleLock lock(m_critSection);
+
+  return (m_iEpgID > 0 && /* valid EPG ID */
+      m_tags.size() > 0 && /* contains at least 1 tag */
+      m_tags.rbegin()->second->EndAsUTC() >= CDateTime::GetCurrentDateTime().GetAsUTCDateTime()); /* the last end time hasn't passed yet */
+}
+
+void CEpg::Clear(void)
+{
+  CSingleLock lock(m_critSection);
+  m_tags.clear();
+}
+
+void CEpg::Cleanup(void)
+{
+  CDateTime cleanupTime = CDateTime::GetCurrentDateTime().GetAsUTCDateTime() -
+      CDateTimeSpan(0, g_advancedSettings.m_iEpgLingerTime / 60, g_advancedSettings.m_iEpgLingerTime % 60, 0);
+  Cleanup(cleanupTime);
+}
+
+void CEpg::Cleanup(const CDateTime &Time)
+{
+  CSingleLock lock(m_critSection);
+  for (map<CDateTime, CEpgInfoTagPtr>::iterator it = m_tags.begin(); it != m_tags.end(); it != m_tags.end() ? it++ : it)
+  {
+    if (it->second->EndAsUTC() < Time)
+    {
+      if (m_nowActiveStart == it->first)
+        m_nowActiveStart.SetValid(false);
+
+      it->second->ClearTimer();
+      m_tags.erase(it++);
+    }
+  }
+}
+
+bool CEpg::InfoTagNow(CEpgInfoTag &tag, bool bUpdateIfNeeded /* = true */)
+{
+  CSingleLock lock(m_critSection);
+  if (m_nowActiveStart.IsValid())
+  {
+    map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.find(m_nowActiveStart);
+    if (it != m_tags.end() && it->second->IsActive())
+    {
+      tag = *it->second;
+      return true;
+    }
+  }
+
+  if (bUpdateIfNeeded)
+  {
+    CDateTime lastActiveTag;
+
+    /* one of the first items will always match if the list is sorted */
+    for (map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+    {
+      if (it->second->IsActive())
+      {
+        m_nowActiveStart = it->first;
+        tag = *it->second;
+        return true;
+      }
+      else if (it->second->WasActive())
+        lastActiveTag = it->first;
+    }
+
+    /* there might be a gap between the last and next event. just return the last if found */
+    map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.find(lastActiveTag);
+    if (it != m_tags.end())
+    {
+      tag = *it->second;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CEpg::InfoTagNext(CEpgInfoTag &tag)
+{
+  CEpgInfoTag nowTag;
+  if (InfoTagNow(nowTag))
+  {
+    CSingleLock lock(m_critSection);
+    map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.find(nowTag.StartAsUTC());
+    if (it != m_tags.end() && ++it != m_tags.end())
+    {
+      tag = *it->second;
+      return true;
+    }
+  }
+  else if (Size() > 0)
+  {
+    /* return the first event that is in the future */
+    for (map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+    {
+      if (it->second->InTheFuture())
+      {
+        tag = *it->second;
+        return true;
+      }
+    }
+  }
+
+  return false;
+}
+
+bool CEpg::CheckPlayingEvent(void)
+{
+  bool bReturn(false);
+  CEpgInfoTag previousTag, newTag;
+  bool bGotPreviousTag = InfoTagNow(previousTag, false);
+  bool bGotCurrentTag = InfoTagNow(newTag);
+
+  if (!bGotPreviousTag || (bGotCurrentTag && previousTag != newTag))
+  {
+    NotifyObservers(ObservableMessageEpgActiveItem);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+CEpgInfoTagPtr CEpg::GetTag(const CDateTime &StartTime) const
+{
+  CSingleLock lock(m_critSection);
+  map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.find(StartTime);
+  if (it != m_tags.end())
+  {
+    return it->second;
+  }
+
+  CEpgInfoTagPtr empty;
+  return empty;
+}
+
+CEpgInfoTagPtr CEpg::GetTagBetween(const CDateTime &beginTime, const CDateTime &endTime) const
+{
+  CSingleLock lock(m_critSection);
+  for (map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+  {
+    if (it->second->StartAsUTC() >= beginTime && it->second->EndAsUTC() <= endTime)
+      return it->second;
+  }
+
+  CEpgInfoTagPtr retVal;
+  return retVal;
+}
+
+CEpgInfoTagPtr CEpg::GetTagAround(const CDateTime &time) const
+{
+  CSingleLock lock(m_critSection);
+  for (map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+  {
+    if ((it->second->StartAsUTC() <= time) && (it->second->EndAsUTC() >= time))
+      return it->second;
+  }
+
+  CEpgInfoTagPtr retVal;
+  return retVal;
+}
+
+void CEpg::AddEntry(const CEpgInfoTag &tag)
+{
+  CEpgInfoTagPtr newTag;
+  CSingleLock lock(m_critSection);
+  map<CDateTime, CEpgInfoTagPtr>::iterator itr = m_tags.find(tag.StartAsUTC());
+  if (itr != m_tags.end())
+    newTag = itr->second;
+  else
+  {
+    newTag = CEpgInfoTagPtr(new CEpgInfoTag(this, m_pvrChannel, m_strName, m_pvrChannel ? m_pvrChannel->IconPath() : StringUtils::EmptyString));
+    m_tags.insert(make_pair(tag.StartAsUTC(), newTag));
+  }
+
+  if (newTag)
+  {
+    newTag->Update(tag);
+    newTag->SetPVRChannel(m_pvrChannel);
+    newTag->m_epg          = this;
+    newTag->m_bChanged     = false;
+  }
+}
+
+bool CEpg::UpdateEntry(const CEpgInfoTag &tag, bool bUpdateDatabase /* = false */, bool bSort /* = true */)
+{
+  CEpgInfoTagPtr infoTag;
+  bool bReturn(false);
+  {
+    CSingleLock lock(m_critSection);
+    map<CDateTime, CEpgInfoTagPtr>::iterator it = m_tags.find(tag.StartAsUTC());
+    bool bNewTag(false);
+    if (it != m_tags.end())
+    {
+      infoTag = it->second;
+    }
+    else
+    {
+      /* create a new tag if no tag with this ID exists */
+      infoTag = CEpgInfoTagPtr(new CEpgInfoTag(this, m_pvrChannel, m_strName, m_pvrChannel ? m_pvrChannel->IconPath() : StringUtils::EmptyString));
+      infoTag->SetUniqueBroadcastID(tag.UniqueBroadcastID());
+      m_tags.insert(make_pair(tag.StartAsUTC(), infoTag));
+      bNewTag = true;
+    }
+
+    infoTag->Update(tag, bNewTag);
+    infoTag->m_epg          = this;
+    infoTag->m_pvrChannel   = m_pvrChannel;
+  }
+
+  if (bUpdateDatabase)
+    bReturn = infoTag->Persist();
+  else
+    bReturn = true;
+
+  return bReturn;
+}
+
+bool CEpg::Load(void)
+{
+  bool bReturn(false);
+  CEpgDatabase *database = g_EpgContainer.GetDatabase();
+
+  if (!database || !database->IsOpen())
+  {
+    CLog::Log(LOGERROR, "Epg - %s - could not open the database", __FUNCTION__);
+    return bReturn;
+  }
+
+  CSingleLock lock(m_critSection);
+  int iEntriesLoaded = database->Get(*this);
+  if (iEntriesLoaded <= 0)
+  {
+    CLog::Log(LOGNOTICE, "Epg - %s - no database entries found for table '%s'.",
+        __FUNCTION__, m_strName.c_str());
+  }
+  else
+  {
+    m_lastScanTime = GetLastScanTime();
+    CLog::Log(LOGDEBUG, "Epg - %s - %d entries loaded for table '%s'.",
+        __FUNCTION__, (int) m_tags.size(), m_strName.c_str());
+    bReturn = true;
+  }
+
+  m_bLoaded = true;
+
+  return bReturn;
+}
+
+bool CEpg::UpdateEntries(const CEpg &epg, bool bStoreInDb /* = true */)
+{
+  bool bReturn(false);
+  CEpgDatabase *database = g_EpgContainer.GetDatabase();
+
+  if (epg.m_tags.size() > 0)
+  {
+    if (bStoreInDb)
+    {
+      if (!database || !database->IsOpen())
+      {
+        CLog::Log(LOGERROR, "%s - could not open the database", __FUNCTION__);
+        return bReturn;
+      }
+      database->BeginTransaction();
+    }
+
+    {
+      CSingleLock lock(m_critSection);
+      CLog::Log(LOGDEBUG, "%s - %u entries in memory before merging", __FUNCTION__, m_tags.size());
+      /* copy over tags */
+      for (map<CDateTime, CEpgInfoTagPtr>::const_iterator it = epg.m_tags.begin(); it != epg.m_tags.end(); it++)
+        UpdateEntry(*it->second, bStoreInDb, false);
+
+      CLog::Log(LOGDEBUG, "%s - %u entries in memory after merging and before fixing", __FUNCTION__, m_tags.size());
+      FixOverlappingEvents(bStoreInDb);
+      CLog::Log(LOGDEBUG, "%s - %u entries in memory after fixing", __FUNCTION__, m_tags.size());
+      /* update the last scan time of this table */
+      m_lastScanTime = CDateTime::GetCurrentDateTime().GetAsUTCDateTime();
+
+      SetChanged();
+    }
+    /* persist changes */
+    if (bStoreInDb)
+    {
+      bReturn = database->CommitTransaction();
+      if (bReturn)
+        Persist(true);
+    }
+    else
+      bReturn = true;
+  }
+  else
+  {
+    if (bStoreInDb)
+      bReturn = Persist(true);
+    else
+      bReturn = true;
+  }
+
+  NotifyObservers(ObservableMessageEpg);
+
+  return bReturn;
+}
+
+CDateTime CEpg::GetLastScanTime(void)
+{
+  CDateTime lastScanTime;
+  {
+    CSingleLock lock(m_critSection);
+
+    if (!m_lastScanTime.IsValid())
+    {
+      if (!g_guiSettings.GetBool("epg.ignoredbforclient"))
+      {
+        CEpgDatabase *database = g_EpgContainer.GetDatabase();
+        CDateTime dtReturn; dtReturn.SetValid(false);
+
+        if (database && database->IsOpen())
+          database->GetLastEpgScanTime(m_iEpgID, &m_lastScanTime);
+      }
+
+      if (!m_lastScanTime.IsValid())
+      {
+        m_lastScanTime.SetDateTime(0, 0, 0, 0, 0, 0);
+        m_lastScanTime.SetValid(true);
+      }
+    }
+    lastScanTime = m_lastScanTime;
+  }
+
+  return m_lastScanTime;
+}
+
+bool CEpg::Update(const time_t start, const time_t end, int iUpdateTime, bool bForceUpdate /* = false */)
+{
+  bool bGrabSuccess(true);
+  bool bUpdate(false);
+
+  /* load the entries from the db first */
+  if (!m_bLoaded && !g_EpgContainer.IgnoreDB())
+    Load();
+
+  /* clean up if needed */
+  if (m_bLoaded)
+    Cleanup();
+
+  /* get the last update time from the database */
+  CDateTime lastScanTime = GetLastScanTime();
+
+  if (!bForceUpdate)
+  {
+    /* check if we have to update */
+    time_t iNow = 0;
+    time_t iLastUpdate = 0;
+    CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsTime(iNow);
+    lastScanTime.GetAsTime(iLastUpdate);
+    bUpdate = (iNow > iLastUpdate + iUpdateTime);
+  }
+  else
+    bUpdate = true;
+
+  if (bUpdate)
+    bGrabSuccess = LoadFromClients(start, end);
+
+  if (bGrabSuccess)
+  {
+    CPVRChannelPtr channel;
+    if (g_PVRManager.GetCurrentChannel(channel) &&
+        channel->EpgID() == m_iEpgID)
+      g_PVRManager.ResetPlayingTag();
+    m_bLoaded = true;
+  }
+  else
+    CLog::Log(LOGERROR, "EPG - %s - failed to update table '%s'", __FUNCTION__, Name().c_str());
+
+  CSingleLock lock(m_critSection);
+  m_bUpdatePending = false;
+
+  return bGrabSuccess;
+}
+
+int CEpg::Get(CFileItemList &results) const
+{
+  int iInitialSize = results.Size();
+
+  CSingleLock lock(m_critSection);
+
+  for (map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+    results.Add(CFileItemPtr(new CFileItem(*it->second)));
+
+  return results.Size() - iInitialSize;
+}
+
+int CEpg::Get(CFileItemList &results, const EpgSearchFilter &filter) const
+{
+  int iInitialSize = results.Size();
+
+  if (!HasValidEntries())
+    return -1;
+
+  CSingleLock lock(m_critSection);
+
+  for (map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+  {
+    if (filter.FilterEntry(*it->second))
+      results.Add(CFileItemPtr(new CFileItem(*it->second)));
+  }
+
+  return results.Size() - iInitialSize;
+}
+
+bool CEpg::Persist(bool bUpdateLastScanTime /* = false */)
+{
+  if (g_guiSettings.GetBool("epg.ignoredbforclient"))
+    return true;
+
+  CEpgDatabase *database = g_EpgContainer.GetDatabase();
+
+  if (!database || !database->IsOpen())
+  {
+    CLog::Log(LOGERROR, "%s - could not open the database", __FUNCTION__);
+    return false;
+  }
+
+  CEpg epgCopy;
+  {
+    CSingleLock lock(m_critSection);
+    epgCopy = *this;
+    m_bChanged     = false;
+    m_bTagsChanged = false;
+  }
+
+  database->BeginTransaction();
+
+  if (epgCopy.m_iEpgID <= 0 || epgCopy.m_bChanged)
+  {
+    int iId = database->Persist(epgCopy);
+    if (iId > 0)
+    {
+      epgCopy.m_iEpgID   = iId;
+      epgCopy.m_bChanged = false;
+      if (m_iEpgID != epgCopy.m_iEpgID)
+      {
+        CSingleLock lock(m_critSection);
+        m_iEpgID = epgCopy.m_iEpgID;
+      }
+    }
+  }
+
+  bool bReturn(true);
+
+  if (bUpdateLastScanTime)
+    bReturn = database->PersistLastEpgScanTime(epgCopy.m_iEpgID);
+
+  database->CommitTransaction();
+
+  return bReturn;
+}
+
+CDateTime CEpg::GetFirstDate(void) const
+{
+  CDateTime first;
+
+  CSingleLock lock(m_critSection);
+  if (m_tags.size() > 0)
+    first = m_tags.begin()->second->StartAsUTC();
+
+  return first;
+}
+
+CDateTime CEpg::GetLastDate(void) const
+{
+  CDateTime last;
+
+  CSingleLock lock(m_critSection);
+  if (m_tags.size() > 0)
+    last = m_tags.rbegin()->second->StartAsUTC();
+
+  return last;
+}
+
+//@}
+
+/** @name Protected methods */
+//@{
+
+bool CEpg::UpdateMetadata(const CEpg &epg, bool bUpdateDb /* = false */)
+{
+  bool bReturn = true;
+  CSingleLock lock(m_critSection);
+
+  m_strName        = epg.m_strName;
+  m_strScraperName = epg.m_strScraperName;
+  if (epg.m_pvrChannel)
+    SetChannel(epg.m_pvrChannel);
+
+  if (bUpdateDb)
+    bReturn = Persist();
+
+  return bReturn;
+}
+
+//@}
+
+/** @name Private methods */
+//@{
+
+bool CEpg::FixOverlappingEvents(bool bUpdateDb /* = false */)
+{
+  bool bReturn(true);
+  CEpgInfoTagPtr previousTag, currentTag;
+  CEpgDatabase *database(NULL);
+  if (bUpdateDb)
+  {
+    database = g_EpgContainer.GetDatabase();
+    if (!database || !database->IsOpen())
+    {
+      CLog::Log(LOGERROR, "%s - could not open the database", __FUNCTION__);
+      return false;
+    }
+  }
+
+  for (map<CDateTime, CEpgInfoTagPtr>::iterator it = m_tags.begin(); it != m_tags.end(); it != m_tags.end() ? it++ : it)
+  {
+    if (!previousTag)
+    {
+      previousTag = it->second;
+      continue;
+    }
+    currentTag = it->second;
+
+    if (previousTag->EndAsUTC() >= currentTag->EndAsUTC())
+    {
+      // delete the current tag. it's completely overlapped
+      if (bUpdateDb)
+        bReturn &= database->Delete(*currentTag);
+
+      if (m_nowActiveStart == it->first)
+        m_nowActiveStart.SetValid(false);
+
+      it->second->ClearTimer();
+      m_tags.erase(it++);
+    }
+    else if (previousTag->EndAsUTC() > currentTag->StartAsUTC())
+    {
+      currentTag->SetStartFromUTC(previousTag->EndAsUTC());
+      if (bUpdateDb)
+        bReturn &= currentTag->Persist();
+
+      previousTag = it->second;
+    }
+    else if (previousTag->EndAsUTC() < currentTag->StartAsUTC())
+    {
+      time_t start, end, middle;
+      previousTag->EndAsUTC().GetAsTime(start);
+      currentTag->StartAsUTC().GetAsTime(end);
+      middle = start + ((end - start) / 2);
+      CDateTime newTime(middle);
+
+      currentTag->SetStartFromUTC(newTime);
+      previousTag->SetEndFromUTC(newTime);
+
+      if (m_nowActiveStart == it->first)
+        m_nowActiveStart = currentTag->StartAsUTC();
+
+      if (bUpdateDb)
+      {
+        bReturn &= currentTag->Persist();
+        bReturn &= previousTag->Persist();
+      }
+
+      previousTag = it->second;
+    }
+    else
+    {
+      previousTag = it->second;
+    }
+  }
+
+  return bReturn;
+}
+
+bool CEpg::UpdateFromScraper(time_t start, time_t end)
+{
+  bool bGrabSuccess = false;
+  if (ScraperName() == "client")
+  {
+    CPVRChannelPtr channel = Channel();
+    if (!channel)
+      CLog::Log(LOGINFO, "%s - channel not found, can't update", __FUNCTION__);
+    else if (!channel->EPGEnabled())
+      CLog::Log(LOGINFO, "%s - EPG updating disabled in the channel configuration", __FUNCTION__);
+    else if (!g_PVRClients->SupportsEPG(channel->ClientID()))
+      CLog::Log(LOGINFO, "%s - the backend for channel '%s' on client '%i' does not support EPGs", __FUNCTION__, channel->ChannelName().c_str(), channel->ClientID());
+    else
+    {
+      CLog::Log(LOGINFO, "%s - updating EPG for channel '%s' from client '%i'", __FUNCTION__, channel->ChannelName().c_str(), channel->ClientID());
+      bGrabSuccess = (g_PVRClients->GetEPGForChannel(*channel, this, start, end) == PVR_ERROR_NO_ERROR);
+    }
+  }
+  else if (m_strScraperName.IsEmpty()) /* no grabber defined */
+    CLog::Log(LOGERROR, "EPG - %s - no EPG scraper defined for table '%s'", __FUNCTION__, m_strName.c_str());
+  else
+  {
+    CLog::Log(LOGINFO, "EPG - %s - updating EPG table '%s' with scraper '%s'", __FUNCTION__, m_strName.c_str(), m_strScraperName.c_str());
+    CLog::Log(LOGERROR, "loading the EPG via scraper has not been implemented yet");
+    // TODO: Add Support for Web EPG Scrapers here
+  }
+
+  return bGrabSuccess;
+}
+
+bool CEpg::PersistTags(void) const
+{
+  bool bReturn = false;
+  CEpgDatabase *database = g_EpgContainer.GetDatabase();
+
+  if (!database || !database->IsOpen())
+  {
+    CLog::Log(LOGERROR, "EPG - %s - could not load the database", __FUNCTION__);
+    return bReturn;
+  }
+
+  CDateTime first = GetFirstDate();
+  CDateTime last = GetLastDate();
+
+  time_t iStart(0), iEnd(0);
+  if (first.IsValid())
+    first.GetAsTime(iStart);
+  if (last.IsValid())
+    last.GetAsTime(iEnd);
+  database->Delete(*this, iStart, iEnd);
+
+  if (m_tags.size() > 0)
+  {
+    for (map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+    {
+      if (!it->second->Persist())
+      {
+        CLog::Log(LOGERROR, "failed to persist epg tag %d", it->second->UniqueBroadcastID());
+        bReturn = false;
+      }
+    }
+  }
+  else
+  {
+    /* Return true if we have no tags, so that no error is logged */
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+//@}
+
+const CStdString &CEpg::ConvertGenreIdToString(int iID, int iSubID)
+{
+  unsigned int iLabelId = 19499;
+  switch (iID)
+  {
+    case EPG_EVENT_CONTENTMASK_MOVIEDRAMA:
+      iLabelId = (iSubID <= 8) ? 19500 + iSubID : 19500;
+      break;
+    case EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS:
+      iLabelId = (iSubID <= 4) ? 19516 + iSubID : 19516;
+      break;
+    case EPG_EVENT_CONTENTMASK_SHOW:
+      iLabelId = (iSubID <= 3) ? 19532 + iSubID : 19532;
+      break;
+    case EPG_EVENT_CONTENTMASK_SPORTS:
+      iLabelId = (iSubID <= 11) ? 19548 + iSubID : 19548;
+      break;
+    case EPG_EVENT_CONTENTMASK_CHILDRENYOUTH:
+      iLabelId = (iSubID <= 5) ? 19564 + iSubID : 19564;
+      break;
+    case EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE:
+      iLabelId = (iSubID <= 6) ? 19580 + iSubID : 19580;
+      break;
+    case EPG_EVENT_CONTENTMASK_ARTSCULTURE:
+      iLabelId = (iSubID <= 11) ? 19596 + iSubID : 19596;
+      break;
+    case EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS:
+      iLabelId = (iSubID <= 3) ? 19612 + iSubID : 19612;
+      break;
+    case EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE:
+      iLabelId = (iSubID <= 7) ? 19628 + iSubID : 19628;
+      break;
+    case EPG_EVENT_CONTENTMASK_LEISUREHOBBIES:
+      iLabelId = (iSubID <= 7) ? 19644 + iSubID : 19644;
+      break;
+    case EPG_EVENT_CONTENTMASK_SPECIAL:
+      iLabelId = (iSubID <= 3) ? 19660 + iSubID : 19660;
+      break;
+    case EPG_EVENT_CONTENTMASK_USERDEFINED:
+      iLabelId = (iSubID <= 3) ? 19676 + iSubID : 19676;
+      break;
+    default:
+      break;
+  }
+
+  return g_localizeStrings.Get(iLabelId);
+}
+
+bool CEpg::UpdateEntry(const EPG_TAG *data, bool bUpdateDatabase /* = false */)
+{
+  if (!data)
+    return false;
+
+  CEpgInfoTag tag(*data);
+  return UpdateEntry(tag, bUpdateDatabase);
+}
+
+bool CEpg::IsRadio(void) const
+{
+  CPVRChannelPtr channel = Channel();
+  return channel ? channel->IsRadio() : false;
+}
+
+bool CEpg::IsRemovableTag(const CEpgInfoTag &tag) const
+{
+  return !tag.HasTimer();
+}
+
+bool CEpg::LoadFromClients(time_t start, time_t end)
+{
+  bool bReturn(false);
+  CPVRChannelPtr channel = Channel();
+  if (channel)
+  {
+    CEpg tmpEpg(channel);
+    if (tmpEpg.UpdateFromScraper(start, end))
+      bReturn = UpdateEntries(tmpEpg, !g_guiSettings.GetBool("epg.ignoredbforclient"));
+  }
+  else
+  {
+    CEpg tmpEpg(m_iEpgID, m_strName, m_strScraperName);
+    if (tmpEpg.UpdateFromScraper(start, end))
+      bReturn = UpdateEntries(tmpEpg, !g_guiSettings.GetBool("epg.ignoredbforclient"));
+  }
+
+  return bReturn;
+}
+
+CEpgInfoTagPtr CEpg::GetNextEvent(const CEpgInfoTag& tag) const
+{
+  CSingleLock lock(m_critSection);
+  map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.find(tag.StartAsUTC());
+  if (it != m_tags.end() && ++it != m_tags.end())
+    return it->second;
+
+  CEpgInfoTagPtr retVal;
+  return retVal;
+}
+
+CEpgInfoTagPtr CEpg::GetPreviousEvent(const CEpgInfoTag& tag) const
+{
+  CSingleLock lock(m_critSection);
+  map<CDateTime, CEpgInfoTagPtr>::const_iterator it = m_tags.find(tag.StartAsUTC());
+  if (it != m_tags.end() && it != m_tags.begin())
+  {
+    it--;
+    return it->second;
+  }
+
+  CEpgInfoTagPtr retVal;
+  return retVal;
+}
+
+CPVRChannelPtr CEpg::Channel(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_pvrChannel;
+}
+
+int CEpg::ChannelID(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_pvrChannel ? m_pvrChannel->ChannelID() : -1;
+}
+
+int CEpg::ChannelNumber(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_pvrChannel ? m_pvrChannel->ChannelNumber() : -1;
+}
+
+void CEpg::SetChannel(PVR::CPVRChannelPtr channel)
+{
+  CSingleLock lock(m_critSection);
+  if (m_pvrChannel != channel)
+  {
+    if (channel)
+      SetName(channel->ChannelName());
+    m_pvrChannel = channel;
+    for (map<CDateTime, CEpgInfoTagPtr>::iterator it = m_tags.begin(); it != m_tags.end(); it++)
+      it->second->SetPVRChannel(m_pvrChannel);
+  }
+}
+
+bool CEpg::HasPVRChannel(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_pvrChannel;
+}
+
+bool CEpg::UpdatePending(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bUpdatePending;
+}
+
+size_t CEpg::Size(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_tags.size();
+}
diff --git a/xbmc/epg/EpgContainer.cpp b/xbmc/epg/EpgContainer.cpp
new file mode 100644
index 0000000..ecf3239
--- /dev/null
+++ b/xbmc/epg/EpgContainer.cpp
@@ -0,0 +1,657 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Application.h"
+#include "threads/SingleLock.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
+#include "dialogs/GUIDialogExtendedProgressBar.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "utils/log.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/timers/PVRTimers.h"
+
+#include "EpgContainer.h"
+#include "Epg.h"
+#include "EpgInfoTag.h"
+#include "EpgSearchFilter.h"
+
+using namespace std;
+using namespace EPG;
+using namespace PVR;
+
+typedef std::map<int, CEpg*>::iterator EPGITR;
+
+CEpgContainer::CEpgContainer(void) :
+    CThread("EPG updater")
+{
+  m_progressHandle = NULL;
+  m_bStop = true;
+  m_bIsUpdating = false;
+  m_bIsInitialising = true;
+  m_iNextEpgId = 0;
+  m_bPreventUpdates = false;
+  m_updateEvent.Reset();
+  m_bLoaded = false;
+  m_bHasPendingUpdates = false;
+}
+
+CEpgContainer::~CEpgContainer(void)
+{
+  Unload();
+}
+
+CEpgContainer &CEpgContainer::Get(void)
+{
+  static CEpgContainer epgInstance;
+  return epgInstance;
+}
+
+void CEpgContainer::Unload(void)
+{
+  Stop();
+  Clear(false);
+}
+
+unsigned int CEpgContainer::NextEpgId(void)
+{
+  CSingleLock lock(m_critSection);
+  return ++m_iNextEpgId;
+}
+
+void CEpgContainer::Clear(bool bClearDb /* = false */)
+{
+  /* make sure the update thread is stopped */
+  bool bThreadRunning = !m_bStop;
+  if (bThreadRunning && !Stop())
+  {
+    CLog::Log(LOGERROR, "%s - cannot stop the update thread", __FUNCTION__);
+    return;
+  }
+
+  {
+    CSingleLock lock(m_critSection);
+    /* clear all epg tables and remove pointers to epg tables on channels */
+    for (map<unsigned int, CEpg *>::iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+    {
+      it->second->UnregisterObserver(this);
+      delete it->second;
+    }
+    m_epgs.clear();
+    m_iNextEpgUpdate  = 0;
+    m_bIsInitialising = true;
+  }
+
+  /* clear the database entries */
+  if (bClearDb && !m_bIgnoreDbForClient)
+  {
+    if (!m_database.IsOpen())
+      m_database.Open();
+
+    if (m_database.IsOpen())
+      m_database.DeleteEpg();
+  }
+
+  SetChanged();
+  NotifyObservers(ObservableMessageEpgContainer, true);
+
+  if (bThreadRunning)
+    Start();
+}
+
+void CEpgContainer::Start(void)
+{
+  CSingleLock lock(m_critSection);
+
+  if (!m_database.IsOpen())
+    m_database.Open();
+
+  m_bIsInitialising = true;
+  m_bStop = false;
+  g_guiSettings.RegisterObserver(this);
+  LoadSettings();
+
+  m_iNextEpgUpdate  = 0;
+  m_iNextEpgActiveTagCheck = 0;
+
+  Create();
+  SetPriority(-1);
+  CLog::Log(LOGNOTICE, "%s - EPG thread started", __FUNCTION__);
+}
+
+bool CEpgContainer::Stop(void)
+{
+  StopThread();
+
+  if (m_database.IsOpen())
+    m_database.Close();
+
+  return true;
+}
+
+void CEpgContainer::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  /* settings were updated */
+  if (msg == ObservableMessageGuiSettings)
+    LoadSettings();
+  else
+  {
+    SetChanged();
+    NotifyObservers(msg);
+  }
+}
+
+void CEpgContainer::LoadFromDB(void)
+{
+  bool bLoaded(true);
+  unsigned int iCounter(0);
+  if (!m_bIgnoreDbForClient && m_database.IsOpen())
+  {
+    ShowProgressDialog(false);
+
+    m_database.DeleteOldEpgEntries();
+    m_database.Get(*this);
+
+    for (map<unsigned int, CEpg *>::iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+    {
+      if (InterruptUpdate())
+      {
+        bLoaded = false;
+        break;
+      }
+      UpdateProgressDialog(++iCounter, m_epgs.size(), it->second->Name());
+      it->second->Load();
+    }
+
+    CloseProgressDialog();
+  }
+
+  CSingleLock lock(m_critSection);
+  m_bLoaded = bLoaded;
+}
+
+bool CEpgContainer::PersistTables(void)
+{
+  return m_database.Persist(*this);
+}
+
+bool CEpgContainer::PersistAll(void)
+{
+  bool bReturn(true);
+  CSingleLock lock(m_critSection);
+  for (map<unsigned int, CEpg *>::iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+  {
+    CEpg *epg = it->second;
+    lock.Leave();
+    if (epg)
+      bReturn &= epg->Persist(false);
+    lock.Enter();
+  }
+
+  return bReturn;
+}
+
+void CEpgContainer::Process(void)
+{
+  time_t iNow       = 0;
+
+  bool bUpdateEpg(true);
+  bool bHasPendingUpdates(false);
+
+  if (!m_bLoaded)
+  {
+    LoadFromDB();
+    CheckPlayingEvents();
+  }
+
+  while (!m_bStop && !g_application.m_bStop)
+  {
+    CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsTime(iNow);
+    {
+      CSingleLock lock(m_critSection);
+      bUpdateEpg = (iNow >= m_iNextEpgUpdate);
+    }
+
+    /* update the EPG */
+    if (!InterruptUpdate() && bUpdateEpg && UpdateEPG())
+      m_bIsInitialising = false;
+
+    /* clean up old entries */
+    if (!m_bStop && iNow >= m_iLastEpgCleanup)
+      RemoveOldEntries();
+
+    /* check for pending manual EPG updates */
+    if (!m_bStop)
+    {
+      {
+        CSingleLock lock(m_critSection);
+        bHasPendingUpdates = m_bHasPendingUpdates;
+      }
+
+      if (bHasPendingUpdates)
+        UpdateEPG(true);
+    }
+
+    /* check for updated active tag */
+    if (!m_bStop)
+      CheckPlayingEvents();
+
+    Sleep(1000);
+  }
+
+  g_guiSettings.UnregisterObserver(this);
+}
+
+CEpg *CEpgContainer::GetById(int iEpgId) const
+{
+  if (iEpgId < 0)
+    return 0;
+
+  CSingleLock lock(m_critSection);
+  map<unsigned int, CEpg *>::const_iterator it = m_epgs.find((unsigned int) iEpgId);
+  return it != m_epgs.end() ? it->second : NULL;
+}
+
+CEpg *CEpgContainer::GetByChannel(const CPVRChannel &channel) const
+{
+  CSingleLock lock(m_critSection);
+  for (map<unsigned int, CEpg *>::const_iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+    if (channel.ChannelID() == it->second->ChannelID())
+      return it->second;
+
+  return NULL;
+}
+
+void CEpgContainer::InsertFromDatabase(int iEpgID, const CStdString &strName, const CStdString &strScraperName)
+{
+  CEpg *epg = new CEpg(iEpgID, strName, strScraperName, true);
+  if (epg)
+  {
+    m_epgs.insert(make_pair(iEpgID, epg));
+    SetChanged();
+    epg->RegisterObserver(this);
+  }
+}
+
+CEpg *CEpgContainer::CreateChannelEpg(CPVRChannelPtr channel)
+{
+  if (!channel)
+    return NULL;
+
+  WaitForUpdateFinish(true);
+  CSingleLock lock(m_critSection);
+
+  CEpg *epg(NULL);
+  if (channel->EpgID() > 0)
+    epg = GetById(channel->EpgID());
+
+  if (!epg)
+  {
+    epg = CreateEpg(NextEpgId());
+    m_epgs.insert(make_pair((unsigned int)epg->EpgID(), epg));
+    SetChanged();
+    epg->RegisterObserver(this);
+  }
+
+  if (epg)
+    epg->SetChannel(channel);
+
+  m_bPreventUpdates = false;
+  CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsTime(m_iNextEpgUpdate);
+
+  NotifyObservers(ObservableMessageEpgContainer);
+
+  return epg;
+}
+
+bool CEpgContainer::LoadSettings(void)
+{
+  m_bIgnoreDbForClient = g_guiSettings.GetBool("epg.ignoredbforclient");
+  m_iUpdateTime        = g_guiSettings.GetInt ("epg.epgupdate") * 60;
+  m_iDisplayTime       = g_guiSettings.GetInt ("epg.daystodisplay") * 24 * 60 * 60;
+
+  return true;
+}
+
+bool CEpgContainer::RemoveOldEntries(void)
+{
+  CLog::Log(LOGINFO, "EpgContainer - %s - removing old EPG entries",
+      __FUNCTION__);
+
+  CDateTime now = CDateTime::GetUTCDateTime() -
+      CDateTimeSpan(0, g_advancedSettings.m_iEpgLingerTime / 60, g_advancedSettings.m_iEpgLingerTime % 60, 0);
+
+  /* call Cleanup() on all known EPG tables */
+  for (map<unsigned int, CEpg *>::iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+    it->second->Cleanup(now);
+
+  /* remove the old entries from the database */
+  if (!m_bIgnoreDbForClient && m_database.IsOpen())
+    m_database.DeleteOldEpgEntries();
+
+  CSingleLock lock(m_critSection);
+  CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsTime(m_iLastEpgCleanup);
+  m_iLastEpgCleanup += g_advancedSettings.m_iEpgCleanupInterval;
+
+  return true;
+}
+
+CEpg *CEpgContainer::CreateEpg(int iEpgId)
+{
+  if (g_PVRManager.IsStarted())
+  {
+    CPVRChannelPtr channel = g_PVRChannelGroups->GetChannelByEpgId(iEpgId);
+    if (channel)
+    {
+      CEpg *epg = new CEpg(channel, true);
+      channel->Persist();
+      return epg;
+    }
+  }
+
+  return new CEpg(iEpgId);
+}
+
+bool CEpgContainer::DeleteEpg(const CEpg &epg, bool bDeleteFromDatabase /* = false */)
+{
+  if (epg.EpgID() < 0)
+    return false;
+
+  CSingleLock lock(m_critSection);
+
+  map<unsigned int, CEpg *>::iterator it = m_epgs.find((unsigned int)epg.EpgID());
+  if (it == m_epgs.end())
+    return false;
+
+  if (bDeleteFromDatabase && !m_bIgnoreDbForClient && m_database.IsOpen())
+    m_database.Delete(*it->second);
+
+  it->second->UnregisterObserver(this);
+  delete it->second;
+  m_epgs.erase(it);
+
+  return true;
+}
+
+void CEpgContainer::CloseProgressDialog(void)
+{
+  if (m_progressHandle)
+  {
+    m_progressHandle->MarkFinished();
+    m_progressHandle = NULL;
+  }
+}
+
+void CEpgContainer::ShowProgressDialog(bool bUpdating /* = true */)
+{
+  if (!m_progressHandle)
+  {
+    CGUIDialogExtendedProgressBar *progressDialog = (CGUIDialogExtendedProgressBar *)g_windowManager.GetWindow(WINDOW_DIALOG_EXT_PROGRESS);
+    if (progressDialog)
+      m_progressHandle = progressDialog->GetHandle(bUpdating ? g_localizeStrings.Get(19004) : g_localizeStrings.Get(19250));
+  }
+}
+
+void CEpgContainer::UpdateProgressDialog(int iCurrent, int iMax, const CStdString &strText)
+{
+  if (!m_progressHandle)
+    ShowProgressDialog();
+
+  if (m_progressHandle)
+  {
+    m_progressHandle->SetProgress(iCurrent, iMax);
+    m_progressHandle->SetText(strText);
+  }
+}
+
+bool CEpgContainer::InterruptUpdate(void) const
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+  bReturn = g_application.m_bStop || m_bStop || m_bPreventUpdates;
+  lock.Leave();
+
+  return bReturn ||
+    (g_guiSettings.GetBool("epg.preventupdateswhileplayingtv") &&
+     g_PVRManager.IsStarted() &&
+     g_PVRManager.IsPlaying());
+}
+
+void CEpgContainer::WaitForUpdateFinish(bool bInterrupt /* = true */)
+{
+  {
+    CSingleLock lock(m_critSection);
+    if (bInterrupt)
+      m_bPreventUpdates = true;
+
+    if (!m_bIsUpdating)
+      return;
+
+    m_updateEvent.Reset();
+  }
+
+  m_updateEvent.Wait();
+}
+
+bool CEpgContainer::UpdateEPG(bool bOnlyPending /* = false */)
+{
+  bool bInterrupted(false);
+  unsigned int iUpdatedTables(0);
+  bool bShowProgress(false);
+
+  /* set start and end time */
+  time_t start;
+  time_t end;
+  CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsTime(start);
+  end = start + m_iDisplayTime;
+  start -= g_advancedSettings.m_iEpgLingerTime * 60;
+  bShowProgress = g_advancedSettings.m_bEpgDisplayUpdatePopup && (m_bIsInitialising || g_advancedSettings.m_bEpgDisplayIncrementalUpdatePopup);
+
+  {
+    CSingleLock lock(m_critSection);
+    if (m_bIsUpdating || InterruptUpdate())
+      return false;
+    m_bIsUpdating = true;
+  }
+
+  if (bShowProgress && !bOnlyPending)
+    ShowProgressDialog();
+
+  if (!m_bIgnoreDbForClient && !m_database.IsOpen())
+  {
+    CLog::Log(LOGERROR, "EpgContainer - %s - could not open the database", __FUNCTION__);
+
+    CSingleLock lock(m_critSection);
+    m_bIsUpdating = false;
+    m_updateEvent.Set();
+
+    if (bShowProgress && !bOnlyPending)
+      CloseProgressDialog();
+
+    return false;
+  }
+
+  /* load or update all EPG tables */
+  CEpg *epg;
+  unsigned int iCounter(0);
+  for (map<unsigned int, CEpg *>::iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+  {
+    if (InterruptUpdate())
+    {
+      bInterrupted = true;
+      break;
+    }
+
+    epg = it->second;
+    if (!epg)
+      continue;
+
+    if (bShowProgress && !bOnlyPending)
+          UpdateProgressDialog(++iCounter, m_epgs.size(), epg->Name());
+
+    if ((!bOnlyPending || epg->UpdatePending()) && epg->Update(start, end, m_iUpdateTime, bOnlyPending))
+      ++iUpdatedTables;
+  }
+
+  if (!bInterrupted)
+  {
+    if (bInterrupted)
+    {
+      /* the update has been interrupted. try again later */
+      time_t iNow;
+      CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsTime(iNow);
+      m_iNextEpgUpdate = iNow + g_advancedSettings.m_iEpgRetryInterruptedUpdateInterval;
+    }
+    else
+    {
+      CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsTime(m_iNextEpgUpdate);
+      m_iNextEpgUpdate += g_advancedSettings.m_iEpgUpdateCheckInterval;
+      m_bHasPendingUpdates = false;
+    }
+  }
+
+  if (bShowProgress && !bOnlyPending)
+    CloseProgressDialog();
+
+  /* notify observers */
+  if (iUpdatedTables > 0)
+  {
+    SetChanged();
+    NotifyObservers(ObservableMessageEpgContainer, true);
+  }
+
+  CSingleLock lock(m_critSection);
+  m_bIsUpdating = false;
+  m_updateEvent.Set();
+
+  return !bInterrupted;
+}
+
+int CEpgContainer::GetEPGAll(CFileItemList &results)
+{
+  int iInitialSize = results.Size();
+
+  CSingleLock lock(m_critSection);
+  for (map<unsigned int, CEpg *>::iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+    it->second->Get(results);
+
+  return results.Size() - iInitialSize;
+}
+
+const CDateTime CEpgContainer::GetFirstEPGDate(void)
+{
+  CDateTime returnValue;
+
+  CSingleLock lock(m_critSection);
+  for (map<unsigned int, CEpg *>::iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+  {
+    lock.Leave();
+    CDateTime entry = it->second->GetFirstDate();
+    if (entry.IsValid() && (!returnValue.IsValid() || entry < returnValue))
+      returnValue = entry;
+    lock.Enter();
+  }
+
+  return returnValue;
+}
+
+const CDateTime CEpgContainer::GetLastEPGDate(void)
+{
+  CDateTime returnValue;
+
+  CSingleLock lock(m_critSection);
+  for (map<unsigned int, CEpg *>::iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+  {
+    lock.Leave();
+    CDateTime entry = it->second->GetLastDate();
+    if (entry.IsValid() && (!returnValue.IsValid() || entry > returnValue))
+      returnValue = entry;
+    lock.Enter();
+  }
+
+  return returnValue;
+}
+
+int CEpgContainer::GetEPGSearch(CFileItemList &results, const EpgSearchFilter &filter)
+{
+  int iInitialSize = results.Size();
+
+  /* get filtered results from all tables */
+  {
+    CSingleLock lock(m_critSection);
+    for (map<unsigned int, CEpg *>::iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+      it->second->Get(results, filter);
+  }
+
+  /* remove duplicate entries */
+  if (filter.m_bPreventRepeats)
+    EpgSearchFilter::RemoveDuplicates(results);
+
+  return results.Size() - iInitialSize;
+}
+
+bool CEpgContainer::CheckPlayingEvents(void)
+{
+  bool bReturn(false);
+  time_t iNow;
+  CSingleLock lock(m_critSection);
+
+  CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsTime(iNow);
+  if (iNow >= m_iNextEpgActiveTagCheck)
+  {
+    bool bFoundChanges(false);
+    CSingleLock lock(m_critSection);
+
+    for (map<unsigned int, CEpg *>::iterator it = m_epgs.begin(); it != m_epgs.end(); it++)
+      bFoundChanges = it->second->CheckPlayingEvent() || bFoundChanges;
+    CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsTime(m_iNextEpgActiveTagCheck);
+    m_iNextEpgActiveTagCheck += g_advancedSettings.m_iEpgActiveTagCheckInterval;
+
+    if (bFoundChanges)
+    {
+      SetChanged();
+      NotifyObservers(ObservableMessageEpgActiveItem, true);
+    }
+
+    /* pvr tags always start on the full minute */
+    if (g_PVRManager.IsStarted())
+      m_iNextEpgActiveTagCheck -= m_iNextEpgActiveTagCheck % 60;
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CEpgContainer::IsInitialising(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bIsInitialising;
+}
+
+void CEpgContainer::SetHasPendingUpdates(bool bHasPendingUpdates /* = true */)
+{
+  CSingleLock lock(m_critSection);
+  m_bHasPendingUpdates = bHasPendingUpdates;
+}
diff --git a/xbmc/epg/EpgDatabase.cpp b/xbmc/epg/EpgDatabase.cpp
new file mode 100644
index 0000000..de81fac
--- /dev/null
+++ b/xbmc/epg/EpgDatabase.cpp
@@ -0,0 +1,437 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "dbwrappers/dataset.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/VideoSettings.h"
+#include "utils/log.h"
+#include "threads/SingleLock.h"
+#include "addons/include/xbmc_pvr_types.h"
+
+#include "EpgDatabase.h"
+#include "EpgContainer.h"
+
+using namespace std;
+using namespace dbiplus;
+using namespace EPG;
+
+bool CEpgDatabase::Open(void)
+{
+  CSingleLock lock(m_critSection);
+  return CDatabase::Open(g_advancedSettings.m_databaseEpg);
+}
+
+bool CEpgDatabase::CreateTables(void)
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  try
+  {
+    CDatabase::CreateTables();
+
+    BeginTransaction();
+
+    CLog::Log(LOGINFO, "EpgDB - %s - creating tables", __FUNCTION__);
+
+    CLog::Log(LOGDEBUG, "EpgDB - %s - creating table 'epg'", __FUNCTION__);
+    m_pDS->exec(
+        "CREATE TABLE epg ("
+          "idEpg           integer primary key, "
+          "sName           varchar(64),"
+          "sScraperName    varchar(32)"
+        ")"
+    );
+
+    CLog::Log(LOGDEBUG, "EpgDB - %s - creating table 'epgtags'", __FUNCTION__);
+    m_pDS->exec(
+        "CREATE TABLE epgtags ("
+          "idBroadcast     integer primary key, "
+          "iBroadcastUid   integer, "
+          "idEpg           integer, "
+          "sTitle          varchar(128), "
+          "sPlotOutline    text, "
+          "sPlot           text, "
+          "iStartTime      integer, "
+          "iEndTime        integer, "
+          "iGenreType      integer, "
+          "iGenreSubType   integer, "
+          "sGenre          varchar(128), "
+          "iFirstAired     integer, "
+          "iParentalRating integer, "
+          "iStarRating     integer, "
+          "bNotify         bool, "
+          "iSeriesId       integer, "
+          "iEpisodeId      integer, "
+          "iEpisodePart    integer, "
+          "sEpisodeName    varchar(128)"
+        ")"
+    );
+    m_pDS->exec("CREATE UNIQUE INDEX idx_epg_idEpg_iStartTime on epgtags(idEpg, iStartTime desc);");
+    m_pDS->exec("CREATE INDEX idx_epg_iEndTime on epgtags(iEndTime);");
+
+    CLog::Log(LOGDEBUG, "EpgDB - %s - creating table 'lastepgscan'", __FUNCTION__);
+    m_pDS->exec("CREATE TABLE lastepgscan ("
+          "idEpg integer primary key, "
+          "sLastScan varchar(20)"
+        ")"
+    );
+
+    CommitTransaction();
+
+    bReturn = true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "EpgDB - %s - unable to create EPG tables:%i",
+        __FUNCTION__, (int)GetLastError());
+    RollbackTransaction();
+    bReturn = false;
+  }
+
+  return bReturn;
+}
+
+bool CEpgDatabase::UpdateOldVersion(int iVersion)
+{
+  bool bReturn = true;
+
+  if (iVersion < 4)
+  {
+    CLog::Log(LOGERROR, "EpgDB - %s - updating from table versions < 4 not supported. please delete '%s'", __FUNCTION__, GetBaseDBName());
+    return false;
+  }
+
+  BeginTransaction();
+
+  try
+  {
+    if (iVersion < 5)
+      m_pDS->exec("ALTER TABLE epgtags ADD sGenre varchar(128);");
+    if (iVersion < 6)
+    {
+      m_pDS->exec("DROP INDEX idx_epg_iBroadcastUid;");
+      m_pDS->exec("DROP INDEX idx_epg_idEpg;");
+      m_pDS->exec("DROP INDEX idx_epg_iStartTime;");
+      m_pDS->exec("DROP INDEX idx_epg_iEndTime;");
+    }
+    if (iVersion < 7)
+    {
+      m_pDS->exec("CREATE INDEX idx_epg_iEndTime on epgtags(iEndTime);");
+    }
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "Error attempting to update the database version!");
+    bReturn = false;
+  }
+
+  if (bReturn)
+    CommitTransaction();
+  else
+    RollbackTransaction();
+
+  return bReturn;
+}
+
+bool CEpgDatabase::DeleteEpg(void)
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+  CLog::Log(LOGDEBUG, "EpgDB - %s - deleting all EPG data from the database", __FUNCTION__);
+
+  bReturn = DeleteValues("epg") || bReturn;
+  bReturn = DeleteValues("epgtags") || bReturn;
+  bReturn = DeleteValues("lastepgscan") || bReturn;
+
+  return bReturn;
+}
+
+bool CEpgDatabase::Delete(const CEpg &table, const time_t start /* = 0 */, const time_t end /* = 0 */)
+{
+  /* invalid channel */
+  if (table.EpgID() <= 0)
+  {
+    CLog::Log(LOGERROR, "EpgDB - %s - invalid channel id: %d",
+        __FUNCTION__, table.EpgID());
+    return false;
+  }
+
+  CStdString strWhereClause;
+  strWhereClause = FormatSQL("idEpg = %u", table.EpgID());
+
+  if (start != 0)
+    strWhereClause.append(FormatSQL(" AND iStartTime >= %u", start).c_str());
+
+  if (end != 0)
+    strWhereClause.append(FormatSQL(" AND iEndTime <= %u", end).c_str());
+
+  CSingleLock lock(m_critSection);
+  return DeleteValues("epgtags", strWhereClause);
+}
+
+bool CEpgDatabase::DeleteOldEpgEntries(void)
+{
+  time_t iCleanupTime;
+  CDateTime cleanupTime = CDateTime::GetCurrentDateTime().GetAsUTCDateTime() -
+      CDateTimeSpan(0, g_advancedSettings.m_iEpgLingerTime / 60, g_advancedSettings.m_iEpgLingerTime % 60, 0);
+  cleanupTime.GetAsTime(iCleanupTime);
+
+  CStdString strWhereClause = FormatSQL("iEndTime < %u", iCleanupTime);
+
+  CSingleLock lock(m_critSection);
+  return DeleteValues("epgtags", strWhereClause);
+}
+
+bool CEpgDatabase::Delete(const CEpgInfoTag &tag)
+{
+  /* tag without a database ID was not persisted */
+  if (tag.BroadcastId() <= 0)
+    return false;
+
+  CStdString strWhereClause = FormatSQL("idBroadcast = %u", tag.BroadcastId());
+
+  CSingleLock lock(m_critSection);
+  return DeleteValues("epgtags", strWhereClause);
+}
+
+int CEpgDatabase::Get(CEpgContainer &container)
+{
+  int iReturn(-1);
+  CSingleLock lock(m_critSection);
+
+  CStdString strQuery = FormatSQL("SELECT idEpg, sName, sScraperName FROM epg;");
+  if (ResultQuery(strQuery))
+  {
+    iReturn = 0;
+
+    try
+    {
+      while (!m_pDS->eof())
+      {
+        int iEpgID                = m_pDS->fv("idEpg").get_asInt();
+        CStdString strName        = m_pDS->fv("sName").get_asString().c_str();
+        CStdString strScraperName = m_pDS->fv("sScraperName").get_asString().c_str();
+
+        container.InsertFromDatabase(iEpgID, strName, strScraperName);
+        ++iReturn;
+        m_pDS->next();
+      }
+      m_pDS->close();
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR, "%s - couldn't load EPG data from the database", __FUNCTION__);
+    }
+  }
+
+  return iReturn;
+}
+
+int CEpgDatabase::Get(CEpg &epg)
+{
+  int iReturn(-1);
+  CSingleLock lock(m_critSection);
+
+  CStdString strQuery = FormatSQL("SELECT * FROM epgtags WHERE idEpg = %u;", epg.EpgID());
+  if (ResultQuery(strQuery))
+  {
+    iReturn = 0;
+    try
+    {
+      while (!m_pDS->eof())
+      {
+        CEpgInfoTag newTag;
+
+        time_t iStartTime, iEndTime, iFirstAired;
+        iStartTime = (time_t) m_pDS->fv("iStartTime").get_asInt();
+        CDateTime startTime(iStartTime);
+        newTag.m_startTime = startTime;
+
+        iEndTime = (time_t) m_pDS->fv("iEndTime").get_asInt();
+        CDateTime endTime(iEndTime);
+        newTag.m_endTime = endTime;
+
+        iFirstAired = (time_t) m_pDS->fv("iFirstAired").get_asInt();
+        CDateTime firstAired(iFirstAired);
+        newTag.m_firstAired = firstAired;
+
+        newTag.m_iUniqueBroadcastID = m_pDS->fv("iBroadcastUid").get_asInt();
+        newTag.m_iBroadcastId       = m_pDS->fv("idBroadcast").get_asInt();
+        newTag.m_strTitle           = m_pDS->fv("sTitle").get_asString().c_str();
+        newTag.m_strPlotOutline     = m_pDS->fv("sPlotOutline").get_asString().c_str();
+        newTag.m_strPlot            = m_pDS->fv("sPlot").get_asString().c_str();
+        newTag.m_iGenreType         = m_pDS->fv("iGenreType").get_asInt();
+        newTag.m_iGenreSubType      = m_pDS->fv("iGenreSubType").get_asInt();
+        newTag.m_genre              = StringUtils::Split(m_pDS->fv("sGenre").get_asString().c_str(), g_advancedSettings.m_videoItemSeparator);
+        newTag.m_iParentalRating    = m_pDS->fv("iParentalRating").get_asInt();
+        newTag.m_iStarRating        = m_pDS->fv("iStarRating").get_asInt();
+        newTag.m_bNotify            = m_pDS->fv("bNotify").get_asBool();
+        newTag.m_iEpisodeNumber     = m_pDS->fv("iEpisodeId").get_asInt();
+        newTag.m_iEpisodePart       = m_pDS->fv("iEpisodePart").get_asInt();
+        newTag.m_strEpisodeName     = m_pDS->fv("sEpisodeName").get_asString().c_str();
+        newTag.m_iSeriesNumber      = m_pDS->fv("iSeriesId").get_asInt();
+
+        epg.AddEntry(newTag);
+        ++iReturn;
+
+        m_pDS->next();
+      }
+      m_pDS->close();
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR, "%s - couldn't load EPG data from the database", __FUNCTION__);
+    }
+  }
+  return iReturn;
+}
+
+bool CEpgDatabase::GetLastEpgScanTime(int iEpgId, CDateTime *lastScan)
+{
+  bool bReturn = false;
+  CStdString strWhereClause = FormatSQL("idEpg = %u", iEpgId);
+  CSingleLock lock(m_critSection);
+  CStdString strValue = GetSingleValue("lastepgscan", "sLastScan", strWhereClause);
+
+  if (!strValue.IsEmpty())
+  {
+    lastScan->SetFromDBDateTime(strValue.c_str());
+    bReturn = true;
+  }
+  else
+  {
+    lastScan->SetValid(false);
+  }
+
+  return bReturn;
+}
+
+bool CEpgDatabase::PersistLastEpgScanTime(int iEpgId /* = 0 */, bool bQueueWrite /* = false */)
+{
+  CStdString strQuery = FormatSQL("REPLACE INTO lastepgscan(idEpg, sLastScan) VALUES (%u, '%s');",
+      iEpgId, CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsDBDateTime().c_str());
+
+  CSingleLock lock(m_critSection);
+  return bQueueWrite ? QueueInsertQuery(strQuery) : ExecuteQuery(strQuery);
+}
+
+bool CEpgDatabase::Persist(const CEpgContainer &epg)
+{
+  for (map<unsigned int, CEpg *>::const_iterator it = epg.m_epgs.begin(); it != epg.m_epgs.end(); it++)
+  {
+    CEpg *epg = it->second;
+    if (epg)
+      Persist(*epg, true);
+  }
+
+  return CommitInsertQueries();
+}
+
+int CEpgDatabase::Persist(const CEpg &epg, bool bQueueWrite /* = false */)
+{
+  int iReturn(-1);
+
+  CStdString strQuery;
+  if (epg.EpgID() > 0)
+    strQuery = FormatSQL("REPLACE INTO epg (idEpg, sName, sScraperName) "
+        "VALUES (%u, '%s', '%s');", epg.EpgID(), epg.Name().c_str(), epg.ScraperName().c_str());
+  else
+    strQuery = FormatSQL("INSERT INTO epg (sName, sScraperName) "
+        "VALUES ('%s', '%s');", epg.Name().c_str(), epg.ScraperName().c_str());
+
+  CSingleLock lock(m_critSection);
+  if (bQueueWrite)
+  {
+    if (QueueInsertQuery(strQuery))
+      iReturn = epg.EpgID() <= 0 ? 0 : epg.EpgID();
+  }
+  else
+  {
+    if (ExecuteQuery(strQuery))
+      iReturn = epg.EpgID() <= 0 ? (int) m_pDS->lastinsertid() : epg.EpgID();
+  }
+
+  return iReturn;
+}
+
+int CEpgDatabase::Persist(const CEpgInfoTag &tag, bool bSingleUpdate /* = true */)
+{
+  int iReturn(-1);
+
+  if (tag.EpgID() <= 0)
+  {
+    CLog::Log(LOGERROR, "%s - tag '%s' does not have a valid table", __FUNCTION__, tag.Title(true).c_str());
+    return iReturn;
+  }
+
+  time_t iStartTime, iEndTime, iFirstAired;
+  tag.StartAsUTC().GetAsTime(iStartTime);
+  tag.EndAsUTC().GetAsTime(iEndTime);
+  tag.FirstAiredAsUTC().GetAsTime(iFirstAired);
+
+  int iBroadcastId = tag.BroadcastId();
+  CSingleLock lock(m_critSection);
+  CStdString strQuery;
+  
+  /* Only store the genre string when needed */
+  CStdString strGenre = (tag.GenreType() == EPG_GENRE_USE_STRING) ? StringUtils::Join(tag.Genre(), g_advancedSettings.m_videoItemSeparator) : "";
+
+  if (iBroadcastId < 0)
+  {
+    strQuery = FormatSQL("INSERT INTO epgtags (idEpg, iStartTime, "
+        "iEndTime, sTitle, sPlotOutline, sPlot, iGenreType, iGenreSubType, sGenre, "
+        "iFirstAired, iParentalRating, iStarRating, bNotify, iSeriesId, "
+        "iEpisodeId, iEpisodePart, sEpisodeName, iBroadcastUid) "
+        "VALUES (%u, %u, %u, '%s', '%s', '%s', %i, %i, '%s', %u, %i, %i, %i, %i, %i, %i, '%s', %i);",
+        tag.EpgID(), iStartTime, iEndTime,
+        tag.Title(true).c_str(), tag.PlotOutline(true).c_str(), tag.Plot(true).c_str(), tag.GenreType(), tag.GenreSubType(), strGenre.c_str(),
+        iFirstAired, tag.ParentalRating(), tag.StarRating(), tag.Notify(),
+        tag.SeriesNum(), tag.EpisodeNum(), tag.EpisodePart(), tag.EpisodeName().c_str(),
+        tag.UniqueBroadcastID());
+  }
+  else
+  {
+    strQuery = FormatSQL("REPLACE INTO epgtags (idEpg, iStartTime, "
+        "iEndTime, sTitle, sPlotOutline, sPlot, iGenreType, iGenreSubType, sGenre, "
+        "iFirstAired, iParentalRating, iStarRating, bNotify, iSeriesId, "
+        "iEpisodeId, iEpisodePart, sEpisodeName, iBroadcastUid, idBroadcast) "
+        "VALUES (%u, %u, %u, '%s', '%s', '%s', %i, %i, '%s', %u, %i, %i, %i, %i, %i, %i, '%s', %i, %i);",
+        tag.EpgID(), iStartTime, iEndTime,
+        tag.Title(true).c_str(), tag.PlotOutline(true).c_str(), tag.Plot(true).c_str(), tag.GenreType(), tag.GenreSubType(), strGenre.c_str(),
+        iFirstAired, tag.ParentalRating(), tag.StarRating(), tag.Notify(),
+        tag.SeriesNum(), tag.EpisodeNum(), tag.EpisodePart(), tag.EpisodeName().c_str(),
+        tag.UniqueBroadcastID(), iBroadcastId);
+  }
+
+  if (bSingleUpdate)
+  {
+    if (ExecuteQuery(strQuery))
+      iReturn = (int) m_pDS->lastinsertid();
+  }
+  else
+  {
+    QueueInsertQuery(strQuery);
+    iReturn = 0;
+  }
+
+  return iReturn;
+}
diff --git a/xbmc/epg/EpgInfoTag.cpp b/xbmc/epg/EpgInfoTag.cpp
new file mode 100644
index 0000000..f58f8c1
--- /dev/null
+++ b/xbmc/epg/EpgInfoTag.cpp
@@ -0,0 +1,982 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "guilib/LocalizeStrings.h"
+#include "Epg.h"
+#include "EpgInfoTag.h"
+#include "EpgContainer.h"
+#include "EpgDatabase.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/PVRManager.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
+#include "utils/log.h"
+#include "addons/include/xbmc_pvr_types.h"
+
+using namespace std;
+using namespace EPG;
+using namespace PVR;
+
+CEpgInfoTag::CEpgInfoTag(void) :
+    m_bNotify(false),
+    m_bChanged(false),
+    m_iBroadcastId(-1),
+    m_iGenreType(0),
+    m_iGenreSubType(0),
+    m_iParentalRating(0),
+    m_iStarRating(0),
+    m_iSeriesNumber(0),
+    m_iEpisodeNumber(0),
+    m_iEpisodePart(0),
+    m_iUniqueBroadcastID(-1),
+    m_epg(NULL)
+{
+  CPVRChannelPtr emptyChannel;
+  m_pvrChannel = emptyChannel;
+
+  CPVRTimerInfoTagPtr emptyTimer;
+  m_timer = emptyTimer;
+}
+
+CEpgInfoTag::CEpgInfoTag(CEpg *epg, PVR::CPVRChannelPtr pvrChannel, const CStdString &strTableName /* = StringUtils::EmptyString */, const CStdString &strIconPath /* = StringUtils::EmptyString */) :
+    m_bNotify(false),
+    m_bChanged(false),
+    m_iBroadcastId(-1),
+    m_iGenreType(0),
+    m_iGenreSubType(0),
+    m_iParentalRating(0),
+    m_iStarRating(0),
+    m_iSeriesNumber(0),
+    m_iEpisodeNumber(0),
+    m_iEpisodePart(0),
+    m_iUniqueBroadcastID(-1),
+    m_strIconPath(strIconPath),
+    m_epg(epg),
+    m_pvrChannel(pvrChannel)
+{
+  CPVRTimerInfoTagPtr emptyTimer;
+  m_timer = emptyTimer;
+}
+
+CEpgInfoTag::CEpgInfoTag(const EPG_TAG &data) :
+    m_bNotify(false),
+    m_bChanged(false),
+    m_iBroadcastId(-1),
+    m_iGenreType(0),
+    m_iGenreSubType(0),
+    m_iParentalRating(0),
+    m_iStarRating(0),
+    m_iSeriesNumber(0),
+    m_iEpisodeNumber(0),
+    m_iEpisodePart(0),
+    m_iUniqueBroadcastID(-1),
+    m_epg(NULL)
+{
+  CPVRChannelPtr emptyChannel;
+  m_pvrChannel = emptyChannel;
+
+  CPVRTimerInfoTagPtr emptyTimer;
+  m_timer = emptyTimer;
+
+  Update(data);
+}
+
+CEpgInfoTag::CEpgInfoTag(const CEpgInfoTag &tag) :
+    m_bNotify(tag.m_bNotify),
+    m_bChanged(tag.m_bChanged),
+    m_iBroadcastId(tag.m_iBroadcastId),
+    m_iGenreType(tag.m_iGenreType),
+    m_iGenreSubType(tag.m_iGenreSubType),
+    m_iParentalRating(tag.m_iParentalRating),
+    m_iStarRating(tag.m_iStarRating),
+    m_iSeriesNumber(tag.m_iSeriesNumber),
+    m_iEpisodeNumber(tag.m_iEpisodeNumber),
+    m_iEpisodePart(tag.m_iEpisodePart),
+    m_iUniqueBroadcastID(tag.m_iUniqueBroadcastID),
+    m_strTitle(tag.m_strTitle),
+    m_strPlotOutline(tag.m_strPlotOutline),
+    m_strPlot(tag.m_strPlot),
+    m_genre(tag.m_genre),
+    m_strEpisodeName(tag.m_strEpisodeName),
+    m_strIconPath(tag.m_strIconPath),
+    m_strFileNameAndPath(tag.m_strFileNameAndPath),
+    m_startTime(tag.m_startTime),
+    m_endTime(tag.m_endTime),
+    m_firstAired(tag.m_firstAired),
+    m_timer(tag.m_timer),
+    m_epg(tag.m_epg),
+    m_pvrChannel(tag.m_pvrChannel)
+{
+}
+
+CEpgInfoTag::~CEpgInfoTag()
+{
+  ClearTimer();
+}
+
+bool CEpgInfoTag::operator ==(const CEpgInfoTag& right) const
+{
+  if (this == &right) return true;
+
+  CSingleLock lock(m_critSection);
+  return (m_bNotify            == right.m_bNotify &&
+          m_bChanged           == right.m_bChanged &&
+          m_iBroadcastId       == right.m_iBroadcastId &&
+          m_iGenreType         == right.m_iGenreType &&
+          m_iGenreSubType      == right.m_iGenreSubType &&
+          m_iParentalRating    == right.m_iParentalRating &&
+          m_firstAired         == right.m_firstAired &&
+          m_iStarRating        == right.m_iStarRating &&
+          m_iSeriesNumber      == right.m_iSeriesNumber &&
+          m_iEpisodeNumber     == right.m_iEpisodeNumber &&
+          m_iEpisodePart       == right.m_iEpisodePart &&
+          m_iUniqueBroadcastID == right.m_iUniqueBroadcastID &&
+          m_strTitle           == right.m_strTitle &&
+          m_strPlotOutline     == right.m_strPlotOutline &&
+          m_strPlot            == right.m_strPlot &&
+          m_genre              == right.m_genre &&
+          m_strEpisodeName     == right.m_strEpisodeName &&
+          m_strIconPath        == right.m_strIconPath &&
+          m_strFileNameAndPath == right.m_strFileNameAndPath &&
+          m_startTime          == right.m_startTime &&
+          m_endTime            == right.m_endTime &&
+          m_pvrChannel         == right.m_pvrChannel);
+}
+
+bool CEpgInfoTag::operator !=(const CEpgInfoTag& right) const
+{
+  if (this == &right) return false;
+
+  return !(*this == right);
+}
+
+CEpgInfoTag &CEpgInfoTag::operator =(const CEpgInfoTag &other)
+{
+  CSingleLock lock(other.m_critSection);
+
+  m_bNotify            = other.m_bNotify;
+  m_bChanged           = other.m_bChanged;
+  m_iBroadcastId       = other.m_iBroadcastId;
+  m_iGenreType         = other.m_iGenreType;
+  m_iGenreSubType      = other.m_iGenreSubType;
+  m_iParentalRating    = other.m_iParentalRating;
+  m_iStarRating        = other.m_iStarRating;
+  m_iSeriesNumber      = other.m_iSeriesNumber;
+  m_iEpisodeNumber     = other.m_iEpisodeNumber;
+  m_iEpisodePart       = other.m_iEpisodePart;
+  m_iUniqueBroadcastID = other.m_iUniqueBroadcastID;
+  m_strTitle           = other.m_strTitle;
+  m_strPlotOutline     = other.m_strPlotOutline;
+  m_strPlot            = other.m_strPlot;
+  m_genre              = other.m_genre;
+  m_strEpisodeName     = other.m_strEpisodeName;
+  m_strIconPath        = other.m_strIconPath;
+  m_strFileNameAndPath = other.m_strFileNameAndPath;
+  m_startTime          = other.m_startTime;
+  m_endTime            = other.m_endTime;
+  m_firstAired         = other.m_firstAired;
+  m_timer              = other.m_timer;
+  m_epg                = other.m_epg;
+  m_pvrChannel         = other.m_pvrChannel;
+
+  return *this;
+}
+
+bool CEpgInfoTag::Changed(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bChanged;
+}
+
+bool CEpgInfoTag::IsActive(void) const
+{
+  CDateTime now = CDateTime::GetUTCDateTime();
+  CSingleLock lock(m_critSection);
+  return (m_startTime <= now && m_endTime > now);
+}
+
+bool CEpgInfoTag::WasActive(void) const
+{
+  CDateTime now = CDateTime::GetUTCDateTime();
+  CSingleLock lock(m_critSection);
+  return (m_endTime < now);
+}
+
+bool CEpgInfoTag::InTheFuture(void) const
+{
+  CDateTime now = CDateTime::GetUTCDateTime();
+  CSingleLock lock(m_critSection);
+  return (m_startTime > now);
+}
+
+float CEpgInfoTag::ProgressPercentage(void) const
+{
+  float fReturn(0);
+  int iDuration;
+  time_t currentTime, startTime, endTime;
+  CDateTime::GetCurrentDateTime().GetAsUTCDateTime().GetAsTime(currentTime);
+
+  CSingleLock lock(m_critSection);
+  m_startTime.GetAsTime(startTime);
+  m_endTime.GetAsTime(endTime);
+  iDuration = endTime - startTime > 0 ? endTime - startTime : 3600;
+
+  if (currentTime >= startTime && currentTime <= endTime)
+    fReturn = ((float) currentTime - startTime) / iDuration * 100;
+  else if (currentTime > endTime)
+    fReturn = 100;
+
+  return fReturn;
+}
+
+CEpgInfoTagPtr CEpgInfoTag::GetNextEvent(void) const
+{
+  return GetTable()->GetNextEvent(*this);
+}
+
+CEpgInfoTagPtr CEpgInfoTag::GetPreviousEvent(void) const
+{
+  return GetTable()->GetPreviousEvent(*this);
+}
+
+void CEpgInfoTag::SetUniqueBroadcastID(int iUniqueBroadcastID)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_iUniqueBroadcastID != iUniqueBroadcastID)
+    {
+      m_iUniqueBroadcastID = iUniqueBroadcastID;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+int CEpgInfoTag::UniqueBroadcastID(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iUniqueBroadcastID;
+}
+
+void CEpgInfoTag::SetBroadcastId(int iId)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_iBroadcastId != iId)
+    {
+      m_iBroadcastId = iId;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+int CEpgInfoTag::BroadcastId(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iBroadcastId;
+}
+
+CDateTime CEpgInfoTag::StartAsUTC(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_startTime;
+}
+
+CDateTime CEpgInfoTag::StartAsLocalTime(void) const
+{
+  CDateTime retVal;
+  CSingleLock lock(m_critSection);
+  retVal.SetFromUTCDateTime(m_startTime);
+  return retVal;
+}
+
+void CEpgInfoTag::SetStartFromUTC(const CDateTime &start)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_startTime != start)
+    {
+      m_startTime = start;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+void CEpgInfoTag::SetStartFromLocalTime(const CDateTime &start)
+{
+  CDateTime tmp = start.GetAsUTCDateTime();
+  SetStartFromUTC(tmp);
+}
+
+CDateTime CEpgInfoTag::EndAsUTC(void) const
+{
+  CDateTime retVal;
+  CSingleLock lock(m_critSection);
+  retVal = m_endTime;
+  return retVal;
+}
+
+CDateTime CEpgInfoTag::EndAsLocalTime(void) const
+{
+  CDateTime retVal;
+  CSingleLock lock(m_critSection);
+  retVal.SetFromUTCDateTime(m_endTime);
+  return retVal;
+}
+
+void CEpgInfoTag::SetEndFromUTC(const CDateTime &end)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_endTime != end)
+    {
+      m_endTime = end;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+void CEpgInfoTag::SetEndFromLocalTime(const CDateTime &end)
+{
+  CDateTime tmp = end.GetAsUTCDateTime();
+  SetEndFromUTC(tmp);
+}
+
+int CEpgInfoTag::GetDuration(void) const
+{
+  time_t start, end;
+  CSingleLock lock(m_critSection);
+  m_startTime.GetAsTime(start);
+  m_endTime.GetAsTime(end);
+  return end - start > 0 ? end - start : 3600;
+}
+
+void CEpgInfoTag::SetTitle(const CStdString &strTitle)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_strTitle != strTitle)
+    {
+      m_strTitle = strTitle;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+CStdString CEpgInfoTag::Title(bool bOverrideParental /* = false */) const
+{
+  CStdString strTitle;
+  bool bParentalLocked(false);
+
+  {
+    CSingleLock lock(m_critSection);
+    strTitle = m_strTitle;
+    if (m_pvrChannel)
+      bParentalLocked = g_PVRManager.IsParentalLocked(*m_pvrChannel);
+  }
+
+  if (!bOverrideParental && bParentalLocked)
+    strTitle = g_localizeStrings.Get(19266); // parental locked
+  else if (strTitle.empty() && !g_guiSettings.GetBool("epg.hidenoinfoavailable"))
+    strTitle = g_localizeStrings.Get(19055); // no information available
+
+  return strTitle;
+}
+
+void CEpgInfoTag::SetPlotOutline(const CStdString &strPlotOutline)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_strPlotOutline != strPlotOutline)
+    {
+      m_strPlotOutline = strPlotOutline;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+CStdString CEpgInfoTag::PlotOutline(bool bOverrideParental /* = false */) const
+{
+  CStdString retVal;
+  CSingleLock lock(m_critSection);
+  if (bOverrideParental || !m_pvrChannel || !g_PVRManager.IsParentalLocked(*m_pvrChannel))
+    retVal = m_strPlotOutline;
+
+  return retVal;
+}
+
+void CEpgInfoTag::SetPlot(const CStdString &strPlot)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    CStdString strPlotClean = (m_strPlotOutline.length() > 0 && strPlot.Left(m_strPlotOutline.length()).Equals(m_strPlotOutline)) ?
+      strPlot.Right(strPlot.length() - m_strPlotOutline.length()) :
+      strPlot;
+
+    if (m_strPlot != strPlotClean)
+    {
+      m_strPlot = strPlotClean;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+CStdString CEpgInfoTag::Plot(bool bOverrideParental /* = false */) const
+{
+  CStdString retVal;
+  CSingleLock lock(m_critSection);
+  if (bOverrideParental || !m_pvrChannel || !g_PVRManager.IsParentalLocked(*m_pvrChannel))
+    retVal = m_strPlot;
+
+  return retVal;
+}
+
+void CEpgInfoTag::SetGenre(int iID, int iSubID, const char* strGenre)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_iGenreType != iID || m_iGenreSubType != iSubID)
+    {
+      m_iGenreType    = iID;
+      m_iGenreSubType = iSubID;
+      if ((iID == EPG_GENRE_USE_STRING) && (strGenre != NULL) && (strlen(strGenre) > 0))
+      {
+        /* Type and sub type are not given. No EPG color coding possible
+         * Use the provided genre description as backup. */
+        m_genre = StringUtils::Split(strGenre, g_advancedSettings.m_videoItemSeparator);
+      }
+      else
+      {
+        /* Determine the genre description from the type and subtype IDs */
+        m_genre = StringUtils::Split(CEpg::ConvertGenreIdToString(iID, iSubID), g_advancedSettings.m_videoItemSeparator);
+      }
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+int CEpgInfoTag::GenreType(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iGenreType;
+}
+
+int CEpgInfoTag::GenreSubType(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iGenreSubType;
+}
+
+const vector<string> CEpgInfoTag::Genre(void) const
+{
+  vector<string> retVal;
+  CSingleLock lock(m_critSection);
+  retVal = m_genre;
+  return retVal;
+}
+
+CDateTime CEpgInfoTag::FirstAiredAsUTC(void) const
+{
+  CDateTime retVal;
+  CSingleLock lock(m_critSection);
+  retVal = m_firstAired;
+  return retVal;
+}
+
+CDateTime CEpgInfoTag::FirstAiredAsLocalTime(void) const
+{
+  CDateTime retVal;
+  CSingleLock lock(m_critSection);
+  retVal.SetFromUTCDateTime(m_firstAired);
+  return retVal;
+}
+
+void CEpgInfoTag::SetFirstAiredFromUTC(const CDateTime &firstAired)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_firstAired != firstAired)
+    {
+      m_firstAired = firstAired;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+void CEpgInfoTag::SetFirstAiredFromLocalTime(const CDateTime &firstAired)
+{
+  CDateTime tmp = firstAired.GetAsUTCDateTime();
+  SetFirstAiredFromUTC(tmp);
+}
+
+void CEpgInfoTag::SetParentalRating(int iParentalRating)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_iParentalRating != iParentalRating)
+    {
+      m_iParentalRating = iParentalRating;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+int CEpgInfoTag::ParentalRating(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iParentalRating;
+}
+
+void CEpgInfoTag::SetStarRating(int iStarRating)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_iStarRating != iStarRating)
+    {
+      m_iStarRating = iStarRating;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+int CEpgInfoTag::StarRating(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iStarRating;
+}
+
+void CEpgInfoTag::SetNotify(bool bNotify)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_bNotify != bNotify)
+    {
+      m_bNotify = bNotify;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+bool CEpgInfoTag::Notify(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bNotify;
+}
+
+void CEpgInfoTag::SetSeriesNum(int iSeriesNum)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_iSeriesNumber != iSeriesNum)
+    {
+      m_iSeriesNumber = iSeriesNum;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+int CEpgInfoTag::SeriesNum(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iSeriesNumber;
+}
+
+void CEpgInfoTag::SetEpisodeNum(int iEpisodeNum)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_iEpisodeNumber != iEpisodeNum)
+    {
+      m_iEpisodeNumber = iEpisodeNum;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+int CEpgInfoTag::EpisodeNum(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iEpisodeNumber;
+}
+
+void CEpgInfoTag::SetEpisodePart(int iEpisodePart)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_iEpisodePart != iEpisodePart)
+    {
+      m_iEpisodePart = iEpisodePart;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+int CEpgInfoTag::EpisodePart(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iEpisodePart;
+}
+
+void CEpgInfoTag::SetEpisodeName(const CStdString &strEpisodeName)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_strEpisodeName != strEpisodeName)
+    {
+      m_strEpisodeName = strEpisodeName;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+CStdString CEpgInfoTag::EpisodeName(void) const
+{
+  CStdString retVal;
+  CSingleLock lock(m_critSection);
+  retVal = m_strEpisodeName;
+  return retVal;
+}
+
+void CEpgInfoTag::SetIcon(const CStdString &strIconPath)
+{
+  bool bUpdate(false);
+  {
+    CSingleLock lock(m_critSection);
+    if (m_strIconPath != strIconPath)
+    {
+      m_strIconPath = strIconPath;
+      m_bChanged = true;
+      bUpdate = true;
+    }
+  }
+  if (bUpdate)
+    UpdatePath();
+}
+
+CStdString CEpgInfoTag::Icon(void) const
+{
+  CStdString retVal;
+
+  CSingleLock lock(m_critSection);
+  retVal = m_strIconPath;
+  return retVal;
+}
+
+void CEpgInfoTag::SetPath(const CStdString &strFileNameAndPath)
+{
+  CSingleLock lock(m_critSection);
+  if (m_strFileNameAndPath != strFileNameAndPath)
+  {
+    m_strFileNameAndPath = strFileNameAndPath;
+    m_bChanged = true;
+  }
+}
+
+CStdString CEpgInfoTag::Path(void) const
+{
+  string retVal;
+  CSingleLock lock(m_critSection);
+  retVal = m_strFileNameAndPath;
+  return retVal;
+}
+
+//void CEpgInfoTag::SetTimer(CPVRTimerInfoTagPtr newTimer)
+//{
+//  CPVRTimerInfoTagPtr oldTimer;
+//  {
+//    CSingleLock lock(m_critSection);
+//    oldTimer = m_timer;
+//    m_timer = newTimer;
+//  }
+//  if (oldTimer)
+//    oldTimer->ClearEpgTag();
+//}
+
+bool CEpgInfoTag::HasTimer(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_timer != NULL;
+}
+
+CPVRTimerInfoTagPtr CEpgInfoTag::Timer(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_timer;
+}
+
+void CEpgInfoTag::SetPVRChannel(PVR::CPVRChannelPtr channel)
+{
+  CSingleLock lock(m_critSection);
+  m_pvrChannel = channel;
+}
+
+bool CEpgInfoTag::HasPVRChannel(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_pvrChannel != NULL;
+}
+
+int CEpgInfoTag::PVRChannelNumber(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_pvrChannel ? m_pvrChannel->ChannelNumber() : -1;
+}
+
+CStdString CEpgInfoTag::PVRChannelName(void) const
+{
+  CStdString strReturn;
+  CSingleLock lock(m_critSection);
+  if (m_pvrChannel)
+    strReturn = m_pvrChannel->ChannelName();
+  return strReturn;
+}
+
+const PVR::CPVRChannelPtr CEpgInfoTag::ChannelTag(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_pvrChannel;
+}
+
+void CEpgInfoTag::Update(const EPG_TAG &tag)
+{
+  CSingleLock lock(m_critSection);
+  SetStartFromUTC(tag.startTime + g_advancedSettings.m_iPVRTimeCorrection);
+  SetEndFromUTC(tag.endTime + g_advancedSettings.m_iPVRTimeCorrection);
+  SetTitle(tag.strTitle);
+  SetPlotOutline(tag.strPlotOutline);
+  SetPlot(tag.strPlot);
+  SetGenre(tag.iGenreType, tag.iGenreSubType, tag.strGenreDescription);
+  SetParentalRating(tag.iParentalRating);
+  SetUniqueBroadcastID(tag.iUniqueBroadcastId);
+  SetNotify(tag.bNotify);
+  SetFirstAiredFromUTC(tag.firstAired + g_advancedSettings.m_iPVRTimeCorrection);
+  SetEpisodeNum(tag.iEpisodeNumber);
+  SetEpisodePart(tag.iEpisodePartNumber);
+  SetEpisodeName(tag.strEpisodeName);
+  SetStarRating(tag.iStarRating);
+  SetIcon(tag.strIconPath);
+}
+
+bool CEpgInfoTag::Update(const CEpgInfoTag &tag, bool bUpdateBroadcastId /* = true */)
+{
+  bool bChanged(false);
+  {
+    CSingleLock lock(m_critSection);
+    bChanged = (
+        m_strTitle           != tag.m_strTitle ||
+        m_strPlotOutline     != tag.m_strPlotOutline ||
+        m_strPlot            != tag.m_strPlot ||
+        m_startTime          != tag.m_startTime ||
+        m_endTime            != tag.m_endTime ||
+        m_iGenreType         != tag.m_iGenreType ||
+        m_iGenreSubType      != tag.m_iGenreSubType ||
+        m_firstAired         != tag.m_firstAired ||
+        m_iParentalRating    != tag.m_iParentalRating ||
+        m_iStarRating        != tag.m_iStarRating ||
+        m_bNotify            != tag.m_bNotify ||
+        m_iEpisodeNumber     != tag.m_iEpisodeNumber ||
+        m_iEpisodePart       != tag.m_iEpisodePart ||
+        m_iSeriesNumber      != tag.m_iSeriesNumber ||
+        m_strEpisodeName     != tag.m_strEpisodeName ||
+        m_iUniqueBroadcastID != tag.m_iUniqueBroadcastID ||
+        EpgID()              != tag.EpgID() ||
+        m_pvrChannel         != tag.m_pvrChannel ||
+        m_genre              != tag.m_genre
+    );
+    if (bUpdateBroadcastId)
+      bChanged = bChanged || m_iBroadcastId != tag.m_iBroadcastId;
+
+    if (bChanged)
+    {
+      if (bUpdateBroadcastId)
+        m_iBroadcastId       = tag.m_iBroadcastId;
+
+      m_strTitle           = tag.m_strTitle;
+      m_strPlotOutline     = tag.m_strPlotOutline;
+      m_strPlot            = tag.m_strPlot;
+      m_startTime          = tag.m_startTime;
+      m_endTime            = tag.m_endTime;
+      m_iGenreType         = tag.m_iGenreType;
+      m_iGenreSubType      = tag.m_iGenreSubType;
+      m_epg                = tag.m_epg;
+      m_pvrChannel         = tag.m_pvrChannel;
+      if (m_iGenreType == EPG_GENRE_USE_STRING)
+      {
+        /* No type/subtype. Use the provided description */
+        m_genre = tag.m_genre;
+      }
+      else
+      {
+        /* Determine genre description by type/subtype */
+        m_genre = StringUtils::Split(CEpg::ConvertGenreIdToString(tag.m_iGenreType, tag.m_iGenreSubType), g_advancedSettings.m_videoItemSeparator);
+      }
+      m_firstAired         = tag.m_firstAired;
+      m_iParentalRating    = tag.m_iParentalRating;
+      m_iStarRating        = tag.m_iStarRating;
+      m_bNotify            = tag.m_bNotify;
+      m_iEpisodeNumber     = tag.m_iEpisodeNumber;
+      m_iEpisodePart       = tag.m_iEpisodePart;
+      m_iSeriesNumber      = tag.m_iSeriesNumber;
+      m_strEpisodeName     = tag.m_strEpisodeName;
+      m_iUniqueBroadcastID = tag.m_iUniqueBroadcastID;
+
+      m_bChanged = true;
+    }
+  }
+  if (bChanged)
+    UpdatePath();
+
+  return bChanged;
+}
+
+bool CEpgInfoTag::Persist(bool bSingleUpdate /* = true */)
+{
+  bool bReturn = false;
+  CSingleLock lock(m_critSection);
+  if (!m_bChanged)
+    return true;
+  CLog::Log(LOGDEBUG, "Epg - %s - Infotag '%s' %s, persisting...", __FUNCTION__, m_strTitle.c_str(), m_iBroadcastId > 0 ? "has changes" : "is new");
+  CEpgDatabase *database = g_EpgContainer.GetDatabase();
+  if (!database || (bSingleUpdate && !database->IsOpen()))
+  {
+    CLog::Log(LOGERROR, "%s - could not open the database", __FUNCTION__);
+    return bReturn;
+  }
+
+  int iId = database->Persist(*this, bSingleUpdate);
+  if (iId >= 0)
+  {
+    bReturn = true;
+
+    if (iId > 0)
+    {
+      m_iBroadcastId = iId;
+      m_bChanged = false;
+    }
+  }
+
+  return bReturn;
+}
+
+void CEpgInfoTag::UpdatePath(void)
+{
+  CStdString path;
+  {
+    CSingleLock lock(m_critSection);
+    path.Format("pvr://guide/%04i/%s.epg", EpgID(), m_startTime.GetAsDBDateTime().c_str());
+  }
+
+  SetPath(path);
+}
+
+const CEpg *CEpgInfoTag::GetTable() const
+{
+  return m_epg;
+}
+
+const int CEpgInfoTag::EpgID(void) const
+{
+  return m_epg ? m_epg->EpgID() : -1;
+}
+
+void CEpgInfoTag::SetTimer(CPVRTimerInfoTagPtr timer)
+{
+  CSingleLock lock(m_critSection);
+  m_timer = timer;
+}
+
+void CEpgInfoTag::ClearTimer(void)
+{
+  CPVRTimerInfoTagPtr previousTag;
+  {
+    CSingleLock lock(m_critSection);
+    previousTag = m_timer;
+    CPVRTimerInfoTagPtr empty;
+    m_timer = empty;
+  }
+
+  if (previousTag)
+    previousTag->ClearEpgTag();
+}
diff --git a/xbmc/epg/EpgSearchFilter.cpp b/xbmc/epg/EpgSearchFilter.cpp
new file mode 100644
index 0000000..ea6e10a
--- /dev/null
+++ b/xbmc/epg/EpgSearchFilter.cpp
@@ -0,0 +1,249 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "guilib/LocalizeStrings.h"
+#include "utils/TextSearch.h"
+#include "utils/log.h"
+#include "FileItem.h"
+#include "../addons/include/xbmc_pvr_types.h"
+
+#include "EpgSearchFilter.h"
+#include "EpgContainer.h"
+
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "pvr/timers/PVRTimers.h"
+
+using namespace std;
+using namespace EPG;
+using namespace PVR;
+
+void EpgSearchFilter::Reset()
+{
+  m_strSearchTerm            = "";
+  m_bIsCaseSensitive         = false;
+  m_bSearchInDescription     = false;
+  m_iGenreType               = EPG_SEARCH_UNSET;
+  m_iGenreSubType            = EPG_SEARCH_UNSET;
+  m_iMinimumDuration         = EPG_SEARCH_UNSET;
+  m_iMaximumDuration         = EPG_SEARCH_UNSET;
+  m_startDateTime.SetFromUTCDateTime(g_EpgContainer.GetFirstEPGDate());
+  m_endDateTime.SetFromUTCDateTime(g_EpgContainer.GetLastEPGDate());
+  m_bIncludeUnknownGenres    = false;
+  m_bIgnorePresentTimers     = false;
+  m_bIgnorePresentRecordings = false;
+  m_bPreventRepeats          = false;
+
+  /* pvr specific filters */
+  m_iChannelNumber           = EPG_SEARCH_UNSET;
+  m_bFTAOnly                 = false;
+  m_iChannelGroup            = EPG_SEARCH_UNSET;
+  m_bIgnorePresentTimers     = true;
+  m_bIgnorePresentRecordings = true;
+}
+
+bool EpgSearchFilter::MatchGenre(const CEpgInfoTag &tag) const
+{
+  bool bReturn(true);
+
+  if (m_iGenreType != EPG_SEARCH_UNSET)
+  {
+    bool bIsUnknownGenre(tag.GenreType() > EPG_EVENT_CONTENTMASK_USERDEFINED ||
+        tag.GenreType() < EPG_EVENT_CONTENTMASK_MOVIEDRAMA);
+    bReturn = ((m_bIncludeUnknownGenres && bIsUnknownGenre) || tag.GenreType() == m_iGenreType);
+  }
+
+  return bReturn;
+}
+
+bool EpgSearchFilter::MatchDuration(const CEpgInfoTag &tag) const
+{
+  bool bReturn(true);
+
+  if (m_iMinimumDuration != EPG_SEARCH_UNSET)
+    bReturn = (tag.GetDuration() > m_iMinimumDuration * 60);
+
+  if (bReturn && m_iMaximumDuration != EPG_SEARCH_UNSET)
+    bReturn = (tag.GetDuration() < m_iMaximumDuration * 60);
+
+  return bReturn;
+}
+
+bool EpgSearchFilter::MatchStartAndEndTimes(const CEpgInfoTag &tag) const
+{
+  return (tag.StartAsLocalTime() >= m_startDateTime && tag.EndAsLocalTime() <= m_endDateTime);
+}
+
+bool EpgSearchFilter::MatchSearchTerm(const CEpgInfoTag &tag) const
+{
+  bool bReturn(true);
+
+  if (!m_strSearchTerm.IsEmpty())
+  {
+    CTextSearch search(m_strSearchTerm, m_bIsCaseSensitive, SEARCH_DEFAULT_OR);
+    bReturn = search.Search(tag.Title()) ||
+        search.Search(tag.PlotOutline());
+  }
+
+  return bReturn;
+}
+
+bool EpgSearchFilter::FilterEntry(const CEpgInfoTag &tag) const
+{
+  return (MatchGenre(tag) &&
+      MatchDuration(tag) &&
+      MatchStartAndEndTimes(tag) &&
+      MatchSearchTerm(tag)) &&
+      (!tag.HasPVRChannel() ||
+      (MatchChannelNumber(tag) &&
+       MatchChannelGroup(tag) &&
+       (!m_bFTAOnly || !tag.ChannelTag()->IsEncrypted())));
+}
+
+int EpgSearchFilter::RemoveDuplicates(CFileItemList &results)
+{
+  unsigned int iSize = results.Size();
+
+  for (unsigned int iResultPtr = 0; iResultPtr < iSize; iResultPtr++)
+  {
+    const CEpgInfoTag *epgentry_1 = results.Get(iResultPtr)->GetEPGInfoTag();
+    for (unsigned int iTagPtr = 0; iTagPtr < iSize; iTagPtr++)
+    {
+      const CEpgInfoTag *epgentry_2 = results.Get(iTagPtr)->GetEPGInfoTag();
+      if (iResultPtr == iTagPtr)
+        continue;
+
+      if (epgentry_1->Title()       != epgentry_2->Title() ||
+          epgentry_1->Plot()        != epgentry_2->Plot() ||
+          epgentry_1->PlotOutline() != epgentry_2->PlotOutline())
+        continue;
+
+      results.Remove(iTagPtr);
+      iResultPtr--;
+      iTagPtr--;
+      iSize--;
+    }
+  }
+
+  return iSize;
+}
+
+
+bool EpgSearchFilter::MatchChannelNumber(const CEpgInfoTag &tag) const
+{
+  bool bReturn(true);
+
+  if (m_iChannelNumber != EPG_SEARCH_UNSET && g_PVRManager.IsStarted())
+  {
+    CPVRChannelGroupPtr group = (m_iChannelGroup != EPG_SEARCH_UNSET) ? g_PVRChannelGroups->GetByIdFromAll(m_iChannelGroup) : g_PVRChannelGroups->GetGroupAllTV();
+    if (!group)
+      group = CPVRManager::Get().ChannelGroups()->GetGroupAllTV();
+
+    bReturn = (m_iChannelNumber == (int) group->GetChannelNumber(*tag.ChannelTag()));
+  }
+
+  return bReturn;
+}
+
+bool EpgSearchFilter::MatchChannelGroup(const CEpgInfoTag &tag) const
+{
+  bool bReturn(true);
+
+  if (m_iChannelGroup != EPG_SEARCH_UNSET && g_PVRManager.IsStarted())
+  {
+    CPVRChannelGroupPtr group = g_PVRChannelGroups->GetByIdFromAll(m_iChannelGroup);
+    bReturn = (group && group->IsGroupMember(*tag.ChannelTag()));
+  }
+
+  return bReturn;
+}
+
+int EpgSearchFilter::FilterRecordings(CFileItemList &results)
+{
+  int iRemoved(0);
+  if (!g_PVRManager.IsStarted())
+    return iRemoved;
+
+  CFileItemList recordings;
+  g_PVRRecordings->GetAll(recordings);
+
+  // TODO inefficient!
+  for (int iRecordingPtr = 0; iRecordingPtr < recordings.Size(); iRecordingPtr++)
+  {
+    CPVRRecording *recording = recordings.Get(iRecordingPtr)->GetPVRRecordingInfoTag();
+    if (!recording)
+      continue;
+
+    for (int iResultPtr = 0; iResultPtr < results.Size(); iResultPtr++)
+    {
+      const CEpgInfoTag *epgentry  = results.Get(iResultPtr)->GetEPGInfoTag();
+
+      /* no match */
+      if (!epgentry ||
+          epgentry->Title() != recording->m_strTitle ||
+          epgentry->Plot()  != recording->m_strPlot)
+        continue;
+
+      results.Remove(iResultPtr);
+      iResultPtr--;
+      ++iRemoved;
+    }
+  }
+
+  return iRemoved;
+}
+
+int EpgSearchFilter::FilterTimers(CFileItemList &results)
+{
+  int iRemoved(0);
+  if (!g_PVRManager.IsStarted())
+    return iRemoved;
+
+  vector<CFileItemPtr> timers = g_PVRTimers->GetActiveTimers();
+  // TODO inefficient!
+  for (unsigned int iTimerPtr = 0; iTimerPtr < timers.size(); iTimerPtr++)
+  {
+    CFileItemPtr fileItem = timers.at(iTimerPtr);
+    if (!fileItem || !fileItem->HasPVRTimerInfoTag())
+      continue;
+
+    CPVRTimerInfoTag *timer = fileItem->GetPVRTimerInfoTag();
+    if (!timer)
+      continue;
+
+    for (int iResultPtr = 0; iResultPtr < results.Size(); iResultPtr++)
+    {
+      const CEpgInfoTag *epgentry = results.Get(iResultPtr)->GetEPGInfoTag();
+      if (!epgentry ||
+          *epgentry->ChannelTag() != *timer->ChannelTag() ||
+          epgentry->StartAsUTC()   <  timer->StartAsUTC() ||
+          epgentry->EndAsUTC()     >  timer->EndAsUTC())
+        continue;
+
+      results.Remove(iResultPtr);
+      iResultPtr--;
+      ++iRemoved;
+    }
+  }
+
+  return iRemoved;
+}
diff --git a/xbmc/epg/GUIEPGGridContainer.cpp b/xbmc/epg/GUIEPGGridContainer.cpp
new file mode 100644
index 0000000..1095df1
--- /dev/null
+++ b/xbmc/epg/GUIEPGGridContainer.cpp
@@ -0,0 +1,1934 @@
+/*
+*      Copyright (C) 2012 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "guilib/Key.h"
+#include "guilib/GUIControlFactory.h"
+#include "guilib/GUIListItem.h"
+#include "guilib/GUIFontManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "guilib/DirtyRegion.h"
+#include <tinyxml.h>
+#include "utils/log.h"
+#include "utils/Variant.h"
+#include "threads/SystemClock.h"
+#include "GUIInfoManager.h"
+
+#include "epg/Epg.h"
+#include "pvr/channels/PVRChannel.h"
+
+#include "GUIEPGGridContainer.h"
+
+using namespace PVR;
+using namespace EPG;
+using namespace std;
+
+#define SHORTGAP     5 // how many blocks is considered a short-gap in nav logic
+#define MINSPERBLOCK 5 /// would be nice to offer zooming of busy schedules /// performance cost to increase resolution 5 fold?
+#define BLOCKJUMP    4 // how many blocks are jumped with each analogue scroll action
+
+CGUIEPGGridContainer::CGUIEPGGridContainer(int parentID, int controlID, float posX, float posY, float width,
+                                           float height, ORIENTATION orientation, int scrollTime,
+                                           int preloadItems, int timeBlocks, int rulerUnit)
+    : CGUIControl(parentID, controlID, posX, posY, width, height)
+{
+  ControlType             = GUICONTAINER_EPGGRID;
+  m_blocksPerPage         = timeBlocks;
+  m_rulerUnit             = rulerUnit;
+  m_channelCursor         = 0;
+  m_blockCursor           = 0;
+  m_channelOffset         = 0;
+  m_blockOffset           = 0;
+  m_channelScrollOffset   = 0;
+  m_channelScrollSpeed    = 0;
+  m_channelScrollLastTime = 0;
+  m_programmeScrollOffset = 0;
+  m_programmeScrollSpeed  = 0;
+  m_programmeScrollLastTime  = 0;
+  m_scrollTime            = scrollTime ? scrollTime : 1;
+  m_renderTime            = 0;
+  m_item                  = NULL;
+  m_lastItem              = NULL;
+  m_lastChannel           = NULL;
+  m_channelWrapAround     = true; /// get from settings?
+  m_orientation           = orientation;
+  m_programmeLayout       = NULL;
+  m_focusedProgrammeLayout= NULL;
+  m_channelLayout         = NULL;
+  m_focusedChannelLayout  = NULL;
+  m_rulerLayout           = NULL;
+  m_rulerPosX             = 0;
+  m_rulerPosY             = 0;
+  m_rulerHeight           = 0;
+  m_rulerWidth            = 0;
+  m_channelPosX           = 0;
+  m_channelPosY           = 0;
+  m_channelHeight         = 0;
+  m_channelWidth          = 0;
+  m_gridPosX              = 0;
+  m_gridPosY              = 0;
+  m_gridWidth             = 0;
+  m_gridHeight            = 0;
+  m_blockSize             = 0;
+  m_analogScrollCount     = 0;
+  m_cacheChannelItems     = preloadItems;
+  m_cacheRulerItems       = preloadItems;
+  m_cacheProgrammeItems   = preloadItems;
+  m_gridIndex             = NULL;
+}
+
+CGUIEPGGridContainer::~CGUIEPGGridContainer(void)
+{
+  Reset();
+}
+
+void CGUIEPGGridContainer::Process(unsigned int currentTime, CDirtyRegionList &dirtyregions)
+{
+  bool changed = false;
+  m_renderTime = currentTime;
+
+  changed = true;
+
+  if (changed)
+    MarkDirtyRegion();
+
+  CGUIControl::Process(currentTime, dirtyregions);
+}
+
+void CGUIEPGGridContainer::Render()
+{
+  ValidateOffset();
+
+  if (m_bInvalidated)
+    UpdateLayout();
+
+  if (!m_focusedChannelLayout || !m_channelLayout || !m_rulerLayout || !m_focusedProgrammeLayout || !m_programmeLayout || m_rulerItems.size()<=1 || (m_gridEnd - m_gridStart) == CDateTimeSpan(0, 0, 0, 0))
+    return;
+
+  UpdateScrollOffset();
+
+  int chanOffset  = (int)floorf(m_channelScrollOffset / m_programmeLayout->Size(m_orientation));
+  int blockOffset = (int)floorf(m_programmeScrollOffset / m_blockSize);
+  int rulerOffset = (int)floorf(m_programmeScrollOffset / m_blockSize);
+
+  /// Render channel names
+  int cacheBeforeChannel, cacheAfterChannel;
+  GetChannelCacheOffsets(cacheBeforeChannel, cacheAfterChannel);
+
+  // Free memory not used on screen
+  if ((int)m_channelItems.size() > m_channelsPerPage + cacheBeforeChannel + cacheAfterChannel)
+    FreeChannelMemory(CorrectOffset(chanOffset - cacheBeforeChannel, 0), CorrectOffset(chanOffset + m_channelsPerPage + 1 + cacheAfterChannel, 0));
+
+  if (m_orientation == VERTICAL)
+    g_graphicsContext.SetClipRegion(m_channelPosX, m_channelPosY, m_channelWidth, m_gridHeight);
+  else
+    g_graphicsContext.SetClipRegion(m_channelPosX, m_channelPosY, m_gridWidth, m_channelHeight);
+
+  CPoint originChannel = CPoint(m_channelPosX, m_channelPosY) + m_renderOffset;
+  float pos = (m_orientation == VERTICAL) ? originChannel.y : originChannel.x;
+  float end = (m_orientation == VERTICAL) ? m_posY + m_height : m_posX + m_width;
+
+  // we offset our draw position to take into account scrolling and whether or not our focused
+  // item is offscreen "above" the list.
+  float drawOffset = (chanOffset - cacheBeforeChannel) * m_channelLayout->Size(m_orientation) - m_channelScrollOffset;
+  if (m_channelOffset + m_channelCursor < chanOffset)
+    drawOffset += m_focusedChannelLayout->Size(m_orientation) - m_channelLayout->Size(m_orientation);
+  pos += drawOffset;
+  end += cacheAfterChannel * m_channelLayout->Size(m_orientation);
+
+  float focusedPos = 0;
+  CGUIListItemPtr focusedItem;
+  int current = chanOffset;// - cacheBeforeChannel;
+  while (pos < end && (int)m_channelItems.size())
+  {
+    int itemNo = CorrectOffset(current, 0);
+    if (itemNo >= (int)m_channelItems.size())
+      break;
+    bool focused = (current == m_channelOffset + m_channelCursor);
+    if (itemNo >= 0)
+    {
+      CGUIListItemPtr item = m_channelItems[itemNo];
+      // render our item
+      if (focused)
+      {
+        focusedPos = pos;
+        focusedItem = item;
+      }
+      else
+      {
+        if (m_orientation == VERTICAL)
+          RenderChannelItem(originChannel.x, pos, item.get(), false);
+        else
+          RenderChannelItem(pos, originChannel.y, item.get(), false);
+      }
+    }
+    // increment our position
+    pos += focused ? m_focusedChannelLayout->Size(m_orientation) : m_channelLayout->Size(m_orientation);
+    current++;
+  }
+  // render focused item last so it can overlap other items
+  if (focusedItem)
+  {
+    if (m_orientation == VERTICAL)
+      RenderChannelItem(originChannel.x, focusedPos, focusedItem.get(), true);
+    else
+      RenderChannelItem(focusedPos, originChannel.y, focusedItem.get(), true);
+  }
+  g_graphicsContext.RestoreClipRegion();
+
+  /// Render the ruler items
+  g_graphicsContext.SetClipRegion(m_posX, m_posY, m_width, m_height);
+  CGUIListItemPtr item = m_rulerItems[0];
+  g_graphicsContext.SetOrigin(m_posX, m_posY);
+  item->SetLabel(m_rulerItems[rulerOffset/m_rulerUnit+1]->GetLabel2());
+  if (!item->GetLayout())
+  {
+    CGUIListItemLayout *layout = new CGUIListItemLayout(*m_rulerLayout);
+    if (m_orientation == VERTICAL)
+      layout->SetWidth(m_channelWidth);
+    else
+      layout->SetHeight(m_channelHeight);
+    item->SetLayout(layout);
+  }
+  if (item->GetLayout())
+  {
+    CDirtyRegionList dirtyRegions;
+    item->GetLayout()->Process(item.get(),m_parentID,m_renderTime,dirtyRegions);
+    item->GetLayout()->Render(item.get(), m_parentID);
+  }
+  g_graphicsContext.RestoreOrigin();
+
+  int cacheBeforeRuler, cacheAfterRuler;
+  GetRulerCacheOffsets(cacheBeforeRuler, cacheAfterRuler);
+
+  g_graphicsContext.RestoreClipRegion();
+
+  // Free memory not used on screen
+  if ((int)m_rulerItems.size() > m_blocksPerPage + cacheBeforeRuler + cacheAfterRuler)
+    FreeRulerMemory(CorrectOffset(rulerOffset - cacheBeforeRuler, 0), CorrectOffset(rulerOffset + m_blocksPerPage + 1 + cacheAfterRuler, 0));
+
+  if (m_orientation == VERTICAL)
+    g_graphicsContext.SetClipRegion(m_rulerPosX, m_rulerPosY, m_gridWidth, m_rulerHeight);
+  else
+    g_graphicsContext.SetClipRegion(m_rulerPosX, m_rulerPosY, m_rulerWidth, m_gridHeight);
+
+  CPoint originRuler = CPoint(m_rulerPosX, m_rulerPosY) + m_renderOffset;
+  pos = (m_orientation == VERTICAL) ? originRuler.x : originRuler.y;
+  end = (m_orientation == VERTICAL) ? m_posX + m_width : m_posY + m_height;
+  drawOffset = (rulerOffset - cacheBeforeRuler) * m_blockSize - m_programmeScrollOffset;
+  pos += drawOffset;
+  end += cacheAfterRuler * m_rulerLayout->Size(m_orientation == VERTICAL ? HORIZONTAL : VERTICAL);
+
+  if (rulerOffset % m_rulerUnit != 0)
+  {
+    /* first ruler marker starts before current view */
+    int startBlock = rulerOffset - 1;
+
+    while (startBlock % m_rulerUnit != 0)
+      startBlock--;
+
+    int missingSection = rulerOffset - startBlock;
+
+    pos -= missingSection * m_blockSize;
+  }
+  while (pos < end && (rulerOffset/m_rulerUnit+1) < m_rulerItems.size())
+  {
+    item = m_rulerItems[rulerOffset/m_rulerUnit+1];
+    if (m_orientation == VERTICAL)
+    {
+      g_graphicsContext.SetOrigin(pos, originRuler.y);
+      pos += m_rulerWidth;
+    }
+    else
+    {
+      g_graphicsContext.SetOrigin(originRuler.x, pos);
+      pos += m_rulerHeight;
+    }
+    if (!item->GetLayout())
+    {
+      CGUIListItemLayout *layout = new CGUIListItemLayout(*m_rulerLayout);
+      if (m_orientation == VERTICAL)
+        layout->SetWidth(m_rulerWidth);
+      else
+        layout->SetHeight(m_rulerHeight);
+
+      item->SetLayout(layout);
+    }
+    if (item->GetLayout())
+    {
+      CDirtyRegionList dirtyRegions;
+      item->GetLayout()->Process(item.get(),m_parentID,m_renderTime,dirtyRegions);
+      item->GetLayout()->Render(item.get(), m_parentID);
+    }
+    g_graphicsContext.RestoreOrigin();
+
+    rulerOffset += m_rulerUnit;
+  }
+  g_graphicsContext.RestoreClipRegion();
+
+  /// Render programmes
+  int cacheBeforeProgramme, cacheAfterProgramme;
+  GetProgrammeCacheOffsets(cacheBeforeProgramme, cacheAfterProgramme);
+
+  // Free memory not used on screen
+  if ((int)m_programmeItems.size() > m_ProgrammesPerPage + cacheBeforeProgramme + cacheAfterProgramme)
+    FreeProgrammeMemory(CorrectOffset(blockOffset - cacheBeforeProgramme, 0), CorrectOffset(blockOffset + m_ProgrammesPerPage + 1 + cacheAfterProgramme, 0));
+
+  g_graphicsContext.SetClipRegion(m_gridPosX, m_gridPosY, m_gridWidth, m_gridHeight);
+  CPoint originProgramme = CPoint(m_gridPosX, m_gridPosY) + m_renderOffset;
+  float posA = (m_orientation != VERTICAL) ? originProgramme.y : originProgramme.x;
+  float endA = (m_orientation != VERTICAL) ? m_posY + m_height : m_posX + m_width;
+  float posB = (m_orientation == VERTICAL) ? originProgramme.y : originProgramme.x;
+  float endB = (m_orientation == VERTICAL) ? m_gridPosY + m_gridHeight : m_posX + m_width;
+  endA += cacheAfterProgramme * m_blockSize;
+
+  float DrawOffsetA = blockOffset * m_blockSize - m_programmeScrollOffset;
+  posA += DrawOffsetA;
+  float DrawOffsetB = (chanOffset - cacheBeforeProgramme) * m_channelLayout->Size(m_orientation) - m_channelScrollOffset;
+  posB += DrawOffsetB;
+
+  int channel = chanOffset;
+
+  float focusedPosX = 0;
+  float focusedPosY = 0;
+  float focusedwidth = 0;
+  float focusedheight = 0;
+  while (posB < endB && m_channelItems.size())
+  {
+    if (channel >= (int)m_channelItems.size())
+      break;
+
+    int block = blockOffset;
+    float posA2 = posA;
+
+    CGUIListItemPtr item = m_gridIndex[channel][block].item;
+    if (blockOffset > 0 && item == m_gridIndex[channel][blockOffset-1].item)
+    {
+      /* first program starts before current view */
+      int startBlock = blockOffset - 1;
+      while (m_gridIndex[channel][startBlock].item == item)
+        startBlock--;
+
+      block = startBlock + 1;
+      int missingSection = blockOffset - block;
+      posA2 -= missingSection * m_blockSize;
+    }
+
+    while (posA2 < endA && m_programmeItems.size())   // FOR EACH ITEM ///////////////
+    {
+      item = m_gridIndex[channel][block].item;
+      if (!item || !item.get()->IsFileItem())
+        break;
+
+      bool focused = (channel == m_channelOffset + m_channelCursor) && (item == m_gridIndex[m_channelOffset + m_channelCursor][m_blockOffset + m_blockCursor].item);
+
+      // render our item
+      if (focused)
+      {
+        if (m_orientation == VERTICAL)
+        {
+          focusedPosX = posA2;
+          focusedPosY = posB;
+        }
+        else
+        {
+          focusedPosX = posB;
+          focusedPosY = posA2;
+        }
+        focusedItem = item;
+        focusedwidth = m_gridIndex[channel][block].width;
+        focusedheight = m_gridIndex[channel][block].height;
+      }
+      else
+      {
+        if (m_orientation == VERTICAL)
+          RenderProgrammeItem(posA2, posB, m_gridIndex[channel][block].width, m_gridIndex[channel][block].height, item.get(), focused);
+        else
+          RenderProgrammeItem(posB, posA2, m_gridIndex[channel][block].width, m_gridIndex[channel][block].height, item.get(), focused);
+      }
+
+      // increment our X position
+      if (m_orientation == VERTICAL)
+      {
+        posA2 += m_gridIndex[channel][block].width; // assumes focused & unfocused layouts have equal length
+        block += (int)(m_gridIndex[channel][block].width / m_blockSize);
+      }
+      else
+      {
+        posA2 += m_gridIndex[channel][block].height; // assumes focused & unfocused layouts have equal length
+        block += (int)(m_gridIndex[channel][block].height / m_blockSize);
+      }
+    }
+
+    // increment our Y position
+    channel++;
+    posB += m_orientation == VERTICAL ? m_channelHeight : m_channelWidth;
+  }
+
+  // and render the focused item last (for overlapping purposes)
+  if (focusedItem)
+    RenderProgrammeItem(focusedPosX, focusedPosY, focusedwidth, focusedheight, focusedItem.get(), true);
+
+  g_graphicsContext.RestoreClipRegion();
+
+  CGUIControl::Render();
+}
+
+void CGUIEPGGridContainer::RenderChannelItem(float posX, float posY, CGUIListItem *item, bool focused)
+{
+  if (!m_focusedChannelLayout || !m_channelLayout) return;
+
+  // set the origin
+  g_graphicsContext.SetOrigin(posX, posY);
+
+  if (m_bInvalidated)
+    item->SetInvalid();
+  if (focused)
+  {
+    if (!item->GetFocusedLayout())
+    {
+      CGUIListItemLayout *layout = new CGUIListItemLayout(*m_focusedChannelLayout);
+      item->SetFocusedLayout(layout);
+    }
+    if (item->GetFocusedLayout())
+    {
+      if (item != m_lastChannel || !HasFocus())
+      {
+        item->GetFocusedLayout()->SetFocusedItem(0);
+      }
+      if (item != m_lastChannel && HasFocus())
+      {
+        item->GetFocusedLayout()->ResetAnimation(ANIM_TYPE_UNFOCUS);
+        unsigned int subItem = 1;
+        if (m_lastChannel && m_lastChannel->GetFocusedLayout())
+          subItem = m_lastChannel->GetFocusedLayout()->GetFocusedItem();
+        item->GetFocusedLayout()->SetFocusedItem(subItem ? subItem : 1);
+      }
+      CDirtyRegionList dirtyRegions;
+      item->GetFocusedLayout()->Process(item,m_parentID,m_renderTime,dirtyRegions);
+      item->GetFocusedLayout()->Render(item, m_parentID);
+    }
+    m_lastChannel = item;
+  }
+  else
+  {
+    if (item->GetFocusedLayout())
+      item->GetFocusedLayout()->SetFocusedItem(0);  // focus is not set
+    if (!item->GetLayout())
+    {
+      CGUIListItemLayout *layout = new CGUIListItemLayout(*m_channelLayout);
+      item->SetLayout(layout);
+    }
+    if (item->GetFocusedLayout() && item->GetFocusedLayout()->IsAnimating(ANIM_TYPE_UNFOCUS))
+    {
+      CDirtyRegionList dirtyRegions;
+      item->GetFocusedLayout()->Process(item,m_parentID,m_renderTime,dirtyRegions);
+      item->GetFocusedLayout()->Render(item, m_parentID);
+    }
+    else if (item->GetLayout())
+    {
+      CDirtyRegionList dirtyRegions;
+      item->GetLayout()->Process(item,m_parentID,m_renderTime,dirtyRegions);
+      item->GetLayout()->Render(item, m_parentID);
+    }
+  }
+  g_graphicsContext.RestoreOrigin();
+}
+
+void CGUIEPGGridContainer::RenderProgrammeItem(float posX, float posY, float width, float height, CGUIListItem *item, bool focused)
+{
+  if (!m_focusedProgrammeLayout || !m_programmeLayout) return;
+
+  // set the origin
+  g_graphicsContext.SetOrigin(posX, posY);
+
+  if (m_bInvalidated)
+    item->SetInvalid();
+  if (focused)
+  {
+    if (!item->GetFocusedLayout())
+    {
+      CGUIListItemLayout *layout = new CGUIListItemLayout(*m_focusedProgrammeLayout);
+      CFileItem *fileItem = item->IsFileItem() ? (CFileItem *)item : NULL;
+      if (fileItem)
+      {
+        const CEpgInfoTag* tag = fileItem->GetEPGInfoTag();
+        if (m_orientation == VERTICAL)
+          layout->SetWidth(width);
+        else
+          layout->SetHeight(height);
+
+        item->SetProperty("GenreType", tag->GenreType());
+      }
+      item->SetFocusedLayout(layout);
+    }
+    if (item->GetFocusedLayout())
+    {
+      if (item != m_lastItem || !HasFocus())
+      {
+        item->GetFocusedLayout()->SetFocusedItem(0);
+      }
+      if (item != m_lastItem && HasFocus())
+      {
+        item->GetFocusedLayout()->ResetAnimation(ANIM_TYPE_UNFOCUS);
+        unsigned int subItem = 1;
+        if (m_lastItem && m_lastItem->GetFocusedLayout())
+          subItem = m_lastItem->GetFocusedLayout()->GetFocusedItem();
+        item->GetFocusedLayout()->SetFocusedItem(subItem ? subItem : 1);
+      }
+      CDirtyRegionList dirtyRegions;
+      item->GetFocusedLayout()->Process(item,m_parentID,m_renderTime,dirtyRegions);
+      item->GetFocusedLayout()->Render(item, m_parentID);
+    }
+    m_lastItem = item;
+  }
+  else
+  {
+    if (item->GetFocusedLayout())
+      item->GetFocusedLayout()->SetFocusedItem(0);  // focus is not set
+    if (!item->GetLayout())
+    {
+      CGUIListItemLayout *layout = new CGUIListItemLayout(*m_programmeLayout);
+      CFileItem *fileItem = item->IsFileItem() ? (CFileItem *)item : NULL;
+      if (fileItem)
+      {
+        const CEpgInfoTag* tag = fileItem->GetEPGInfoTag();
+        if (m_orientation == VERTICAL)
+          layout->SetWidth(width);
+        else
+          layout->SetHeight(height);
+
+        item->SetProperty("GenreType", tag->GenreType());
+      }
+      item->SetLayout(layout);
+    }
+    if (item->GetFocusedLayout() && item->GetFocusedLayout()->IsAnimating(ANIM_TYPE_UNFOCUS))
+    {
+      CDirtyRegionList dirtyRegions;
+      item->GetFocusedLayout()->Process(item,m_parentID,m_renderTime,dirtyRegions);
+      item->GetFocusedLayout()->Render(item, m_parentID);
+    }
+    else if (item->GetLayout())
+    {
+      CDirtyRegionList dirtyRegions;
+      item->GetLayout()->Process(item,m_parentID,m_renderTime,dirtyRegions);
+      item->GetLayout()->Render(item, m_parentID);
+    }
+  }
+  g_graphicsContext.RestoreOrigin();
+}
+
+bool CGUIEPGGridContainer::OnAction(const CAction &action)
+{
+  switch (action.GetID())
+  {
+  case ACTION_MOVE_LEFT:
+  case ACTION_MOVE_RIGHT:
+  case ACTION_MOVE_DOWN:
+  case ACTION_MOVE_UP:
+    { // use base class implementation
+
+      return CGUIControl::OnAction(action);
+    }
+
+    break;
+  case ACTION_PAGE_UP:
+    {
+      if (m_orientation == VERTICAL)
+      {
+        if (m_channelOffset == 0)
+        { // already on the first page, so move to the first item
+          SetChannel(0);
+        }
+        else
+        { // scroll up to the previous page
+          ChannelScroll(-m_channelsPerPage);
+        }
+      }
+      else
+        ProgrammesScroll(-m_blocksPerPage/4);
+
+      return true;
+    }
+
+    break;
+  case ACTION_PAGE_DOWN:
+    {
+      if (m_orientation == VERTICAL)
+      {
+        if (m_channelOffset == m_channels - m_channelsPerPage || m_channels < m_channelsPerPage)
+        { // already at the last page, so move to the last item.
+          SetChannel(m_channels - m_channelOffset - 1);
+        }
+        else
+        { // scroll down to the next page
+          ChannelScroll(m_channelsPerPage);
+        }
+      }
+      else
+        ProgrammesScroll(m_blocksPerPage/4);
+
+      return true;
+    }
+
+    break;
+
+    // smooth scrolling (for analog controls)
+  case ACTION_TELETEXT_RED:
+  case ACTION_TELETEXT_GREEN:
+  case ACTION_SCROLL_UP: // left horizontal scrolling
+    {
+      int blocksToJump = action.GetID() == ACTION_TELETEXT_RED ? m_blocksPerPage/2 : m_blocksPerPage/4;
+
+      m_analogScrollCount += action.GetAmount() * action.GetAmount();
+      bool handled = false;
+
+      while (m_analogScrollCount > 0.4)
+      {
+        handled = true;
+        m_analogScrollCount -= 0.4f;
+
+        if (m_blockOffset > 0 && m_blockCursor <= m_blocksPerPage / 2)
+        {
+          ProgrammesScroll(-blocksToJump);
+        }
+        else if (m_blockCursor > blocksToJump)
+        {
+          SetBlock(m_blockCursor - blocksToJump);
+        }
+      }
+
+      return handled;
+    }
+
+    break;
+
+  case ACTION_TELETEXT_BLUE:
+  case ACTION_TELETEXT_YELLOW:
+  case ACTION_SCROLL_DOWN: // right horizontal scrolling
+    {
+      int blocksToJump = action.GetID() == ACTION_TELETEXT_BLUE ? m_blocksPerPage/2 : m_blocksPerPage/4;
+
+      m_analogScrollCount += action.GetAmount() * action.GetAmount();
+      bool handled = false;
+
+      while (m_analogScrollCount > 0.4)
+      {
+        handled = true;
+        m_analogScrollCount -= 0.4f;
+
+        if (m_blockOffset + m_blocksPerPage < m_blocks && m_blockCursor >= m_blocksPerPage / 2)
+        {
+          ProgrammesScroll(blocksToJump);
+        }
+        else if (m_blockCursor < m_blocksPerPage - blocksToJump && m_blockOffset + m_blockCursor < m_blocks - blocksToJump)
+        {
+          SetBlock(m_blockCursor + blocksToJump);
+        }
+      }
+
+      return handled;
+    }
+
+    break;
+
+  default:
+    if (action.GetID())
+      return OnClick(action.GetID());
+    break;
+  }
+
+  return false;
+}
+
+bool CGUIEPGGridContainer::OnMessage(CGUIMessage& message)
+{
+  if (message.GetControlId() == GetID())
+  {
+    if (message.GetMessage() == GUI_MSG_ITEM_SELECTED)
+    {
+      message.SetParam1(GetSelectedItem());
+      return true;
+    }
+    else if (message.GetMessage() == GUI_MSG_LABEL_BIND && message.GetPointer())
+    {
+      Reset();
+      CFileItemList *items = (CFileItemList *)message.GetPointer();
+
+      /* Create Channel items */
+      int iLastChannelNumber = -1;
+      ItemsPtr itemsPointer;
+      itemsPointer.start = 0;
+      for (int i = 0; i < items->Size(); ++i)
+      {
+        const CEpgInfoTag* tag = items->Get(i)->GetEPGInfoTag();
+        if (!tag || !tag->HasPVRChannel())
+          continue;
+
+        int iCurrentChannelNumber = tag->PVRChannelNumber();
+        if (iCurrentChannelNumber != iLastChannelNumber)
+        {
+          CPVRChannelPtr channel = tag->ChannelTag();
+          if (!channel)
+            continue;
+
+          if (i > 0)
+          {
+            itemsPointer.stop = i-1;
+            m_epgItemsPtr.push_back(itemsPointer);
+            itemsPointer.start = i;
+          }
+          iLastChannelNumber = iCurrentChannelNumber;
+          CGUIListItemPtr item(new CFileItem(*channel));
+          m_channelItems.push_back(item);
+        }
+      }
+      if (items->Size() > 0)
+      {
+        itemsPointer.stop = items->Size()-1;
+        m_epgItemsPtr.push_back(itemsPointer);
+      }
+
+      /* Create programme items */
+      for (int i = 0; i < items->Size(); i++)
+        m_programmeItems.push_back(items->Get(i));
+
+      ClearGridIndex();
+      m_gridIndex = (struct GridItemsPtr **) calloc(1,m_channelItems.size()*sizeof(struct GridItemsPtr));
+      if (m_gridIndex != NULL)
+      {
+        for (unsigned int i = 0; i < m_channelItems.size(); i++)
+        {
+          m_gridIndex[i] = (struct GridItemsPtr*) calloc(1,MAXBLOCKS*sizeof(struct GridItemsPtr));
+        }
+      }
+
+      UpdateLayout(true); // true to refresh all items
+
+      /* Create Ruler items */
+      CDateTime ruler; ruler.SetFromUTCDateTime(m_gridStart);
+      CDateTimeSpan unit(0, 0, m_rulerUnit * MINSPERBLOCK, 0);
+      CGUIListItemPtr rulerItem(new CFileItem(ruler.GetAsLocalizedDate(true, true)));
+      rulerItem->SetProperty("DateLabel", true);
+      m_rulerItems.push_back(rulerItem);
+
+      for (; ruler < m_gridEnd; ruler += unit)
+      {
+        CGUIListItemPtr rulerItem(new CFileItem(ruler.GetAsLocalizedTime("", false)));
+        rulerItem->SetLabel2(ruler.GetAsLocalizedDate(true, true));
+        m_rulerItems.push_back(rulerItem);
+      }
+
+      UpdateItems();
+      //SelectItem(message.GetParam1());
+      return true;
+    }
+    else if (message.GetMessage() == GUI_MSG_REFRESH_LIST)
+    { // update our list contents
+      for (unsigned int i = 0; i < m_channelItems.size(); ++i)
+        m_channelItems[i]->SetInvalid();
+      for (unsigned int i = 0; i < m_programmeItems.size(); ++i)
+        m_programmeItems[i]->SetInvalid();
+      for (unsigned int i = 0; i < m_rulerItems.size(); ++i)
+        m_rulerItems[i]->SetInvalid();
+    }
+  }
+
+  return CGUIControl::OnMessage(message);
+}
+
+void CGUIEPGGridContainer::UpdateItems()
+{
+  CDateTimeSpan blockDuration, gridDuration;
+
+  /* check for invalid start and end time */
+  if (m_gridStart >= m_gridEnd)
+  {
+    CLog::Log(LOGERROR, "CGUIEPGGridContainer - %s - invalid start and end time set", __FUNCTION__);
+    CGUIMessage msg(GUI_MSG_LABEL_RESET, GetID(), GetParentID()); // message the window
+    SendWindowMessage(msg);
+    return;
+  }
+
+  gridDuration = m_gridEnd - m_gridStart;
+
+  m_blocks = (gridDuration.GetDays()*24*60 + gridDuration.GetHours()*60 + gridDuration.GetMinutes()) / MINSPERBLOCK;
+  if (m_blocks >= MAXBLOCKS)
+    m_blocks = MAXBLOCKS;
+
+  /* if less than one page, can't display grid */
+  if (m_blocks < m_blocksPerPage)
+  {
+    CLog::Log(LOGERROR, "(%s) - Less than one page of data available.", __FUNCTION__);
+    CGUIMessage msg(GUI_MSG_LABEL_RESET, GetID(), GetParentID()); // message the window
+    SendWindowMessage(msg);
+    return;
+  }
+
+  blockDuration.SetDateTimeSpan(0, 0, MINSPERBLOCK, 0);
+
+  long tick(XbmcThreads::SystemClockMillis());
+
+  for (unsigned int row = 0; row < m_channelItems.size(); ++row)
+  {
+    CDateTime gridCursor  = m_gridStart; //reset cursor for new channel
+    unsigned long progIdx = m_epgItemsPtr[row].start;
+    unsigned long lastIdx = m_epgItemsPtr[row].stop;
+    int iEpgId            = ((CFileItem *)m_programmeItems[progIdx].get())->GetEPGInfoTag()->EpgID();
+
+    /** FOR EACH BLOCK **********************************************************************/
+
+    for (int block = 0; block < m_blocks; block++)
+    {
+      while (progIdx <= lastIdx)
+      {
+        CGUIListItemPtr item = m_programmeItems[progIdx];
+        const CEpgInfoTag* tag = ((CFileItem *)item.get())->GetEPGInfoTag();
+        if (tag == NULL)
+          progIdx++;
+
+        if (tag->EpgID() != iEpgId)
+          break;
+
+        if (m_gridEnd <= tag->StartAsUTC())
+        {
+          break;
+        }
+        else if (gridCursor >= tag->EndAsUTC())
+        {
+          progIdx++;
+        }
+        else if (gridCursor < tag->EndAsUTC())
+        {
+          m_gridIndex[row][block].item = item;
+          break;
+        }
+        else
+        {
+          progIdx++;
+        }
+      }
+
+      gridCursor += blockDuration;
+    }
+
+    /** FOR EACH BLOCK **********************************************************************/
+    int itemSize = 1; // size of the programme in blocks
+    int savedBlock = 0;
+
+    for (int block = 0; block < m_blocks; block++)
+    {
+      if (m_gridIndex[row][block].item != m_gridIndex[row][block+1].item)
+      {
+        if (!m_gridIndex[row][block].item)
+        {
+          CEpgInfoTag broadcast;
+          CFileItemPtr unknown(new CFileItem(broadcast));
+          for (int i = block ; i > block - itemSize; i--)
+          {
+            m_gridIndex[row][i].item = unknown;
+          }
+        }
+
+        CGUIListItemPtr item = m_gridIndex[row][block].item;
+        CFileItem *fileItem = (CFileItem *)item.get();
+
+        m_gridIndex[row][savedBlock].item->SetProperty("GenreType", fileItem->GetEPGInfoTag()->GenreType());
+        if (m_orientation == VERTICAL)
+        {
+          m_gridIndex[row][savedBlock].width   = itemSize*m_blockSize;
+          m_gridIndex[row][savedBlock].height  = m_channelHeight;
+        }
+        else
+        {
+          m_gridIndex[row][savedBlock].width   = m_channelWidth;
+          m_gridIndex[row][savedBlock].height  = itemSize*m_blockSize;
+        }
+
+        itemSize = 1;
+        savedBlock = block+1;
+      }
+      else
+      {
+        itemSize++;
+      }
+    }
+  }
+
+  /******************************************* END ******************************************/
+
+  CLog::Log(LOGDEBUG, "%s completed successfully in %u ms", __FUNCTION__, (unsigned int)(XbmcThreads::SystemClockMillis()-tick));
+
+  m_channels = (int)m_epgItemsPtr.size();
+  m_item = GetItem(m_channelCursor);
+  if (m_item)
+    m_blockCursor = GetBlock(m_item->item, m_channelCursor);
+
+  SetInvalid();
+}
+
+void CGUIEPGGridContainer::ChannelScroll(int amount)
+{
+  // increase or decrease the vertical offset
+  int offset = m_channelOffset + amount;
+
+  if (offset > m_channels - m_channelsPerPage)
+  {
+    offset = m_channels - m_channelsPerPage;
+  }
+
+  if (offset < 0) offset = 0;
+
+  ScrollToChannelOffset(offset);
+}
+
+void CGUIEPGGridContainer::ProgrammesScroll(int amount)
+{
+  // increase or decrease the horizontal offset
+  int offset = m_blockOffset + amount;
+
+  if (offset > m_blocks - m_blocksPerPage)
+  {
+    offset = m_blocks - m_blocksPerPage;
+  }
+
+  if (offset < 0) offset = 0;
+
+  ScrollToBlockOffset(offset);
+}
+
+bool CGUIEPGGridContainer::MoveChannel(bool direction)
+{
+  if (direction)
+  {
+    if (m_channelCursor > 0)
+    {
+      SetChannel(m_channelCursor - 1);
+    }
+    else if (m_channelCursor == 0 && m_channelOffset)
+    {
+      ScrollToChannelOffset(m_channelOffset - 1);
+      SetChannel(0);
+    }
+    else if (m_channelWrapAround)
+    {
+      int offset = m_channels - m_channelsPerPage;
+
+      if (offset < 0) offset = 0;
+
+      SetChannel(m_channels - offset - 1);
+
+      ScrollToChannelOffset(offset);
+    }
+    else
+      return false;
+  }
+  else
+  {
+    if (m_channelOffset + m_channelCursor + 1 < m_channels)
+    {
+      if (m_channelCursor + 1 < m_channelsPerPage)
+      {
+        SetChannel(m_channelCursor + 1);
+      }
+      else
+      {
+        ScrollToChannelOffset(m_channelOffset + 1);
+        SetChannel(m_channelsPerPage - 1);
+      }
+    }
+    else if (m_channelWrapAround)
+    {
+      SetChannel(0);
+      ScrollToChannelOffset(0);
+    }
+    else
+      return false;
+  }
+  return true;
+}
+
+bool CGUIEPGGridContainer::MoveProgrammes(bool direction)
+{
+  if (!m_gridIndex || !m_item)
+    return false;
+
+  if (direction)
+  {
+    if (m_channelCursor + m_channelOffset < 0 || m_blockOffset < 0)
+      return false;
+
+    if (m_item->item != m_gridIndex[m_channelCursor + m_channelOffset][m_blockOffset].item)
+    {
+      // this is not first item on page
+      m_item = GetPrevItem(m_channelCursor);
+      m_blockCursor = GetBlock(m_item->item, m_channelCursor);
+    }
+    else if (m_blockCursor <= 0 && m_blockOffset)
+    {
+      // we're at the left edge and offset
+      int itemSize = GetItemSize(m_item);
+      int block = GetRealBlock(m_item->item, m_channelCursor);
+
+      if (block < m_blockOffset) /* current item begins before current offset, keep selected */
+      {
+        if (itemSize > m_blocksPerPage) /* current item is longer than one page, scroll one page left */
+        {
+          m_blockOffset < m_blocksPerPage ? block = 0 : block = m_blockOffset - m_blocksPerPage; // number blocks left < m_blocksPerPAge
+          ScrollToBlockOffset(block);
+          SetBlock(0);
+        }
+        else /* current item is shorter than one page, scroll left to start of item */
+        {
+          ScrollToBlockOffset(block); // -1?
+          SetBlock(0); // align cursor to left edge
+        }
+      }
+      else /* current item starts on this page's edge, select the previous item */
+      {
+        m_item = GetPrevItem(m_channelCursor);
+        itemSize = GetItemSize(m_item);
+
+        if (itemSize > m_blocksPerPage) // previous item is longer than one page, scroll left to last page of item */
+        {
+          ScrollToBlockOffset(m_blockOffset - m_blocksPerPage); // left one whole page
+          //SetBlock(m_blocksPerPage -1 ); // helps navigation by setting cursor to far right edge
+          SetBlock(0); // align cursor to left edge
+        }
+        else /* previous item is shorter than one page, scroll left to start of item */
+        {
+          ScrollToBlockOffset(m_blockOffset - itemSize);
+          SetBlock(0); //should be zero
+        }
+      }
+    }
+    else
+      return false;
+  }
+  else
+  {
+    if (m_item->item != m_gridIndex[m_channelCursor + m_channelOffset][m_blocksPerPage + m_blockOffset - 1].item)
+    {
+      // this is not last item on page
+      m_item = GetNextItem(m_channelCursor);
+      m_blockCursor = GetBlock(m_item->item, m_channelCursor);
+    }
+    else if ((m_blockOffset != m_blocks - m_blocksPerPage) && m_blocks > m_blocksPerPage)
+    {
+      // at right edge, more than one page and not at maximum offset
+      int itemSize = GetItemSize(m_item);
+      int block = GetRealBlock(m_item->item, m_channelCursor);
+
+      if (itemSize > m_blocksPerPage - m_blockCursor) // current item extends into next page, keep selected
+      {
+        if (itemSize > m_blocksPerPage) // current item is longer than one page, scroll one page right
+        {
+          if (m_blockOffset && m_blockOffset + m_blocksPerPage > m_blocks)
+            block = m_blocks - m_blocksPerPage;
+          else
+            block = m_blockOffset + m_blocksPerPage;
+
+          ScrollToBlockOffset(block);
+
+          SetBlock(0);
+        }
+        else // current item is shorter than one page, scroll so end of item sits on end of grid
+        {
+          ScrollToBlockOffset(block + itemSize - m_blocksPerPage);
+          SetBlock(GetBlock(m_item->item, m_channelCursor)); /// change to middle block of item?
+        }
+      }
+      else // current item finishes on this page's edge, select the next item
+      {
+        m_item = GetNextItem(m_channelCursor);
+        itemSize = GetItemSize(m_item);
+
+        if (itemSize > m_blocksPerPage) // next item is longer than one page, scroll to first page of this item
+        {
+          ScrollToBlockOffset(m_blockOffset + m_blocksPerPage);
+          SetBlock(0);
+        }
+        else // next item is shorter than one page, scroll so end of item sits on end of grid
+        {
+          ScrollToBlockOffset(m_blockOffset + itemSize);
+          SetBlock(m_blocksPerPage - itemSize); /// change to middle block of item?
+        }
+      }
+    }
+    else
+      return false;
+  }
+  return true;
+}
+
+void CGUIEPGGridContainer::OnUp()
+{
+  if (m_orientation == VERTICAL)
+  {
+    if (!MoveChannel(true))
+      CGUIControl::OnUp();
+  }
+  else
+  {
+    if (!MoveProgrammes(true))
+      CGUIControl::OnUp();
+  }
+}
+
+void CGUIEPGGridContainer::OnDown()
+{
+  if (m_orientation == VERTICAL)
+  {
+    if (!MoveChannel(false))
+      CGUIControl::OnDown();
+  }
+  else
+  {
+    if (!MoveProgrammes(false))
+      CGUIControl::OnDown();
+  }
+}
+
+void CGUIEPGGridContainer::OnLeft()
+{
+  if (m_orientation == VERTICAL)
+  {
+    if (!MoveProgrammes(true))
+      CGUIControl::OnLeft();
+  }
+  else
+  {
+    if (!MoveChannel(true))
+      CGUIControl::OnLeft();
+  }
+}
+
+void CGUIEPGGridContainer::OnRight()
+{
+  if (m_orientation == VERTICAL)
+  {
+    if (!MoveProgrammes(false))
+      CGUIControl::OnRight();
+  }
+  else
+  {
+    if (!MoveChannel(false))
+      CGUIControl::OnRight();
+  }
+}
+
+void CGUIEPGGridContainer::SetChannel(const CStdString &channel)
+{
+  int iChannelIndex(-1);
+  for (unsigned int iIndex = 0; iIndex < m_channelItems.size(); iIndex++)
+  {
+    CStdString strPath = m_channelItems[iIndex]->GetProperty("path").asString(StringUtils::EmptyString);
+    if (strPath == channel)
+    {
+      iChannelIndex = iIndex;
+      break;
+    }
+  }
+
+  if (iChannelIndex >= 0)
+    ScrollToChannelOffset(iChannelIndex);
+}
+
+void CGUIEPGGridContainer::SetChannel(const CPVRChannel &channel)
+{
+  int iChannelIndex(-1);
+  for (unsigned int iIndex = 0; iIndex < m_channelItems.size(); iIndex++)
+  {
+    int iChannelId = m_channelItems[iIndex]->GetProperty("channelid").asInteger(-1);
+    if (iChannelId == channel.ChannelID())
+    {
+      iChannelIndex = iIndex;
+      break;
+    }
+  }
+
+  if (iChannelIndex >= 0)
+    ScrollToChannelOffset(iChannelIndex);
+}
+
+void CGUIEPGGridContainer::SetChannel(int channel)
+{
+  if (m_blockCursor + m_blockOffset == 0 || m_blockOffset + m_blockCursor + GetItemSize(m_item) == m_blocks)
+  {
+    m_item          = GetItem(channel);
+    if (m_item)
+    {
+      m_blockCursor   = GetBlock(m_item->item, channel);
+      m_channelCursor = channel;
+    }
+    return;
+  }
+
+  /* basic checks failed, need to correctly identify nearest item */
+  m_item          = GetClosestItem(channel);
+  if (m_item)
+  {
+    m_channelCursor = channel;
+    m_blockCursor   = GetBlock(m_item->item, m_channelCursor);
+  }
+}
+
+void CGUIEPGGridContainer::SetBlock(int block)
+{
+  m_blockCursor = block;
+  m_item        = GetItem(m_channelCursor);
+}
+
+CGUIListItemLayout *CGUIEPGGridContainer::GetFocusedLayout() const
+{
+  CGUIListItemPtr item = GetListItem(0);
+
+  if (item.get()) return item->GetFocusedLayout();
+
+  return NULL;
+}
+
+bool CGUIEPGGridContainer::SelectItemFromPoint(const CPoint &point)
+{
+  /* point has already had origin set to m_posX, m_posY */
+  if (!m_focusedProgrammeLayout || !m_programmeLayout)
+    return false;
+
+  int channel = (int)(point.y / m_channelHeight);
+  int block   = (int)(point.x / m_blockSize);
+
+  if (channel > m_channelsPerPage) channel = m_channelsPerPage - 1;
+  if (channel >= m_channels) channel = m_channels - 1;
+  if (channel < 0) channel = 0;
+  if (block > m_blocksPerPage) block = m_blocksPerPage - 1;
+  if (block < 0) block = 0;
+
+  SetChannel(channel);
+  SetBlock(block);
+  return true;
+}
+
+EVENT_RESULT CGUIEPGGridContainer::OnMouseEvent(const CPoint &point, const CMouseEvent &event)
+{
+  switch (event.m_id)
+  {
+  case ACTION_MOUSE_LEFT_CLICK:
+    OnMouseClick(0, point);
+    return EVENT_RESULT_HANDLED;
+  case ACTION_MOUSE_RIGHT_CLICK:
+    OnMouseClick(1, point);
+    return EVENT_RESULT_HANDLED;
+  case ACTION_MOUSE_DOUBLE_CLICK:
+    OnMouseDoubleClick(0, point);
+    return EVENT_RESULT_HANDLED;
+  case ACTION_MOUSE_WHEEL_UP:
+    OnMouseWheel(-1, point);
+    return EVENT_RESULT_HANDLED;
+  case ACTION_MOUSE_WHEEL_DOWN:
+    OnMouseWheel(1, point);
+    return EVENT_RESULT_HANDLED;
+  default:
+    return EVENT_RESULT_UNHANDLED;
+  }
+}
+
+bool CGUIEPGGridContainer::OnMouseOver(const CPoint &point)
+{
+  // select the item under the pointer
+  SelectItemFromPoint(point - CPoint(m_gridPosX, m_posY + m_rulerHeight));
+  return CGUIControl::OnMouseOver(point);
+}
+
+bool CGUIEPGGridContainer::OnMouseClick(int dwButton, const CPoint &point)
+{
+  if (SelectItemFromPoint(point - CPoint(m_gridPosX, m_posY + m_rulerHeight)))
+  { // send click message to window
+    OnClick(ACTION_MOUSE_LEFT_CLICK + dwButton);
+    return true;
+  }
+
+  return false;
+}
+
+bool CGUIEPGGridContainer::OnMouseDoubleClick(int dwButton, const CPoint &point)
+{
+  if (SelectItemFromPoint(point - CPoint(m_gridPosX, m_posY + m_rulerHeight)))
+  { // send double click message to window
+    OnClick(ACTION_MOUSE_DOUBLE_CLICK + dwButton);
+    return true;
+  }
+
+  return false;
+}
+
+bool CGUIEPGGridContainer::OnClick(int actionID)
+{
+  int subItem = 0;
+
+  if (actionID == ACTION_SELECT_ITEM || actionID == ACTION_MOUSE_LEFT_CLICK)
+  {
+    // grab the currently focused subitem (if applicable)
+    CGUIListItemLayout *focusedLayout = GetFocusedLayout();
+
+    if (focusedLayout)
+      subItem = focusedLayout->GetFocusedItem();
+  }
+
+  // Don't know what to do, so send to our parent window.
+  CGUIMessage msg(GUI_MSG_CLICKED, GetID(), GetParentID(), actionID, subItem);
+  return SendWindowMessage(msg);
+}
+
+bool CGUIEPGGridContainer::OnMouseWheel(char wheel, const CPoint &point)
+{
+  ///doesn't work while an item is selected?
+  ProgrammesScroll(-wheel);
+  return true;
+}
+
+int CGUIEPGGridContainer::GetSelectedItem() const
+{
+  if (!m_gridIndex ||
+      !m_epgItemsPtr.size() ||
+      m_channelCursor + m_channelCursor >= (int)m_channelItems.size() ||
+      m_blockCursor + m_blockOffset >= (int)m_programmeItems.size())
+    return 0;
+
+  CGUIListItemPtr currentItem = m_gridIndex[m_channelCursor + m_channelOffset][m_blockCursor + m_blockOffset].item;
+  if (!currentItem)
+    return 0;
+
+  for (int i = 0; i < (int)m_programmeItems.size(); i++)
+  {
+    if (currentItem == m_programmeItems[i])
+      return i;
+  }
+  return 0;
+}
+
+CGUIListItemPtr CGUIEPGGridContainer::GetListItem(int offset) const
+{
+  if (!m_epgItemsPtr.size())
+    return CGUIListItemPtr();
+
+  return m_item->item;
+}
+
+GridItemsPtr *CGUIEPGGridContainer::GetClosestItem(const int &channel)
+{
+  GridItemsPtr *closest = GetItem(channel);
+
+  if(!closest)
+    return NULL;
+
+  int block = GetBlock(closest->item, channel);
+  int left;   // num blocks to start of previous item
+  int right;  // num blocks to start of next item
+
+  if (block == m_blockCursor)
+    return closest; // item & m_item start together
+
+  if (block + GetItemSize(closest) == m_blockCursor + GetItemSize(m_item))
+    return closest; // closest item ends when current does
+
+  if (block > m_blockCursor)  // item starts after m_item
+  {
+    left = m_blockCursor - GetBlock(closest->item, channel);
+    right = block - m_blockCursor;
+  }
+  else
+  {
+    left  = m_blockCursor - block;
+    right = GetBlock(GetNextItem(channel)->item, channel) - m_blockCursor;
+  }
+
+  if (right <= SHORTGAP && right <= left && m_blockCursor + right < m_blocksPerPage)
+    return &m_gridIndex[channel + m_channelOffset][m_blockCursor + right + m_blockOffset];
+
+  return &m_gridIndex[channel + m_channelOffset][m_blockCursor - left  + m_blockOffset];
+}
+
+int CGUIEPGGridContainer::GetItemSize(GridItemsPtr *item)
+{
+  if (!item)
+    return (int) m_blockSize; /// stops it crashing
+
+  return (int) ((m_orientation == VERTICAL ? item->width : item->height) / m_blockSize);
+}
+
+int CGUIEPGGridContainer::GetBlock(const CGUIListItemPtr &item, const int &channel)
+{
+  if (!item)
+    return 0;
+
+  return GetRealBlock(item, channel) - m_blockOffset;
+}
+
+int CGUIEPGGridContainer::GetRealBlock(const CGUIListItemPtr &item, const int &channel)
+{
+  int block = 0;
+
+  while (m_gridIndex[channel + m_channelOffset][block].item != item && block < m_blocks)
+    block++;
+
+  return block;
+}
+
+GridItemsPtr *CGUIEPGGridContainer::GetNextItem(const int &channel)
+{
+  int i = m_blockCursor;
+
+  while (m_gridIndex[channel + m_channelOffset][i + m_blockOffset].item == m_gridIndex[channel + m_channelOffset][m_blockCursor + m_blockOffset].item && i < m_blocksPerPage)
+    i++;
+
+  return &m_gridIndex[channel + m_channelOffset][i + m_blockOffset];
+}
+
+GridItemsPtr *CGUIEPGGridContainer::GetPrevItem(const int &channel)
+{
+  int i = m_blockCursor;
+
+  while (m_gridIndex[channel + m_channelOffset][i + m_blockOffset].item == m_gridIndex[channel + m_channelOffset][m_blockCursor + m_blockOffset].item && i > 0)
+    i--;
+
+  return &m_gridIndex[channel + m_channelOffset][i + m_blockOffset];
+
+//  return &m_gridIndex[channel + m_channelOffset][m_blockCursor + m_blockOffset - 1];
+}
+
+GridItemsPtr *CGUIEPGGridContainer::GetItem(const int &channel)
+{
+  if ( (channel >= 0) && (channel < m_channels) )
+    return &m_gridIndex[channel + m_channelOffset][m_blockCursor + m_blockOffset];
+  else
+    return NULL;
+}
+
+void CGUIEPGGridContainer::SetFocus(bool bOnOff)
+{
+  if (bOnOff != HasFocus())
+  {
+    SetInvalid();
+    /*m_lastItem.reset();
+    m_lastChannel.reset();*/
+  }
+
+  CGUIControl::SetFocus(bOnOff);
+}
+
+void CGUIEPGGridContainer::DoRender()
+{
+  CGUIControl::DoRender();
+  m_wasReset = false;
+}
+
+void CGUIEPGGridContainer::ScrollToChannelOffset(int offset)
+{
+  float size = m_programmeLayout->Size(VERTICAL);
+  int range = m_channelsPerPage / 4;
+
+  if (range <= 0) range = 1;
+
+  if (offset * size < m_channelScrollOffset &&  m_channelScrollOffset - offset * size > size * range)
+  { // scrolling up, and we're jumping more than 0.5 of a screen
+    m_channelScrollOffset = (offset + range) * size;
+  }
+
+  if (offset * size > m_channelScrollOffset && offset * size - m_channelScrollOffset > size * range)
+  { // scrolling down, and we're jumping more than 0.5 of a screen
+    m_channelScrollOffset = (offset - range) * size;
+  }
+
+  m_channelScrollSpeed = (offset * size - m_channelScrollOffset) / m_scrollTime;
+
+  m_channelOffset = offset;
+}
+
+void CGUIEPGGridContainer::ScrollToBlockOffset(int offset)
+{
+  float size = m_blockSize;
+  int range = m_blocksPerPage / 1;
+
+  if (range <= 0) range = 1;
+
+  if (offset * size < m_programmeScrollOffset &&  m_programmeScrollOffset - offset * size > size * range)
+  { // scrolling left, and we're jumping more than 0.5 of a screen
+    m_programmeScrollOffset = (offset + range) * size;
+  }
+
+  if (offset * size > m_programmeScrollOffset && offset * size - m_programmeScrollOffset > size * range)
+  { // scrolling right, and we're jumping more than 0.5 of a screen
+    m_programmeScrollOffset = (offset - range) * size;
+  }
+
+  m_programmeScrollSpeed = (offset * size - m_programmeScrollOffset) / m_scrollTime;
+
+  m_blockOffset = offset;
+}
+
+void CGUIEPGGridContainer::ValidateOffset()
+{
+  if (!m_programmeLayout)
+    return;
+
+  if (m_channelOffset > m_channels - m_channelsPerPage)
+  {
+    m_channelOffset = m_channels - m_channelsPerPage;
+    m_channelScrollOffset = m_channelOffset * m_channelHeight;
+  }
+
+  if (m_channelOffset < 0)
+  {
+    m_channelOffset = 0;
+    m_channelScrollOffset = 0;
+  }
+
+  if (m_blockOffset > m_blocks - m_blocksPerPage)
+  {
+    m_blockOffset = m_blocks - m_blocksPerPage;
+    m_programmeScrollOffset = m_blockOffset * m_blockSize;
+  }
+
+  if (m_blockOffset < 0)
+  {
+    m_blockOffset = 0;
+    m_programmeScrollOffset = 0;
+  }
+}
+
+void CGUIEPGGridContainer::LoadLayout(TiXmlElement *layout)
+{
+  /* layouts for the channel column */
+  TiXmlElement *itemElement = layout->FirstChildElement("channellayout");
+  while (itemElement)
+  { // we have a new item layout
+    CGUIListItemLayout itemLayout;
+    itemLayout.LoadLayout(itemElement, GetParentID(), false);
+    m_channelLayouts.push_back(itemLayout);
+    itemElement = itemElement->NextSiblingElement("channellayout");
+  }
+  itemElement = layout->FirstChildElement("focusedchannellayout");
+  while (itemElement)
+  { // we have a new item layout
+    CGUIListItemLayout itemLayout;
+    itemLayout.LoadLayout(itemElement, GetParentID(), true);
+    m_focusedChannelLayouts.push_back(itemLayout);
+    itemElement = itemElement->NextSiblingElement("focusedchannellayout");
+  }
+
+  /* layouts for the grid items */
+  itemElement = layout->FirstChildElement("focusedlayout");
+  while (itemElement)
+  {
+    CGUIListItemLayout itemLayout;
+    itemLayout.LoadLayout(itemElement, GetParentID(), true);
+    m_focusedProgrammeLayouts.push_back(itemLayout);
+    itemElement = itemElement->NextSiblingElement("focusedlayout");
+  }
+  itemElement = layout->FirstChildElement("itemlayout");
+  while (itemElement)
+  {
+    CGUIListItemLayout itemLayout;
+    itemLayout.LoadLayout(itemElement, GetParentID(), false);
+    m_programmeLayouts.push_back(itemLayout);
+    itemElement = itemElement->NextSiblingElement("itemlayout");
+  }
+
+  /* layout for the timeline above the grid */
+  itemElement = layout->FirstChildElement("rulerlayout");
+  while (itemElement)
+  {
+    CGUIListItemLayout itemLayout;
+    itemLayout.LoadLayout(itemElement, GetParentID(), false);
+    m_rulerLayouts.push_back(itemLayout);
+    itemElement = itemElement->NextSiblingElement("rulerlayout");
+  }
+}
+
+void CGUIEPGGridContainer::UpdateLayout(bool updateAllItems)
+{
+  // if container is invalid, either new data has arrived, or m_blockSize has changed
+  //  need to run UpdateItems rather than CalculateLayout?
+  if (updateAllItems)
+  { // free memory of items
+    for (iItems it = m_channelItems.begin(); it != m_channelItems.end(); it++)
+      (*it)->FreeMemory();
+    for (iItems it = m_rulerItems.begin(); it != m_rulerItems.end(); it++)
+      (*it)->FreeMemory();
+    for (iItems it = m_programmeItems.begin(); it != m_programmeItems.end(); it++)
+      (*it)->FreeMemory();
+  }
+
+  // and recalculate the layout
+  CalculateLayout();
+}
+
+CStdString CGUIEPGGridContainer::GetDescription() const
+{
+  CStdString strLabel;
+  int item = GetSelectedItem();
+  if (item >= 0 && item < (int)m_programmeItems.size())
+  {
+    CGUIListItemPtr pItem = m_programmeItems[item];
+    strLabel = pItem->GetLabel();
+  }
+  return strLabel;
+}
+
+void CGUIEPGGridContainer::ClearGridIndex(void)
+{
+  if (m_gridIndex)
+  {
+    for (unsigned int i = 0; i < m_channelItems.size(); i++)
+    {
+      for (int block = 0; block < m_blocks; block++)
+      {
+        if (m_gridIndex[i][block].item)
+          m_gridIndex[i][block].item.get()->ClearProperties();
+      }
+      free(m_gridIndex[i]);
+    }
+    free(m_gridIndex);
+  }
+}
+
+void CGUIEPGGridContainer::Reset()
+{
+  ClearGridIndex();
+
+  m_wasReset = true;
+  m_channelItems.clear();
+  m_programmeItems.clear();
+  m_rulerItems.clear();
+  m_epgItemsPtr.clear();
+
+  m_lastItem    = NULL;
+  m_lastChannel = NULL;
+  m_gridIndex   = NULL;
+}
+
+void CGUIEPGGridContainer::GoToBegin()
+{
+  ScrollToBlockOffset(0);
+  SetBlock(0);
+}
+
+void CGUIEPGGridContainer::GoToEnd()
+{
+  int blocksEnd = 0;   // the end block of the last epg element for the selected channel
+  int blocksStart = 0; // the start block of the last epg element for the selected channel
+  int blockOffset = 0; // the block offset to scroll to
+  for (int blockIndex = m_blocks; blockIndex >= 0 && (!blocksEnd || !blocksStart); blockIndex--)
+  {
+    if (!blocksEnd && m_gridIndex[m_channelCursor + m_channelOffset][blockIndex].item != NULL)
+      blocksEnd = blockIndex;
+    if (blocksEnd && m_gridIndex[m_channelCursor + m_channelOffset][blocksEnd].item != 
+                     m_gridIndex[m_channelCursor + m_channelOffset][blockIndex].item)
+      blocksStart = blockIndex + 1;
+  }
+  if (blocksEnd - blocksStart > m_blocksPerPage)
+    blockOffset = blocksStart;
+  else if (blocksEnd > m_blocksPerPage)
+    blockOffset = blocksEnd - m_blocksPerPage;
+
+  ScrollToBlockOffset(blockOffset); // scroll to the start point of the last epg element
+  SetBlock(m_blocksPerPage - 1);    // select the last epg element
+}
+
+void CGUIEPGGridContainer::SetStartEnd(CDateTime start, CDateTime end)
+{
+  m_gridStart = CDateTime(start.GetYear(), start.GetMonth(), start.GetDay(), start.GetHour(), start.GetMinute() >= 30 ? 30 : 0, 0);
+  m_gridEnd = CDateTime(end.GetYear(), end.GetMonth(), end.GetDay(), end.GetHour(), end.GetMinute() >= 30 ? 30 : 0, 0);
+
+  CLog::Log(LOGDEBUG, "CGUIEPGGridContainer - %s - start=%s end=%s",
+      __FUNCTION__, m_gridStart.GetAsLocalizedDateTime(false, true).c_str(), m_gridEnd.GetAsLocalizedDateTime(false, true).c_str());
+}
+
+void CGUIEPGGridContainer::CalculateLayout()
+{
+  CGUIListItemLayout *oldFocusedChannelLayout   = m_focusedChannelLayout;
+  CGUIListItemLayout *oldChannelLayout          = m_channelLayout;
+  CGUIListItemLayout *oldFocusedProgrammeLayout = m_focusedProgrammeLayout;
+  CGUIListItemLayout *oldProgrammeLayout        = m_programmeLayout;
+  CGUIListItemLayout *oldRulerLayout            = m_rulerLayout;
+  GetCurrentLayouts();
+
+  if (!m_focusedProgrammeLayout || !m_programmeLayout || !m_focusedChannelLayout || !m_channelLayout || !m_rulerLayout)
+    return;
+
+  if (oldChannelLayout   == m_channelLayout   && oldFocusedChannelLayout   == m_focusedChannelLayout   &&
+      oldProgrammeLayout == m_programmeLayout && oldFocusedProgrammeLayout == m_focusedProgrammeLayout &&
+      oldRulerLayout     == m_rulerLayout)
+    return; // nothing has changed, so don't update stuff
+
+  m_channelHeight       = m_channelLayout->Size(VERTICAL);
+  m_channelWidth        = m_channelLayout->Size(HORIZONTAL);
+  if (m_orientation == VERTICAL)
+  {
+    m_rulerHeight       = m_rulerLayout->Size(VERTICAL);
+    m_gridPosX          = m_posX + m_channelWidth;
+    m_gridPosY          = m_posY + m_rulerHeight;
+    m_gridWidth         = m_width - m_channelWidth;
+    m_gridHeight        = m_height - m_rulerHeight;
+    m_blockSize         = m_gridWidth / m_blocksPerPage;
+    m_rulerWidth        = m_rulerUnit * m_blockSize;
+    m_channelPosX       = m_posX;
+    m_channelPosY       = m_posY + m_rulerHeight;
+    m_rulerPosX         = m_posX + m_channelWidth;
+    m_rulerPosY         = m_posY;
+    m_channelsPerPage   = (int)(m_gridHeight / m_channelHeight);
+    m_ProgrammesPerPage = (int)(m_gridWidth / m_blockSize) + 1;
+  }
+  else
+  {
+    m_rulerWidth        = m_rulerLayout->Size(HORIZONTAL);
+    m_gridPosX          = m_posX + m_rulerWidth;
+    m_gridPosY          = m_posY + m_channelHeight;
+    m_gridWidth         = m_width - m_rulerWidth;
+    m_gridHeight        = m_height - m_channelHeight;
+    m_blockSize         = m_gridHeight / m_blocksPerPage;
+    m_rulerHeight       = m_rulerUnit * m_blockSize;
+    m_channelPosX       = m_posX + m_rulerWidth;
+    m_channelPosY       = m_posY;
+    m_rulerPosX         = m_posX;
+    m_rulerPosY         = m_posY + m_channelHeight;
+    m_channelsPerPage   = (int)(m_gridWidth / m_channelWidth);
+    m_ProgrammesPerPage = (int)(m_gridHeight / m_blockSize) + 1;
+  }
+
+  // ensure that the scroll offsets are a multiple of our sizes
+  m_channelScrollOffset   = m_channelOffset * m_programmeLayout->Size(m_orientation);
+  m_programmeScrollOffset = m_blockOffset * m_blockSize;
+}
+
+void CGUIEPGGridContainer::UpdateScrollOffset()
+{
+  m_channelScrollOffset += m_channelScrollSpeed * (m_renderTime - m_channelScrollLastTime);
+  if ((m_channelScrollSpeed < 0 && m_channelScrollOffset < m_channelOffset * m_programmeLayout->Size(m_orientation)) ||
+      (m_channelScrollSpeed > 0 && m_channelScrollOffset > m_channelOffset * m_programmeLayout->Size(m_orientation)))
+  {
+    m_channelScrollOffset = m_channelOffset * m_programmeLayout->Size(m_orientation);
+    m_channelScrollSpeed = 0;
+  }
+  m_channelScrollLastTime = m_renderTime;
+
+  m_programmeScrollOffset += m_programmeScrollSpeed * (m_renderTime - m_programmeScrollLastTime);
+  if ((m_programmeScrollSpeed < 0 && m_programmeScrollOffset < m_blockOffset * m_blockSize) ||
+      (m_programmeScrollSpeed > 0 && m_programmeScrollOffset > m_blockOffset * m_blockSize))
+  {
+    m_programmeScrollOffset = m_blockOffset * m_blockSize;
+    m_programmeScrollSpeed = 0;
+  }
+  m_programmeScrollLastTime = m_renderTime;
+}
+
+void CGUIEPGGridContainer::GetCurrentLayouts()
+{
+  m_channelLayout = NULL;
+  for (unsigned int i = 0; i < m_channelLayouts.size(); i++)
+  {
+    if (m_channelLayouts[i].CheckCondition())
+    {
+      m_channelLayout = &m_channelLayouts[i];
+      break;
+    }
+  }
+  if (!m_channelLayout && m_channelLayouts.size())
+    m_channelLayout = &m_channelLayouts[0];  // failsafe
+
+  m_focusedChannelLayout = NULL;
+  for (unsigned int i = 0; i < m_focusedChannelLayouts.size(); i++)
+  {
+    if (m_focusedChannelLayouts[i].CheckCondition())
+    {
+      m_focusedChannelLayout = &m_focusedChannelLayouts[i];
+      break;
+    }
+  }
+  if (!m_focusedChannelLayout && m_focusedChannelLayouts.size())
+    m_focusedChannelLayout = &m_focusedChannelLayouts[0];  // failsafe
+
+  m_programmeLayout = NULL;
+  for (unsigned int i = 0; i < m_programmeLayouts.size(); i++)
+  {
+    if (m_programmeLayouts[i].CheckCondition())
+    {
+      m_programmeLayout = &m_programmeLayouts[i];
+      break;
+    }
+  }
+  if (!m_programmeLayout && m_programmeLayouts.size())
+    m_programmeLayout = &m_programmeLayouts[0];  // failsafe
+
+  m_focusedProgrammeLayout = NULL;
+  for (unsigned int i = 0; i < m_focusedProgrammeLayouts.size(); i++)
+  {
+    if (m_focusedProgrammeLayouts[i].CheckCondition())
+    {
+      m_focusedProgrammeLayout = &m_focusedProgrammeLayouts[i];
+      break;
+    }
+  }
+  if (!m_focusedProgrammeLayout && m_focusedProgrammeLayouts.size())
+    m_focusedProgrammeLayout = &m_focusedProgrammeLayouts[0];  // failsafe
+
+  m_rulerLayout = NULL;
+  for (unsigned int i = 0; i < m_rulerLayouts.size(); i++)
+  {
+    if (m_rulerLayouts[i].CheckCondition())
+    {
+      m_rulerLayout = &m_rulerLayouts[i];
+      break;
+    }
+  }
+  if (!m_rulerLayout && m_rulerLayouts.size())
+    m_rulerLayout = &m_rulerLayouts[0];  // failsafe
+}
+
+int CGUIEPGGridContainer::CorrectOffset(int offset, int cursor) const
+{
+  return offset + cursor;
+}
+
+void CGUIEPGGridContainer::SetRenderOffset(const CPoint &offset)
+{
+  m_renderOffset = offset;
+}
+
+void CGUIEPGGridContainer::FreeChannelMemory(int keepStart, int keepEnd)
+{
+  if (keepStart < keepEnd)
+  { // remove before keepStart and after keepEnd
+    for (int i = 0; i < keepStart && i < (int)m_channelItems.size(); ++i)
+      m_channelItems[i]->FreeMemory();
+    for (int i = keepEnd + 1; i < (int)m_channelItems.size(); ++i)
+      m_channelItems[i]->FreeMemory();
+  }
+  else
+  { // wrapping
+    for (int i = keepEnd + 1; i < keepStart && i < (int)m_channelItems.size(); ++i)
+      m_channelItems[i]->FreeMemory();
+  }
+}
+
+void CGUIEPGGridContainer::FreeProgrammeMemory(int keepStart, int keepEnd)
+{
+  if (keepStart < keepEnd)
+  { // remove before keepStart and after keepEnd
+    for (unsigned int i = 0; i < m_epgItemsPtr.size(); i++)
+    {
+      unsigned long progIdx = m_epgItemsPtr[i].start;
+      unsigned long lastIdx = m_epgItemsPtr[i].stop;
+
+      for (unsigned int j = progIdx; j < keepStart+progIdx && j < lastIdx; ++j)
+        m_programmeItems[j]->FreeMemory();
+      for (unsigned int j = keepEnd+progIdx + 1; j < lastIdx; ++j)
+        m_programmeItems[j]->FreeMemory();
+    }
+  }
+  else
+  { // wrapping
+    for (unsigned int i = 0; i < m_epgItemsPtr.size(); i++)
+    {
+      unsigned long progIdx = m_epgItemsPtr[i].start;
+      unsigned long lastIdx = m_epgItemsPtr[i].stop;
+
+      for (unsigned int j = keepEnd+progIdx + 1; j < keepStart+progIdx && j < lastIdx; ++j)
+        m_programmeItems[j]->FreeMemory();
+    }
+  }
+}
+
+void CGUIEPGGridContainer::FreeRulerMemory(int keepStart, int keepEnd)
+{
+  if (keepStart < keepEnd)
+  { // remove before keepStart and after keepEnd
+    for (int i = 1; i < keepStart && i < (int)m_rulerItems.size(); ++i)
+      m_rulerItems[i]->FreeMemory();
+    for (int i = keepEnd + 1; i < (int)m_rulerItems.size(); ++i)
+      m_rulerItems[i]->FreeMemory();
+  }
+  else
+  { // wrapping
+    for (int i = keepEnd + 1; i < keepStart && i < (int)m_rulerItems.size(); ++i)
+    {
+      if (i == 0)
+        continue;
+      m_rulerItems[i]->FreeMemory();
+    }
+  }
+}
+
+void CGUIEPGGridContainer::GetChannelCacheOffsets(int &cacheBefore, int &cacheAfter)
+{
+  if (m_channelScrollSpeed > 0)
+  {
+    cacheBefore = 0;
+    cacheAfter = m_cacheChannelItems;
+  }
+  else if (m_channelScrollSpeed < 0)
+  {
+    cacheBefore = m_cacheChannelItems;
+    cacheAfter = 0;
+  }
+  else
+  {
+    cacheBefore = m_cacheChannelItems / 2;
+    cacheAfter = m_cacheChannelItems / 2;
+  }
+}
+
+void CGUIEPGGridContainer::GetProgrammeCacheOffsets(int &cacheBefore, int &cacheAfter)
+{
+  if (m_programmeScrollSpeed > 0)
+  {
+    cacheBefore = 0;
+    cacheAfter = m_cacheProgrammeItems;
+  }
+  else if (m_programmeScrollSpeed < 0)
+  {
+    cacheBefore = m_cacheProgrammeItems;
+    cacheAfter = 0;
+  }
+  else
+  {
+    cacheBefore = m_cacheProgrammeItems / 2;
+    cacheAfter = m_cacheProgrammeItems / 2;
+  }
+}
+
+void CGUIEPGGridContainer::GetRulerCacheOffsets(int &cacheBefore, int &cacheAfter)
+{
+  if (m_programmeScrollSpeed > 0)
+  {
+    cacheBefore = 0;
+    cacheAfter = m_cacheRulerItems;
+  }
+  else if (m_programmeScrollSpeed < 0)
+  {
+    cacheBefore = m_cacheRulerItems;
+    cacheAfter = 0;
+  }
+  else
+  {
+    cacheBefore = m_cacheRulerItems / 2;
+    cacheAfter = m_cacheRulerItems / 2;
+  }
+}
diff --git a/xbmc/filesystem/AddonsDirectory.cpp b/xbmc/filesystem/AddonsDirectory.cpp
index 3b36459..da51ee7 100644
--- a/xbmc/filesystem/AddonsDirectory.cpp
+++ b/xbmc/filesystem/AddonsDirectory.cpp
@@ -33,2 +33,3 @@
 #include "File.h"
+#include "SpecialProtocol.h"
 #include "utils/URIUtils.h"
@@ -203,2 +204,3 @@ void CAddonsDirectory::GenerateListing(CURL &path, VECADDONS& addons, CFileItemL
 {
+  CStdString xbmcPath = CSpecialProtocol::TranslatePath("special://xbmc/addons");
   items.ClearItems();
@@ -215,2 +217,5 @@ void CAddonsDirectory::GenerateListing(CURL &path, VECADDONS& addons, CFileItemL
       pItem->SetProperty("Addon.Status",g_localizeStrings.Get(305));
+    else if ((addon->Type() == ADDON_PVRDLL) && (CStdString(pItem->GetProperty("Addon.Path").asString()).Left(xbmcPath.size()).Equals(xbmcPath)))
+      pItem->SetProperty("Addon.Status",g_localizeStrings.Get(24023));
+
     if (!addon->Props().broken.IsEmpty())
diff --git a/xbmc/filesystem/DirectoryFactory.cpp b/xbmc/filesystem/DirectoryFactory.cpp
index 00eb9a3..289934e 100644
--- a/xbmc/filesystem/DirectoryFactory.cpp
+++ b/xbmc/filesystem/DirectoryFactory.cpp
@@ -79,2 +79,5 @@
 #endif
+#ifdef HAS_PVRCLIENTS
+#include "PVRDirectory.h"
+#endif
 #if defined(TARGET_ANDROID)
@@ -208,2 +211,5 @@ IDirectory* CDirectoryFactory::Create(const CStdString& strPath)
 #endif
+#ifdef HAS_PVRCLIENTS
+    if (strProtocol == "pvr") return new CPVRDirectory();
+#endif
 #ifdef HAS_ZEROCONF
diff --git a/xbmc/filesystem/FileFactory.cpp b/xbmc/filesystem/FileFactory.cpp
index 9be1fb7..6ee61eb 100644
--- a/xbmc/filesystem/FileFactory.cpp
+++ b/xbmc/filesystem/FileFactory.cpp
@@ -57,2 +57,5 @@
 #endif
+#ifdef HAS_PVRCLIENTS
+#include "PVRFile.h"
+#endif
 #if defined(TARGET_ANDROID)
@@ -180,2 +183,5 @@ IFile* CFileFactory::CreateLoader(const CURL& url)
 #endif
+#ifdef HAS_PVRCLIENTS
+    else if (strProtocol == "pvr") return new CPVRFile();
+#endif
 #ifdef HAS_FILESYSTEM_NFS
diff --git a/xbmc/filesystem/MythFile.cpp b/xbmc/filesystem/MythFile.cpp
index 9711981..47501c0 100644
--- a/xbmc/filesystem/MythFile.cpp
+++ b/xbmc/filesystem/MythFile.cpp
@@ -634,3 +634,3 @@ bool CMythFile::ChangeChannel(int direction, const CStdString &channel)
 
-bool CMythFile::NextChannel()
+bool CMythFile::NextChannel(bool preview)
 {
@@ -639,3 +639,3 @@ bool CMythFile::NextChannel()
 
-bool CMythFile::PrevChannel()
+bool CMythFile::PrevChannel(bool preview)
 {
diff --git a/xbmc/filesystem/PVRDirectory.cpp b/xbmc/filesystem/PVRDirectory.cpp
new file mode 100644
index 0000000..f5c12b0
--- /dev/null
+++ b/xbmc/filesystem/PVRDirectory.cpp
@@ -0,0 +1,126 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ * This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "PVRDirectory.h"
+#include "FileItem.h"
+#include "Util.h"
+#include "URL.h"
+#include "utils/log.h"
+#include "utils/URIUtils.h"
+#include "guilib/LocalizeStrings.h"
+
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/channels/PVRChannelGroup.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "pvr/timers/PVRTimers.h"
+
+using namespace std;
+using namespace XFILE;
+using namespace PVR;
+
+CPVRDirectory::CPVRDirectory()
+{
+}
+
+CPVRDirectory::~CPVRDirectory()
+{
+}
+
+bool CPVRDirectory::GetDirectory(const CStdString& strPath, CFileItemList &items)
+{
+  CStdString base(strPath);
+  URIUtils::RemoveSlashAtEnd(base);
+
+  CURL url(strPath);
+  CStdString fileName = url.GetFileName();
+  URIUtils::RemoveSlashAtEnd(fileName);
+  CLog::Log(LOGDEBUG, "CPVRDirectory::GetDirectory(%s)", base.c_str());
+  items.SetCacheToDisc(CFileItemList::CACHE_NEVER);
+
+  if (!g_PVRManager.IsStarted())
+    return false;
+
+  if (fileName == "")
+  {
+    CFileItemPtr item;
+
+    item.reset(new CFileItem(base + "/channels/", true));
+    item->SetLabel(g_localizeStrings.Get(19019));
+    item->SetLabelPreformated(true);
+    items.Add(item);
+
+    item.reset(new CFileItem(base + "/recordings/", true));
+    item->SetLabel(g_localizeStrings.Get(19017));
+    item->SetLabelPreformated(true);
+    items.Add(item);
+
+    item.reset(new CFileItem(base + "/timers/", true));
+    item->SetLabel(g_localizeStrings.Get(19040));
+    item->SetLabelPreformated(true);
+    items.Add(item);
+
+    item.reset(new CFileItem(base + "/guide/", true));
+    item->SetLabel(g_localizeStrings.Get(19029));
+    item->SetLabelPreformated(true);
+    items.Add(item);
+
+    // Sort by name only. Labels are preformated.
+    items.AddSortMethod(SORT_METHOD_LABEL, 551 /* Name */, LABEL_MASKS("%L", "", "%L", ""));
+
+    return true;
+  }
+  else if (fileName.Left(10) == "recordings")
+  {
+    return g_PVRRecordings->GetDirectory(strPath, items);
+  }
+  else if (fileName.Left(8) == "channels")
+  {
+    return g_PVRChannelGroups->GetDirectory(strPath, items);
+  }
+  else if (fileName.Left(6) == "timers")
+  {
+    return g_PVRTimers->GetDirectory(strPath, items);
+  }
+
+  return false;
+}
+
+bool CPVRDirectory::SupportsFileOperations(const CStdString& strPath)
+{
+  CURL url(strPath);
+  CStdString filename = url.GetFileName();
+
+  return URIUtils::IsPVRRecording(filename);
+}
+
+bool CPVRDirectory::IsLiveTV(const CStdString& strPath)
+{
+  CURL url(strPath);
+  CStdString filename = url.GetFileName();
+
+  return URIUtils::IsLiveTV(filename);
+}
+
+bool CPVRDirectory::HasRecordings()
+{
+  return g_PVRRecordings->GetNumRecordings() > 0;
+}
diff --git a/xbmc/filesystem/PVRFile.cpp b/xbmc/filesystem/PVRFile.cpp
new file mode 100644
index 0000000..d3be8c3
--- /dev/null
+++ b/xbmc/filesystem/PVRFile.cpp
@@ -0,0 +1,318 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "PVRFile.h"
+#include "Util.h"
+#include "cores/dvdplayer/DVDInputStreams/DVDInputStream.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "pvr/addons/PVRClients.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "URL.h"
+
+using namespace std;
+using namespace XFILE;
+using namespace PVR;
+
+CPVRFile::CPVRFile()
+{
+  m_isPlayRecording = false;
+  m_playingItem     = -1;
+}
+
+CPVRFile::~CPVRFile()
+{
+}
+
+bool CPVRFile::Open(const CURL& url)
+{
+  Close();
+
+  if (!g_PVRManager.IsStarted())
+    return false;
+
+  CStdString strURL = url.Get();
+
+  if (strURL.Left(18) == "pvr://channels/tv/" || strURL.Left(21) == "pvr://channels/radio/")
+  {
+    CFileItemPtr tag = g_PVRChannelGroups->GetByPath(strURL);
+    if (tag && tag->HasPVRChannelInfoTag())
+    {
+      if (!g_PVRManager.OpenLiveStream(*tag))
+        return false;
+
+      m_isPlayRecording = false;
+      CLog::Log(LOGDEBUG, "PVRFile - %s - playback has started on filename %s", __FUNCTION__, strURL.c_str());
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "PVRFile - %s - channel not found with filename %s", __FUNCTION__, strURL.c_str());
+      return false;
+    }
+  }
+  else if (strURL.Left(17) == "pvr://recordings/")
+  {
+    CFileItemPtr tag = g_PVRRecordings->GetByPath(strURL);
+    if (tag && tag->HasPVRRecordingInfoTag())
+    {
+      if (!g_PVRManager.OpenRecordedStream(*tag->GetPVRRecordingInfoTag()))
+        return false;
+
+      m_isPlayRecording = true;
+      CLog::Log(LOGDEBUG, "%s - Recording has started on filename %s", __FUNCTION__, strURL.c_str());
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "PVRFile - Recording not found with filename %s", strURL.c_str());
+      return false;
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "%s - invalid path specified %s", __FUNCTION__, strURL.c_str());
+    return false;
+  }
+
+  return true;
+}
+
+void CPVRFile::Close()
+{
+  g_PVRManager.CloseStream();
+}
+
+unsigned int CPVRFile::Read(void* buffer, int64_t size)
+{
+  return g_PVRManager.IsStarted() ? g_PVRClients->ReadStream((BYTE*)buffer, size) : 0;
+}
+
+int64_t CPVRFile::GetLength()
+{
+  return g_PVRManager.IsStarted() ? g_PVRClients->GetStreamLength() : 0;
+}
+
+int64_t CPVRFile::Seek(int64_t pos, int whence)
+{
+  return g_PVRManager.IsStarted() ? g_PVRClients->SeekStream(pos, whence) : 0;
+}
+
+int64_t CPVRFile::GetPosition()
+{
+  return g_PVRManager.IsStarted() ? g_PVRClients->GetStreamPosition() : 0;
+}
+
+int CPVRFile::GetTotalTime()
+{
+  return g_PVRManager.GetTotalTime();
+}
+
+int CPVRFile::GetStartTime()
+{
+  return g_PVRManager.GetStartTime();
+}
+
+bool CPVRFile::NextChannel(bool preview/* = false*/)
+{
+  unsigned int newchannel;
+
+  if (m_isPlayRecording)
+  {
+    /* We are inside a recording, skip channelswitch */
+    return true;
+  }
+
+  /* Do channel switch and save new channel number, it is not always
+   * increased by one in a case if next channel is encrypted or we
+   * on the beginning or end of the channel list!
+   */
+  if (g_PVRManager.ChannelUp(&newchannel, preview))
+  {
+    m_playingItem = newchannel;
+    return true;
+  }
+  else
+  {
+    return false;
+  }
+}
+
+bool CPVRFile::PrevChannel(bool preview/* = false*/)
+{
+  unsigned int newchannel;
+
+  if (m_isPlayRecording)
+  {
+    /* We are inside a recording, skip channelswitch */
+    return true;
+  }
+
+  /* Do channel switch and save new channel number, it is not always
+   * increased by one in a case if next channel is encrypted or we
+   * on the beginning or end of the channel list!
+   */
+  if (g_PVRManager.ChannelDown(&newchannel, preview))
+  {
+    m_playingItem = newchannel;
+    return true;
+  }
+  else
+  {
+    return false;
+  }
+}
+
+bool CPVRFile::SelectChannel(unsigned int channel)
+{
+  if (m_isPlayRecording)
+  {
+    /* We are inside a recording, skip channelswitch */
+    /** TODO:
+     ** Add support for cutting keys (functions becomes the numeric keys as integer)
+     **/
+    return true;
+  }
+
+  if (g_PVRManager.ChannelSwitch(channel))
+  {
+    m_playingItem = channel;
+    return true;
+  }
+  else
+  {
+    return false;
+  }
+}
+
+bool CPVRFile::UpdateItem(CFileItem& item)
+{
+  return g_PVRManager.UpdateItem(item);
+}
+
+CStdString CPVRFile::TranslatePVRFilename(const CStdString& pathFile)
+{
+  if (!g_PVRManager.IsStarted())
+    return StringUtils::EmptyString;
+
+  CStdString FileName = pathFile;
+  if (FileName.substr(0, 14) == "pvr://channels")
+  {
+    CFileItemPtr channel = g_PVRChannelGroups->GetByPath(FileName);
+    if (channel && channel->HasPVRChannelInfoTag())
+    {
+      CStdString stream = channel->GetPVRChannelInfoTag()->StreamURL();
+      if(!stream.IsEmpty())
+      {
+        if (stream.compare(6, 7, "stream/") == 0)
+        {
+          // pvr://stream
+          // This function was added to retrieve the stream URL for this item
+          // Is is used for the MediaPortal (ffmpeg) PVR addon
+          // see PVRManager.cpp
+          return g_PVRClients->GetStreamURL(*channel->GetPVRChannelInfoTag());
+        }
+        else
+        {
+          return stream;
+        }
+      }
+    }
+  }
+  return FileName;
+}
+
+bool CPVRFile::CanRecord()
+{
+  if (m_isPlayRecording || !g_PVRManager.IsStarted())
+    return false;
+
+  return g_PVRClients->CanRecordInstantly();
+}
+
+bool CPVRFile::IsRecording()
+{
+  return g_PVRManager.IsStarted() && g_PVRClients->IsRecordingOnPlayingChannel();
+}
+
+bool CPVRFile::Record(bool bOnOff)
+{
+  return g_PVRManager.StartRecordingOnPlayingChannel(bOnOff);
+}
+
+bool CPVRFile::Delete(const CURL& url)
+{
+  if (!g_PVRManager.IsStarted())
+    return false;
+
+  CStdString path(url.GetFileName());
+  if (path.Left(11) == "recordings/" && path[path.size()-1] != '/')
+  {
+    CStdString strURL = url.Get();
+    CFileItemPtr tag = g_PVRRecordings->GetByPath(strURL);
+    if (tag && tag->HasPVRRecordingInfoTag())
+      return tag->GetPVRRecordingInfoTag()->Delete();
+  }
+  return false;
+}
+
+bool CPVRFile::Rename(const CURL& url, const CURL& urlnew)
+{
+  if (!g_PVRManager.IsStarted())
+    return false;
+
+  CStdString path(url.GetFileName());
+  CStdString newname(urlnew.GetFileName());
+
+  size_t found = newname.find_last_of("/");
+  if (found != CStdString::npos)
+    newname = newname.substr(found+1);
+
+  if (path.Left(11) == "recordings/" && path[path.size()-1] != '/')
+  {
+    CStdString strURL = url.Get();
+    CFileItemPtr tag = g_PVRRecordings->GetByPath(strURL);
+    if (tag && tag->HasPVRRecordingInfoTag())
+      return tag->GetPVRRecordingInfoTag()->Rename(newname);
+  }
+  return false;
+}
+
+bool CPVRFile::Exists(const CURL& url)
+{
+  return g_PVRManager.IsStarted() &&
+      g_PVRRecordings->GetByPath(url.Get())->HasPVRRecordingInfoTag();
+}
+
+int CPVRFile::IoControl(EIoControl request, void *param)
+{
+  if (request == IOCTRL_SEEK_POSSIBLE)
+  {
+    if (!g_PVRManager.IsStarted())
+      return 0;
+    else if (g_PVRClients->GetStreamLength() && g_PVRClients->SeekStream(0, SEEK_CUR) >= 0)
+      return 1;
+    else
+      return 0;
+  }
+
+  return -1;
+}
diff --git a/xbmc/filesystem/SlingboxFile.cpp b/xbmc/filesystem/SlingboxFile.cpp
index 5804f65..0fa832a 100644
--- a/xbmc/filesystem/SlingboxFile.cpp
+++ b/xbmc/filesystem/SlingboxFile.cpp
@@ -196,3 +196,3 @@ bool CSlingboxFile::SkipNext()
 
-bool CSlingboxFile::NextChannel()
+bool CSlingboxFile::NextChannel(bool bPreview /* = false */)
 {
@@ -282,3 +282,3 @@ bool CSlingboxFile::NextChannel()
 
-bool CSlingboxFile::PrevChannel()
+bool CSlingboxFile::PrevChannel(bool bPreview /* = false */)
 {
diff --git a/xbmc/filesystem/VTPFile.cpp b/xbmc/filesystem/VTPFile.cpp
index 5a3306d..2d1f467 100644
--- a/xbmc/filesystem/VTPFile.cpp
+++ b/xbmc/filesystem/VTPFile.cpp
@@ -142,3 +142,3 @@ int64_t CVTPFile::Seek(int64_t pos, int whence)
 
-bool CVTPFile::NextChannel()
+bool CVTPFile::NextChannel(bool preview/* = false*/)
 {
@@ -168,3 +168,3 @@ bool CVTPFile::NextChannel()
 
-bool CVTPFile::PrevChannel()
+bool CVTPFile::PrevChannel(bool preview/* = false*/)
 {
diff --git a/xbmc/guilib/GUIControlFactory.cpp b/xbmc/guilib/GUIControlFactory.cpp
index 5f00ad2..45b62db 100644
--- a/xbmc/guilib/GUIControlFactory.cpp
+++ b/xbmc/guilib/GUIControlFactory.cpp
@@ -51,2 +51,3 @@
 #include "GUIWrappingListContainer.h"
+#include "epg/GUIEPGGridContainer.h"
 #include "GUIPanelContainer.h"
@@ -66,2 +67,3 @@
 using namespace std;
+using namespace EPG;
 
@@ -108,2 +110,3 @@ static const ControlMapping controls[] =
     {"fixedlist",         CGUIControl::GUICONTAINER_FIXEDLIST},
+    {"epggrid",           CGUIControl::GUICONTAINER_EPGGRID},
     {"panel",             CGUIControl::GUICONTAINER_PANEL}};
@@ -674,2 +677,4 @@ CGUIControl* CGUIControlFactory::Create(int parentID, const CRect &rect, TiXmlEl
   int scrollTime = 200;
+  int timeBlocks = 36;
+  int rulerUnit = 12;
   bool useControlCoords = false;
@@ -890,2 +895,4 @@ CGUIControl* CGUIControlFactory::Create(int parentID, const CRect &rect, TiXmlEl
   XMLUtils::GetBoolean(pControlNode,"pulseonselect", bPulse);
+  XMLUtils::GetInt(pControlNode, "timeblocks", timeBlocks);
+  XMLUtils::GetInt(pControlNode, "rulerunit", rulerUnit);
 
@@ -1187,2 +1194,3 @@ CGUIControl* CGUIControlFactory::Create(int parentID, const CRect &rect, TiXmlEl
       textureOverlay, bReveal);
+
     ((CGUIProgressControl *)control)->SetInfo(singleInfo);
@@ -1238,2 +1246,8 @@ CGUIControl* CGUIControlFactory::Create(int parentID, const CRect &rect, TiXmlEl
   }
+  else if (type == CGUIControl::GUICONTAINER_EPGGRID)
+  {
+    control = new CGUIEPGGridContainer(parentID, id, posX, posY, width, height, orientation, scrollTime, preloadItems, timeBlocks, rulerUnit);
+    ((CGUIEPGGridContainer *)control)->LoadLayout(pControlNode);
+    ((CGUIEPGGridContainer *)control)->SetRenderOffset(offset);
+  }
   else if (type == CGUIControl::GUICONTAINER_FIXEDLIST)
diff --git a/xbmc/guilib/GUIDialog.cpp b/xbmc/guilib/GUIDialog.cpp
index 92bdd99..ef7bf65 100644
--- a/xbmc/guilib/GUIDialog.cpp
+++ b/xbmc/guilib/GUIDialog.cpp
@@ -41,2 +41,3 @@ CGUIDialog::CGUIDialog(int id, const CStdString &xmlFile)
   m_enableSound = true;
+  m_bAutoClosed = false;
 }
@@ -241,3 +242,6 @@ void CGUIDialog::FrameMove()
       if (m_showStartTime + m_showDuration < CTimeUtils::GetFrameTime() && !m_closing)
+      {
+        m_bAutoClosed = true;
         Close();
+      }
     }
@@ -265,6 +269,9 @@ void CGUIDialog::SetAutoClose(unsigned int timeoutMs)
    m_showDuration = timeoutMs;
-   if (m_active)
-     m_showStartTime = CTimeUtils::GetFrameTime();
+   ResetAutoClose();
 }
 
-
+void CGUIDialog::ResetAutoClose(void)
+{
+  if (m_autoClosing && m_active)
+    m_showStartTime = CTimeUtils::GetFrameTime();
+}
diff --git a/xbmc/guilib/GUIEditControl.cpp b/xbmc/guilib/GUIEditControl.cpp
index 054e472..75b546d 100644
--- a/xbmc/guilib/GUIEditControl.cpp
+++ b/xbmc/guilib/GUIEditControl.cpp
@@ -269,2 +269,16 @@ void CGUIEditControl::OnClick()
       break;
+    case INPUT_TYPE_TIME:
+    {
+      CDateTime dateTime;
+      dateTime.SetFromDBTime(utf8);
+      SYSTEMTIME time;
+      dateTime.GetAsSystemTime(time);
+      if (CGUIDialogNumeric::ShowAndGetTime(time, heading > 0 ? heading : g_localizeStrings.Get(21420)))
+      {
+        dateTime = CDateTime(time);
+        utf8 = dateTime.GetAsLocalizedTime("", false);
+        textChanged = true;
+      }
+      break;
+    }
     case INPUT_TYPE_DATE:
@@ -277,3 +291,3 @@ void CGUIEditControl::OnClick()
       dateTime.GetAsSystemTime(date);
-      if (CGUIDialogNumeric::ShowAndGetDate(date, g_localizeStrings.Get(21420)))
+      if (CGUIDialogNumeric::ShowAndGetDate(date, heading > 0 ? heading : g_localizeStrings.Get(21420)))
       {
@@ -294,2 +308,5 @@ void CGUIEditControl::OnClick()
       break;
+    case INPUT_TYPE_PASSWORD_NUMBER_VERIFY_NEW:
+      textChanged = CGUIDialogNumeric::ShowAndVerifyNewPassword(utf8);
+      break;
     case INPUT_TYPE_PASSWORD_MD5:
@@ -460,3 +477,3 @@ CStdStringW CGUIEditControl::GetDisplayedText() const
 {
-  if (m_inputType == INPUT_TYPE_PASSWORD || m_inputType == INPUT_TYPE_PASSWORD_MD5)
+  if (m_inputType == INPUT_TYPE_PASSWORD || m_inputType == INPUT_TYPE_PASSWORD_MD5 || m_inputType == INPUT_TYPE_PASSWORD_NUMBER_VERIFY_NEW)
   {
@@ -487,3 +504,3 @@ void CGUIEditControl::SetLabel2(const std::string &text)
   {
-    m_isMD5 = m_inputType == INPUT_TYPE_PASSWORD_MD5;
+    m_isMD5 = (m_inputType == INPUT_TYPE_PASSWORD_MD5 || m_inputType == INPUT_TYPE_PASSWORD_NUMBER_VERIFY_NEW);
     m_text2 = newText;
@@ -505,3 +522,3 @@ bool CGUIEditControl::ClearMD5()
 {
-  if (m_inputType != INPUT_TYPE_PASSWORD_MD5 || !m_isMD5)
+  if (!(m_inputType == INPUT_TYPE_PASSWORD_MD5 || m_inputType == INPUT_TYPE_PASSWORD_NUMBER_VERIFY_NEW) || !m_isMD5)
     return false;
@@ -510,3 +527,4 @@ bool CGUIEditControl::ClearMD5()
   m_cursorPos = 0;
-  m_isMD5 = false;
+  if (m_inputType != INPUT_TYPE_PASSWORD_NUMBER_VERIFY_NEW)
+    m_isMD5 = false;
   return true;
diff --git a/xbmc/guilib/GUILabelControl.cpp b/xbmc/guilib/GUILabelControl.cpp
index f78c8a9..75129c3 100644
--- a/xbmc/guilib/GUILabelControl.cpp
+++ b/xbmc/guilib/GUILabelControl.cpp
@@ -177,2 +177,9 @@ float CGUILabelControl::GetWidth() const
 
+void CGUILabelControl::SetWidth(float width)
+{
+  m_width = width;
+  m_label.SetMaxRect(m_posX, m_posY, m_width, m_height);
+  CGUIControl::SetWidth(m_width);
+}
+
 bool CGUILabelControl::OnMessage(CGUIMessage& message)
diff --git a/xbmc/guilib/GUIListGroup.cpp b/xbmc/guilib/GUIListGroup.cpp
index cc23bbe..88e9ea7 100644
--- a/xbmc/guilib/GUIListGroup.cpp
+++ b/xbmc/guilib/GUIListGroup.cpp
@@ -120,2 +120,46 @@ void CGUIListGroup::UpdateInfo(const CGUIListItem *item)
 
+void CGUIListGroup::EnlargeWidth(float difference)
+{
+  // Alters the width of the controls that have an ID of 1
+  for (iControls it = m_children.begin(); it != m_children.end(); it++)
+  {
+    CGUIControl *child = *it;
+    if (child->GetID() >= 1 && child->GetID() <= 14)
+    {
+      if (child->GetID() == 1) // label
+      {
+        child->SetWidth(child->GetWidth() + difference - 10);
+        child->SetVisible(child->GetWidth() > 10); ///
+      }
+      else
+      {
+        child->SetWidth(child->GetWidth() + difference);
+      }
+    }
+  }
+  SetInvalid();
+}
+
+void CGUIListGroup::EnlargeHeight(float difference)
+{
+  // Alters the width of the controls that have an ID of 1
+  for (iControls it = m_children.begin(); it != m_children.end(); it++)
+  {
+    CGUIControl *child = *it;
+    if (child->GetID() >= 1 && child->GetID() <= 14)
+    {
+      if (child->GetID() == 1) // label
+      {
+        child->SetHeight(child->GetHeight() + difference);
+        child->SetVisible(child->GetHeight() > 10); ///
+      }
+      else
+      {
+        child->SetHeight(child->GetHeight() + difference);
+      }
+    }
+  }
+  SetInvalid();
+}
+
 void CGUIListGroup::SetInvalid()
diff --git a/xbmc/guilib/GUIListItemLayout.cpp b/xbmc/guilib/GUIListItemLayout.cpp
index 743ef83..22dc238 100644
--- a/xbmc/guilib/GUIListItemLayout.cpp
+++ b/xbmc/guilib/GUIListItemLayout.cpp
@@ -108,2 +108,16 @@ unsigned int CGUIListItemLayout::GetFocusedItem() const
 
+void CGUIListItemLayout::SetWidth(float width)
+{
+  m_group.EnlargeWidth(width - m_width);
+  m_width = width;
+  SetInvalid();
+}
+
+void CGUIListItemLayout::SetHeight(float height)
+{
+  m_group.EnlargeHeight(height - m_height);
+  m_height = height;
+  SetInvalid();
+}
+
 void CGUIListItemLayout::SelectItemFromPoint(const CPoint &point)
diff --git a/xbmc/guilib/GUIListLabel.cpp b/xbmc/guilib/GUIListLabel.cpp
index 794ceb5..255807b 100644
--- a/xbmc/guilib/GUIListLabel.cpp
+++ b/xbmc/guilib/GUIListLabel.cpp
@@ -107,2 +107,14 @@ void CGUIListLabel::SetInvalid()
 
+void CGUIListLabel::SetWidth(float width)
+{
+  m_width = width;
+  if (m_label.GetLabelInfo().align & XBFONT_RIGHT)
+    m_label.SetMaxRect(m_posX - m_width, m_posY, m_width, m_height);
+  else if (m_label.GetLabelInfo().align & XBFONT_CENTER_X)
+    m_label.SetMaxRect(m_posX - m_width*0.5f, m_posY, m_width, m_height);
+  else
+    m_label.SetMaxRect(m_posX, m_posY, m_posX + m_width, m_posY + m_height);
+  CGUIControl::SetWidth(m_width);
+}
+
 void CGUIListLabel::SetLabel(const CStdString &label)
diff --git a/xbmc/guilib/GUIProgressControl.cpp b/xbmc/guilib/GUIProgressControl.cpp
index c9ade8d..70e1f7f 100644
--- a/xbmc/guilib/GUIProgressControl.cpp
+++ b/xbmc/guilib/GUIProgressControl.cpp
@@ -23,2 +23,5 @@
 #include "GUIInfoManager.h"
+#include "GUIListItem.h"
+#include "GUIWindowManager.h"
+#include "FileItem.h"
 
@@ -43,2 +46,3 @@ CGUIProgressControl::CGUIProgressControl(int parentID, int controlID,
   m_bReveal = reveal;
+  m_bChanged = false;
 }
diff --git a/xbmc/guilib/GUIWindow.cpp b/xbmc/guilib/GUIWindow.cpp
index 03c4e7c..458c247 100644
--- a/xbmc/guilib/GUIWindow.cpp
+++ b/xbmc/guilib/GUIWindow.cpp
@@ -56,3 +56,3 @@ CGUIWindow::CGUIWindow(int id, const CStdString &xmlFile)
   SetProperty("xmlfile", xmlFile);
-  m_idRange = 1;
+  m_idRange.push_back(id);
   m_lastControlID = 0;
@@ -368,3 +368,3 @@ void CGUIWindow::Close_Internal(bool forceClose /*= false*/, int nextWindowID /*
 
-void CGUIWindow::Close(bool forceClose /*= false*/, int nextWindowID /*= 0*/, bool enableSound /*= true*/)
+void CGUIWindow::Close(bool forceClose /*= false*/, int nextWindowID /*= 0*/, bool enableSound /*= true*/, bool bWait /* = true */)
 {
@@ -374,3 +374,3 @@ void CGUIWindow::Close(bool forceClose /*= false*/, int nextWindowID /*= 0*/, bo
     CSingleExit leaveIt(g_graphicsContext);
-    CApplicationMessenger::Get().Close(this, forceClose, true, nextWindowID, enableSound);
+    CApplicationMessenger::Get().Close(this, forceClose, bWait, nextWindowID, enableSound);
   }
@@ -996 +996,11 @@ void CGUIWindow::ClearBackground()
 }
+
+bool CGUIWindow::HasID(int controlID) const
+{
+  for (std::vector<int>::const_iterator it = m_idRange.begin(); it != m_idRange.end() ; it++)
+  {
+    if (controlID == *it)
+      return true;
+  }
+  return false;
+}
diff --git a/xbmc/guilib/GUIWindowManager.cpp b/xbmc/guilib/GUIWindowManager.cpp
index 028bb17..e267373 100644
--- a/xbmc/guilib/GUIWindowManager.cpp
+++ b/xbmc/guilib/GUIWindowManager.cpp
@@ -186,5 +186,6 @@ void CGUIWindowManager::Add(CGUIWindow* pWindow)
   CSingleLock lock(g_graphicsContext);
-  for (int i = 0; i < pWindow->GetIDRange(); i++)
+  const vector<int>& idRange = pWindow->GetIDRange();
+  for (vector<int>::const_iterator idIt = idRange.begin(); idIt != idRange.end() ; idIt++)
   {
-    WindowMap::iterator it = m_mapWindows.find(pWindow->GetID() + i);
+    WindowMap::iterator it = m_mapWindows.find(*idIt);
     if (it != m_mapWindows.end())
@@ -192,7 +193,6 @@ void CGUIWindowManager::Add(CGUIWindow* pWindow)
       CLog::Log(LOGERROR, "Error, trying to add a second window with id %u "
-                          "to the window manager",
-                pWindow->GetID());
+                          "to the window manager", *idIt);
       return;
     }
-    m_mapWindows.insert(pair<int, CGUIWindow *>(pWindow->GetID() + i, pWindow));
+    m_mapWindows.insert(pair<int, CGUIWindow *>(*idIt, pWindow));
   }
diff --git a/xbmc/input/ButtonTranslator.cpp b/xbmc/input/ButtonTranslator.cpp
index 0e8e00b..e8ec874 100644
--- a/xbmc/input/ButtonTranslator.cpp
+++ b/xbmc/input/ButtonTranslator.cpp
@@ -237,2 +237,19 @@ static const ActionMapping windows[] =
         {"videos"                   , WINDOW_VIDEO_NAV},
+        {"tv"                       , WINDOW_PVR}, // backward compat
+        {"pvr"                      , WINDOW_PVR},
+
+        {"pvrguideinfo"             , WINDOW_DIALOG_PVR_GUIDE_INFO},
+        {"pvrrecordinginfo"         , WINDOW_DIALOG_PVR_RECORDING_INFO},
+        {"pvrtimersetting"          , WINDOW_DIALOG_PVR_TIMER_SETTING},
+        {"pvrgroupmanager"          , WINDOW_DIALOG_PVR_GROUP_MANAGER},
+        {"pvrchannelmanager"        , WINDOW_DIALOG_PVR_CHANNEL_MANAGER},
+        {"pvrguidesearch"           , WINDOW_DIALOG_PVR_GUIDE_SEARCH},
+        {"pvrchannelscan"           , WINDOW_DIALOG_PVR_CHANNEL_SCAN},
+        {"pvrupdateprogress"        , WINDOW_DIALOG_PVR_UPDATE_PROGRESS},
+        {"pvrosdchannels"           , WINDOW_DIALOG_PVR_OSD_CHANNELS},
+        {"pvrosdguide"              , WINDOW_DIALOG_PVR_OSD_GUIDE},
+        {"pvrosddirector"           , WINDOW_DIALOG_PVR_OSD_DIRECTOR},
+        {"pvrosdcutter"             , WINDOW_DIALOG_PVR_OSD_CUTTER},
+        {"pvrosdteletext"           , WINDOW_DIALOG_OSD_TELETEXT},
+
         {"systeminfo"               , WINDOW_SYSTEM_INFORMATION},
@@ -250,2 +267,4 @@ static const ActionMapping windows[] =
         {"appearancesettings"       , WINDOW_SETTINGS_APPEARANCE},
+        {"pvrsettings"              , WINDOW_SETTINGS_MYPVR},
+        {"tvsettings"               , WINDOW_SETTINGS_MYPVR},  // backward compat
         {"scripts"                  , WINDOW_PROGRAMS}, // backward compat
@@ -262,2 +281,6 @@ static const ActionMapping windows[] =
         {"submenu"                  , WINDOW_DIALOG_SUB_MENU},
+        {"pvrosdchannels"           , WINDOW_DIALOG_PVR_OSD_CHANNELS},
+        {"pvrosdguide"              , WINDOW_DIALOG_PVR_OSD_GUIDE},
+        {"pvrosddirector"           , WINDOW_DIALOG_PVR_OSD_DIRECTOR},
+        {"pvrosdcutter"             , WINDOW_DIALOG_PVR_OSD_CUTTER},
         {"favourites"               , WINDOW_DIALOG_FAVOURITES},
@@ -1154,4 +1177,6 @@ uint32_t CButtonTranslator::TranslateRemoteString(const char *szButton)
   else if (strButton.Equals("recordedtv")) buttonCode = XINPUT_IR_REMOTE_RECORDED_TV;
-  else if (strButton.Equals("guide")) buttonCode = XINPUT_IR_REMOTE_TITLE;   // same as title
+  else if (strButton.Equals("guide")) buttonCode = XINPUT_IR_REMOTE_GUIDE;
   else if (strButton.Equals("livetv")) buttonCode = XINPUT_IR_REMOTE_LIVE_TV;
+  else if (strButton.Equals("liveradio")) buttonCode = XINPUT_IR_REMOTE_LIVE_RADIO;
+  else if (strButton.Equals("epgsearch")) buttonCode = XINPUT_IR_REMOTE_EPG_SEARCH;
   else if (strButton.Equals("star")) buttonCode = XINPUT_IR_REMOTE_STAR;
@@ -1161,2 +1186,4 @@ uint32_t CButtonTranslator::TranslateRemoteString(const char *szButton)
   else if (strButton.Equals("xbox")) buttonCode = XINPUT_IR_REMOTE_DISPLAY; // same as display
+  else if (strButton.Equals("playlist")) buttonCode = XINPUT_IR_REMOTE_PLAYLIST;
+  else if (strButton.Equals("guide")) buttonCode = XINPUT_IR_REMOTE_GUIDE;
   else if (strButton.Equals("teletext")) buttonCode = XINPUT_IR_REMOTE_TELETEXT;
diff --git a/xbmc/interfaces/Builtins.cpp b/xbmc/interfaces/Builtins.cpp
index 2102b03..40cfd01 100644
--- a/xbmc/interfaces/Builtins.cpp
+++ b/xbmc/interfaces/Builtins.cpp
@@ -116,2 +116,4 @@ const BUILT_IN commands[] = {
   { "Suspend",                    false,  "Suspends the system" },
+  { "InhibitIdleShutdown",        false,  "Inhibit idle shutdown" },
+  { "AllowIdleShutdown",          false,  "Allow idle shutdown" },
   { "RestartApp",                 false,  "Restart XBMC" },
@@ -121,2 +123,3 @@ const BUILT_IN commands[] = {
   { "ActivateWindow",             true,   "Activate the specified window" },
+  { "ActivateWindowAndFocus",     true,   "Activate the specified window and sets focus to the specified id" },
   { "ReplaceWindow",              true,   "Replaces the current window with the new one" },
@@ -278,2 +281,7 @@ int CBuiltins::Execute(const CStdString& execString)
   }
+  else if (execute.Equals("inhibitidleshutdown"))
+  {
+    bool inhibit = (params.size() == 1 && params[0].Equals("true"));
+    CApplicationMessenger::Get().InhibitIdleShutdown(inhibit);
+  }
   else if (execute.Equals("minimize"))
@@ -353,2 +361,35 @@ int CBuiltins::Execute(const CStdString& execString)
   }
+  else if ((execute.Equals("activatewindowandfocus")) && params.size())
+  {
+    CStdString strWindow = params[0];
+
+    // confirm the window destination is valid prior to switching
+    int iWindow = CButtonTranslator::TranslateWindow(strWindow);
+    if (iWindow != WINDOW_INVALID)
+    {
+      // disable the screensaver
+      g_application.WakeUpScreenSaverAndDPMS();
+#if defined(__APPLE__) && defined(__arm__)
+      if (params[0].Equals("shutdownmenu"))
+        CBuiltins::Execute("Quit");
+#endif
+      vector<CStdString> dummy;
+      g_windowManager.ActivateWindow(iWindow, dummy, !execute.Equals("activatewindow"));
+
+      unsigned int iPtr = 1;
+      while (params.size() > iPtr + 1)
+      {
+        CGUIMessage msg(GUI_MSG_SETFOCUS, g_windowManager.GetFocusedWindow(),
+            atol(params[iPtr].c_str()),
+            (params.size() >= iPtr + 2) ? atol(params[iPtr + 1].c_str())+1 : 0);
+        g_windowManager.SendMessage(msg);
+        iPtr += 2;
+      }
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "ActivateWindowAndFocus called with invalid destination window: %s", strWindow.c_str());
+      return false;
+    }
+  }
   else if (execute.Equals("runscript") && params.size())
diff --git a/xbmc/interfaces/python/xbmcmodule/xbmcmodule.cpp b/xbmc/interfaces/python/xbmcmodule/xbmcmodule.cpp
index 303b6bc..03132d7 100644
--- a/xbmc/interfaces/python/xbmcmodule/xbmcmodule.cpp
+++ b/xbmc/interfaces/python/xbmcmodule/xbmcmodule.cpp
@@ -56,2 +56,5 @@
 #include "utils/log.h"
+#include "utils/Weather.h"
+#include "guilib/GUIFontManager.h"
+#include "filesystem/Directory.h"
 #include "pyrendercapture.h"
diff --git a/xbmc/pvr/PVRDatabase.cpp b/xbmc/pvr/PVRDatabase.cpp
new file mode 100644
index 0000000..9ef3f1c
--- /dev/null
+++ b/xbmc/pvr/PVRDatabase.cpp
@@ -0,0 +1,932 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "PVRDatabase.h"
+#include "dbwrappers/dataset.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/VideoSettings.h"
+#include "utils/log.h"
+
+#include "PVRManager.h"
+#include "channels/PVRChannelGroupsContainer.h"
+#include "channels/PVRChannelGroupInternal.h"
+#include "addons/PVRClient.h"
+
+using namespace std;
+using namespace dbiplus;
+using namespace PVR;
+using namespace ADDON;
+
+bool CPVRDatabase::Open()
+{
+  return CDatabase::Open(g_advancedSettings.m_databaseTV);
+}
+
+bool CPVRDatabase::CreateTables()
+{
+  bool bReturn(false);
+
+  try
+  {
+    if (!CDatabase::CreateTables())
+      return false;
+
+    BeginTransaction();
+    CLog::Log(LOGINFO, "PVR - %s - creating tables", __FUNCTION__);
+
+    CLog::Log(LOGDEBUG, "PVR - %s - creating table 'clients'", __FUNCTION__);
+    m_pDS->exec(
+        "CREATE TABLE clients ("
+          "idClient integer primary key, "
+          "sName    varchar(64), "
+          "sUid     varchar(32)"
+        ")"
+    );
+
+    CLog::Log(LOGDEBUG, "PVR - %s - creating table 'channels'", __FUNCTION__);
+    m_pDS->exec(
+        "CREATE TABLE channels ("
+          "idChannel            integer primary key, "
+          "iUniqueId            integer, "
+          "bIsRadio             bool, "
+          "bIsHidden            bool, "
+          "bIsUserSetIcon       bool, "
+          "bIsLocked            bool, "
+          "sIconPath            varchar(255), "
+          "sChannelName         varchar(64), "
+          "bIsVirtual           bool, "
+          "bEPGEnabled          bool, "
+          "sEPGScraper          varchar(32), "
+          "iLastWatched         integer,"
+
+          // TODO use mapping table
+          "iClientId            integer, "
+          "iClientChannelNumber integer, "
+          "sInputFormat         varchar(32), "
+          "sStreamURL           varchar(255), "
+          "iEncryptionSystem    integer, "
+
+          "idEpg                integer"
+        ")"
+    );
+    m_pDS->exec("CREATE UNIQUE INDEX idx_channels_iClientId_iUniqueId on channels(iClientId, iUniqueId);");
+
+    // TODO use a mapping table so multiple backends per channel can be implemented
+    //    CLog::Log(LOGDEBUG, "PVR - %s - creating table 'map_channels_clients'", __FUNCTION__);
+    //    m_pDS->exec(
+    //        "CREATE TABLE map_channels_clients ("
+    //          "idChannel             integer primary key, "
+    //          "idClient              integer, "
+    //          "iClientChannelNumber  integer,"
+    //          "sInputFormat          string,"
+    //          "sStreamURL            string,"
+    //          "iEncryptionSystem     integer"
+    //        ");"
+    //    );
+    //    m_pDS->exec("CREATE UNIQUE INDEX idx_idChannel_idClient on map_channels_clients(idChannel, idClient);");
+
+    CLog::Log(LOGDEBUG, "PVR - %s - creating table 'channelgroups'", __FUNCTION__);
+    m_pDS->exec(
+        "CREATE TABLE channelgroups ("
+          "idGroup         integer primary key,"
+          "bIsRadio        bool, "
+          "iGroupType      integer, "
+          "sName           varchar(64)"
+        ")"
+    );
+    m_pDS->exec("CREATE INDEX idx_channelgroups_bIsRadio on channelgroups(bIsRadio);");
+
+    CLog::Log(LOGDEBUG, "PVR - %s - creating table 'map_channelgroups_channels'", __FUNCTION__);
+    m_pDS->exec(
+        "CREATE TABLE map_channelgroups_channels ("
+          "idChannel      integer, "
+          "idGroup        integer, "
+          "iChannelNumber integer"
+        ")"
+    );
+    m_pDS->exec("CREATE UNIQUE INDEX idx_idGroup_idChannel on map_channelgroups_channels(idGroup, idChannel);");
+
+    CLog::Log(LOGDEBUG, "PVR - %s - creating table 'channelsettings'", __FUNCTION__);
+    m_pDS->exec(
+        "CREATE TABLE channelsettings ("
+          "idChannel            integer primary key, "
+          "iInterlaceMethod     integer, "
+          "iViewMode            integer, "
+          "fCustomZoomAmount    float, "
+          "fPixelRatio          float, "
+          "iAudioStream         integer, "
+          "iSubtitleStream      integer,"
+          "fSubtitleDelay       float, "
+          "bSubtitles           bool, "
+          "fBrightness          float, "
+          "fContrast            float, "
+          "fGamma               float,"
+          "fVolumeAmplification float, "
+          "fAudioDelay          float, "
+          "bOutputToAllSpeakers bool, "
+          "bCrop                bool, "
+          "iCropLeft            integer, "
+          "iCropRight           integer, "
+          "iCropTop             integer, "
+          "iCropBottom          integer, "
+          "fSharpness           float, "
+          "fNoiseReduction      float, "
+          "fCustomVerticalShift float, "
+          "bCustomNonLinStretch bool, "
+          "bPostProcess         bool, "
+          "iScalingMethod       integer, "
+          "iDeinterlaceMode     integer "
+        ")"
+    );
+
+    CommitTransaction();
+    bReturn = true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - unable to create PVR database tables (error %i)", __FUNCTION__, (int)GetLastError());
+    RollbackTransaction();
+    bReturn = false;
+  }
+
+  if (bReturn)
+  {
+    // disable all PVR add-on when started the first time
+    ADDON::VECADDONS addons;
+    if ((bReturn = CAddonMgr::Get().GetAddons(ADDON_PVRDLL, addons, true)) == false)
+      CLog::Log(LOGERROR, "PVR - %s - failed to get add-ons from the add-on manager", __FUNCTION__);
+    else
+    {
+      CAddonDatabase database;
+      database.Open();
+      for (IVECADDONS it = addons.begin(); it != addons.end(); it++)
+        database.DisableAddon(it->get()->ID());
+      database.Close();
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRDatabase::UpdateOldVersion(int iVersion)
+{
+  bool bReturn = true;
+
+  BeginTransaction();
+
+  try
+  {
+    if (iVersion < 11)
+    {
+      CLog::Log(LOGERROR, "PVR - %s - updating from table versions < 11 not supported. please delete '%s'",
+          __FUNCTION__, GetBaseDBName());
+      bReturn = false;
+    }
+    else
+    {
+      if (iVersion < 12)
+        m_pDS->exec("DROP VIEW vw_last_watched;");
+
+      if (iVersion < 13)
+        m_pDS->exec("ALTER TABLE channels ADD idEpg integer;");
+
+      if (iVersion < 14)
+        m_pDS->exec("ALTER TABLE channelsettings ADD fCustomVerticalShift float;");
+
+      if (iVersion < 15)
+      {
+        m_pDS->exec("ALTER TABLE channelsettings ADD bCustomNonLinStretch bool;");
+        m_pDS->exec("ALTER TABLE channelsettings ADD bPostProcess bool;");
+        m_pDS->exec("ALTER TABLE channelsettings ADD iScalingMethod integer;");
+      }
+      if (iVersion < 16)
+      {
+        /* sqlite apparently can't delete columns from an existing table, so just leave the extra column alone */
+      }
+      if (iVersion < 17)
+      {
+        m_pDS->exec("ALTER TABLE channelsettings ADD iDeinterlaceMode integer");
+        m_pDS->exec("UPDATE channelsettings SET iDeinterlaceMode = 2 WHERE iInterlaceMethod NOT IN (0,1)"); // anything other than none: method auto => mode force
+        m_pDS->exec("UPDATE channelsettings SET iDeinterlaceMode = 1 WHERE iInterlaceMethod = 1"); // method auto => mode auto
+        m_pDS->exec("UPDATE channelsettings SET iDeinterlaceMode = 0, iInterlaceMethod = 1 WHERE iInterlaceMethod = 0"); // method none => mode off, method auto
+      }
+      if (iVersion < 18)
+      {
+        m_pDS->exec("DROP INDEX idx_channels_iClientId;");
+        m_pDS->exec("DROP INDEX idx_channels_iLastWatched;");
+        m_pDS->exec("DROP INDEX idx_channels_bIsRadio;");
+        m_pDS->exec("DROP INDEX idx_channels_bIsHidden;");
+        m_pDS->exec("DROP INDEX idx_idChannel_idGroup;");
+        m_pDS->exec("DROP INDEX idx_idGroup_iChannelNumber;");
+        m_pDS->exec("CREATE UNIQUE INDEX idx_channels_iClientId_iUniqueId on channels(iClientId, iUniqueId);");
+        m_pDS->exec("CREATE UNIQUE INDEX idx_idGroup_idChannel on map_channelgroups_channels(idGroup, idChannel);");
+      }
+      if (iVersion < 19)
+      {
+        // bit of a hack, but we need to keep the version/contents of the non-pvr databases the same to allow clean upgrades
+        ADDON::VECADDONS addons;
+        if ((bReturn = CAddonMgr::Get().GetAddons(ADDON_PVRDLL, addons, true)) == false)
+          CLog::Log(LOGERROR, "PVR - %s - failed to get add-ons from the add-on manager", __FUNCTION__);
+        else
+        {
+          CAddonDatabase database;
+          database.Open();
+          for (IVECADDONS it = addons.begin(); it != addons.end(); it++)
+          {
+            if (!database.IsSystemPVRAddonEnabled(it->get()->ID()))
+              database.DisableAddon(it->get()->ID());
+          }
+          database.Close();
+        }
+      }
+      if (iVersion < 20)
+        m_pDS->exec("ALTER TABLE channels ADD bIsUserSetIcon bool");
+
+      if (iVersion < 21)
+        m_pDS->exec("ALTER TABLE channelgroups ADD iGroupType integer");
+
+      if (iVersion < 22)
+        m_pDS->exec("ALTER TABLE channels ADD bIsLocked bool");
+    }
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - error attempting to update the database version!", __FUNCTION__);
+    bReturn = false;
+  }
+
+  if (bReturn)
+    CommitTransaction();
+  else
+    RollbackTransaction();
+
+  return bReturn;
+}
+
+int CPVRDatabase::GetLastChannelId(void)
+{
+  int iReturn(0);
+
+  CStdString strQuery = FormatSQL("SELECT MAX(idChannel) as iMaxChannel FROM channels");
+  if (ResultQuery(strQuery))
+  {
+    try
+    {
+      if (!m_pDS->eof())
+        iReturn = m_pDS->fv("iMaxChannel").get_asInt();
+    }
+    catch (...) {}
+  }
+
+  return iReturn;
+}
+
+/********** Channel methods **********/
+
+bool CPVRDatabase::DeleteChannels(void)
+{
+  CLog::Log(LOGDEBUG, "PVR - %s - deleting all channels from the database", __FUNCTION__);
+  return DeleteValues("channels");
+}
+
+bool CPVRDatabase::DeleteClientChannels(const CPVRClient &client)
+{
+  /* invalid client Id */
+  if (client.GetID() <= 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid client id: %i", __FUNCTION__, client.GetID());
+    return false;
+  }
+
+  CLog::Log(LOGDEBUG, "PVR - %s - deleting all channels from client '%i' from the database", __FUNCTION__, client.GetID());
+  CStdString strWhereClause = FormatSQL("iClientId = %u", client.GetID());
+  return DeleteValues("channels", strWhereClause);
+}
+
+bool CPVRDatabase::Delete(const CPVRChannel &channel)
+{
+  /* invalid channel */
+  if (channel.ChannelID() <= 0)
+    return false;
+
+  CLog::Log(LOGDEBUG, "PVR - %s - deleting channel '%s' from the database", __FUNCTION__, channel.ChannelName().c_str());
+  CStdString strWhereClause = FormatSQL("idChannel = %u", channel.ChannelID());
+  return DeleteValues("channels", strWhereClause);
+}
+
+int CPVRDatabase::Get(CPVRChannelGroupInternal &results)
+{
+  int iReturn(0);
+
+  CStdString strQuery = FormatSQL("SELECT channels.idChannel, channels.iUniqueId, channels.bIsRadio, channels.bIsHidden, channels.bIsUserSetIcon, "
+      "channels.sIconPath, channels.sChannelName, channels.bIsVirtual, channels.bEPGEnabled, channels.sEPGScraper, channels.iLastWatched, channels.iClientId, channels.bIsLocked, "
+      "channels.iClientChannelNumber, channels.sInputFormat, channels.sInputFormat, channels.sStreamURL, channels.iEncryptionSystem, map_channelgroups_channels.iChannelNumber, channels.idEpg "
+      "FROM map_channelgroups_channels "
+      "LEFT JOIN channels ON channels.idChannel = map_channelgroups_channels.idChannel "
+      "WHERE map_channelgroups_channels.idGroup = %u", results.IsRadio() ? XBMC_INTERNAL_GROUP_RADIO : XBMC_INTERNAL_GROUP_TV);
+  if (ResultQuery(strQuery))
+  {
+    try
+    {
+      while (!m_pDS->eof())
+      {
+        CPVRChannelPtr channel = CPVRChannelPtr(new CPVRChannel());
+
+        channel->m_iChannelId              = m_pDS->fv("idChannel").get_asInt();
+        channel->m_iUniqueId               = m_pDS->fv("iUniqueId").get_asInt();
+        channel->m_bIsRadio                = m_pDS->fv("bIsRadio").get_asBool();
+        channel->m_bIsHidden               = m_pDS->fv("bIsHidden").get_asBool();
+        channel->m_bIsUserSetIcon          = m_pDS->fv("bIsUserSetIcon").get_asBool();
+        channel->m_bIsLocked               = m_pDS->fv("bIsLocked").get_asBool();
+        channel->m_strIconPath             = m_pDS->fv("sIconPath").get_asString();
+        channel->m_strChannelName          = m_pDS->fv("sChannelName").get_asString();
+        channel->m_bIsVirtual              = m_pDS->fv("bIsVirtual").get_asBool();
+        channel->m_bEPGEnabled             = m_pDS->fv("bEPGEnabled").get_asBool();
+        channel->m_strEPGScraper           = m_pDS->fv("sEPGScraper").get_asString();
+        channel->m_iLastWatched            = (time_t) m_pDS->fv("iLastWatched").get_asInt();
+        channel->m_iClientId               = m_pDS->fv("iClientId").get_asInt();
+        channel->m_iClientChannelNumber    = m_pDS->fv("iClientChannelNumber").get_asInt();
+        channel->m_strInputFormat          = m_pDS->fv("sInputFormat").get_asString();
+        channel->m_strStreamURL            = m_pDS->fv("sStreamURL").get_asString();
+        channel->m_iClientEncryptionSystem = m_pDS->fv("iEncryptionSystem").get_asInt();
+        channel->m_iEpgId                  = m_pDS->fv("idEpg").get_asInt();
+
+        CLog::Log(LOGDEBUG, "PVR - %s - channel '%s' loaded from the database", __FUNCTION__, channel->m_strChannelName.c_str());
+        PVRChannelGroupMember newMember = { channel, m_pDS->fv("iChannelNumber").get_asInt() };
+        results.m_members.push_back(newMember);
+
+        m_pDS->next();
+        ++iReturn;
+      }
+      m_pDS->close();
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR, "PVR - %s - couldn't load channels from the database", __FUNCTION__);
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "PVR - %s - query failed", __FUNCTION__);
+  }
+
+  m_pDS->close();
+  return iReturn;
+}
+
+bool CPVRDatabase::DeleteChannelSettings()
+{
+  CLog::Log(LOGDEBUG, "PVR - %s - deleting all channel settings from the database", __FUNCTION__);
+  return DeleteValues("channelsettings");
+}
+
+bool CPVRDatabase::DeleteChannelSettings(const CPVRChannel &channel)
+{
+  bool bReturn(false);
+
+  /* invalid channel */
+  if (channel.ChannelID() <= 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid channel id: %i", __FUNCTION__, channel.ChannelID());
+    return bReturn;
+  }
+
+  CStdString strWhereClause = FormatSQL("idChannel = %u", channel.ChannelID());
+  return DeleteValues("channelsettings", strWhereClause);
+}
+
+bool CPVRDatabase::GetChannelSettings(const CPVRChannel &channel, CVideoSettings &settings)
+{
+  bool bReturn(false);
+
+  /* invalid channel */
+  if (channel.ChannelID() <= 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid channel id: %i", __FUNCTION__, channel.ChannelID());
+    return bReturn;
+  }
+
+  CStdString strQuery = FormatSQL("SELECT * FROM channelsettings WHERE idChannel = %u;", channel.ChannelID());
+
+  if (ResultQuery(strQuery))
+  {
+    try
+    {
+      if (m_pDS->num_rows() > 0)
+      {
+        settings.m_AudioDelay           = m_pDS->fv("fAudioDelay").get_asFloat();
+        settings.m_AudioStream          = m_pDS->fv("iAudioStream").get_asInt();
+        settings.m_Brightness           = m_pDS->fv("fBrightness").get_asFloat();
+        settings.m_Contrast             = m_pDS->fv("fContrast").get_asFloat();
+        settings.m_CustomPixelRatio     = m_pDS->fv("fPixelRatio").get_asFloat();
+        settings.m_CustomNonLinStretch  = m_pDS->fv("bCustomNonLinStretch").get_asBool();
+        settings.m_NoiseReduction       = m_pDS->fv("fNoiseReduction").get_asFloat();
+        settings.m_PostProcess          = m_pDS->fv("bPostProcess").get_asBool();
+        settings.m_Sharpness            = m_pDS->fv("fSharpness").get_asFloat();
+        settings.m_CustomZoomAmount     = m_pDS->fv("fCustomZoomAmount").get_asFloat();
+        settings.m_CustomVerticalShift  = m_pDS->fv("fCustomVerticalShift").get_asFloat();
+        settings.m_Gamma                = m_pDS->fv("fGamma").get_asFloat();
+        settings.m_SubtitleDelay        = m_pDS->fv("fSubtitleDelay").get_asFloat();
+        settings.m_SubtitleOn           = m_pDS->fv("bSubtitles").get_asBool();
+        settings.m_SubtitleStream       = m_pDS->fv("iSubtitleStream").get_asInt();
+        settings.m_ViewMode             = m_pDS->fv("iViewMode").get_asInt();
+        settings.m_Crop                 = m_pDS->fv("bCrop").get_asBool();
+        settings.m_CropLeft             = m_pDS->fv("iCropLeft").get_asInt();
+        settings.m_CropRight            = m_pDS->fv("iCropRight").get_asInt();
+        settings.m_CropTop              = m_pDS->fv("iCropTop").get_asInt();
+        settings.m_CropBottom           = m_pDS->fv("iCropBottom").get_asInt();
+        settings.m_InterlaceMethod      = (EINTERLACEMETHOD)m_pDS->fv("iInterlaceMethod").get_asInt();
+        settings.m_DeinterlaceMode      = (EDEINTERLACEMODE)m_pDS->fv("iDeinterlaceMode").get_asInt();
+        settings.m_VolumeAmplification  = m_pDS->fv("fVolumeAmplification").get_asFloat();
+        settings.m_OutputToAllSpeakers  = m_pDS->fv("bOutputToAllSpeakers").get_asBool();
+        settings.m_ScalingMethod        = (ESCALINGMETHOD)m_pDS->fv("iScalingMethod").get_asInt();
+
+        bReturn = true;
+      }
+
+      m_pDS->close();
+    }
+    catch(...)
+    {
+      CLog::Log(LOGERROR, "PVR - %s - failed to get channel settings for channel '%s'", __FUNCTION__, channel.ChannelName().c_str());
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "PVR - %s - query failed", __FUNCTION__);
+  }
+
+  return bReturn;
+}
+
+bool CPVRDatabase::PersistChannelSettings(const CPVRChannel &channel, const CVideoSettings &settings)
+{
+  /* invalid channel */
+  if (channel.ChannelID() <= 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid channel id: %i", __FUNCTION__, channel.ChannelID());
+    return false;
+  }
+
+  CStdString strQuery = FormatSQL(
+      "REPLACE INTO channelsettings "
+        "(idChannel, iInterlaceMethod, iViewMode, fCustomZoomAmount, fPixelRatio, iAudioStream, iSubtitleStream, fSubtitleDelay, "
+         "bSubtitles, fBrightness, fContrast, fGamma, fVolumeAmplification, fAudioDelay, bOutputToAllSpeakers, bCrop, iCropLeft, "
+         "iCropRight, iCropTop, iCropBottom, fSharpness, fNoiseReduction, fCustomVerticalShift, bCustomNonLinStretch, bPostProcess, iScalingMethod, iDeinterlaceMode) VALUES "
+         "(%i, %i, %i, %f, %f, %i, %i, %f, %i, %f, %f, %f, %f, %f, %i, %i, %i, %i, %i, %i, %f, %f, %f, %i, %i, %i, %i);",
+       channel.ChannelID(), settings.m_InterlaceMethod, settings.m_ViewMode, settings.m_CustomZoomAmount, settings.m_CustomPixelRatio,
+       settings.m_AudioStream, settings.m_SubtitleStream, settings.m_SubtitleDelay, settings.m_SubtitleOn ? 1 :0,
+       settings.m_Brightness, settings.m_Contrast, settings.m_Gamma, settings.m_VolumeAmplification, settings.m_AudioDelay,
+       settings.m_OutputToAllSpeakers ? 1 : 0, settings.m_Crop ? 1 : 0, settings.m_CropLeft, settings.m_CropRight, settings.m_CropTop,
+       settings.m_CropBottom, settings.m_Sharpness, settings.m_NoiseReduction, settings.m_CustomVerticalShift,
+       settings.m_CustomNonLinStretch ? 1 : 0, settings.m_PostProcess ? 1 : 0, settings.m_ScalingMethod, settings.m_DeinterlaceMode);
+
+  return ExecuteQuery(strQuery);
+}
+
+/********** Channel group methods **********/
+
+bool CPVRDatabase::RemoveChannelsFromGroup(const CPVRChannelGroup &group)
+{
+  CStdString strWhereClause = FormatSQL("idGroup = %u", group.GroupID());
+  return DeleteValues("map_channelgroups_channels", strWhereClause);
+}
+
+bool CPVRDatabase::GetCurrentGroupMembers(const CPVRChannelGroup &group, vector<int> &members)
+{
+  bool bReturn(false);
+  /* invalid group id */
+  if (group.GroupID() <= 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid group id: %d", __FUNCTION__, group.GroupID());
+    return false;
+  }
+
+  CStdString strCurrentMembersQuery = FormatSQL("SELECT idChannel FROM map_channelgroups_channels WHERE idGroup = %u", group.GroupID());
+  if (ResultQuery(strCurrentMembersQuery))
+  {
+    try
+    {
+      while (!m_pDS->eof())
+      {
+        members.push_back(m_pDS->fv("idChannel").get_asInt());
+        m_pDS->next();
+      }
+      m_pDS->close();
+      bReturn = true;
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR, "PVR - %s - couldn't load channels from the database", __FUNCTION__);
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "PVR - %s - query failed", __FUNCTION__);
+  }
+
+  return bReturn;
+}
+
+bool CPVRDatabase::DeleteChannelsFromGroup(const CPVRChannelGroup &group)
+{
+  /* invalid group id */
+  if (group.GroupID() <= 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid group id: %d", __FUNCTION__, group.GroupID());
+    return false;
+  }
+
+  CStdString strWhereClause;
+  strWhereClause = FormatSQL("idGroup = %u", group.GroupID());
+  return DeleteValues("map_channelgroups_channels", strWhereClause);
+}
+
+bool CPVRDatabase::DeleteChannelsFromGroup(const CPVRChannelGroup &group, const vector<int> &channelsToDelete)
+{
+  bool bDelete(true);
+  unsigned int iDeletedChannels(0);
+  /* invalid group id */
+  if (group.GroupID() <= 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid group id: %d", __FUNCTION__, group.GroupID());
+    return false;
+  }
+
+  while (iDeletedChannels < channelsToDelete.size())
+  {
+    CStdString strChannelsToDelete;
+    CStdString strWhereClause;
+
+    for (unsigned int iChannelPtr = 0; iChannelPtr + iDeletedChannels < channelsToDelete.size() && iChannelPtr < 50; iChannelPtr++)
+      strChannelsToDelete.AppendFormat(", %d", channelsToDelete.at(iDeletedChannels + iChannelPtr));
+
+    if (!strChannelsToDelete.IsEmpty())
+    {
+      strChannelsToDelete = strChannelsToDelete.Right(strChannelsToDelete.length() - 2);
+      strWhereClause = FormatSQL("idGroup = %u AND idChannel IN (%s)", group.GroupID(), strChannelsToDelete.c_str());
+      bDelete = DeleteValues("map_channelgroups_channels", strWhereClause) && bDelete;
+    }
+
+    iDeletedChannels += 50;
+  }
+
+  return bDelete;
+}
+
+bool CPVRDatabase::RemoveStaleChannelsFromGroup(const CPVRChannelGroup &group)
+{
+  bool bDelete(true);
+  /* invalid group id */
+  if (group.GroupID() <= 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid group id: %d", __FUNCTION__, group.GroupID());
+    return false;
+  }
+
+  if (!group.IsInternalGroup())
+  {
+    /* First remove channels that don't exist in the main channels table */
+    CStdString strWhereClause = FormatSQL("idChannel IN (SELECT map_channelgroups_channels.idChannel FROM map_channelgroups_channels LEFT JOIN channels on map_channelgroups_channels.idChannel = channels.idChannel WHERE channels.idChannel IS NULL)");
+    bDelete = DeleteValues("map_channelgroups_channels", strWhereClause);
+  }
+
+  if (group.m_members.size() > 0)
+  {
+    vector<int> currentMembers;
+    if (GetCurrentGroupMembers(group, currentMembers))
+    {
+      vector<int> channelsToDelete;
+      for (unsigned int iChannelPtr = 0; iChannelPtr < currentMembers.size(); iChannelPtr++)
+      {
+        if (!group.IsGroupMember(currentMembers.at(iChannelPtr)))
+          channelsToDelete.push_back(currentMembers.at(iChannelPtr));
+      }
+
+      bDelete = DeleteChannelsFromGroup(group, channelsToDelete) && bDelete;
+    }
+  }
+  else
+  {
+    CStdString strWhereClause = FormatSQL("idGroup = %u", group.GroupID());
+    bDelete = DeleteValues("map_channelgroups_channels", strWhereClause) && bDelete;
+  }
+
+  return bDelete;
+}
+
+bool CPVRDatabase::DeleteChannelGroups(void)
+{
+  CLog::Log(LOGDEBUG, "PVR - %s - deleting all channel groups from the database", __FUNCTION__);
+
+  return DeleteValues("channelgroups") &&
+      DeleteValues("map_channelgroups_channels");
+}
+
+bool CPVRDatabase::Delete(const CPVRChannelGroup &group)
+{
+  /* invalid group id */
+  if (group.GroupID() <= 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid group id: %d", __FUNCTION__, group.GroupID());
+    return false;
+  }
+
+  CStdString strWhereClause = FormatSQL("idGroup = %u AND bIsRadio = %u", group.GroupID(), group.IsRadio());
+  return RemoveChannelsFromGroup(group) &&
+      DeleteValues("channelgroups", strWhereClause);
+}
+
+bool CPVRDatabase::Get(CPVRChannelGroups &results)
+{
+  bool bReturn = false;
+  CStdString strQuery = FormatSQL("SELECT * from channelgroups WHERE bIsRadio = %u", results.IsRadio());
+
+  if (ResultQuery(strQuery))
+  {
+    try
+    {
+      while (!m_pDS->eof())
+      {
+        CPVRChannelGroup data(m_pDS->fv("bIsRadio").get_asBool(), m_pDS->fv("idGroup").get_asInt(), m_pDS->fv("sName").get_asString());
+        data.SetGroupType(m_pDS->fv("iGroupType").get_asInt());
+        results.Update(data);
+
+        CLog::Log(LOGDEBUG, "PVR - %s - group '%s' loaded from the database", __FUNCTION__, data.GroupName().c_str());
+        m_pDS->next();
+      }
+      m_pDS->close();
+      bReturn = true;
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR, "%s - couldn't load channels from the database", __FUNCTION__);
+    }
+  }
+
+  return bReturn;
+}
+
+int CPVRDatabase::Get(CPVRChannelGroup &group)
+{
+  int iReturn = -1;
+
+  /* invalid group id */
+  if (group.GroupID() < 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid group id: %d", __FUNCTION__, group.GroupID());
+    return -1;
+  }
+
+  CStdString strQuery = FormatSQL("SELECT idChannel, iChannelNumber FROM map_channelgroups_channels WHERE idGroup = %u ORDER BY iChannelNumber", group.GroupID());
+  if (ResultQuery(strQuery))
+  {
+    iReturn = 0;
+
+    try
+    {
+      while (!m_pDS->eof())
+      {
+        int iChannelId = m_pDS->fv("idChannel").get_asInt();
+        int iChannelNumber = m_pDS->fv("iChannelNumber").get_asInt();
+        CPVRChannelPtr channel = g_PVRChannelGroups->GetGroupAll(group.IsRadio())->GetByChannelID(iChannelId);
+
+        if (channel && group.AddToGroup(*channel, iChannelNumber))
+          ++iReturn;
+
+        m_pDS->next();
+      }
+      m_pDS->close();
+    }
+    catch(...)
+    {
+      CLog::Log(LOGERROR, "PVR - %s - failed to get channels", __FUNCTION__);
+    }
+  }
+
+  return iReturn;
+}
+
+bool CPVRDatabase::PersistChannels(CPVRChannelGroup &group)
+{
+  bool bReturn(true);
+  int iLastChannel(0);
+
+  /* we can only safely get this from a local db */
+  if (m_sqlite)
+    iLastChannel = GetLastChannelId();
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < group.m_members.size(); iChannelPtr++)
+  {
+    PVRChannelGroupMember member = group.m_members.at(iChannelPtr);
+    if (member.channel->IsChanged() || member.channel->IsNew())
+    {
+      if (m_sqlite && member.channel->IsNew())
+        member.channel->SetChannelID(++iLastChannel);
+      bReturn &= Persist(*member.channel, m_sqlite || !member.channel->IsNew());
+    }
+  }
+  return CommitInsertQueries();
+}
+
+bool CPVRDatabase::PersistGroupMembers(CPVRChannelGroup &group)
+{
+  bool bReturn = true;
+  bool bRemoveChannels = true;
+  CStdString strQuery;
+  CSingleLock lock(group.m_critSection);
+
+  if (group.m_members.size() > 0)
+  {
+    for (unsigned int iChannelPtr = 0; iChannelPtr < group.m_members.size(); iChannelPtr++)
+    {
+      PVRChannelGroupMember member = group.m_members.at(iChannelPtr);
+
+      CStdString strWhereClause = FormatSQL("idChannel = %u AND idGroup = %u AND iChannelNumber = %u",
+          member.channel->ChannelID(), group.GroupID(), member.iChannelNumber);
+
+      CStdString strValue = GetSingleValue("map_channelgroups_channels", "idChannel", strWhereClause);
+      if (strValue.IsEmpty())
+      {
+        strQuery = FormatSQL("REPLACE INTO map_channelgroups_channels ("
+            "idGroup, idChannel, iChannelNumber) "
+            "VALUES (%i, %i, %i);",
+            group.GroupID(), member.channel->ChannelID(), member.iChannelNumber);
+        QueueInsertQuery(strQuery);
+      }
+    }
+    lock.Leave();
+
+    bReturn = CommitInsertQueries();
+    bRemoveChannels = RemoveStaleChannelsFromGroup(group);
+  }
+
+  return bReturn && bRemoveChannels;
+}
+
+/********** Client methods **********/
+
+bool CPVRDatabase::DeleteClients()
+{
+  CLog::Log(LOGDEBUG, "PVR - %s - deleting all clients from the database", __FUNCTION__);
+
+  return DeleteValues("clients");
+      //TODO && DeleteValues("map_channels_clients");
+}
+
+bool CPVRDatabase::Delete(const CPVRClient &client)
+{
+  /* invalid client uid */
+  if (client.ID().IsEmpty())
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid client uid", __FUNCTION__);
+    return false;
+  }
+
+  CStdString strWhereClause = FormatSQL("sUid = '%s'", client.ID().c_str());
+  return DeleteValues("clients", strWhereClause);
+}
+
+int CPVRDatabase::GetClientId(const CStdString &strClientUid)
+{
+  CStdString strWhereClause = FormatSQL("sUid = '%s'", strClientUid.c_str());
+  CStdString strValue = GetSingleValue("clients", "idClient", strWhereClause);
+
+  if (strValue.IsEmpty())
+    return -1;
+
+  return atol(strValue.c_str());
+}
+
+bool CPVRDatabase::Persist(CPVRChannelGroup &group)
+{
+  bool bReturn(false);
+  if (group.GroupName().IsEmpty())
+  {
+    CLog::Log(LOGERROR, "%s - empty group name", __FUNCTION__);
+    return bReturn;
+  }
+
+  CStdString strQuery;
+  bReturn = true;
+  {
+    CSingleLock lock(group.m_critSection);
+
+    /* insert a new entry when this is a new group, or replace the existing one otherwise */
+    if (group.GroupID() <= 0)
+      strQuery = FormatSQL("INSERT INTO channelgroups (bIsRadio, iGroupType, sName) VALUES (%i, %i, '%s')",
+          (group.IsRadio() ? 1 :0), group.GroupType(), group.GroupName().c_str());
+    else
+      strQuery = FormatSQL("REPLACE INTO channelgroups (idGroup, bIsRadio, iGroupType, sName) VALUES (%i, %i, %i, '%s')",
+          group.GroupID(), (group.IsRadio() ? 1 :0), group.GroupType(), group.GroupName().c_str());
+
+    bReturn = ExecuteQuery(strQuery);
+
+    /* set the group id if it was <= 0 */
+    if (bReturn && group.GroupID() <= 0)
+      group.m_iGroupId = (int) m_pDS->lastinsertid();
+  }
+
+  /* only persist the channel data for the internal groups */
+  if (group.IsInternalGroup())
+    bReturn &= PersistChannels(group);
+
+  /* persist the group member entries */
+  if (bReturn)
+    bReturn = PersistGroupMembers(group);
+
+  return bReturn;
+}
+
+int CPVRDatabase::Persist(const AddonPtr client)
+{
+  int iReturn(-1);
+
+  /* invalid client uid or name */
+  if (client->Name().IsEmpty() || client->ID().IsEmpty())
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid client uid or name", __FUNCTION__);
+    return iReturn;
+  }
+
+  CStdString strQuery = FormatSQL("REPLACE INTO clients (sName, sUid) VALUES ('%s', '%s');",
+      client->Name().c_str(), client->ID().c_str());
+
+  if (ExecuteQuery(strQuery))
+    iReturn = (int) m_pDS->lastinsertid();
+
+  return iReturn;
+}
+
+bool CPVRDatabase::Persist(CPVRChannel &channel, bool bQueueWrite /* = false */)
+{
+  bool bReturn(false);
+
+  /* invalid channel */
+  if (channel.UniqueID() <= 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - invalid channel uid: %d", __FUNCTION__, channel.UniqueID());
+    return bReturn;
+  }
+
+  CStdString strQuery;
+  if (channel.ChannelID() <= 0)
+  {
+    /* new channel */
+    strQuery = FormatSQL("INSERT INTO channels ("
+        "iUniqueId, bIsRadio, bIsHidden, bIsUserSetIcon, bIsLocked, "
+        "sIconPath, sChannelName, bIsVirtual, bEPGEnabled, sEPGScraper, iLastWatched, iClientId, "
+        "iClientChannelNumber, sInputFormat, sStreamURL, iEncryptionSystem, idEpg) "
+        "VALUES (%i, %i, %i, %i, %i, '%s', '%s', %i, %i, '%s', %u, %i, %i, '%s', '%s', %i, %i)",
+        channel.UniqueID(), (channel.IsRadio() ? 1 :0), (channel.IsHidden() ? 1 : 0), (channel.IsUserSetIcon() ? 1 : 0), (channel.IsLocked() ? 1 : 0),
+        channel.IconPath().c_str(), channel.ChannelName().c_str(), (channel.IsVirtual() ? 1 : 0), (channel.EPGEnabled() ? 1 : 0), channel.EPGScraper().c_str(), channel.LastWatched(), channel.ClientID(),
+        channel.ClientChannelNumber(), channel.InputFormat().c_str(), channel.StreamURL().c_str(), channel.EncryptionSystem(),
+        channel.EpgID());
+  }
+  else
+  {
+    /* update channel */
+    strQuery = FormatSQL("REPLACE INTO channels ("
+        "iUniqueId, bIsRadio, bIsHidden, bIsUserSetIcon, bIsLocked, "
+        "sIconPath, sChannelName, bIsVirtual, bEPGEnabled, sEPGScraper, iLastWatched, iClientId, "
+        "iClientChannelNumber, sInputFormat, sStreamURL, iEncryptionSystem, idChannel, idEpg) "
+        "VALUES (%i, %i, %i, %i, %i, '%s', '%s', %i, %i, '%s', %u, %i, %i, '%s', '%s', %i, %i, %i)",
+        channel.UniqueID(), (channel.IsRadio() ? 1 :0), (channel.IsHidden() ? 1 : 0), (channel.IsUserSetIcon() ? 1 : 0), (channel.IsLocked() ? 1 : 0),
+        channel.IconPath().c_str(), channel.ChannelName().c_str(), (channel.IsVirtual() ? 1 : 0), (channel.EPGEnabled() ? 1 : 0), channel.EPGScraper().c_str(), channel.LastWatched(), channel.ClientID(),
+        channel.ClientChannelNumber(), channel.InputFormat().c_str(), channel.StreamURL().c_str(), channel.EncryptionSystem(), channel.ChannelID(),
+        channel.EpgID());
+  }
+
+  if (bQueueWrite)
+  {
+    QueueInsertQuery(strQuery);
+    bReturn = true;
+  }
+  else if (ExecuteQuery(strQuery))
+  {
+    CSingleLock lock(channel.m_critSection);
+    if (channel.m_iChannelId <= 0)
+      channel.m_iChannelId = (int)m_pDS->lastinsertid();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
diff --git a/xbmc/pvr/PVRGUIInfo.cpp b/xbmc/pvr/PVRGUIInfo.cpp
new file mode 100644
index 0000000..fee1131
--- /dev/null
+++ b/xbmc/pvr/PVRGUIInfo.cpp
@@ -0,0 +1,857 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Application.h"
+#include "PVRGUIInfo.h"
+#include "guilib/LocalizeStrings.h"
+#include "utils/StringUtils.h"
+#include "GUIInfoManager.h"
+#include "Util.h"
+#include "threads/SingleLock.h"
+#include "PVRManager.h"
+#include "pvr/addons/PVRClients.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "pvr/channels/PVRChannel.h"
+#include "epg/EpgInfoTag.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
+
+using namespace PVR;
+using namespace EPG;
+using namespace std;
+
+CPVRGUIInfo::CPVRGUIInfo(void) :
+    CThread("PVR GUI info updater"),
+    m_playingEpgTag(NULL)
+{
+  ResetProperties();
+}
+
+CPVRGUIInfo::~CPVRGUIInfo(void)
+{
+  Stop();
+}
+
+void CPVRGUIInfo::ResetProperties(void)
+{
+  CSingleLock lock(m_critSection);
+  m_strActiveTimerTitle         = StringUtils::EmptyString;
+  m_strActiveTimerChannelName   = StringUtils::EmptyString;
+  m_strActiveTimerChannelIcon   = StringUtils::EmptyString;
+  m_strActiveTimerTime          = StringUtils::EmptyString;
+  m_strNextTimerInfo            = StringUtils::EmptyString;
+  m_strNextRecordingTitle       = StringUtils::EmptyString;
+  m_strNextRecordingChannelName = StringUtils::EmptyString;
+  m_strNextRecordingChannelIcon = StringUtils::EmptyString;
+  m_strNextRecordingTime        = StringUtils::EmptyString;
+  m_iTimerAmount                = 0;
+  m_bHasRecordings              = false;
+  m_iRecordingTimerAmount       = 0;
+  m_iActiveClients              = 0;
+  m_strPlayingClientName        = StringUtils::EmptyString;
+  m_strBackendName              = StringUtils::EmptyString;
+  m_strBackendVersion           = StringUtils::EmptyString;
+  m_strBackendHost              = StringUtils::EmptyString;
+  m_strBackendDiskspace         = StringUtils::EmptyString;
+  m_strBackendTimers            = StringUtils::EmptyString;
+  m_strBackendRecordings        = StringUtils::EmptyString;
+  m_strBackendChannels          = StringUtils::EmptyString;
+  m_strTotalDiskspace           = StringUtils::EmptyString;
+  m_iAddonInfoToggleStart       = 0;
+  m_iAddonInfoToggleCurrent     = 0;
+  m_iTimerInfoToggleStart       = 0;
+  m_iTimerInfoToggleCurrent     = 0;
+  m_iToggleShowInfo             = 0;
+  m_iDuration                   = 0;
+  m_bHasNonRecordingTimers      = false;
+  m_bIsPlayingTV                = false;
+  m_bIsPlayingRadio             = false;
+  m_bIsPlayingRecording         = false;
+  m_bIsPlayingEncryptedStream   = false;
+
+  ResetPlayingTag();
+  ClearQualityInfo(m_qualityInfo);
+}
+
+void CPVRGUIInfo::ClearQualityInfo(PVR_SIGNAL_STATUS &qualityInfo)
+{
+  memset(&qualityInfo, 0, sizeof(qualityInfo));
+  strncpy(qualityInfo.strAdapterName, g_localizeStrings.Get(13106).c_str(), 1024);
+  strncpy(qualityInfo.strAdapterStatus, g_localizeStrings.Get(13106).c_str(), 1024);
+}
+
+void CPVRGUIInfo::Start(void)
+{
+  ResetProperties();
+  Create();
+  SetPriority(-1);
+}
+
+void CPVRGUIInfo::Stop(void)
+{
+  StopThread();
+  if (g_PVRTimers)
+    g_PVRTimers->UnregisterObserver(this);
+}
+
+void CPVRGUIInfo::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  if (msg == ObservableMessageTimers)
+    UpdateTimersCache();
+}
+
+void CPVRGUIInfo::ShowPlayerInfo(int iTimeout)
+{
+  CSingleLock lock(m_critSection);
+
+  if (iTimeout > 0)
+    m_iToggleShowInfo = (int) XbmcThreads::SystemClockMillis() + iTimeout * 1000;
+
+  g_infoManager.SetShowInfo(true);
+}
+
+void CPVRGUIInfo::ToggleShowInfo(void)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_iToggleShowInfo > 0 && m_iToggleShowInfo < (unsigned int) XbmcThreads::SystemClockMillis())
+  {
+    m_iToggleShowInfo = 0;
+    g_infoManager.SetShowInfo(false);
+  }
+}
+
+bool CPVRGUIInfo::AddonInfoToggle(void)
+{
+  CSingleLock lock(m_critSection);
+  if (m_iAddonInfoToggleStart == 0)
+  {
+    m_iAddonInfoToggleStart = XbmcThreads::SystemClockMillis();
+    m_iAddonInfoToggleCurrent = 0;
+    return true;
+  }
+
+  if ((int) (XbmcThreads::SystemClockMillis() - m_iAddonInfoToggleStart) > g_advancedSettings.m_iPVRInfoToggleInterval)
+  {
+    unsigned int iPrevious = m_iAddonInfoToggleCurrent;
+    if (((int) ++m_iAddonInfoToggleCurrent) > m_iActiveClients - 1)
+      m_iAddonInfoToggleCurrent = 0;
+
+    return m_iAddonInfoToggleCurrent != iPrevious;
+  }
+
+  return false;
+}
+
+bool CPVRGUIInfo::TimerInfoToggle(void)
+{
+  CSingleLock lock(m_critSection);
+  if (m_iTimerInfoToggleStart == 0)
+  {
+    m_iTimerInfoToggleStart = XbmcThreads::SystemClockMillis();
+    m_iTimerInfoToggleCurrent = 0;
+    return true;
+  }
+
+  if ((int) (XbmcThreads::SystemClockMillis() - m_iTimerInfoToggleStart) > g_advancedSettings.m_iPVRInfoToggleInterval)
+  {
+    unsigned int iPrevious = m_iTimerInfoToggleCurrent;
+    unsigned int iBoundary = m_iRecordingTimerAmount > 0 ? m_iRecordingTimerAmount : m_iTimerAmount;
+    if (++m_iTimerInfoToggleCurrent > iBoundary - 1)
+      m_iTimerInfoToggleCurrent = 0;
+
+    return m_iTimerInfoToggleCurrent != iPrevious;
+  }
+
+  return false;
+}
+
+void CPVRGUIInfo::Process(void)
+{
+  unsigned int mLoop(0);
+
+  /* updated on request */
+  g_PVRTimers->RegisterObserver(this);
+  UpdateTimersCache();
+
+  while (!g_application.m_bStop && !m_bStop)
+  {
+    if (!m_bStop)
+      ToggleShowInfo();
+    Sleep(0);
+
+    if (!m_bStop)
+      UpdateQualityData();
+    Sleep(0);
+
+    if (!m_bStop)
+      UpdateMisc();
+    Sleep(0);
+
+    if (!m_bStop)
+      UpdatePlayingTag();
+    Sleep(0);
+
+    if (!m_bStop)
+      UpdateTimersToggle();
+    Sleep(0);
+
+    if (!m_bStop)
+      UpdateNextTimer();
+    Sleep(0);
+
+    if (!m_bStop && mLoop % 10 == 0)
+      UpdateBackendCache();    /* updated every 10 iterations */
+
+    if (++mLoop == 1000)
+      mLoop = 0;
+
+    if (!m_bStop)
+      Sleep(1000);
+  }
+
+  if (!m_bStop)
+    ResetPlayingTag();
+}
+
+void CPVRGUIInfo::UpdateQualityData(void)
+{
+  PVR_SIGNAL_STATUS qualityInfo;
+  ClearQualityInfo(qualityInfo);
+
+  PVR_CLIENT client;
+  if (g_guiSettings.GetBool("pvrplayback.signalquality") &&
+      g_PVRClients->GetPlayingClient(client))
+  {
+    client->SignalQuality(qualityInfo);
+  }
+
+  memcpy(&m_qualityInfo, &qualityInfo, sizeof(m_qualityInfo));
+}
+
+void CPVRGUIInfo::UpdateMisc(void)
+{
+  bool bStarted = g_PVRManager.IsStarted();
+  CStdString strPlayingClientName      = bStarted ? g_PVRClients->GetPlayingClientName() : StringUtils::EmptyString;
+  bool       bHasRecordings            = bStarted && g_PVRRecordings->GetNumRecordings() > 0;
+  bool       bIsPlayingTV              = bStarted && g_PVRClients->IsPlayingTV();
+  bool       bIsPlayingRadio           = bStarted && g_PVRClients->IsPlayingRadio();
+  bool       bIsPlayingRecording       = bStarted && g_PVRClients->IsPlayingRecording();
+  bool       bIsPlayingEncryptedStream = bStarted && g_PVRClients->IsEncrypted();
+  /* safe to fetch these unlocked, since they're updated from the same thread as this one */
+  bool       bHasNonRecordingTimers    = bStarted && m_iTimerAmount - m_iRecordingTimerAmount > 0;
+
+  CSingleLock lock(m_critSection);
+  m_strPlayingClientName      = strPlayingClientName;
+  m_bHasRecordings            = bHasRecordings;
+  m_bHasNonRecordingTimers    = bHasNonRecordingTimers;
+  m_bIsPlayingTV              = bIsPlayingTV;
+  m_bIsPlayingRadio           = bIsPlayingRadio;
+  m_bIsPlayingRecording       = bIsPlayingRecording;
+  m_bIsPlayingEncryptedStream = bIsPlayingEncryptedStream;
+}
+
+bool CPVRGUIInfo::TranslateCharInfo(DWORD dwInfo, CStdString &strValue) const
+{
+  bool bReturn(true);
+  CSingleLock lock(m_critSection);
+
+  switch(dwInfo)
+  {
+  case PVR_NOW_RECORDING_TITLE:
+    CharInfoActiveTimerTitle(strValue);
+    break;
+  case PVR_NOW_RECORDING_CHANNEL:
+    CharInfoActiveTimerChannelName(strValue);
+    break;
+  case PVR_NOW_RECORDING_CHAN_ICO:
+    CharInfoActiveTimerChannelIcon(strValue);
+    break;
+  case PVR_NOW_RECORDING_DATETIME:
+    CharInfoActiveTimerDateTime(strValue);
+    break;
+  case PVR_NEXT_RECORDING_TITLE:
+    CharInfoNextTimerTitle(strValue);
+    break;
+  case PVR_NEXT_RECORDING_CHANNEL:
+    CharInfoNextTimerChannelName(strValue);
+    break;
+  case PVR_NEXT_RECORDING_CHAN_ICO:
+    CharInfoNextTimerChannelIcon(strValue);
+    break;
+  case PVR_NEXT_RECORDING_DATETIME:
+    CharInfoNextTimerDateTime(strValue);
+    break;
+  case PVR_PLAYING_DURATION:
+    CharInfoPlayingDuration(strValue);
+    break;
+  case PVR_PLAYING_TIME:
+    CharInfoPlayingTime(strValue);
+    break;
+  case PVR_NEXT_TIMER:
+    CharInfoNextTimer(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_VIDEO_BR:
+    CharInfoVideoBR(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_AUDIO_BR:
+    CharInfoAudioBR(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_DOLBY_BR:
+    CharInfoDolbyBR(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_SIG:
+    CharInfoSignal(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_SNR:
+    CharInfoSNR(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_BER:
+    CharInfoBER(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_UNC:
+    CharInfoUNC(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_CLIENT:
+    CharInfoPlayingClientName(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_DEVICE:
+    CharInfoFrontendName(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_STATUS:
+    CharInfoFrontendStatus(strValue);
+    break;
+  case PVR_ACTUAL_STREAM_CRYPTION:
+    CharInfoEncryption(strValue);
+    break;
+  case PVR_BACKEND_NAME:
+    CharInfoBackendName(strValue);
+    break;
+  case PVR_BACKEND_VERSION:
+    CharInfoBackendVersion(strValue);
+    break;
+  case PVR_BACKEND_HOST:
+    CharInfoBackendHost(strValue);
+    break;
+  case PVR_BACKEND_DISKSPACE:
+    CharInfoBackendDiskspace(strValue);
+    break;
+  case PVR_BACKEND_CHANNELS:
+    CharInfoBackendChannels(strValue);
+    break;
+  case PVR_BACKEND_TIMERS:
+    CharInfoBackendTimers(strValue);
+    break;
+  case PVR_BACKEND_RECORDINGS:
+    CharInfoBackendRecordings(strValue);
+    break;
+  case PVR_BACKEND_NUMBER:
+    CharInfoBackendNumber(strValue);
+    break;
+  case PVR_TOTAL_DISKSPACE:
+    CharInfoTotalDiskSpace(strValue);
+    break;
+  default:
+    strValue = StringUtils::EmptyString;
+    bReturn = false;
+    break;
+  }
+
+  return bReturn;
+}
+
+bool CPVRGUIInfo::TranslateBoolInfo(DWORD dwInfo) const
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  switch (dwInfo)
+  {
+  case PVR_IS_RECORDING:
+    bReturn = m_iRecordingTimerAmount > 0;
+    break;
+  case PVR_HAS_TIMER:
+    bReturn = m_iTimerAmount > 0;
+    break;
+  case PVR_HAS_NONRECORDING_TIMER:
+    bReturn = m_bHasNonRecordingTimers;
+    break;
+  case PVR_IS_PLAYING_TV:
+    bReturn = m_bIsPlayingTV;
+    break;
+  case PVR_IS_PLAYING_RADIO:
+    bReturn = m_bIsPlayingRadio;
+    break;
+  case PVR_IS_PLAYING_RECORDING:
+    bReturn = m_bIsPlayingRecording;
+    break;
+  case PVR_ACTUAL_STREAM_ENCRYPTED:
+    bReturn = m_bIsPlayingEncryptedStream;
+    break;
+  default:
+    break;
+  }
+
+  return bReturn;
+}
+
+int CPVRGUIInfo::TranslateIntInfo(DWORD dwInfo) const
+{
+  int iReturn(0);
+  CSingleLock lock(m_critSection);
+
+  if (dwInfo == PVR_PLAYING_PROGRESS)
+    iReturn = (int) ((float) GetStartTime() / m_iDuration * 100);
+  else if (dwInfo == PVR_ACTUAL_STREAM_SIG_PROGR)
+    iReturn = (int) ((float) m_qualityInfo.iSignal / 0xFFFF * 100);
+  else if (dwInfo == PVR_ACTUAL_STREAM_SNR_PROGR)
+    iReturn = (int) ((float) m_qualityInfo.iSNR / 0xFFFF * 100);
+
+  return iReturn;
+}
+
+void CPVRGUIInfo::CharInfoActiveTimerTitle(CStdString &strValue) const
+{
+  strValue.Format("%s", m_strActiveTimerTitle);
+}
+
+void CPVRGUIInfo::CharInfoActiveTimerChannelName(CStdString &strValue) const
+{
+  strValue.Format("%s", m_strActiveTimerChannelName);
+}
+
+void CPVRGUIInfo::CharInfoActiveTimerChannelIcon(CStdString &strValue) const
+{
+  strValue.Format("%s", m_strActiveTimerChannelIcon);
+}
+
+void CPVRGUIInfo::CharInfoActiveTimerDateTime(CStdString &strValue) const
+{
+  strValue.Format("%s", m_strActiveTimerTime);
+}
+
+void CPVRGUIInfo::CharInfoNextTimerTitle(CStdString &strValue) const
+{
+  strValue.Format("%s", m_strNextRecordingTitle);
+}
+
+void CPVRGUIInfo::CharInfoNextTimerChannelName(CStdString &strValue) const
+{
+  strValue.Format("%s", m_strNextRecordingChannelName);
+}
+
+void CPVRGUIInfo::CharInfoNextTimerChannelIcon(CStdString &strValue) const
+{
+  strValue.Format("%s", m_strNextRecordingChannelIcon);
+}
+
+void CPVRGUIInfo::CharInfoNextTimerDateTime(CStdString &strValue) const
+{
+  strValue.Format("%s", m_strNextRecordingTime);
+}
+
+void CPVRGUIInfo::CharInfoPlayingDuration(CStdString &strValue) const
+{
+  strValue.Format("%s", StringUtils::SecondsToTimeString(m_iDuration / 1000, TIME_FORMAT_GUESS));
+}
+
+void CPVRGUIInfo::CharInfoPlayingTime(CStdString &strValue) const
+{
+  strValue.Format("%s", StringUtils::SecondsToTimeString(GetStartTime()/1000, TIME_FORMAT_GUESS));
+}
+
+void CPVRGUIInfo::CharInfoNextTimer(CStdString &strValue) const
+{
+  strValue.Format("%s", m_strNextTimerInfo);
+}
+
+void CPVRGUIInfo::CharInfoBackendNumber(CStdString &strValue) const
+{
+  if (m_iActiveClients > 0)
+    strValue.Format("%u %s %u", m_iAddonInfoToggleCurrent+1, g_localizeStrings.Get(20163), m_iActiveClients);
+  else
+    strValue.Format("%s", g_localizeStrings.Get(14023));
+}
+
+void CPVRGUIInfo::CharInfoTotalDiskSpace(CStdString &strValue) const
+{
+  strValue.Format("%s", m_strTotalDiskspace);
+}
+
+void CPVRGUIInfo::CharInfoVideoBR(CStdString &strValue) const
+{
+  strValue.Format("%.2f Mbit/s", m_qualityInfo.dVideoBitrate);
+}
+
+void CPVRGUIInfo::CharInfoAudioBR(CStdString &strValue) const
+{
+  strValue.Format("%.0f kbit/s", m_qualityInfo.dAudioBitrate);
+}
+
+void CPVRGUIInfo::CharInfoDolbyBR(CStdString &strValue) const
+{
+  strValue.Format("%.0f kbit/s", m_qualityInfo.dDolbyBitrate);
+}
+
+void CPVRGUIInfo::CharInfoSignal(CStdString &strValue) const
+{
+  strValue.Format("%d %%", m_qualityInfo.iSignal / 655);
+}
+
+void CPVRGUIInfo::CharInfoSNR(CStdString &strValue) const
+{
+  strValue.Format("%d %%", m_qualityInfo.iSNR / 655);
+}
+
+void CPVRGUIInfo::CharInfoBER(CStdString &strValue) const
+{
+  strValue.Format("%08X", m_qualityInfo.iBER);
+}
+
+void CPVRGUIInfo::CharInfoUNC(CStdString &strValue) const
+{
+  strValue.Format("%08X", m_qualityInfo.iUNC);
+}
+
+void CPVRGUIInfo::CharInfoFrontendName(CStdString &strValue) const
+{
+  if (!strcmp(m_qualityInfo.strAdapterName, StringUtils::EmptyString))
+    strValue.Format("%s", g_localizeStrings.Get(13205));
+  else
+    strValue.Format("%s", m_qualityInfo.strAdapterName);
+}
+
+void CPVRGUIInfo::CharInfoFrontendStatus(CStdString &strValue) const
+{
+  if (!strcmp(m_qualityInfo.strAdapterStatus, StringUtils::EmptyString))
+    strValue.Format("%s", g_localizeStrings.Get(13205));
+  else
+    strValue.Format("%s", m_qualityInfo.strAdapterStatus);
+}
+
+void CPVRGUIInfo::CharInfoBackendName(CStdString &strValue) const
+{
+  if (m_strBackendName.IsEmpty())
+    strValue.Format("%s", g_localizeStrings.Get(13205));
+  else
+    strValue.Format("%s", m_strBackendName);
+}
+
+void CPVRGUIInfo::CharInfoBackendVersion(CStdString &strValue) const
+{
+  if (m_strBackendVersion.IsEmpty())
+    strValue.Format("%s", g_localizeStrings.Get(13205));
+  else
+    strValue.Format("%s",  m_strBackendVersion);
+}
+
+void CPVRGUIInfo::CharInfoBackendHost(CStdString &strValue) const
+{
+  if (m_strBackendHost.IsEmpty())
+    strValue.Format("%s", g_localizeStrings.Get(13205));
+  else
+    strValue.Format("%s", m_strBackendHost);
+}
+
+void CPVRGUIInfo::CharInfoBackendDiskspace(CStdString &strValue) const
+{
+  if (m_strBackendDiskspace.IsEmpty())
+    strValue.Format("%s", g_localizeStrings.Get(13205));
+  else
+    strValue.Format("%s", m_strBackendDiskspace);
+}
+
+void CPVRGUIInfo::CharInfoBackendChannels(CStdString &strValue) const
+{
+  if (m_strBackendChannels.IsEmpty())
+    strValue.Format("%s", g_localizeStrings.Get(13205));
+  else
+    strValue.Format("%s", m_strBackendChannels);
+}
+
+void CPVRGUIInfo::CharInfoBackendTimers(CStdString &strValue) const
+{
+  if (m_strBackendTimers.IsEmpty())
+    strValue.Format("%s", g_localizeStrings.Get(13205));
+  else
+    strValue.Format("%s", m_strBackendTimers);
+}
+
+void CPVRGUIInfo::CharInfoBackendRecordings(CStdString &strValue) const
+{
+  if (m_strBackendRecordings.IsEmpty())
+    strValue.Format("%s", g_localizeStrings.Get(13205));
+  else
+    strValue.Format("%s", m_strBackendRecordings);
+}
+
+void CPVRGUIInfo::CharInfoPlayingClientName(CStdString &strValue) const
+{
+  if (m_strPlayingClientName.IsEmpty())
+    strValue.Format("%s", g_localizeStrings.Get(13205));
+  else
+    strValue.Format("%s", m_strPlayingClientName);
+}
+
+void CPVRGUIInfo::CharInfoEncryption(CStdString &strValue) const
+{
+  CPVRChannelPtr channel;
+  if (g_PVRClients->GetPlayingChannel(channel))
+    strValue.Format("%s", channel->EncryptionName().c_str());
+  else
+    strValue = StringUtils::EmptyString;
+}
+
+void CPVRGUIInfo::UpdateBackendCache(void)
+{
+  CStdString strBackendName;
+  CStdString strBackendVersion;
+  CStdString strBackendHost;
+  CStdString strBackendDiskspace;
+  CStdString strBackendTimers;
+  CStdString strBackendRecordings;
+  CStdString strBackendChannels;
+  int        iActiveClients(0);
+
+  if (!AddonInfoToggle())
+    return;
+
+  CPVRClients *clients = g_PVRClients;
+  PVR_CLIENTMAP activeClients;
+  iActiveClients = clients->GetConnectedClients(activeClients);
+  if (iActiveClients > 0)
+  {
+    PVR_CLIENTMAP_CITR activeClient = activeClients.begin();
+    /* safe to read unlocked */
+    for (unsigned int i = 0; i < m_iAddonInfoToggleCurrent; i++)
+      activeClient++;
+
+    long long kBTotal = 0;
+    long long kBUsed  = 0;
+
+    if (activeClient->second->GetDriveSpace(&kBTotal, &kBUsed) == PVR_ERROR_NO_ERROR)
+    {
+      kBTotal /= 1024; // Convert to MBytes
+      kBUsed /= 1024;  // Convert to MBytes
+      strBackendDiskspace.Format("%s %.1f GByte - %s: %.1f GByte",
+          g_localizeStrings.Get(20161), (float) kBTotal / 1024, g_localizeStrings.Get(20162), (float) kBUsed / 1024);
+    }
+    else
+    {
+      strBackendDiskspace = g_localizeStrings.Get(19055);
+    }
+
+    int NumChannels = activeClient->second->GetChannelsAmount();
+    if (NumChannels >= 0)
+      strBackendChannels.Format("%i", NumChannels);
+    else
+      strBackendChannels = g_localizeStrings.Get(161);
+
+    int NumTimers = activeClient->second->GetTimersAmount();
+    if (NumTimers >= 0)
+      strBackendTimers.Format("%i", NumTimers);
+    else
+      strBackendTimers = g_localizeStrings.Get(161);
+
+    int NumRecordings = activeClient->second->GetRecordingsAmount();
+    if (NumRecordings >= 0)
+      strBackendRecordings.Format("%i", NumRecordings);
+    else
+      strBackendRecordings = g_localizeStrings.Get(161);
+
+    strBackendName    = activeClient->second->GetBackendName();
+    strBackendVersion = activeClient->second->GetBackendVersion();
+    strBackendHost    = activeClient->second->GetConnectionString();
+  }
+
+  CSingleLock lock(m_critSection);
+  m_strBackendName         = strBackendName;
+  m_strBackendVersion      = strBackendVersion;
+  m_strBackendHost         = strBackendHost;
+  m_strBackendDiskspace    = strBackendDiskspace;
+  m_strBackendTimers       = strBackendTimers;
+  m_strBackendRecordings   = strBackendRecordings;
+  m_strBackendChannels     = strBackendChannels;
+  m_iActiveClients         = iActiveClients;
+}
+
+void CPVRGUIInfo::UpdateTimersCache(void)
+{
+  int iTimerAmount          = g_PVRTimers->AmountActiveTimers();
+  int iRecordingTimerAmount = g_PVRTimers->AmountActiveRecordings();
+
+  {
+    CSingleLock lock(m_critSection);
+    m_iTimerAmount          = iTimerAmount;
+    m_iRecordingTimerAmount = iRecordingTimerAmount;
+    m_iTimerInfoToggleStart = 0;
+  }
+
+  UpdateTimersToggle();
+}
+
+void CPVRGUIInfo::UpdateNextTimer(void)
+{
+  CStdString strNextRecordingTitle;
+  CStdString strNextRecordingChannelName;
+  CStdString strNextRecordingChannelIcon;
+  CStdString strNextRecordingTime;
+  CStdString strNextTimerInfo;
+
+  CFileItemPtr tag = g_PVRTimers->GetNextActiveTimer();
+  if (tag && tag->HasPVRTimerInfoTag())
+  {
+    CPVRTimerInfoTag *timer = tag->GetPVRTimerInfoTag();
+    strNextRecordingTitle.Format("%s",       timer->Title());
+    strNextRecordingChannelName.Format("%s", timer->ChannelName());
+    strNextRecordingChannelIcon.Format("%s", timer->ChannelIcon());
+    strNextRecordingTime.Format("%s",        timer->StartAsLocalTime().GetAsLocalizedDateTime(false, false));
+
+    strNextTimerInfo.Format("%s %s %s %s",
+        g_localizeStrings.Get(19106),
+        timer->StartAsLocalTime().GetAsLocalizedDate(true),
+        g_localizeStrings.Get(19107),
+        timer->StartAsLocalTime().GetAsLocalizedTime("HH:mm", false));
+  }
+
+  CSingleLock lock(m_critSection);
+  m_strNextRecordingTitle       = strNextRecordingTitle;
+  m_strNextRecordingChannelName = strNextRecordingChannelName;
+  m_strNextRecordingChannelIcon = strNextRecordingChannelIcon;
+  m_strNextRecordingTime        = strNextRecordingTime;
+  m_strNextTimerInfo            = strNextTimerInfo;
+}
+
+void CPVRGUIInfo::UpdateTimersToggle(void)
+{
+  if (!TimerInfoToggle())
+    return;
+
+  CStdString strActiveTimerTitle;
+  CStdString strActiveTimerChannelName;
+  CStdString strActiveTimerChannelIcon;
+  CStdString strActiveTimerTime;
+
+  /* safe to fetch these unlocked, since they're updated from the same thread as this one */
+  if (m_iRecordingTimerAmount > 0)
+  {
+    vector<CFileItemPtr> activeTags = g_PVRTimers->GetActiveRecordings();
+    if (m_iTimerInfoToggleCurrent < activeTags.size() && activeTags.at(m_iTimerInfoToggleCurrent)->HasPVRTimerInfoTag())
+    {
+      CPVRTimerInfoTag *tag = activeTags.at(m_iTimerInfoToggleCurrent)->GetPVRTimerInfoTag();
+      strActiveTimerTitle.Format("%s",       tag->Title());
+      strActiveTimerChannelName.Format("%s", tag->ChannelName());
+      strActiveTimerChannelIcon.Format("%s", tag->ChannelIcon());
+      strActiveTimerTime.Format("%s",        tag->StartAsLocalTime().GetAsLocalizedDateTime(false, false));
+    }
+  }
+
+  CSingleLock lock(m_critSection);
+  m_strActiveTimerTitle         = strActiveTimerTitle;
+  m_strActiveTimerChannelName   = strActiveTimerChannelName;
+  m_strActiveTimerChannelIcon   = strActiveTimerChannelIcon;
+  m_strActiveTimerTime          = strActiveTimerTime;
+}
+
+int CPVRGUIInfo::GetDuration(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iDuration;
+}
+
+int CPVRGUIInfo::GetStartTime(void) const
+{
+  CSingleLock lock(m_critSection);
+  if (m_playingEpgTag)
+  {
+    /* Calculate here the position we have of the running live TV event.
+     * "position in ms" = ("current local time" - "event start local time") * 1000
+     */
+    CDateTime current = CDateTime::GetCurrentDateTime();
+    CDateTime start = m_playingEpgTag->StartAsLocalTime();
+    CDateTimeSpan time = current > start ? current - start : CDateTimeSpan(0, 0, 0, 0);
+    return (time.GetDays()   * 60 * 60 * 24
+         + time.GetHours()   * 60 * 60
+         + time.GetMinutes() * 60
+         + time.GetSeconds()) * 1000;
+  }
+  else
+  {
+    return 0;
+  }
+}
+
+void CPVRGUIInfo::ResetPlayingTag(void)
+{
+  CSingleLock lock(m_critSection);
+  SAFE_DELETE(m_playingEpgTag);
+  m_iDuration = 0;
+}
+
+bool CPVRGUIInfo::GetPlayingTag(CEpgInfoTag &tag) const
+{
+  bool bReturn(false);
+
+  CSingleLock lock(m_critSection);
+  if (m_playingEpgTag)
+  {
+    tag = *m_playingEpgTag;
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+void CPVRGUIInfo::UpdatePlayingTag(void)
+{
+  CPVRChannelPtr currentChannel;
+  CPVRRecording recording;
+  if (g_PVRManager.GetCurrentChannel(currentChannel))
+  {
+    CEpgInfoTag epgTag;
+    bool bHasEpgTag  = GetPlayingTag(epgTag);
+    CPVRChannelPtr channel;
+    if (bHasEpgTag)
+      channel = epgTag.ChannelTag();
+
+    if (!bHasEpgTag || !epgTag.IsActive() ||
+        !channel || *channel != *currentChannel)
+    {
+      CEpgInfoTag newTag;
+      {
+        CSingleLock lock(m_critSection);
+        ResetPlayingTag();
+        if (currentChannel->GetEPGNow(newTag))
+        {
+          m_playingEpgTag = new CEpgInfoTag(newTag);
+          m_iDuration     = m_playingEpgTag->GetDuration() * 1000;
+        }
+      }
+      g_PVRManager.UpdateCurrentFile();
+    }
+  }
+  else if (g_PVRClients->GetPlayingRecording(recording))
+  {
+    ResetPlayingTag();
+    m_iDuration = recording.GetDuration() * 1000;
+  }
+}
diff --git a/xbmc/pvr/PVRManager.cpp b/xbmc/pvr/PVRManager.cpp
new file mode 100644
index 0000000..15fe68a
--- /dev/null
+++ b/xbmc/pvr/PVRManager.cpp
@@ -0,0 +1,1223 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include "GUIInfoManager.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogNumeric.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "dialogs/GUIDialogExtendedProgressBar.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "music/tags/MusicInfoTag.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "threads/SingleLock.h"
+#include "windows/GUIWindowPVR.h"
+#include "utils/log.h"
+#include "utils/Stopwatch.h"
+#include "utils/StringUtils.h"
+#include "threads/Atomics.h"
+#include "windows/GUIWindowPVRCommon.h"
+
+#include "PVRManager.h"
+#include "PVRDatabase.h"
+#include "PVRGUIInfo.h"
+#include "addons/PVRClients.h"
+#include "channels/PVRChannel.h"
+#include "channels/PVRChannelGroupsContainer.h"
+#include "channels/PVRChannelGroupInternal.h"
+#include "epg/EpgContainer.h"
+#include "recordings/PVRRecordings.h"
+#include "timers/PVRTimers.h"
+
+using namespace std;
+using namespace MUSIC_INFO;
+using namespace PVR;
+using namespace EPG;
+
+CPVRManager::CPVRManager(void) :
+    CThread("PVR manager"),
+    m_channelGroups(NULL),
+    m_recordings(NULL),
+    m_timers(NULL),
+    m_addons(NULL),
+    m_guiInfo(NULL),
+    m_triggerEvent(true),
+    m_currentFile(NULL),
+    m_database(NULL),
+    m_bFirstStart(true),
+    m_progressHandle(NULL),
+    m_managerState(ManagerStateStopped)
+{
+  ResetProperties();
+}
+
+CPVRManager::~CPVRManager(void)
+{
+  Stop();
+  CLog::Log(LOGDEBUG,"PVRManager - destroyed");
+}
+
+CPVRManager &CPVRManager::Get(void)
+{
+  static CPVRManager pvrManagerInstance;
+  return pvrManagerInstance;
+}
+
+void CPVRManager::Cleanup(void)
+{
+  CSingleLock lock(m_critSection);
+
+  SAFE_DELETE(m_addons);
+  SAFE_DELETE(m_guiInfo);
+  SAFE_DELETE(m_timers);
+  SAFE_DELETE(m_recordings);
+  SAFE_DELETE(m_channelGroups);
+  SAFE_DELETE(m_parentalTimer);
+  SAFE_DELETE(m_database);
+  m_triggerEvent.Set();
+
+  m_currentFile           = NULL;
+  m_bIsSwitchingChannels  = false;
+
+  for (unsigned int iJobPtr = 0; iJobPtr < m_pendingUpdates.size(); iJobPtr++)
+    delete m_pendingUpdates.at(iJobPtr);
+  m_pendingUpdates.clear();
+
+  SetState(ManagerStateStopped);
+}
+
+void CPVRManager::ResetProperties(void)
+{
+  CSingleLock lock(m_critSection);
+  Cleanup();
+
+  if (!g_application.m_bStop)
+  {
+    m_addons        = new CPVRClients;
+    m_channelGroups = new CPVRChannelGroupsContainer;
+    m_recordings    = new CPVRRecordings;
+    m_timers        = new CPVRTimers;
+    m_guiInfo       = new CPVRGUIInfo;
+    m_parentalTimer = new CStopWatch;
+  }
+}
+
+void CPVRManager::Start(void)
+{
+  CSingleLock lock(m_critSection);
+
+  /* first stop and remove any clients */
+  Stop();
+
+  /* don't start if Settings->Video->TV->Enable isn't checked */
+  if (!g_guiSettings.GetBool("pvrmanager.enabled"))
+    return;
+
+  ResetProperties();
+  SetState(ManagerStateStarting);
+
+  /* create and open database */
+  if (!m_database)
+    m_database = new CPVRDatabase;
+  m_database->Open();
+
+  /* create the supervisor thread to do all background activities */
+  StartUpdateThreads();
+}
+
+void CPVRManager::Stop(void)
+{
+  /* check whether the pvrmanager is loaded */
+  if (GetState() == ManagerStateStopping ||
+      GetState() == ManagerStateStopped)
+    return;
+
+  SetState(ManagerStateStopping);
+
+  /* stop the EPG updater, since it might be using the pvr add-ons */
+  g_EpgContainer.Unload();
+
+  CLog::Log(LOGNOTICE, "PVRManager - stopping");
+
+  /* stop playback if needed */
+  if (IsPlaying())
+  {
+    CLog::Log(LOGNOTICE,"PVRManager - %s - stopping PVR playback", __FUNCTION__);
+    CApplicationMessenger::Get().MediaStop();
+  }
+
+  /* stop all update threads */
+  StopUpdateThreads();
+
+  /* executes the set wakeup command */
+  SetWakeupCommand();
+
+  /* close database */
+  if (m_database->IsOpen())
+    m_database->Close();
+
+  /* unload all data */
+  Cleanup();
+}
+
+ManagerState CPVRManager::GetState(void) const
+{
+  CSingleLock lock(m_managerStateMutex);
+  return m_managerState;
+}
+
+void CPVRManager::SetState(ManagerState state) 
+{
+  CSingleLock lock(m_managerStateMutex);
+  m_managerState = state;
+}
+
+void CPVRManager::Process(void)
+{
+  g_EpgContainer.Stop();
+
+  /* load the pvr data from the db and clients if it's not already loaded */
+  if (!Load())
+  {
+    CLog::Log(LOGERROR, "PVRManager - %s - failed to load PVR data", __FUNCTION__);
+    return;
+  }
+
+  if (GetState() == ManagerStateStarting)
+    SetState(ManagerStateStarted);
+  else
+    return;
+
+  /* main loop */
+  CLog::Log(LOGDEBUG, "PVRManager - %s - entering main loop", __FUNCTION__);
+  g_EpgContainer.Start();
+
+  bool bRestart(false);
+  while (GetState() == ManagerStateStarted && m_addons && m_addons->HasConnectedClients() && !bRestart)
+  {
+    /* continue last watched channel after first startup */
+    if (m_bFirstStart && g_guiSettings.GetInt("pvrplayback.startlast") != START_LAST_CHANNEL_OFF)
+      ContinueLastChannel();
+
+    /* execute the next pending jobs if there are any */
+    try
+    {
+      ExecutePendingJobs();
+    }
+    catch (...)
+    {
+      CLog::Log(LOGERROR, "PVRManager - %s - an error occured while trying to execute the last update job, trying to recover", __FUNCTION__);
+      bRestart = true;
+    }
+
+    if (GetState() == ManagerStateStarted && !bRestart)
+      m_triggerEvent.WaitMSec(1000);
+  }
+
+  if (GetState() == ManagerStateStarted)
+  {
+    CLog::Log(LOGNOTICE, "PVRManager - %s - no add-ons enabled anymore. restarting the pvrmanager", __FUNCTION__);
+    Stop();
+    Start();
+    return;
+  }
+}
+
+bool CPVRManager::SetWakeupCommand(void)
+{
+  if (!g_guiSettings.GetBool("pvrpowermanagement.enabled"))
+    return false;
+
+  const CStdString strWakeupCommand = g_guiSettings.GetString("pvrpowermanagement.setwakeupcmd", false);
+  if (!strWakeupCommand.IsEmpty() && m_timers)
+  {
+    time_t iWakeupTime;
+    const CDateTime nextEvent = m_timers->GetNextEventTime();
+    nextEvent.GetAsTime(iWakeupTime);
+
+    CStdString strExecCommand;
+    strExecCommand.Format("%s %d", strWakeupCommand, iWakeupTime);
+
+    const int iReturn = system(strExecCommand.c_str());
+    if (iReturn != 0)
+      CLog::Log(LOGERROR, "%s - failed to execute wakeup command '%s': %s (%d)", __FUNCTION__, strExecCommand.c_str(), strerror(iReturn), iReturn);
+
+    return iReturn == 0;
+  }
+
+  return false;
+}
+
+bool CPVRManager::StartUpdateThreads(void)
+{
+  StopUpdateThreads();
+  CLog::Log(LOGNOTICE, "PVRManager - starting up");
+
+  /* create the pvrmanager thread, which will ensure that all data will be loaded */
+  SetState(ManagerStateStarting);
+  Create();
+  SetPriority(-1);
+
+  return true;
+}
+
+void CPVRManager::StopUpdateThreads(void)
+{
+  SetState(ManagerStateInterrupted);
+
+  StopThread();
+  if (m_guiInfo)
+    m_guiInfo->Stop();
+  if (m_addons)
+    m_addons->Stop();
+}
+
+bool CPVRManager::Load(void)
+{
+  /* start the add-on update thread */
+  m_addons->Start();
+
+  /* load at least one client */
+  while (GetState() == ManagerStateStarting && m_addons && !m_addons->HasConnectedClients())
+    Sleep(50);
+
+  if (GetState() != ManagerStateStarting || !m_addons || !m_addons->HasConnectedClients())
+    return false;
+
+  CLog::Log(LOGDEBUG, "PVRManager - %s - active clients found. continue to start", __FUNCTION__);
+
+  CGUIWindowPVR *pWindow = (CGUIWindowPVR *) g_windowManager.GetWindow(WINDOW_PVR);
+  if (pWindow)
+    pWindow->Reset();
+
+  /* load all channels and groups */
+  ShowProgressDialog(g_localizeStrings.Get(19236), 0); // Loading channels from clients
+  if (!m_channelGroups->Load() || GetState() != ManagerStateStarting)
+    return false;
+
+  /* get timers from the backends */
+  ShowProgressDialog(g_localizeStrings.Get(19237), 50); // Loading timers from clients
+  m_timers->Load();
+
+  /* get recordings from the backend */
+  ShowProgressDialog(g_localizeStrings.Get(19238), 75); // Loading recordings from clients
+  m_recordings->Load();
+
+  CSingleLock lock(m_critSection);
+  if (GetState() != ManagerStateStarting)
+    return false;
+
+  /* start the other pvr related update threads */
+  ShowProgressDialog(g_localizeStrings.Get(19239), 85); // Starting background threads
+  m_guiInfo->Start();
+
+  /* close the progess dialog */
+  HideProgressDialog();
+
+  return true;
+}
+
+void CPVRManager::ShowProgressDialog(const CStdString &strText, int iProgress)
+{
+  if (!m_progressHandle)
+  {
+    CGUIDialogExtendedProgressBar *loadingProgressDialog = (CGUIDialogExtendedProgressBar *)g_windowManager.GetWindow(WINDOW_DIALOG_EXT_PROGRESS);
+    m_progressHandle = loadingProgressDialog->GetHandle(g_localizeStrings.Get(19235)); // PVR manager is starting up
+  }
+
+  m_progressHandle->SetPercentage((float)iProgress);
+  m_progressHandle->SetText(strText);
+}
+
+void CPVRManager::HideProgressDialog(void)
+{
+  if (m_progressHandle)
+  {
+    m_progressHandle->MarkFinished();
+    m_progressHandle = NULL;
+  }
+}
+
+bool CPVRManager::ChannelSwitch(unsigned int iChannelNumber)
+{
+  CSingleLock lock(m_critSection);
+
+  CPVRChannelGroupPtr playingGroup = GetPlayingGroup(m_addons->IsPlayingRadio());
+  if (!playingGroup)
+  {
+    CLog::Log(LOGERROR, "PVRManager - %s - cannot get the selected group", __FUNCTION__);
+    return false;
+  }
+
+  CFileItemPtr channel = playingGroup->GetByChannelNumber(iChannelNumber);
+  if (!channel || !channel->HasPVRChannelInfoTag())
+  {
+    CLog::Log(LOGERROR, "PVRManager - %s - cannot find channel %d", __FUNCTION__, iChannelNumber);
+    return false;
+  }
+
+  return PerformChannelSwitch(*channel->GetPVRChannelInfoTag(), false);
+}
+
+bool CPVRManager::ChannelUpDown(unsigned int *iNewChannelNumber, bool bPreview, bool bUp)
+{
+  bool bReturn = false;
+  if (IsPlayingTV() || IsPlayingRadio())
+  {
+    CFileItem currentFile(g_application.CurrentFileItem());
+    CPVRChannel *currentChannel = currentFile.GetPVRChannelInfoTag();
+    CPVRChannelGroupPtr group = GetPlayingGroup(currentChannel->IsRadio());
+    if (group)
+    {
+      CFileItemPtr newChannel = bUp ?
+          group->GetByChannelUp(*currentChannel) :
+          group->GetByChannelDown(*currentChannel);
+
+      if (newChannel && newChannel->HasPVRChannelInfoTag() &&
+          PerformChannelSwitch(*newChannel->GetPVRChannelInfoTag(), bPreview))
+      {
+        *iNewChannelNumber = newChannel->GetPVRChannelInfoTag()->ChannelNumber();
+        bReturn = true;
+      }
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRManager::ContinueLastChannel(void)
+{
+  {
+    CSingleLock lock(m_critSection);
+    if (!m_bFirstStart)
+      return true;
+    m_bFirstStart = false;
+  }
+
+  bool bReturn(false);
+  CFileItemPtr channel = m_channelGroups->GetLastPlayedChannel();
+  if (channel && channel->HasPVRChannelInfoTag())
+  {
+    CLog::Log(LOGNOTICE, "PVRManager - %s - continue playback on channel '%s'", __FUNCTION__, channel->GetPVRChannelInfoTag()->ChannelName().c_str());
+    bReturn = StartPlayback(channel->GetPVRChannelInfoTag(), (g_guiSettings.GetInt("pvrplayback.startlast") == START_LAST_CHANNEL_MIN));
+  }
+
+  return bReturn;
+}
+
+void CPVRManager::ResetDatabase(bool bShowProgress /* = true */)
+{
+  CLog::Log(LOGNOTICE,"PVRManager - %s - clearing the PVR database", __FUNCTION__);
+
+  g_EpgContainer.Stop();
+
+  CGUIDialogProgress* pDlgProgress = NULL;
+  if (bShowProgress)
+  {
+    pDlgProgress = (CGUIDialogProgress*)g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
+    pDlgProgress->SetLine(0, StringUtils::EmptyString);
+    pDlgProgress->SetLine(1, g_localizeStrings.Get(19186)); // All data in the PVR database is being erased
+    pDlgProgress->SetLine(2, StringUtils::EmptyString);
+    pDlgProgress->StartModal();
+    pDlgProgress->Progress();
+  }
+
+  if (m_addons && m_addons->IsPlaying())
+  {
+    CLog::Log(LOGNOTICE,"PVRManager - %s - stopping playback", __FUNCTION__);
+    CApplicationMessenger::Get().MediaStop();
+  }
+
+  if (bShowProgress)
+  {
+    pDlgProgress->SetPercentage(10);
+    pDlgProgress->Progress();
+  }
+
+  /* stop the thread */
+  if (g_guiSettings.GetBool("pvrmanager.enabled"))
+    Stop();
+
+  if (bShowProgress)
+  {
+    pDlgProgress->SetPercentage(20);
+    pDlgProgress->Progress();
+  }
+
+  if (!m_database)
+    m_database = new CPVRDatabase;
+
+  if (m_database && m_database->Open())
+  {
+    /* clean the EPG database */
+    g_EpgContainer.Clear(true);
+    if (bShowProgress)
+    {
+      pDlgProgress->SetPercentage(30);
+      pDlgProgress->Progress();
+    }
+
+    m_database->DeleteChannelGroups();
+    if (bShowProgress)
+    {
+      pDlgProgress->SetPercentage(50);
+      pDlgProgress->Progress();
+    }
+
+    /* delete all channels */
+    m_database->DeleteChannels();
+    if (bShowProgress)
+    {
+      pDlgProgress->SetPercentage(70);
+      pDlgProgress->Progress();
+    }
+
+    /* delete all channel settings */
+    m_database->DeleteChannelSettings();
+    if (bShowProgress)
+    {
+      pDlgProgress->SetPercentage(80);
+      pDlgProgress->Progress();
+    }
+
+    /* delete all client information */
+    m_database->DeleteClients();
+    if (bShowProgress)
+    {
+      pDlgProgress->SetPercentage(90);
+      pDlgProgress->Progress();
+    }
+
+    m_database->Close();
+  }
+
+  CLog::Log(LOGNOTICE,"PVRManager - %s - PVR database cleared", __FUNCTION__);
+
+  g_EpgContainer.Start();
+
+  if (g_guiSettings.GetBool("pvrmanager.enabled"))
+  {
+    CLog::Log(LOGNOTICE,"PVRManager - %s - restarting the PVRManager", __FUNCTION__);
+    m_database->Open();
+    Cleanup();
+    Start();
+  }
+
+  if (bShowProgress)
+  {
+    pDlgProgress->SetPercentage(100);
+    pDlgProgress->Close();
+  }
+}
+
+void CPVRManager::ResetEPG(void)
+{
+  CLog::Log(LOGNOTICE,"PVRManager - %s - clearing the EPG database", __FUNCTION__);
+
+  StopUpdateThreads();
+  g_EpgContainer.Stop();
+  g_EpgContainer.Reset();
+
+  if (g_guiSettings.GetBool("pvrmanager.enabled"))
+  {
+    static_cast<CPVRChannelGroupInternal *>(m_channelGroups->GetGroupAllTV().get())->CreateChannelEpgs(true);
+    static_cast<CPVRChannelGroupInternal *>(m_channelGroups->GetGroupAllRadio().get())->CreateChannelEpgs(true);
+    g_EpgContainer.Start();
+    StartUpdateThreads();
+  }
+}
+
+bool CPVRManager::IsPlaying(void) const
+{
+  return IsStarted() && m_addons && m_addons->IsPlaying();
+}
+
+bool CPVRManager::GetCurrentChannel(CPVRChannelPtr &channel) const
+{
+  return m_addons && m_addons->GetPlayingChannel(channel);
+}
+
+int CPVRManager::GetCurrentEpg(CFileItemList &results) const
+{
+  int iReturn = -1;
+
+  CPVRChannelPtr channel;
+  if (m_addons->GetPlayingChannel(channel))
+    iReturn = channel->GetEPG(results);
+  else
+    CLog::Log(LOGDEBUG,"PVRManager - %s - no current channel set", __FUNCTION__);
+
+  return iReturn;
+}
+
+void CPVRManager::ResetPlayingTag(void)
+{
+  CSingleLock lock(m_critSection);
+  if (GetState() == ManagerStateStarted && m_guiInfo)
+    m_guiInfo->ResetPlayingTag();
+}
+
+int CPVRManager::GetPreviousChannel(void)
+{
+  CPVRChannelPtr currentChannel;
+  if (GetCurrentChannel(currentChannel))
+  {
+    CPVRChannelGroupPtr selectedGroup = GetPlayingGroup(currentChannel->IsRadio());
+    CFileItemPtr channel = selectedGroup->GetLastPlayedChannel(currentChannel->ChannelID());
+    if (channel && channel->HasPVRChannelInfoTag())
+      return channel->GetPVRChannelInfoTag()->ChannelNumber();
+  }
+  return -1;
+}
+
+bool CPVRManager::ToggleRecordingOnChannel(unsigned int iChannelId)
+{
+  bool bReturn = false;
+
+  CPVRChannelPtr channel = m_channelGroups->GetChannelById(iChannelId);
+  if (!channel)
+    return bReturn;
+
+  if (m_addons->HasTimerSupport(channel->ClientID()))
+  {
+    /* timers are supported on this channel */
+    if (!channel->IsRecording())
+    {
+      bReturn = m_timers->InstantTimer(*channel);
+      if (!bReturn)
+        CGUIDialogOK::ShowAndGetInput(19033,0,19164,0);
+    }
+    else
+    {
+      /* delete active timers */
+      bReturn = m_timers->DeleteTimersOnChannel(*channel, false, true);
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRManager::StartRecordingOnPlayingChannel(bool bOnOff)
+{
+  bool bReturn = false;
+
+  CPVRChannelPtr channel;
+  if (!m_addons->GetPlayingChannel(channel))
+    return bReturn;
+
+  if (m_addons->HasTimerSupport(channel->ClientID()))
+  {
+    /* timers are supported on this channel */
+    if (bOnOff && !channel->IsRecording())
+    {
+      bReturn = m_timers->InstantTimer(*channel);
+      if (!bReturn)
+        CGUIDialogOK::ShowAndGetInput(19033,0,19164,0);
+    }
+    else if (!bOnOff && channel->IsRecording())
+    {
+      /* delete active timers */
+      bReturn = m_timers->DeleteTimersOnChannel(*channel, false, true);
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRManager::CheckParentalLock(const CPVRChannel &channel)
+{
+  bool bReturn = !IsParentalLocked(channel) ||
+      CheckParentalPIN();
+
+  if (!bReturn)
+    CLog::Log(LOGERROR, "PVRManager - %s - parental lock verification failed for channel '%s': wrong PIN entered.", __FUNCTION__, channel.ChannelName().c_str());
+
+  return bReturn;
+}
+
+bool CPVRManager::IsParentalLocked(const CPVRChannel &channel)
+{
+  bool bReturn(false);
+  CPVRChannelPtr currentChannel(new CPVRChannel(false));
+
+  if (// different channel
+      (!GetCurrentChannel(currentChannel) || channel != *currentChannel) &&
+      // parental control enabled
+      g_guiSettings.GetBool("pvrparental.enabled") &&
+      // channel is locked
+      channel.IsLocked())
+  {
+    float parentalDurationMs = g_guiSettings.GetInt("pvrparental.duration") * 1000.0f;
+    bReturn = m_parentalTimer &&
+        (!m_parentalTimer->IsRunning() ||
+          m_parentalTimer->GetElapsedMilliseconds() > parentalDurationMs);
+  }
+
+  return bReturn;
+}
+
+bool CPVRManager::CheckParentalPIN(const char *strTitle /* = NULL */)
+{
+  CStdString pinCode = g_guiSettings.GetString("pvrparental.pin");
+
+  if (!g_guiSettings.GetBool("pvrparental.enabled") || pinCode.empty())
+    return true;
+
+  // Locked channel. Enter PIN:
+  bool bValidPIN = CGUIDialogNumeric::ShowAndVerifyInput(pinCode, strTitle ? strTitle : g_localizeStrings.Get(19263).c_str(), true);
+  if (!bValidPIN)
+    // display message: The entered PIN number was incorrect
+    CGUIDialogOK::ShowAndGetInput(19264,0,19265,0);
+  else if (m_parentalTimer)
+  {
+    // reset the timer
+    m_parentalTimer->StartZero();
+  }
+
+  return bValidPIN;
+}
+
+void CPVRManager::SaveCurrentChannelSettings(void)
+{
+  m_addons->SaveCurrentChannelSettings();
+}
+
+void CPVRManager::LoadCurrentChannelSettings()
+{
+  m_addons->LoadCurrentChannelSettings();
+}
+
+void CPVRManager::SetPlayingGroup(CPVRChannelGroupPtr group)
+{
+  m_channelGroups->Get(group->IsRadio())->SetSelectedGroup(group);
+}
+
+CPVRChannelGroupPtr CPVRManager::GetPlayingGroup(bool bRadio /* = false */)
+{
+  return m_channelGroups->GetSelectedGroup(bRadio);
+}
+
+bool CPVRRecordingsUpdateJob::DoWork(void)
+{
+  g_PVRRecordings->Update();
+  return true;
+}
+
+bool CPVRTimersUpdateJob::DoWork(void)
+{
+  return g_PVRTimers->Update();
+}
+
+bool CPVRChannelsUpdateJob::DoWork(void)
+{
+  return g_PVRChannelGroups->Update(true);
+}
+
+bool CPVRChannelGroupsUpdateJob::DoWork(void)
+{
+  return g_PVRChannelGroups->Update(false);
+}
+
+bool CPVRChannelSettingsSaveJob::DoWork(void)
+{
+  g_PVRManager.SaveCurrentChannelSettings();
+  return true;
+}
+
+bool CPVRManager::OpenLiveStream(const CFileItem &channel)
+{
+  bool bReturn(false);
+  if (!channel.HasPVRChannelInfoTag())
+    return bReturn;
+
+  CLog::Log(LOGDEBUG,"PVRManager - %s - opening live stream on channel '%s'",
+      __FUNCTION__, channel.GetPVRChannelInfoTag()->ChannelName().c_str());
+
+  // check if we're allowed to play this file
+  if (IsParentalLocked(*channel.GetPVRChannelInfoTag()))
+    return bReturn;
+
+  if ((bReturn = m_addons->OpenStream(*channel.GetPVRChannelInfoTag(), false)) != false)
+  {
+    CSingleLock lock(m_critSection);
+    if(m_currentFile)
+      delete m_currentFile;
+    m_currentFile = new CFileItem(channel);
+  }
+
+  return bReturn;
+}
+
+bool CPVRManager::OpenRecordedStream(const CPVRRecording &tag)
+{
+  bool bReturn = false;
+  CSingleLock lock(m_critSection);
+
+  CLog::Log(LOGDEBUG,"PVRManager - %s - opening recorded stream '%s'",
+      __FUNCTION__, tag.m_strFile.c_str());
+
+  if ((bReturn = m_addons->OpenStream(tag)) != false)
+  {
+    delete m_currentFile;
+    m_currentFile = new CFileItem(tag);
+  }
+
+  return bReturn;
+}
+
+void CPVRManager::CloseStream(void)
+{
+  CPVRChannelPtr channel;
+  bool bPersistChannel(false);
+
+  {
+    CSingleLock lock(m_critSection);
+
+    if (m_addons->GetPlayingChannel(channel))
+    {
+      /* store current time in iLastWatched */
+      time_t tNow;
+      CDateTime::GetCurrentDateTime().GetAsTime(tNow);
+      channel->SetLastWatched(tNow);
+      bPersistChannel = true;
+    }
+
+    m_addons->CloseStream();
+    SAFE_DELETE(m_currentFile);
+  }
+
+  if (bPersistChannel)
+    channel->Persist();
+}
+
+void CPVRManager::UpdateCurrentFile(void)
+{
+  CSingleLock lock(m_critSection);
+  if (m_currentFile)
+    UpdateItem(*m_currentFile);
+}
+
+bool CPVRManager::UpdateItem(CFileItem& item)
+{
+  /* Don't update if a recording is played */
+  if (item.IsPVRRecording())
+    return false;
+
+  if (!item.IsPVRChannel())
+  {
+    CLog::Log(LOGERROR, "CPVRManager - %s - no channel tag provided", __FUNCTION__);
+    return false;
+  }
+
+  CSingleLock lock(m_critSection);
+  if (!m_currentFile || *m_currentFile->GetPVRChannelInfoTag() == *item.GetPVRChannelInfoTag())
+    return false;
+
+  g_application.CurrentFileItem() = *m_currentFile;
+  g_infoManager.SetCurrentItem(*m_currentFile);
+
+  CPVRChannel* channelTag = item.GetPVRChannelInfoTag();
+  CEpgInfoTag epgTagNow;
+  bool bHasTagNow = channelTag->GetEPGNow(epgTagNow);
+
+  if (channelTag->IsRadio())
+  {
+    CMusicInfoTag* musictag = item.GetMusicInfoTag();
+    if (musictag)
+    {
+      musictag->SetTitle(bHasTagNow ?
+          epgTagNow.Title() :
+          g_guiSettings.GetBool("epg.hidenoinfoavailable") ?
+              StringUtils::EmptyString :
+              g_localizeStrings.Get(19055)); // no information available
+      if (bHasTagNow)
+        musictag->SetGenre(epgTagNow.Genre());
+      musictag->SetDuration(bHasTagNow ? epgTagNow.GetDuration() : 3600);
+      musictag->SetURL(channelTag->Path());
+      musictag->SetArtist(channelTag->ChannelName());
+      musictag->SetAlbumArtist(channelTag->ChannelName());
+      musictag->SetLoaded(true);
+      musictag->SetComment(StringUtils::EmptyString);
+      musictag->SetLyrics(StringUtils::EmptyString);
+    }
+  }
+  else
+  {
+    CVideoInfoTag *videotag = item.GetVideoInfoTag();
+    if (videotag)
+    {
+      videotag->m_strTitle = bHasTagNow ?
+          epgTagNow.Title() :
+          g_guiSettings.GetBool("epg.hidenoinfoavailable") ?
+              StringUtils::EmptyString :
+              g_localizeStrings.Get(19055); // no information available
+      if (bHasTagNow)
+        videotag->m_genre = epgTagNow.Genre();
+      videotag->m_strPath = channelTag->Path();
+      videotag->m_strFileNameAndPath = channelTag->Path();
+      videotag->m_strPlot = bHasTagNow ? epgTagNow.Plot() : StringUtils::EmptyString;
+      videotag->m_strPlotOutline = bHasTagNow ? epgTagNow.PlotOutline() : StringUtils::EmptyString;
+      videotag->m_iEpisode = bHasTagNow ? epgTagNow.EpisodeNum() : 0;
+    }
+  }
+
+  return false;
+}
+
+
+bool CPVRManager::UpdateCurrentLastPlayedPosition(int lastplayedposition)
+{
+  // Only anything but recordings we fake success
+  if (!IsPlayingRecording())
+    return true;
+
+  bool rc = false;
+  CPVRRecording currentRecording;
+
+  if (m_addons)
+  {
+    PVR_ERROR error;
+    rc = m_addons->GetPlayingRecording(currentRecording) && m_addons->SetRecordingLastPlayedPosition(currentRecording, lastplayedposition, &error);
+  }
+  return rc;
+}
+
+bool CPVRManager::SetRecordingLastPlayedPosition(const CPVRRecording &recording, int lastplayedposition)
+{
+  bool rc = false;
+
+  if (m_addons)
+  {
+    PVR_ERROR error;
+    rc = m_addons->SetRecordingLastPlayedPosition(recording, lastplayedposition, &error);
+  }
+  return rc;
+}
+
+int CPVRManager::GetRecordingLastPlayedPosition(const CPVRRecording &recording)
+{
+  int rc = 0;
+
+  if (m_addons)
+  {
+    rc = m_addons->GetRecordingLastPlayedPosition(recording);
+  }
+  return rc;
+}
+
+bool CPVRManager::StartPlayback(const CPVRChannel *channel, bool bPreview /* = false */)
+{
+  g_settings.m_bStartVideoWindowed = bPreview;
+  CApplicationMessenger::Get().MediaPlay(CFileItem(*channel));
+  CLog::Log(LOGNOTICE, "PVRManager - %s - started playback on channel '%s'",
+      __FUNCTION__, channel->ChannelName().c_str());
+  return true;
+}
+
+bool CPVRManager::PerformChannelSwitch(const CPVRChannel &channel, bool bPreview)
+{
+  bool bSwitched(false);
+
+  if (IsParentalLocked(channel))
+    return false;
+
+  CSingleLock lock(m_critSection);
+  if (m_bIsSwitchingChannels)
+  {
+    CLog::Log(LOGDEBUG, "PVRManager - %s - can't switch to channel '%s'. waiting for the previous switch to complete",
+        __FUNCTION__, channel.ChannelName().c_str());
+    return bSwitched;
+  }
+  m_bIsSwitchingChannels = true;
+
+  CLog::Log(LOGDEBUG, "PVRManager - %s - switching to channel '%s'",
+      __FUNCTION__, channel.ChannelName().c_str());
+
+  /* make sure that channel settings are persisted */
+  if (!bPreview)
+  {
+    CPVRChannelPtr currentChannel;
+    if (m_addons->GetPlayingChannel(currentChannel))
+    {
+      /* store current time in iLastWatched */
+      time_t tNow;
+      CDateTime::GetCurrentDateTime().GetAsTime(tNow);
+      currentChannel->SetLastWatched(tNow);
+    }
+
+    SaveCurrentChannelSettings();
+  }
+
+  SAFE_DELETE(m_currentFile);
+
+  lock.Leave();
+
+  if (!bPreview && (channel.ClientID() < 0 || !m_addons->SwitchChannel(channel)))
+  {
+    lock.Enter();
+    m_bIsSwitchingChannels = false;
+    lock.Leave();
+
+    CLog::Log(LOGERROR, "PVRManager - %s - failed to switch to channel '%s'",
+        __FUNCTION__, channel.ChannelName().c_str());
+  }
+  else
+  {
+    bSwitched = true;
+
+    lock.Enter();
+    m_currentFile = new CFileItem(channel);
+
+    if (!bPreview)
+      CLog::Log(LOGNOTICE, "PVRManager - %s - switched to channel '%s'",
+          __FUNCTION__, channel.ChannelName().c_str());
+
+    m_bIsSwitchingChannels = false;
+  }
+
+  if (!bSwitched)
+  {
+    CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error,
+        g_localizeStrings.Get(19166), // PVR information
+        g_localizeStrings.Get(19035)); // This channel cannot be played. Check the log for details.
+  }
+
+  return bSwitched;
+}
+
+int CPVRManager::GetTotalTime(void) const
+{
+  return IsStarted() && m_guiInfo ? m_guiInfo->GetDuration() : 0;
+}
+
+int CPVRManager::GetStartTime(void) const
+{
+  return IsStarted() && m_guiInfo ? m_guiInfo->GetStartTime() : 0;
+}
+
+bool CPVRManager::TranslateBoolInfo(DWORD dwInfo) const
+{
+   return IsStarted() && m_guiInfo ? m_guiInfo->TranslateBoolInfo(dwInfo) : false;
+}
+
+bool CPVRManager::TranslateCharInfo(DWORD dwInfo, CStdString &strValue) const
+{
+  return IsStarted() && m_guiInfo ? m_guiInfo->TranslateCharInfo(dwInfo, strValue) : false;
+}
+
+int CPVRManager::TranslateIntInfo(DWORD dwInfo) const
+{
+  return IsStarted() && m_guiInfo ? m_guiInfo->TranslateIntInfo(dwInfo) : 0;
+}
+
+bool CPVRManager::HasTimers(void) const
+{
+  return IsStarted() && m_timers ? m_timers->HasActiveTimers() : false;
+}
+
+bool CPVRManager::IsRecording(void) const
+{
+  return IsStarted() && m_timers ? m_timers->IsRecording() : false;
+}
+
+bool CPVRManager::IsIdle(void) const
+{
+  if (!IsStarted())
+    return true;
+
+  if (IsRecording() || IsPlaying()) // pvr recording or playing?
+  {
+    return false;
+  }
+  else if (m_timers) // has active timers, etc.?
+  {
+    const CDateTime now = CDateTime::GetUTCDateTime();
+    const CDateTimeSpan idle(0, 0, g_guiSettings.GetInt("pvrpowermanagement.backendidletime"), 0);
+
+    const CDateTime next = m_timers->GetNextEventTime();
+    const CDateTimeSpan delta = next - now;
+
+    if (delta < idle)
+    {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+void CPVRManager::ShowPlayerInfo(int iTimeout)
+{
+  if (IsStarted() && m_guiInfo)
+    m_guiInfo->ShowPlayerInfo(iTimeout);
+}
+
+void CPVRManager::LocalizationChanged(void)
+{
+  CSingleLock lock(m_critSection);
+  if (IsStarted())
+  {
+    static_cast<CPVRChannelGroupInternal *>(m_channelGroups->GetGroupAllRadio().get())->CheckGroupName();
+    static_cast<CPVRChannelGroupInternal *>(m_channelGroups->GetGroupAllTV().get())->CheckGroupName();
+  }
+}
+
+bool CPVRManager::IsInitialising(void) const
+{
+  return GetState() == ManagerStateStarting;
+}
+
+bool CPVRManager::IsStarted(void) const
+{
+  return GetState() == ManagerStateStarted;
+}
+
+bool CPVRManager::IsPlayingTV(void) const
+{
+  return IsStarted() && m_addons && m_addons->IsPlayingTV();
+}
+
+bool CPVRManager::IsPlayingRadio(void) const
+{
+  return IsStarted() && m_addons && m_addons->IsPlayingRadio();
+}
+
+bool CPVRManager::IsPlayingRecording(void) const
+{
+  return IsStarted() && m_addons && m_addons->IsPlayingRecording();
+}
+
+bool CPVRManager::IsRunningChannelScan(void) const
+{
+  return IsStarted() && m_addons && m_addons->IsRunningChannelScan();
+}
+
+void CPVRManager::StartChannelScan(void)
+{
+  if (IsStarted() && m_addons)
+    m_addons->StartChannelScan();
+}
+
+void CPVRManager::SearchMissingChannelIcons(void)
+{
+  if (IsStarted() && m_channelGroups)
+    m_channelGroups->SearchMissingChannelIcons();
+}
+
+bool CPVRManager::IsJobPending(const char *strJobName) const
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSectionTriggers);
+  for (unsigned int iJobPtr = 0; IsStarted() && iJobPtr < m_pendingUpdates.size(); iJobPtr++)
+  {
+    if (!strcmp(m_pendingUpdates.at(iJobPtr)->GetType(), strJobName))
+    {
+      bReturn = true;
+      break;
+    }
+  }
+
+  return bReturn;
+}
+
+void CPVRManager::TriggerRecordingsUpdate(void)
+{
+  CSingleLock lock(m_critSectionTriggers);
+  if (!IsStarted() || IsJobPending("pvr-update-recordings"))
+    return;
+
+  m_pendingUpdates.push_back(new CPVRRecordingsUpdateJob());
+
+  lock.Leave();
+  m_triggerEvent.Set();
+}
+
+void CPVRManager::TriggerTimersUpdate(void)
+{
+  CSingleLock lock(m_critSectionTriggers);
+  if (!IsStarted() || IsJobPending("pvr-update-timers"))
+    return;
+
+  m_pendingUpdates.push_back(new CPVRTimersUpdateJob());
+
+  lock.Leave();
+  m_triggerEvent.Set();
+}
+
+void CPVRManager::TriggerChannelsUpdate(void)
+{
+  CSingleLock lock(m_critSectionTriggers);
+  if (!IsStarted() || IsJobPending("pvr-update-channels"))
+    return;
+
+  m_pendingUpdates.push_back(new CPVRChannelsUpdateJob());
+
+  lock.Leave();
+  m_triggerEvent.Set();
+}
+
+void CPVRManager::TriggerChannelGroupsUpdate(void)
+{
+  CSingleLock lock(m_critSectionTriggers);
+  if (!IsStarted() || IsJobPending("pvr-update-channelgroups"))
+    return;
+
+  m_pendingUpdates.push_back(new CPVRChannelGroupsUpdateJob());
+
+  lock.Leave();
+  m_triggerEvent.Set();
+}
+
+void CPVRManager::TriggerSaveChannelSettings(void)
+{
+  CSingleLock lock(m_critSectionTriggers);
+  if (!IsStarted() || IsJobPending("pvr-save-channelsettings"))
+    return;
+
+  m_pendingUpdates.push_back(new CPVRChannelSettingsSaveJob());
+
+  lock.Leave();
+  m_triggerEvent.Set();
+}
+
+void CPVRManager::ExecutePendingJobs(void)
+{
+  CSingleLock lock(m_critSectionTriggers);
+
+  while (m_pendingUpdates.size() > 0)
+  {
+    CJob *job = m_pendingUpdates.at(0);
+    m_pendingUpdates.erase(m_pendingUpdates.begin());
+    lock.Leave();
+
+    job->DoWork();
+    delete job;
+
+    lock.Enter();
+  }
+
+  m_triggerEvent.Reset();
+}
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
new file mode 100644
index 0000000..1be0f70
--- /dev/null
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -0,0 +1,1334 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <vector>
+#include "PVRClient.h"
+#include "pvr/PVRManager.h"
+#include "epg/Epg.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/timers/PVRTimerInfoTag.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "settings/AdvancedSettings.h"
+#include "utils/log.h"
+#include "settings/GUISettings.h"
+
+using namespace std;
+using namespace ADDON;
+using namespace PVR;
+using namespace EPG;
+
+#define DEFAULT_INFO_STRING_VALUE "unknown"
+
+CPVRClient::CPVRClient(const AddonProps& props) :
+    CAddonDll<DllPVRClient, PVRClient, PVR_PROPERTIES>(props),
+    m_apiVersion("0.0.0")
+{
+  ResetProperties();
+}
+
+CPVRClient::CPVRClient(const cp_extension_t *ext) :
+    CAddonDll<DllPVRClient, PVRClient, PVR_PROPERTIES>(ext),
+    m_apiVersion("0.0.0")
+{
+  ResetProperties();
+}
+
+CPVRClient::~CPVRClient(void)
+{
+  Destroy();
+  SAFE_DELETE(m_pInfo);
+}
+
+void CPVRClient::ResetProperties(int iClientId /* = PVR_INVALID_CLIENT_ID */)
+{
+  /* initialise members */
+  SAFE_DELETE(m_pInfo);
+  m_pInfo = new PVR_PROPERTIES;
+  m_strUserPath           = CSpecialProtocol::TranslatePath(Profile());
+  m_pInfo->strUserPath    = m_strUserPath.c_str();
+  m_strClientPath         = CSpecialProtocol::TranslatePath(Path());
+  m_pInfo->strClientPath  = m_strClientPath.c_str();
+  m_menuhooks.clear();
+  m_bReadyToUse           = false;
+  m_iClientId             = iClientId;
+  m_strBackendVersion     = DEFAULT_INFO_STRING_VALUE;
+  m_strConnectionString   = DEFAULT_INFO_STRING_VALUE;
+  m_strFriendlyName       = DEFAULT_INFO_STRING_VALUE;
+  m_strBackendName        = DEFAULT_INFO_STRING_VALUE;
+  m_bIsPlayingTV          = false;
+  m_bIsPlayingRecording   = false;
+  memset(&m_addonCapabilities, 0, sizeof(m_addonCapabilities));
+  ResetQualityData(m_qualityInfo);
+  m_apiVersion = AddonVersion("0.0.0");
+}
+
+bool CPVRClient::Create(int iClientId)
+{
+  if (iClientId <= PVR_INVALID_CLIENT_ID || iClientId == PVR_VIRTUAL_CLIENT_ID)
+    return false;
+
+  /* ensure that a previous instance is destroyed */
+  Destroy();
+
+  /* reset all properties to defaults */
+  ResetProperties(iClientId);
+
+  /* initialise the add-on */
+  bool bReadyToUse(false);
+  CLog::Log(LOGDEBUG, "PVR - %s - creating PVR add-on instance '%s'", __FUNCTION__, Name().c_str());
+  try
+  {
+    bReadyToUse = CAddonDll<DllPVRClient, PVRClient, PVR_PROPERTIES>::Create() &&
+        GetAddonProperties();
+  }
+  catch (exception &e) { LogException(e, __FUNCTION__); }
+
+  m_bReadyToUse = bReadyToUse;
+  if (!bReadyToUse)
+    ResetProperties(iClientId);
+
+  return bReadyToUse;
+}
+
+bool CPVRClient::DllLoaded(void) const
+{
+  try { return CAddonDll<DllPVRClient, PVRClient, PVR_PROPERTIES>::DllLoaded(); }
+  catch (exception &e) { LogException(e, __FUNCTION__); }
+
+  return false;
+}
+
+void CPVRClient::Destroy(void)
+{
+  if (!m_bReadyToUse)
+    return;
+  m_bReadyToUse = false;
+
+  /* reset 'ready to use' to false */
+  CLog::Log(LOGDEBUG, "PVR - %s - destroying PVR add-on '%s'", __FUNCTION__, GetFriendlyName().c_str());
+
+  /* destroy the add-on */
+  try { CAddonDll<DllPVRClient, PVRClient, PVR_PROPERTIES>::Destroy(); }
+  catch (exception &e) { LogException(e, __FUNCTION__); }
+
+  /* reset all properties to defaults */
+  ResetProperties();
+}
+
+void CPVRClient::ReCreate(void)
+{
+  int iClientID(m_iClientId);
+  Destroy();
+
+  /* recreate the instance */
+  Create(iClientID);
+}
+
+bool CPVRClient::ReadyToUse(void) const
+{
+  return m_bReadyToUse;
+}
+
+int CPVRClient::GetID(void) const
+{
+  return m_iClientId;
+}
+
+/*!
+ * @brief Copy over group info from xbmcGroup to addonGroup.
+ * @param xbmcGroup The group on XBMC's side.
+ * @param addonGroup The group on the addon's side.
+ */
+void CPVRClient::WriteClientGroupInfo(const CPVRChannelGroup &xbmcGroup, PVR_CHANNEL_GROUP &addonGroup)
+{
+  memset(&addonGroup, 0, sizeof(addonGroup));
+
+  addonGroup.bIsRadio     = xbmcGroup.IsRadio();
+  strncpy(addonGroup.strGroupName, xbmcGroup.GroupName().c_str(), sizeof(addonGroup.strGroupName) - 1);
+}
+
+/*!
+ * @brief Copy over recording info from xbmcRecording to addonRecording.
+ * @param xbmcRecording The recording on XBMC's side.
+ * @param addonRecording The recording on the addon's side.
+ */
+void CPVRClient::WriteClientRecordingInfo(const CPVRRecording &xbmcRecording, PVR_RECORDING &addonRecording)
+{
+  time_t recTime;
+  xbmcRecording.RecordingTimeAsUTC().GetAsTime(recTime);
+
+  memset(&addonRecording, 0, sizeof(addonRecording));
+
+  addonRecording.recordingTime  = recTime - g_advancedSettings.m_iPVRTimeCorrection;
+  strncpy(addonRecording.strRecordingId, xbmcRecording.m_strRecordingId.c_str(), sizeof(addonRecording.strRecordingId) - 1);
+  strncpy(addonRecording.strTitle, xbmcRecording.m_strTitle.c_str(), sizeof(addonRecording.strTitle) - 1);
+  strncpy(addonRecording.strPlotOutline, xbmcRecording.m_strPlotOutline.c_str(), sizeof(addonRecording.strPlotOutline) - 1);
+  strncpy(addonRecording.strPlot, xbmcRecording.m_strPlot.c_str(), sizeof(addonRecording.strPlot) - 1);
+  strncpy(addonRecording.strChannelName, xbmcRecording.m_strChannelName.c_str(), sizeof(addonRecording.strChannelName) - 1);
+  addonRecording.iDuration      = xbmcRecording.GetDuration();
+  addonRecording.iPriority      = xbmcRecording.m_iPriority;
+  addonRecording.iLifetime      = xbmcRecording.m_iLifetime;
+  strncpy(addonRecording.strDirectory, xbmcRecording.m_strDirectory.c_str(), sizeof(addonRecording.strDirectory) - 1);
+  strncpy(addonRecording.strStreamURL, xbmcRecording.m_strStreamURL.c_str(), sizeof(addonRecording.strStreamURL) - 1);
+}
+
+/*!
+ * @brief Copy over timer info from xbmcTimer to addonTimer.
+ * @param xbmcTimer The timer on XBMC's side.
+ * @param addonTimer The timer on the addon's side.
+ */
+void CPVRClient::WriteClientTimerInfo(const CPVRTimerInfoTag &xbmcTimer, PVR_TIMER &addonTimer)
+{
+  time_t start, end, firstDay;
+  xbmcTimer.StartAsUTC().GetAsTime(start);
+  xbmcTimer.EndAsUTC().GetAsTime(end);
+  xbmcTimer.FirstDayAsUTC().GetAsTime(firstDay);
+  CEpgInfoTagPtr epgTag = xbmcTimer.GetEpgInfoTag();
+
+  memset(&addonTimer, 0, sizeof(addonTimer));
+
+  addonTimer.iClientIndex      = xbmcTimer.m_iClientIndex;
+  addonTimer.state             = xbmcTimer.m_state;
+  addonTimer.iClientIndex      = xbmcTimer.m_iClientIndex;
+  addonTimer.iClientChannelUid = xbmcTimer.m_iClientChannelUid;
+  strncpy(addonTimer.strTitle, xbmcTimer.m_strTitle.c_str(), sizeof(addonTimer.strTitle) - 1);
+  strncpy(addonTimer.strDirectory, xbmcTimer.m_strDirectory.c_str(), sizeof(addonTimer.strDirectory) - 1);
+  addonTimer.iPriority         = xbmcTimer.m_iPriority;
+  addonTimer.iLifetime         = xbmcTimer.m_iLifetime;
+  addonTimer.bIsRepeating      = xbmcTimer.m_bIsRepeating;
+  addonTimer.iWeekdays         = xbmcTimer.m_iWeekdays;
+  addonTimer.startTime         = start - g_advancedSettings.m_iPVRTimeCorrection;
+  addonTimer.endTime           = end - g_advancedSettings.m_iPVRTimeCorrection;
+  addonTimer.firstDay          = firstDay - g_advancedSettings.m_iPVRTimeCorrection;
+  addonTimer.iEpgUid           = epgTag ? epgTag->UniqueBroadcastID() : -1;
+  strncpy(addonTimer.strSummary, xbmcTimer.m_strSummary.c_str(), sizeof(addonTimer.strSummary) - 1);
+  addonTimer.iMarginStart      = xbmcTimer.m_iMarginStart;
+  addonTimer.iMarginEnd        = xbmcTimer.m_iMarginEnd;
+  addonTimer.iGenreType        = xbmcTimer.m_iGenreType;
+  addonTimer.iGenreSubType     = xbmcTimer.m_iGenreSubType;
+}
+
+/*!
+ * @brief Copy over channel info from xbmcChannel to addonClient.
+ * @param xbmcChannel The channel on XBMC's side.
+ * @param addonChannel The channel on the addon's side.
+ */
+void CPVRClient::WriteClientChannelInfo(const CPVRChannel &xbmcChannel, PVR_CHANNEL &addonChannel)
+{
+  memset(&addonChannel, 0, sizeof(addonChannel));
+
+  addonChannel.iUniqueId         = xbmcChannel.UniqueID();
+  addonChannel.iChannelNumber    = xbmcChannel.ClientChannelNumber();
+  strncpy(addonChannel.strChannelName, xbmcChannel.ClientChannelName().c_str(), sizeof(addonChannel.strChannelName) - 1);
+  strncpy(addonChannel.strIconPath, xbmcChannel.IconPath().c_str(), sizeof(addonChannel.strIconPath) - 1);
+  addonChannel.iEncryptionSystem = xbmcChannel.EncryptionSystem();
+  addonChannel.bIsRadio          = xbmcChannel.IsRadio();
+  addonChannel.bIsHidden         = xbmcChannel.IsHidden();
+  strncpy(addonChannel.strInputFormat, xbmcChannel.InputFormat().c_str(), sizeof(addonChannel.strInputFormat) - 1);
+  strncpy(addonChannel.strStreamURL, xbmcChannel.StreamURL().c_str(), sizeof(addonChannel.strStreamURL) - 1);
+}
+
+bool CPVRClient::IsCompatibleAPIVersion(const ADDON::AddonVersion &minVersion, const ADDON::AddonVersion &version)
+{
+  AddonVersion myMinVersion = AddonVersion(XBMC_PVR_MIN_API_VERSION);
+  AddonVersion myVersion = AddonVersion(XBMC_PVR_API_VERSION);
+  return (version >= myMinVersion && minVersion <= myVersion);
+}
+
+bool CPVRClient::GetAddonProperties(void)
+{
+  CStdString strHostName, strBackendName, strConnectionString, strFriendlyName, strBackendVersion;
+  PVR_ADDON_CAPABILITIES addonCapabilities;
+
+  /* check the API version */
+  AddonVersion minVersion = AddonVersion("0.0.0");
+  try { m_apiVersion = AddonVersion(m_pStruct->GetPVRAPIVersion()); }
+  catch (exception &e) { LogException(e, "GetPVRAPIVersion()"); return false;  }
+
+  try { minVersion = AddonVersion(m_pStruct->GetMininumPVRAPIVersion()); }
+  catch (exception &e) { LogException(e, "GetMininumPVRAPIVersion()"); return false;  }
+
+  if (!IsCompatibleAPIVersion(minVersion, m_apiVersion))
+  {
+    CLog::Log(LOGERROR, "PVR - Add-on '%s' is using an incompatible API version. Please contact the developer of this add-on: %s", GetFriendlyName().c_str(), Author().c_str());
+    return false;
+  }
+
+  /* get the capabilities */
+  try
+  {
+    memset(&addonCapabilities, 0, sizeof(addonCapabilities));
+    PVR_ERROR retVal = m_pStruct->GetAddonCapabilities(&addonCapabilities);
+    if (retVal != PVR_ERROR_NO_ERROR)
+    {
+      CLog::Log(LOGERROR, "PVR - couldn't get the capabilities for add-on '%s'. Please contact the developer of this add-on: %s", GetFriendlyName().c_str(), Author().c_str());
+      return false;
+    }
+  }
+  catch (exception &e) { LogException(e, "GetAddonCapabilities()"); return false; }
+
+  /* get the name of the backend */
+  try { strBackendName = m_pStruct->GetBackendName(); }
+  catch (exception &e) { LogException(e, "GetBackendName()"); return false;  }
+
+  /* get the connection string */
+  try { strConnectionString = m_pStruct->GetConnectionString(); }
+  catch (exception &e) { LogException(e, "GetConnectionString()"); return false;  }
+
+  /* display name = backend name:connection string */
+  strFriendlyName.Format("%s:%s", strBackendName.c_str(), strConnectionString.c_str());
+
+  /* backend version number */
+  try { strBackendVersion = m_pStruct->GetBackendVersion(); }
+  catch (exception &e) { LogException(e, "GetBackendVersion()"); return false;  }
+
+  /* update the members */
+  m_strBackendName      = strBackendName;
+  m_strConnectionString = strConnectionString;
+  m_strFriendlyName     = strFriendlyName;
+  m_strBackendVersion   = strBackendVersion;
+  m_addonCapabilities   = addonCapabilities;
+
+  return true;
+}
+
+PVR_ADDON_CAPABILITIES CPVRClient::GetAddonCapabilities(void) const
+{
+  PVR_ADDON_CAPABILITIES addonCapabilities(m_addonCapabilities);
+  return addonCapabilities;
+}
+
+CStdString CPVRClient::GetBackendName(void) const
+{
+  CStdString strReturn(m_strBackendName);
+  return strReturn;
+}
+
+CStdString CPVRClient::GetBackendVersion(void) const
+{
+  CStdString strReturn(m_strBackendVersion);
+  return strReturn;
+}
+
+CStdString CPVRClient::GetConnectionString(void) const
+{
+  CStdString strReturn(m_strConnectionString);
+  return strReturn;
+}
+
+CStdString CPVRClient::GetFriendlyName(void) const
+{
+  CStdString strReturn(m_strFriendlyName);
+  return strReturn;
+}
+
+PVR_ERROR CPVRClient::GetDriveSpace(long long *iTotal, long long *iUsed)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  try { return m_pStruct->GetDriveSpace(iTotal, iUsed); }
+  catch (exception &e) { LogException(e, __FUNCTION__); }
+
+  /* default to 0 on error */
+  *iTotal = 0;
+  *iUsed  = 0;
+
+  return PVR_ERROR_UNKNOWN;
+}
+
+PVR_ERROR CPVRClient::StartChannelScan(void)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsChannelScan)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  try { return m_pStruct->DialogChannelScan(); }
+  catch (exception &e) { LogException(e, __FUNCTION__); }
+
+  return PVR_ERROR_UNKNOWN;
+}
+
+void CPVRClient::CallMenuHook(const PVR_MENUHOOK &hook)
+{
+  if (!m_bReadyToUse)
+    return;
+
+  try { m_pStruct->MenuHook(hook); }
+  catch (exception &e) { LogException(e, __FUNCTION__); }
+}
+
+PVR_ERROR CPVRClient::GetEPGForChannel(const CPVRChannel &channel, CEpg *epg, time_t start /* = 0 */, time_t end /* = 0 */, bool bSaveInDb /* = false*/)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsEPG)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    PVR_CHANNEL addonChannel;
+    WriteClientChannelInfo(channel, addonChannel);
+
+    ADDON_HANDLE_STRUCT handle;
+    handle.callerAddress  = this;
+    handle.dataAddress    = epg;
+    handle.dataIdentifier = bSaveInDb ? 1 : 0; // used by the callback method CAddonCallbacksPVR::PVRTransferEpgEntry()
+    retVal = m_pStruct->GetEpg(&handle,
+        addonChannel,
+        start ? start - g_advancedSettings.m_iPVRTimeCorrection : 0,
+        end ? end - g_advancedSettings.m_iPVRTimeCorrection : 0);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+int CPVRClient::GetChannelGroupsAmount(void)
+{
+  int iReturn(-EINVAL);
+
+  if (!m_bReadyToUse)
+    return iReturn;
+
+  if (!m_addonCapabilities.bSupportsChannelGroups)
+    return iReturn;
+
+  try { iReturn = m_pStruct->GetChannelGroupsAmount(); }
+  catch (exception &e) { LogException(e, __FUNCTION__); }
+
+  return iReturn;
+}
+
+PVR_ERROR CPVRClient::GetChannelGroups(CPVRChannelGroups *groups)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsChannelGroups)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    ADDON_HANDLE_STRUCT handle;
+    handle.callerAddress = this;
+    handle.dataAddress = groups;
+    retVal = m_pStruct->GetChannelGroups(&handle, groups->IsRadio());
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+PVR_ERROR CPVRClient::GetChannelGroupMembers(CPVRChannelGroup *group)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsChannelGroups)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    ADDON_HANDLE_STRUCT handle;
+    handle.callerAddress = this;
+    handle.dataAddress = group;
+
+    PVR_CHANNEL_GROUP tag;
+    WriteClientGroupInfo(*group, tag);
+
+    CLog::Log(LOGDEBUG, "PVR - %s - get group members for group '%s' from add-on '%s'",
+        __FUNCTION__, tag.strGroupName, GetFriendlyName().c_str());
+    retVal = m_pStruct->GetChannelGroupMembers(&handle, tag);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+int CPVRClient::GetChannelsAmount(void)
+{
+  int iReturn(-EINVAL);
+  if (m_bReadyToUse && (m_addonCapabilities.bSupportsTV || m_addonCapabilities.bSupportsRadio))
+  {
+    try { iReturn = m_pStruct->GetChannelsAmount(); }
+    catch (exception &e) { LogException(e, __FUNCTION__); }
+  }
+
+  return iReturn;
+}
+
+PVR_ERROR CPVRClient::GetChannels(CPVRChannelGroup &channels, bool radio)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if ((!m_addonCapabilities.bSupportsRadio && radio) ||
+      (!m_addonCapabilities.bSupportsTV && !radio))
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+
+  try
+  {
+    ADDON_HANDLE_STRUCT handle;
+    handle.callerAddress = this;
+    handle.dataAddress = (CPVRChannelGroup*) &channels;
+    retVal = m_pStruct->GetChannels(&handle, radio);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+int CPVRClient::GetRecordingsAmount(void)
+{
+  int iReturn(-EINVAL);
+
+  if (m_addonCapabilities.bSupportsRecordings)
+  {
+    try { iReturn = m_pStruct->GetRecordingsAmount(); }
+    catch (exception &e) { LogException(e, __FUNCTION__); }
+  }
+
+  return iReturn;
+}
+
+PVR_ERROR CPVRClient::GetRecordings(CPVRRecordings *results)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsRecordings)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    ADDON_HANDLE_STRUCT handle;
+    handle.callerAddress = this;
+    handle.dataAddress = (CPVRRecordings*) results;
+    retVal = m_pStruct->GetRecordings(&handle);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+PVR_ERROR CPVRClient::DeleteRecording(const CPVRRecording &recording)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsRecordings)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    PVR_RECORDING tag;
+    WriteClientRecordingInfo(recording, tag);
+
+    retVal = m_pStruct->DeleteRecording(tag);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+PVR_ERROR CPVRClient::RenameRecording(const CPVRRecording &recording)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsRecordings)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    PVR_RECORDING tag;
+    WriteClientRecordingInfo(recording, tag);
+
+    retVal = m_pStruct->RenameRecording(tag);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+PVR_ERROR CPVRClient::SetRecordingPlayCount(const CPVRRecording &recording, int count)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsRecordingPlayCount)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    PVR_RECORDING tag;
+    WriteClientRecordingInfo(recording, tag);
+
+    retVal = m_pStruct->SetRecordingPlayCount(tag, count);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+PVR_ERROR CPVRClient::SetRecordingLastPlayedPosition(const CPVRRecording &recording, int lastplayedposition)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsLastPlayedPosition)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    PVR_RECORDING tag;
+    WriteClientRecordingInfo(recording, tag);
+
+    retVal = m_pStruct->SetRecordingLastPlayedPosition(tag, lastplayedposition);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+int CPVRClient::GetRecordingLastPlayedPosition(const CPVRRecording &recording)
+{
+  int iReturn(-EINVAL);
+  if (!m_bReadyToUse)
+    return iReturn;
+
+  if (!m_addonCapabilities.bSupportsLastPlayedPosition)
+    return iReturn;
+
+  try
+  {
+    PVR_RECORDING tag;
+    WriteClientRecordingInfo(recording, tag);
+
+    iReturn = m_pStruct->GetRecordingLastPlayedPosition(tag);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return iReturn;
+}
+
+int CPVRClient::GetTimersAmount(void)
+{
+  int iReturn(-EINVAL);
+  if (!m_bReadyToUse)
+    return iReturn;
+
+  if (!m_addonCapabilities.bSupportsTimers)
+    return iReturn;
+
+  try { iReturn = m_pStruct->GetTimersAmount(); }
+  catch (exception &e) { LogException(e, __FUNCTION__); }
+
+  return iReturn;
+}
+
+PVR_ERROR CPVRClient::GetTimers(CPVRTimers *results)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsTimers)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    ADDON_HANDLE_STRUCT handle;
+    handle.callerAddress = this;
+    handle.dataAddress = (CPVRTimers*) results;
+    retVal = m_pStruct->GetTimers(&handle);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+PVR_ERROR CPVRClient::AddTimer(const CPVRTimerInfoTag &timer)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsTimers)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    PVR_TIMER tag;
+    WriteClientTimerInfo(timer, tag);
+
+    retVal = m_pStruct->AddTimer(tag);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+PVR_ERROR CPVRClient::DeleteTimer(const CPVRTimerInfoTag &timer, bool bForce /* = false */)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsTimers)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    PVR_TIMER tag;
+    WriteClientTimerInfo(timer, tag);
+
+    retVal = m_pStruct->DeleteTimer(tag, bForce);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+PVR_ERROR CPVRClient::RenameTimer(const CPVRTimerInfoTag &timer, const CStdString &strNewName)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsTimers)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    PVR_TIMER tag;
+    WriteClientTimerInfo(timer, tag);
+
+    retVal = m_pStruct->UpdateTimer(tag);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+PVR_ERROR CPVRClient::UpdateTimer(const CPVRTimerInfoTag &timer)
+{
+  if (!m_bReadyToUse)
+    return PVR_ERROR_REJECTED;
+
+  if (!m_addonCapabilities.bSupportsTimers)
+    return PVR_ERROR_NOT_IMPLEMENTED;
+
+  PVR_ERROR retVal(PVR_ERROR_UNKNOWN);
+  try
+  {
+    PVR_TIMER tag;
+    WriteClientTimerInfo(timer, tag);
+
+    retVal = m_pStruct->UpdateTimer(tag);
+
+    LogError(retVal, __FUNCTION__);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return retVal;
+}
+
+int CPVRClient::ReadStream(void* lpBuf, int64_t uiBufSize)
+{
+  if (IsPlayingLiveStream())
+  {
+    try { return m_pStruct->ReadLiveStream((unsigned char *)lpBuf, (int)uiBufSize); }
+    catch (exception &e) { LogException(e, "ReadLiveStream()"); }
+  }
+  else if (IsPlayingRecording())
+  {
+    try { return m_pStruct->ReadRecordedStream((unsigned char *)lpBuf, (int)uiBufSize); }
+    catch (exception &e) { LogException(e, "ReadRecordedStream()"); }
+  }
+  return -EINVAL;
+}
+
+int64_t CPVRClient::SeekStream(int64_t iFilePosition, int iWhence/* = SEEK_SET*/)
+{
+  if (IsPlayingLiveStream())
+  {
+    try { return m_pStruct->SeekLiveStream(iFilePosition, iWhence); }
+    catch (exception &e) { LogException(e, "SeekLiveStream()"); }
+  }
+  else if (IsPlayingRecording())
+  {
+    try { return m_pStruct->SeekRecordedStream(iFilePosition, iWhence); }
+    catch (exception &e) { LogException(e, "SeekRecordedStream()"); }
+  }
+  return -EINVAL;
+}
+
+int64_t CPVRClient::GetStreamPosition(void)
+{
+  if (IsPlayingLiveStream())
+  {
+    try { return m_pStruct->PositionLiveStream(); }
+    catch (exception &e) { LogException(e, "PositionLiveStream()"); }
+  }
+  else if (IsPlayingRecording())
+  {
+    try { return m_pStruct->PositionRecordedStream(); }
+    catch (exception &e) { LogException(e, "PositionRecordedStream()"); }
+  }
+  return -EINVAL;
+}
+
+int64_t CPVRClient::GetStreamLength(void)
+{
+  if (IsPlayingLiveStream())
+  {
+    try { return m_pStruct->LengthLiveStream(); }
+    catch (exception &e) { LogException(e, "LengthLiveStream()"); }
+  }
+  else if (IsPlayingRecording())
+  {
+    try { return m_pStruct->LengthRecordedStream(); }
+    catch (exception &e) { LogException(e, "PositionRecordedStream()"); }
+  }
+  return -EINVAL;
+}
+
+int CPVRClient::GetCurrentClientChannel(void)
+{
+  if (IsPlayingLiveStream())
+  {
+    try { return m_pStruct->GetCurrentClientChannel(); }
+    catch (exception &e) { LogException(e, __FUNCTION__); }
+  }
+  return -EINVAL;
+}
+
+bool CPVRClient::SwitchChannel(const CPVRChannel &channel)
+{
+  bool bSwitched(false);
+
+  if (IsPlayingLiveStream() && CanPlayChannel(channel))
+  {
+    PVR_CHANNEL tag;
+    WriteClientChannelInfo(channel, tag);
+    try { bSwitched = m_pStruct->SwitchChannel(tag); }
+    catch (exception &e) { LogException(e, __FUNCTION__); }
+  }
+
+  if (bSwitched)
+  {
+    CPVRChannelPtr currentChannel = g_PVRChannelGroups->GetByUniqueID(channel.UniqueID(), channel.ClientID());
+    CSingleLock lock(m_critSection);
+    ResetQualityData(m_qualityInfo);
+    m_playingChannel = currentChannel;
+  }
+
+  return bSwitched;
+}
+
+bool CPVRClient::SignalQuality(PVR_SIGNAL_STATUS &qualityinfo)
+{
+  if (IsPlayingLiveStream())
+  {
+    try
+    {
+      PVR_ERROR retVal = m_pStruct->SignalStatus(qualityinfo);
+      return LogError(retVal, __FUNCTION__);
+    }
+    catch (exception &e)
+    {
+      LogException(e, __FUNCTION__);
+    }
+  }
+  return false;
+}
+
+CStdString CPVRClient::GetLiveStreamURL(const CPVRChannel &channel)
+{
+  CStdString strReturn;
+
+  if (!m_bReadyToUse || !CanPlayChannel(channel))
+    return strReturn;
+
+  try
+  {
+    PVR_CHANNEL tag;
+    WriteClientChannelInfo(channel, tag);
+    strReturn = m_pStruct->GetLiveStreamURL(tag);
+  }
+  catch (exception &e)
+  {
+    LogException(e, __FUNCTION__);
+  }
+
+  return strReturn;
+}
+
+PVR_ERROR CPVRClient::GetStreamProperties(PVR_STREAM_PROPERTIES *props)
+{
+  if (!IsPlaying())
+    return PVR_ERROR_REJECTED;
+
+  try { return m_pStruct->GetStreamProperties(props); }
+  catch (exception &e) { LogException(e, __FUNCTION__); }
+
+  return PVR_ERROR_UNKNOWN;
+}
+
+void CPVRClient::DemuxReset(void)
+{
+  if (m_bReadyToUse && m_addonCapabilities.bHandlesDemuxing)
+  {
+    try { m_pStruct->DemuxReset(); }
+    catch (exception &e) { LogException(e, __FUNCTION__); }
+  }
+}
+
+void CPVRClient::DemuxAbort(void)
+{
+  if (m_bReadyToUse && m_addonCapabilities.bHandlesDemuxing)
+  {
+    try { m_pStruct->DemuxAbort(); }
+    catch (exception &e) { LogException(e, __FUNCTION__); }
+  }
+}
+
+void CPVRClient::DemuxFlush(void)
+{
+  if (m_bReadyToUse && m_addonCapabilities.bHandlesDemuxing)
+  {
+    try { m_pStruct->DemuxFlush(); }
+    catch (exception &e) { LogException(e, __FUNCTION__); }
+  }
+}
+
+DemuxPacket* CPVRClient::DemuxRead(void)
+{
+  if (m_bReadyToUse && m_addonCapabilities.bHandlesDemuxing)
+  {
+    try { return m_pStruct->DemuxRead(); }
+    catch (exception &e) { LogException(e, __FUNCTION__); }
+  }
+  return NULL;
+}
+
+bool CPVRClient::HaveMenuHooks(void) const
+{
+  return m_bReadyToUse ? m_menuhooks.size() > 0 : false;
+}
+
+PVR_MENUHOOKS *CPVRClient::GetMenuHooks(void)
+{
+  return &m_menuhooks;
+}
+
+const char *CPVRClient::ToString(const PVR_ERROR error)
+{
+  switch (error)
+  {
+  case PVR_ERROR_NO_ERROR:
+    return "no error";
+  case PVR_ERROR_NOT_IMPLEMENTED:
+    return "not implemented";
+  case PVR_ERROR_SERVER_ERROR:
+    return "server error";
+  case PVR_ERROR_SERVER_TIMEOUT:
+    return "server timeout";
+  case PVR_ERROR_RECORDING_RUNNING:
+    return "recording already running";
+  case PVR_ERROR_ALREADY_PRESENT:
+    return "already present";
+  case PVR_ERROR_REJECTED:
+    return "rejected by the backend";
+  case PVR_ERROR_INVALID_PARAMETERS:
+    return "invalid parameters for this method";
+  case PVR_ERROR_FAILED:
+    return "the command failed";
+  case PVR_ERROR_UNKNOWN:
+  default:
+    return "unknown error";
+  }
+}
+
+bool CPVRClient::LogError(const PVR_ERROR error, const char *strMethod) const
+{
+  if (error != PVR_ERROR_NO_ERROR)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - addon '%s' returned an error: %s",
+        strMethod, GetFriendlyName().c_str(), ToString(error));
+    return false;
+  }
+  return true;
+}
+
+void CPVRClient::LogException(const exception &e, const char *strFunctionName) const
+{
+  CLog::Log(LOGERROR, "PVR - exception '%s' caught while trying to call '%s' on add-on '%s'. Please contact the developer of this add-on: %s", e.what(), strFunctionName, GetFriendlyName().c_str(), Author().c_str());
+}
+
+bool CPVRClient::CanPlayChannel(const CPVRChannel &channel) const
+{
+  return (m_bReadyToUse &&
+           ((m_addonCapabilities.bSupportsTV && !channel.IsRadio()) ||
+            (m_addonCapabilities.bSupportsRadio && channel.IsRadio())));
+}
+
+bool CPVRClient::SupportsChannelGroups(void) const
+{
+  return m_addonCapabilities.bSupportsChannelGroups;
+}
+
+bool CPVRClient::SupportsChannelScan(void) const
+{
+  return m_addonCapabilities.bSupportsChannelScan;
+}
+
+bool CPVRClient::SupportsEPG(void) const
+{
+  return m_addonCapabilities.bSupportsEPG;
+}
+
+bool CPVRClient::SupportsLastPlayedPosition(void) const
+{
+  return m_addonCapabilities.bSupportsLastPlayedPosition;
+}
+
+bool CPVRClient::SupportsRadio(void) const
+{
+  return m_addonCapabilities.bSupportsRadio;
+}
+
+bool CPVRClient::SupportsRecordings(void) const
+{
+  return m_addonCapabilities.bSupportsRecordings;
+}
+
+bool CPVRClient::SupportsRecordingFolders(void) const
+{
+  return m_addonCapabilities.bSupportsRecordingFolders;
+}
+
+bool CPVRClient::SupportsRecordingPlayCount(void) const
+{
+  return m_addonCapabilities.bSupportsRecordingPlayCount;
+}
+
+bool CPVRClient::SupportsTimers(void) const
+{
+  return m_addonCapabilities.bSupportsTimers;
+}
+
+bool CPVRClient::SupportsTV(void) const
+{
+  return m_addonCapabilities.bSupportsTV;
+}
+
+bool CPVRClient::HandlesDemuxing(void) const
+{
+  return m_addonCapabilities.bHandlesDemuxing;
+}
+
+bool CPVRClient::HandlesInputStream(void) const
+{
+  return m_addonCapabilities.bHandlesInputStream;
+}
+
+bool CPVRClient::IsPlayingLiveStream(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bReadyToUse && m_bIsPlayingTV;
+}
+
+bool CPVRClient::IsPlayingLiveTV(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bReadyToUse && m_bIsPlayingTV && !m_playingChannel->IsRadio();
+}
+
+bool CPVRClient::IsPlayingLiveRadio(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bReadyToUse && m_bIsPlayingTV && m_playingChannel->IsRadio();
+}
+
+bool CPVRClient::IsPlayingEncryptedChannel(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bReadyToUse && m_bIsPlayingTV && m_playingChannel->IsEncrypted();
+}
+
+bool CPVRClient::IsPlayingRecording(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bReadyToUse && m_bIsPlayingRecording;
+}
+
+bool CPVRClient::IsPlaying(void) const
+{
+  return IsPlayingLiveStream() ||
+         IsPlayingRecording();
+}
+
+bool CPVRClient::GetPlayingChannel(CPVRChannelPtr &channel) const
+{
+  CSingleLock lock(m_critSection);
+  if (m_bReadyToUse && m_bIsPlayingTV)
+  {
+    channel = m_playingChannel;
+    return true;
+  }
+  return false;
+}
+
+bool CPVRClient::GetPlayingRecording(CPVRRecording &recording) const
+{
+  CSingleLock lock(m_critSection);
+  if (m_bReadyToUse && m_bIsPlayingRecording)
+  {
+    recording = m_playingRecording;
+    return true;
+  }
+  return false;
+}
+
+bool CPVRClient::OpenStream(const CPVRChannel &channel, bool bIsSwitchingChannel)
+{
+  bool bReturn(false);
+  CloseStream();
+
+  if(!CanPlayChannel(channel))
+  {
+    CLog::Log(LOGDEBUG, "add-on '%s' can not play channel '%s'", GetFriendlyName().c_str(), channel.ChannelName().c_str());
+  }
+  else if (!channel.StreamURL().IsEmpty())
+  {
+    CLog::Log(LOGDEBUG, "opening live stream on url '%s'", channel.StreamURL().c_str());
+    bReturn = true;
+
+    // the Njoy N7 sometimes doesn't switch channels, but opens a stream to the previous channel
+    // when not waiting for a short period.
+    // added in 1.1.0
+    AddonVersion checkVersion("1.1.0");
+    if (m_apiVersion >= checkVersion)
+    {
+      unsigned int iWaitTimeMs = m_pStruct->GetChannelSwitchDelay();
+      if (iWaitTimeMs > 0)
+        XbmcThreads::ThreadSleep(iWaitTimeMs);
+    }
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "opening live stream for channel '%s'", channel.ChannelName().c_str());
+    PVR_CHANNEL tag;
+    WriteClientChannelInfo(channel, tag);
+
+    try { bReturn = m_pStruct->OpenLiveStream(tag); }
+    catch (exception &e) { LogException(e, __FUNCTION__); }
+  }
+
+  if (bReturn)
+  {
+    CPVRChannelPtr currentChannel = g_PVRChannelGroups->GetByUniqueID(channel.UniqueID(), channel.ClientID());
+    CSingleLock lock(m_critSection);
+    m_playingChannel      = currentChannel;
+    m_bIsPlayingTV        = true;
+    m_bIsPlayingRecording = false;
+  }
+
+  return bReturn;
+}
+
+bool CPVRClient::OpenStream(const CPVRRecording &recording)
+{
+  bool bReturn(false);
+  CloseStream();
+
+  if (m_bReadyToUse && m_addonCapabilities.bSupportsRecordings)
+  {
+    PVR_RECORDING tag;
+    WriteClientRecordingInfo(recording, tag);
+
+    try { bReturn = m_pStruct->OpenRecordedStream(tag); }
+    catch (exception &e) { LogException(e, __FUNCTION__); }
+  }
+
+  if (bReturn)
+  {
+    CSingleLock lock(m_critSection);
+    m_playingRecording    = recording;
+    m_bIsPlayingTV        = false;
+    m_bIsPlayingRecording = true;
+  }
+
+  return bReturn;
+}
+
+void CPVRClient::CloseStream(void)
+{
+  if (IsPlayingLiveStream())
+  {
+    try { m_pStruct->CloseLiveStream(); }
+    catch (exception &e) { LogException(e, "CloseLiveStream()"); }
+
+    CSingleLock lock(m_critSection);
+    m_bIsPlayingTV = false;
+  }
+  else if (IsPlayingRecording())
+  {
+    try { return m_pStruct->CloseRecordedStream(); }
+    catch (exception &e) { LogException(e, "CloseRecordedStream()"); }
+
+    CSingleLock lock(m_critSection);
+    m_bIsPlayingRecording = false;
+  }
+}
+
+void CPVRClient::ResetQualityData(PVR_SIGNAL_STATUS &qualityInfo)
+{
+  memset(&qualityInfo, 0, sizeof(qualityInfo));
+  if (g_guiSettings.GetBool("pvrplayback.signalquality"))
+  {
+    strncpy(qualityInfo.strAdapterName, g_localizeStrings.Get(13205).c_str(), 1024);
+    strncpy(qualityInfo.strAdapterStatus, g_localizeStrings.Get(13205).c_str(), 1024);
+  }
+  else
+  {
+    strncpy(qualityInfo.strAdapterName, g_localizeStrings.Get(13106).c_str(), 1024);
+    strncpy(qualityInfo.strAdapterStatus, g_localizeStrings.Get(13106).c_str(), 1024);
+  }
+}
+
+void CPVRClient::GetQualityData(PVR_SIGNAL_STATUS *status) const
+{
+  CSingleLock lock(m_critSection);
+  *status = m_qualityInfo;
+}
+
+int CPVRClient::GetSignalLevel(void) const
+{
+  CSingleLock lock(m_critSection);
+  return (int) ((float) m_qualityInfo.iSignal / 0xFFFF * 100);
+}
+
+int CPVRClient::GetSNR(void) const
+{
+  CSingleLock lock(m_critSection);
+  return (int) ((float) m_qualityInfo.iSNR / 0xFFFF * 100);
+}
+
+void CPVRClient::UpdateCharInfoSignalStatus(void)
+{
+  PVR_SIGNAL_STATUS qualityInfo;
+  ResetQualityData(qualityInfo);
+
+  if (g_guiSettings.GetBool("pvrplayback.signalquality"))
+    SignalQuality(qualityInfo);
+
+  CSingleLock lock(m_critSection);
+  m_qualityInfo = qualityInfo;
+}
diff --git a/xbmc/pvr/addons/PVRClients.cpp b/xbmc/pvr/addons/PVRClients.cpp
new file mode 100644
index 0000000..33f093a
--- /dev/null
+++ b/xbmc/pvr/addons/PVRClients.cpp
@@ -0,0 +1,1303 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "PVRClients.h"
+
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include "settings/GUISettings.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogSelect.h"
+#include "pvr/PVRManager.h"
+#include "pvr/PVRDatabase.h"
+#include "guilib/GUIWindowManager.h"
+#include "settings/Settings.h"
+#include "pvr/channels/PVRChannelGroups.h"
+#include "pvr/channels/PVRChannelGroupInternal.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "pvr/timers/PVRTimers.h"
+
+#ifdef HAS_VIDEO_PLAYBACK
+#include "cores/VideoRenderers/RenderManager.h"
+#endif
+
+using namespace std;
+using namespace ADDON;
+using namespace PVR;
+using namespace EPG;
+
+CPVRClients::CPVRClients(void) :
+    CThread("PVR add-on updater"),
+    m_bChannelScanRunning(false),
+    m_bIsSwitchingChannels(false),
+    m_bIsValidChannelSettings(false),
+    m_playingClientId(-EINVAL),
+    m_bIsPlayingLiveTV(false),
+    m_bIsPlayingRecording(false),
+    m_scanStart(0),
+    m_bNoAddonWarningDisplayed(false)
+{
+}
+
+CPVRClients::~CPVRClients(void)
+{
+  Unload();
+}
+
+void CPVRClients::Start(void)
+{
+  Stop();
+
+  m_addonDb.Open();
+  Create();
+  SetPriority(-1);
+}
+
+void CPVRClients::Stop(void)
+{
+  StopThread();
+  m_addonDb.Close();
+}
+
+bool CPVRClients::IsConnectedClient(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client);
+}
+
+bool CPVRClients::IsConnectedClient(const AddonPtr addon)
+{
+  for (PVR_CLIENTMAP_CITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+    if (itr->second->ID() == addon->ID())
+      return itr->second->ReadyToUse();
+  return false;
+}
+
+int CPVRClients::GetClientId(const AddonPtr client) const
+{
+  CSingleLock lock(m_critSection);
+
+  for (PVR_CLIENTMAP_CITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+    if (itr->second->ID() == client->ID())
+      return itr->first;
+
+  return -1;
+}
+
+bool CPVRClients::GetClient(int iClientId, PVR_CLIENT &addon) const
+{
+  bool bReturn(false);
+  if (iClientId <= PVR_INVALID_CLIENT_ID || iClientId == PVR_VIRTUAL_CLIENT_ID)
+    return bReturn;
+
+  CSingleLock lock(m_critSection);
+
+  PVR_CLIENTMAP_CITR itr = m_clientMap.find(iClientId);
+  if (itr != m_clientMap.end())
+  {
+    addon = itr->second;
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CPVRClients::GetConnectedClient(int iClientId, PVR_CLIENT &addon) const
+{
+  if (GetClient(iClientId, addon))
+    return addon->ReadyToUse();
+  return false;
+}
+
+bool CPVRClients::RequestRestart(AddonPtr addon, bool bDataChanged)
+{
+  return StopClient(addon, true);
+}
+
+bool CPVRClients::RequestRemoval(AddonPtr addon)
+{
+  return StopClient(addon, false);
+}
+
+void CPVRClients::Unload(void)
+{
+  Stop();
+
+  CSingleLock lock(m_critSection);
+
+  /* destroy all clients */
+  for (PVR_CLIENTMAP_ITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+    itr->second->Destroy();
+
+  /* reset class properties */
+  m_bChannelScanRunning  = false;
+  m_bIsPlayingLiveTV     = false;
+  m_bIsPlayingRecording  = false;
+  m_strPlayingClientName = "";
+
+  m_clientMap.clear();
+}
+
+int CPVRClients::GetFirstConnectedClientID(void)
+{
+  CSingleLock lock(m_critSection);
+
+  for (PVR_CLIENTMAP_ITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+    if (itr->second->ReadyToUse())
+      return itr->second->GetID();
+
+  return -1;
+}
+
+int CPVRClients::EnabledClientAmount(void) const
+{
+  int iReturn(0);
+  CSingleLock lock(m_critSection);
+
+  for (PVR_CLIENTMAP_CITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+    if (itr->second->Enabled())
+      ++iReturn;
+
+  return iReturn;
+}
+
+bool CPVRClients::HasEnabledClients(void) const
+{
+  return EnabledClientAmount() > 0;
+}
+
+bool CPVRClients::StopClient(AddonPtr client, bool bRestart)
+{
+  int iId = GetClientId(client);
+  PVR_CLIENT mappedClient;
+  if (GetConnectedClient(iId, mappedClient))
+  {
+    g_PVRManager.StopUpdateThreads();
+    if (bRestart)
+      mappedClient->ReCreate();
+    else
+      mappedClient->Destroy();
+    g_PVRManager.StartUpdateThreads();
+
+    return true;
+  }
+
+  return false;
+}
+
+int CPVRClients::ConnectedClientAmount(void) const
+{
+  int iReturn(0);
+  CSingleLock lock(m_critSection);
+
+  for (PVR_CLIENTMAP_CITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+    if (itr->second->ReadyToUse())
+      ++iReturn;
+
+  return iReturn;
+}
+
+bool CPVRClients::HasConnectedClients(void) const
+{
+  CSingleLock lock(m_critSection);
+
+  for (PVR_CLIENTMAP_CITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+    if (itr->second->ReadyToUse())
+      return true;
+
+  return false;
+}
+
+bool CPVRClients::GetClientName(int iClientId, CStdString &strName) const
+{
+  bool bReturn(false);
+  PVR_CLIENT client;
+  if ((bReturn = GetConnectedClient(iClientId, client)) == true)
+    strName = client->GetFriendlyName();
+
+  return bReturn;
+}
+
+int CPVRClients::GetConnectedClients(PVR_CLIENTMAP &clients) const
+{
+  int iReturn(0);
+  CSingleLock lock(m_critSection);
+
+  for (PVR_CLIENTMAP_CITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+  {
+    if (itr->second->ReadyToUse())
+    {
+      clients.insert(std::make_pair(itr->second->GetID(), itr->second));
+      ++iReturn;
+    }
+  }
+
+  return iReturn;
+}
+
+int CPVRClients::GetPlayingClientID(void) const
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_bIsPlayingLiveTV || m_bIsPlayingRecording)
+    return m_playingClientId;
+  return -EINVAL;
+}
+
+const CStdString CPVRClients::GetPlayingClientName(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_strPlayingClientName;
+}
+
+CStdString CPVRClients::GetStreamURL(const CPVRChannel &tag)
+{
+  CStdString strReturn;
+  PVR_CLIENT client;
+  if (GetConnectedClient(tag.ClientID(), client))
+    strReturn = client->GetLiveStreamURL(tag);
+  else
+    CLog::Log(LOGERROR, "PVR - %s - cannot find client %d",__FUNCTION__, tag.ClientID());
+
+  return strReturn;
+}
+
+bool CPVRClients::SwitchChannel(const CPVRChannel &channel)
+{
+  {
+    CSingleLock lock(m_critSection);
+    if (m_bIsSwitchingChannels)
+    {
+      CLog::Log(LOGDEBUG, "PVRClients - %s - can't switch to channel '%s'. waiting for the previous switch to complete", __FUNCTION__, channel.ChannelName().c_str());
+      return false;
+    }
+    m_bIsSwitchingChannels = true;
+  }
+
+  bool bSwitchSuccessful(false);
+  CPVRChannelPtr currentChannel;
+  if (// no channel is currently playing
+      !GetPlayingChannel(currentChannel) ||
+      // different backend
+      currentChannel->ClientID() != channel.ClientID() ||
+      // different type
+      currentChannel->IsRadio() != channel.IsRadio() ||
+      // stream URL should always be opened as a new file
+      !channel.StreamURL().IsEmpty() || !currentChannel->StreamURL().IsEmpty())
+  {
+    CloseStream();
+    if (channel.StreamURL().IsEmpty())
+    {
+      bSwitchSuccessful = OpenStream(channel, true);
+    }
+    else
+    {
+      CFileItem m_currentFile(channel);
+      CApplicationMessenger::Get().PlayFile(m_currentFile, false);
+      bSwitchSuccessful = true;
+    }
+  }
+  // same channel
+  else if (currentChannel.get() && *currentChannel == channel)
+  {
+    bSwitchSuccessful = true;
+  }
+  else
+  {
+    PVR_CLIENT client;
+    if (GetConnectedClient(channel.ClientID(), client))
+      bSwitchSuccessful = client->SwitchChannel(channel);
+  }
+
+  {
+    CSingleLock lock(m_critSection);
+    m_bIsSwitchingChannels = false;
+    if (bSwitchSuccessful)
+      m_bIsValidChannelSettings = false;
+  }
+
+  if (!bSwitchSuccessful)
+    CLog::Log(LOGERROR, "PVR - %s - cannot switch to channel '%s' on client '%d'",__FUNCTION__, channel.ChannelName().c_str(), channel.ClientID());
+
+  return bSwitchSuccessful;
+}
+
+bool CPVRClients::GetPlayingChannel(CPVRChannelPtr &channel) const
+{
+  PVR_CLIENT client;
+  if (GetPlayingClient(client))
+    return client->GetPlayingChannel(channel);
+  return false;
+}
+
+bool CPVRClients::GetPlayingRecording(CPVRRecording &recording) const
+{
+  PVR_CLIENT client;
+  if (GetPlayingClient(client))
+    return client->GetPlayingRecording(recording);
+  return false;
+}
+
+bool CPVRClients::HasTimerSupport(int iClientId)
+{
+  CSingleLock lock(m_critSection);
+
+  return IsConnectedClient(iClientId) && m_clientMap[iClientId]->SupportsTimers();
+}
+
+PVR_ERROR CPVRClients::GetTimers(CPVRTimers *timers)
+{
+  PVR_ERROR error(PVR_ERROR_NO_ERROR);
+  PVR_CLIENTMAP clients;
+  GetConnectedClients(clients);
+
+  /* get the timer list from each client */
+  for (PVR_CLIENTMAP_ITR itrClients = clients.begin(); itrClients != clients.end(); itrClients++)
+  {
+    PVR_ERROR currentError = (*itrClients).second->GetTimers(timers);
+    if (currentError != PVR_ERROR_NOT_IMPLEMENTED &&
+        currentError != PVR_ERROR_NO_ERROR)
+    {
+      CLog::Log(LOGERROR, "PVR - %s - cannot get timers from client '%d': %s",__FUNCTION__, (*itrClients).first, CPVRClient::ToString(currentError));
+      error = currentError;
+    }
+  }
+
+  return error;
+}
+
+PVR_ERROR CPVRClients::AddTimer(const CPVRTimerInfoTag &timer)
+{
+  PVR_ERROR error(PVR_ERROR_UNKNOWN);
+
+  PVR_CLIENT client;
+  if (GetConnectedClient(timer.m_iClientId, client))
+    error = client->AddTimer(timer);
+
+  if (error != PVR_ERROR_NO_ERROR)
+    CLog::Log(LOGERROR, "PVR - %s - cannot add timer to client '%d': %s",__FUNCTION__, timer.m_iClientId, CPVRClient::ToString(error));
+
+  return error;
+}
+
+PVR_ERROR CPVRClients::UpdateTimer(const CPVRTimerInfoTag &timer)
+{
+  PVR_ERROR error(PVR_ERROR_UNKNOWN);
+
+  PVR_CLIENT client;
+  if (GetConnectedClient(timer.m_iClientId, client))
+    error = client->UpdateTimer(timer);
+
+  if (error != PVR_ERROR_NO_ERROR)
+    CLog::Log(LOGERROR, "PVR - %s - cannot update timer on client '%d': %s",__FUNCTION__, timer.m_iClientId, CPVRClient::ToString(error));
+
+  return error;
+}
+
+PVR_ERROR CPVRClients::DeleteTimer(const CPVRTimerInfoTag &timer, bool bForce)
+{
+  PVR_ERROR error(PVR_ERROR_UNKNOWN);
+  PVR_CLIENT client;
+
+  if (GetConnectedClient(timer.m_iClientId, client))
+    error = client->DeleteTimer(timer, bForce);
+
+  return error;
+}
+
+PVR_ERROR CPVRClients::RenameTimer(const CPVRTimerInfoTag &timer, const CStdString &strNewName)
+{
+  PVR_ERROR error(PVR_ERROR_UNKNOWN);
+
+  PVR_CLIENT client;
+  if (GetConnectedClient(timer.m_iClientId, client))
+    error = client->RenameTimer(timer, strNewName);
+
+  if (error != PVR_ERROR_NO_ERROR)
+    CLog::Log(LOGERROR, "PVR - %s - cannot rename timer on client '%d': %s",__FUNCTION__, timer.m_iClientId, CPVRClient::ToString(error));
+
+  return error;
+}
+
+PVR_ERROR CPVRClients::GetRecordings(CPVRRecordings *recordings)
+{
+  PVR_ERROR error(PVR_ERROR_NO_ERROR);
+  PVR_CLIENTMAP clients;
+  GetConnectedClients(clients);
+
+  for (PVR_CLIENTMAP_ITR itrClients = clients.begin(); itrClients != clients.end(); itrClients++)
+  {
+    PVR_ERROR currentError = (*itrClients).second->GetRecordings(recordings);
+    if (currentError != PVR_ERROR_NOT_IMPLEMENTED &&
+        currentError != PVR_ERROR_NO_ERROR)
+    {
+      CLog::Log(LOGERROR, "PVR - %s - cannot get recordings from client '%d': %s",__FUNCTION__, (*itrClients).first, CPVRClient::ToString(currentError));
+      error = currentError;
+    }
+  }
+
+  return error;
+}
+
+PVR_ERROR CPVRClients::RenameRecording(const CPVRRecording &recording)
+{
+  PVR_ERROR error(PVR_ERROR_UNKNOWN);
+
+  PVR_CLIENT client;
+  if (GetConnectedClient(recording.m_iClientId, client))
+    error = client->RenameRecording(recording);
+
+  if (error != PVR_ERROR_NO_ERROR)
+    CLog::Log(LOGERROR, "PVR - %s - cannot rename recording on client '%d': %s",__FUNCTION__, recording.m_iClientId, CPVRClient::ToString(error));
+
+  return error;
+}
+
+PVR_ERROR CPVRClients::DeleteRecording(const CPVRRecording &recording)
+{
+  PVR_ERROR error(PVR_ERROR_UNKNOWN);
+
+  PVR_CLIENT client;
+  if (GetConnectedClient(recording.m_iClientId, client))
+    error = client->DeleteRecording(recording);
+
+  if (error != PVR_ERROR_NO_ERROR)
+    CLog::Log(LOGERROR, "PVR - %s - cannot delete recording from client '%d': %s",__FUNCTION__, recording.m_iClientId, CPVRClient::ToString(error));
+
+  return error;
+}
+
+bool CPVRClients::SetRecordingLastPlayedPosition(const CPVRRecording &recording, int lastplayedposition, PVR_ERROR *error)
+{
+  *error = PVR_ERROR_UNKNOWN;
+  PVR_CLIENT client;
+  if (GetConnectedClient(recording.m_iClientId, client) && client->SupportsRecordings())
+    *error = client->SetRecordingLastPlayedPosition(recording, lastplayedposition);
+  else
+    CLog::Log(LOGERROR, "PVR - %s - client %d does not support recordings",__FUNCTION__, recording.m_iClientId);
+
+  return *error == PVR_ERROR_NO_ERROR;
+}
+
+int CPVRClients::GetRecordingLastPlayedPosition(const CPVRRecording &recording)
+{
+  int rc = 0;
+
+  PVR_CLIENT client;
+  if (GetConnectedClient(recording.m_iClientId, client) && client->SupportsRecordings())
+    rc = client->GetRecordingLastPlayedPosition(recording);
+  else
+    CLog::Log(LOGERROR, "PVR - %s - client %d does not support recordings",__FUNCTION__, recording.m_iClientId);
+
+  return rc;
+}
+
+bool CPVRClients::SetRecordingPlayCount(const CPVRRecording &recording, int count, PVR_ERROR *error)
+{
+  *error = PVR_ERROR_UNKNOWN;
+  PVR_CLIENT client;
+  if (GetConnectedClient(recording.m_iClientId, client) && client->SupportsRecordingPlayCount())
+    *error = client->SetRecordingPlayCount(recording, count);
+  else
+    CLog::Log(LOGERROR, "PVR - %s - client %d does not support setting recording's play count",__FUNCTION__, recording.m_iClientId);
+
+  return *error == PVR_ERROR_NO_ERROR;
+}
+
+bool CPVRClients::IsRecordingOnPlayingChannel(void) const
+{
+  CPVRChannelPtr currentChannel;
+  return GetPlayingChannel(currentChannel) &&
+      currentChannel->IsRecording();
+}
+
+bool CPVRClients::CanRecordInstantly(void)
+{
+  CPVRChannelPtr currentChannel;
+  return GetPlayingChannel(currentChannel) &&
+      currentChannel->CanRecord();
+}
+
+PVR_ERROR CPVRClients::GetEPGForChannel(const CPVRChannel &channel, CEpg *epg, time_t start, time_t end)
+{
+  PVR_ERROR error(PVR_ERROR_UNKNOWN);
+  PVR_CLIENT client;
+  if (GetConnectedClient(channel.ClientID(), client))
+    error = client->GetEPGForChannel(channel, epg, start, end);
+
+  if (error != PVR_ERROR_NO_ERROR)
+    CLog::Log(LOGERROR, "PVR - %s - cannot get EPG for channel '%s' from client '%d': %s",__FUNCTION__, channel.ChannelName().c_str(), channel.ClientID(), CPVRClient::ToString(error));
+
+  return error;
+}
+
+PVR_ERROR CPVRClients::GetChannels(CPVRChannelGroupInternal *group)
+{
+  PVR_ERROR error(PVR_ERROR_NO_ERROR);
+  PVR_CLIENTMAP clients;
+  GetConnectedClients(clients);
+
+  /* get the channel list from each client */
+  for (PVR_CLIENTMAP_ITR itrClients = clients.begin(); itrClients != clients.end(); itrClients++)
+  {
+    PVR_ERROR currentError = (*itrClients).second->GetChannels(*group, group->IsRadio());
+    if (currentError != PVR_ERROR_NOT_IMPLEMENTED &&
+        currentError != PVR_ERROR_NO_ERROR)
+    {
+      error = currentError;
+      CLog::Log(LOGERROR, "PVR - %s - cannot get channels from client '%d': %s",__FUNCTION__, (*itrClients).first, CPVRClient::ToString(error));
+    }
+  }
+
+  return error;
+}
+
+PVR_ERROR CPVRClients::GetChannelGroups(CPVRChannelGroups *groups)
+{
+  PVR_ERROR error(PVR_ERROR_NO_ERROR);
+  PVR_CLIENTMAP clients;
+  GetConnectedClients(clients);
+
+  for (PVR_CLIENTMAP_ITR itrClients = clients.begin(); itrClients != clients.end(); itrClients++)
+  {
+    PVR_ERROR currentError = (*itrClients).second->GetChannelGroups(groups);
+    if (currentError != PVR_ERROR_NOT_IMPLEMENTED &&
+        currentError != PVR_ERROR_NO_ERROR)
+    {
+      error = currentError;
+      CLog::Log(LOGERROR, "PVR - %s - cannot get groups from client '%d': %s",__FUNCTION__, (*itrClients).first, CPVRClient::ToString(error));
+    }
+  }
+
+  return error;
+}
+
+PVR_ERROR CPVRClients::GetChannelGroupMembers(CPVRChannelGroup *group)
+{
+  PVR_ERROR error(PVR_ERROR_NO_ERROR);
+  PVR_CLIENTMAP clients;
+  GetConnectedClients(clients);
+
+  /* get the member list from each client */
+  for (PVR_CLIENTMAP_ITR itrClients = clients.begin(); itrClients != clients.end(); itrClients++)
+  {
+    PVR_ERROR currentError = (*itrClients).second->GetChannelGroupMembers(group);
+    if (currentError != PVR_ERROR_NOT_IMPLEMENTED &&
+        currentError != PVR_ERROR_NO_ERROR)
+    {
+      error = currentError;
+      CLog::Log(LOGERROR, "PVR - %s - cannot get group members from client '%d': %s",__FUNCTION__, (*itrClients).first, CPVRClient::ToString(error));
+    }
+  }
+
+  return error;
+}
+
+bool CPVRClients::HasMenuHooks(int iClientID)
+{
+  if (iClientID < 0)
+    iClientID = GetPlayingClientID();
+
+  PVR_CLIENT client;
+  return (GetConnectedClient(iClientID, client) &&
+      client->HaveMenuHooks());
+}
+
+bool CPVRClients::GetMenuHooks(int iClientID, PVR_MENUHOOKS *hooks)
+{
+  bool bReturn(false);
+
+  if (iClientID < 0)
+    iClientID = GetPlayingClientID();
+
+  PVR_CLIENT client;
+  if (GetConnectedClient(iClientID, client) && client->HaveMenuHooks())
+  {
+    hooks = client->GetMenuHooks();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+void CPVRClients::ProcessMenuHooks(int iClientID)
+{
+  PVR_MENUHOOKS *hooks = NULL;
+
+  if (iClientID < 0)
+    iClientID = GetPlayingClientID();
+
+  PVR_CLIENT client;
+  if (GetConnectedClient(iClientID, client) && client->HaveMenuHooks())
+  {
+    hooks = client->GetMenuHooks();
+    std::vector<int> hookIDs;
+
+    CGUIDialogSelect* pDialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+    pDialog->Reset();
+    pDialog->SetHeading(19196);
+    for (unsigned int i = 0; i < hooks->size(); i++)
+      pDialog->Add(client->GetString(hooks->at(i).iLocalizedStringId));
+    pDialog->DoModal();
+
+    int selection = pDialog->GetSelectedLabel();
+    if (selection >= 0)
+      client->CallMenuHook(hooks->at(selection));
+  }
+}
+
+bool CPVRClients::IsRunningChannelScan(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bChannelScanRunning;
+}
+
+vector<PVR_CLIENT> CPVRClients::GetClientsSupportingChannelScan(void) const
+{
+  vector<PVR_CLIENT> possibleScanClients;
+  CSingleLock lock(m_critSection);
+
+  /* get clients that support channel scanning */
+  for (PVR_CLIENTMAP_CITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+  {
+    if (itr->second->ReadyToUse() && itr->second->SupportsChannelScan())
+      possibleScanClients.push_back(itr->second);
+  }
+
+  return possibleScanClients;
+}
+
+void CPVRClients::StartChannelScan(void)
+{
+  PVR_CLIENT scanClient;
+  CSingleLock lock(m_critSection);
+  vector<PVR_CLIENT> possibleScanClients = GetClientsSupportingChannelScan();
+  m_bChannelScanRunning = true;
+
+  /* multiple clients found */
+  if (possibleScanClients.size() > 1)
+  {
+    CGUIDialogSelect* pDialog= (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+
+    pDialog->Reset();
+    pDialog->SetHeading(19119);
+
+    for (unsigned int i = 0; i < possibleScanClients.size(); i++)
+      pDialog->Add(possibleScanClients[i]->GetFriendlyName());
+
+    pDialog->DoModal();
+
+    int selection = pDialog->GetSelectedLabel();
+    if (selection >= 0)
+      scanClient = possibleScanClients[selection];
+  }
+  /* one client found */
+  else if (possibleScanClients.size() == 1)
+  {
+    scanClient = possibleScanClients[0];
+  }
+  /* no clients found */
+  else if (!scanClient)
+  {
+    CGUIDialogOK::ShowAndGetInput(19033,0,19192,0);
+    return;
+  }
+
+  /* start the channel scan */
+  CLog::Log(LOGNOTICE,"PVR - %s - starting to scan for channels on client %s",
+      __FUNCTION__, scanClient->GetFriendlyName().c_str());
+  long perfCnt = XbmcThreads::SystemClockMillis();
+
+  /* stop the supervisor thread */
+  g_PVRManager.StopUpdateThreads();
+
+  /* do the scan */
+  if (scanClient->StartChannelScan() != PVR_ERROR_NO_ERROR)
+    /* an error occured */
+    CGUIDialogOK::ShowAndGetInput(19111,0,19193,0);
+
+  /* restart the supervisor thread */
+  g_PVRManager.StartUpdateThreads();
+
+  CLog::Log(LOGNOTICE, "PVRManager - %s - channel scan finished after %li.%li seconds",
+      __FUNCTION__, (XbmcThreads::SystemClockMillis()-perfCnt)/1000, (XbmcThreads::SystemClockMillis()-perfCnt)%1000);
+  m_bChannelScanRunning = false;
+}
+
+bool CPVRClients::IsKnownClient(const AddonPtr client) const
+{
+  // database IDs start at 1
+  return GetClientId(client) > 0;
+}
+
+int CPVRClients::RegisterClient(AddonPtr client)
+{
+  int iClientId(-1);
+  if (!client->Enabled())
+    return -1;
+
+  CLog::Log(LOGDEBUG, "%s - registering add-on '%s'", __FUNCTION__, client->Name().c_str());
+
+  CPVRDatabase *database = GetPVRDatabase();
+  if (!database)
+    return -1;
+
+  // check whether we already know this client
+  iClientId = database->GetClientId(client->ID());
+
+  // try to register the new client in the db
+  if (iClientId < 0 && (iClientId = database->Persist(client)) < 0)
+  {
+    CLog::Log(LOGERROR, "PVR - %s - can't add client '%s' to the database", __FUNCTION__, client->Name().c_str());
+    return -1;
+  }
+
+  PVR_CLIENT addon;
+  // load and initialise the client libraries
+  {
+    CSingleLock lock(m_critSection);
+    PVR_CLIENTMAP_ITR existingClient = m_clientMap.find(iClientId);
+    if (existingClient != m_clientMap.end())
+    {
+      // return existing client
+      addon = existingClient->second;
+    }
+    else
+    {
+      // create a new client instance
+      addon = boost::dynamic_pointer_cast<CPVRClient>(client);
+      m_clientMap.insert(std::make_pair(iClientId, addon));
+    }
+  }
+
+  if (iClientId < 0)
+    CLog::Log(LOGERROR, "PVR - %s - can't register add-on '%s'", __FUNCTION__, client->Name().c_str());
+
+  return iClientId;
+}
+
+bool CPVRClients::UpdateAndInitialiseClients(bool bInitialiseAllClients /* = false */)
+{
+  bool bReturn(true);
+  ADDON::VECADDONS map;
+  ADDON::VECADDONS disableAddons;
+  {
+    CSingleLock lock(m_critSection);
+    map = m_addons;
+  }
+
+  if (map.size() == 0)
+    return false;
+
+  for (unsigned iClientPtr = 0; iClientPtr < map.size(); iClientPtr++)
+  {
+    const AddonPtr clientAddon = map.at(iClientPtr);
+    bool bEnabled = clientAddon->Enabled() &&
+        !m_addonDb.IsAddonDisabled(clientAddon->ID());
+
+    if (!bEnabled && IsKnownClient(clientAddon))
+    {
+      /* stop the client and remove it from the db */
+      StopClient(clientAddon, false);
+    }
+    else if (bEnabled && (bInitialiseAllClients || !IsKnownClient(clientAddon) || !IsConnectedClient(clientAddon)))
+    {
+      bool bDisabled(false);
+
+      // register the add-on in the pvr db, and create the CPVRClient instance
+      int iClientId = RegisterClient(clientAddon);
+      if (iClientId < 0)
+      {
+        // failed to register or create the add-on, disable it
+        CLog::Log(LOGWARNING, "%s - failed to register add-on %s, disabling it", __FUNCTION__, clientAddon->Name().c_str());
+        disableAddons.push_back(clientAddon);
+        bDisabled = true;
+      }
+      else
+      {
+        PVR_CLIENT addon;
+        if (!GetClient(iClientId, addon))
+        {
+          CLog::Log(LOGWARNING, "%s - failed to find add-on %s, disabling it", __FUNCTION__, clientAddon->Name().c_str());
+          disableAddons.push_back(clientAddon);
+          bDisabled = true;
+        }
+        // re-check the enabled status. newly installed clients get disabled when they're added to the db
+        else if (addon->Enabled() && !addon->Create(iClientId))
+        {
+          CLog::Log(LOGWARNING, "%s - failed to create add-on %s", __FUNCTION__, clientAddon->Name().c_str());
+          if (!addon.get() || !addon->DllLoaded())
+          {
+            // failed to load the dll of this add-on, disable it
+            CLog::Log(LOGWARNING, "%s - failed to load the dll for add-on %s, disabling it", __FUNCTION__, clientAddon->Name().c_str());
+            disableAddons.push_back(clientAddon);
+            bDisabled = true;
+          }
+        }
+      }
+
+      if (bDisabled && (g_PVRManager.GetState() == ManagerStateStarted || g_PVRManager.GetState() == ManagerStateStarting))
+        CGUIDialogOK::ShowAndGetInput(24070, 24071, 16029, 0);
+    }
+  }
+
+  // disable add-ons that failed to initialise
+  if (disableAddons.size() > 0)
+  {
+    CSingleLock lock(m_critSection);
+    for (ADDON::VECADDONS::iterator it = disableAddons.begin(); it != disableAddons.end(); it++)
+    {
+      // disable in the add-on db
+      m_addonDb.DisableAddon((*it)->ID(), true);
+
+      // remove from the pvr add-on list
+      ADDON::VECADDONS::iterator addonPtr = std::find(m_addons.begin(), m_addons.end(), *it);
+      if (addonPtr != m_addons.end())
+        m_addons.erase(addonPtr);
+    }
+  }
+
+  return bReturn;
+}
+
+void CPVRClients::Process(void)
+{
+  bool bCheckedEnabledClientsOnStartup(false);
+
+  CAddonMgr::Get().RegisterAddonMgrCallback(ADDON_PVRDLL, this);
+  CAddonMgr::Get().RegisterObserver(this);
+
+  UpdateAddons();
+
+  while (!g_application.m_bStop && !m_bStop)
+  {
+    UpdateAndInitialiseClients();
+
+    if (!bCheckedEnabledClientsOnStartup)
+    {
+      bCheckedEnabledClientsOnStartup = true;
+      if (!HasEnabledClients() && !m_bNoAddonWarningDisplayed)
+        ShowDialogNoClientsEnabled();
+    }
+
+    PVR_CLIENT client;
+    if (GetPlayingClient(client))
+      client->UpdateCharInfoSignalStatus();
+    Sleep(1000);
+  }
+}
+
+void CPVRClients::ShowDialogNoClientsEnabled(void)
+{
+  if (g_PVRManager.GetState() != ManagerStateStarted && !g_PVRManager.GetState() == ManagerStateStarting)
+    return;
+
+  CGUIDialogOK::ShowAndGetInput(19240, 19241, 19242, 19243);
+
+  vector<CStdString> params;
+  params.push_back("addons://disabled/xbmc.pvrclient");
+  params.push_back("return");
+  g_windowManager.ActivateWindow(WINDOW_ADDON_BROWSER, params);
+}
+
+void CPVRClients::SaveCurrentChannelSettings(void)
+{
+  CPVRChannelPtr channel;
+  {
+    CSingleLock lock(m_critSection);
+    if (!GetPlayingChannel(channel) || !m_bIsValidChannelSettings)
+      return;
+  }
+
+  CPVRDatabase *database = GetPVRDatabase();
+  if (!database)
+    return;
+
+  if (g_settings.m_currentVideoSettings != g_settings.m_defaultVideoSettings)
+  {
+    CLog::Log(LOGDEBUG, "PVR - %s - persisting custom channel settings for channel '%s'",
+        __FUNCTION__, channel->ChannelName().c_str());
+    database->PersistChannelSettings(*channel, g_settings.m_currentVideoSettings);
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "PVR - %s - no custom channel settings for channel '%s'",
+        __FUNCTION__, channel->ChannelName().c_str());
+    database->DeleteChannelSettings(*channel);
+  }
+}
+
+void CPVRClients::LoadCurrentChannelSettings(void)
+{
+  CPVRChannelPtr channel;
+  {
+    CSingleLock lock(m_critSection);
+    if (!GetPlayingChannel(channel))
+      return;
+  }
+
+  CPVRDatabase *database = GetPVRDatabase();
+  if (!database)
+    return;
+
+  if (g_application.m_pPlayer)
+  {
+    /* set the default settings first */
+    CVideoSettings loadedChannelSettings = g_settings.m_defaultVideoSettings;
+
+    /* try to load the settings from the database */
+    database->GetChannelSettings(*channel, loadedChannelSettings);
+
+    g_settings.m_currentVideoSettings = g_settings.m_defaultVideoSettings;
+    g_settings.m_currentVideoSettings.m_Brightness          = loadedChannelSettings.m_Brightness;
+    g_settings.m_currentVideoSettings.m_Contrast            = loadedChannelSettings.m_Contrast;
+    g_settings.m_currentVideoSettings.m_Gamma               = loadedChannelSettings.m_Gamma;
+    g_settings.m_currentVideoSettings.m_Crop                = loadedChannelSettings.m_Crop;
+    g_settings.m_currentVideoSettings.m_CropLeft            = loadedChannelSettings.m_CropLeft;
+    g_settings.m_currentVideoSettings.m_CropRight           = loadedChannelSettings.m_CropRight;
+    g_settings.m_currentVideoSettings.m_CropTop             = loadedChannelSettings.m_CropTop;
+    g_settings.m_currentVideoSettings.m_CropBottom          = loadedChannelSettings.m_CropBottom;
+    g_settings.m_currentVideoSettings.m_CustomPixelRatio    = loadedChannelSettings.m_CustomPixelRatio;
+    g_settings.m_currentVideoSettings.m_CustomZoomAmount    = loadedChannelSettings.m_CustomZoomAmount;
+    g_settings.m_currentVideoSettings.m_CustomVerticalShift = loadedChannelSettings.m_CustomVerticalShift;
+    g_settings.m_currentVideoSettings.m_NoiseReduction      = loadedChannelSettings.m_NoiseReduction;
+    g_settings.m_currentVideoSettings.m_Sharpness           = loadedChannelSettings.m_Sharpness;
+    g_settings.m_currentVideoSettings.m_InterlaceMethod     = loadedChannelSettings.m_InterlaceMethod;
+    g_settings.m_currentVideoSettings.m_OutputToAllSpeakers = loadedChannelSettings.m_OutputToAllSpeakers;
+    g_settings.m_currentVideoSettings.m_AudioDelay          = loadedChannelSettings.m_AudioDelay;
+    g_settings.m_currentVideoSettings.m_AudioStream         = loadedChannelSettings.m_AudioStream;
+    g_settings.m_currentVideoSettings.m_SubtitleOn          = loadedChannelSettings.m_SubtitleOn;
+    g_settings.m_currentVideoSettings.m_SubtitleDelay       = loadedChannelSettings.m_SubtitleDelay;
+    g_settings.m_currentVideoSettings.m_CustomNonLinStretch = loadedChannelSettings.m_CustomNonLinStretch;
+    g_settings.m_currentVideoSettings.m_ScalingMethod       = loadedChannelSettings.m_ScalingMethod;
+    g_settings.m_currentVideoSettings.m_PostProcess         = loadedChannelSettings.m_PostProcess;
+    g_settings.m_currentVideoSettings.m_DeinterlaceMode     = loadedChannelSettings.m_DeinterlaceMode;
+
+    /* only change the view mode if it's different */
+    if (g_settings.m_currentVideoSettings.m_ViewMode != loadedChannelSettings.m_ViewMode)
+    {
+      g_settings.m_currentVideoSettings.m_ViewMode = loadedChannelSettings.m_ViewMode;
+
+      g_renderManager.SetViewMode(g_settings.m_currentVideoSettings.m_ViewMode);
+      g_settings.m_currentVideoSettings.m_CustomZoomAmount = g_settings.m_fZoomAmount;
+      g_settings.m_currentVideoSettings.m_CustomPixelRatio = g_settings.m_fPixelRatio;
+    }
+
+    /* only change the subtitle stream, if it's different */
+    if (g_settings.m_currentVideoSettings.m_SubtitleStream != loadedChannelSettings.m_SubtitleStream)
+    {
+      g_settings.m_currentVideoSettings.m_SubtitleStream = loadedChannelSettings.m_SubtitleStream;
+
+      g_application.m_pPlayer->SetSubtitle(g_settings.m_currentVideoSettings.m_SubtitleStream);
+    }
+
+    /* only change the audio stream if it's different */
+    if (g_application.m_pPlayer->GetAudioStream() != g_settings.m_currentVideoSettings.m_AudioStream)
+      g_application.m_pPlayer->SetAudioStream(g_settings.m_currentVideoSettings.m_AudioStream);
+
+    g_application.m_pPlayer->SetAVDelay(g_settings.m_currentVideoSettings.m_AudioDelay);
+    g_application.m_pPlayer->SetDynamicRangeCompression((long)(g_settings.m_currentVideoSettings.m_VolumeAmplification * 100));
+    g_application.m_pPlayer->SetSubtitleVisible(g_settings.m_currentVideoSettings.m_SubtitleOn);
+    g_application.m_pPlayer->SetSubTitleDelay(g_settings.m_currentVideoSettings.m_SubtitleDelay);
+
+    /* settings can be saved on next channel switch */
+    m_bIsValidChannelSettings = true;
+  }
+}
+
+bool CPVRClients::UpdateAddons(void)
+{
+  ADDON::VECADDONS addons;
+  bool bReturn(CAddonMgr::Get().GetAddons(ADDON_PVRDLL, addons, true));
+
+  if (bReturn)
+  {
+    CSingleLock lock(m_critSection);
+    m_addons = addons;
+  }
+
+  if ((!bReturn || addons.size() == 0) && !m_bNoAddonWarningDisplayed &&
+      !CAddonMgr::Get().HasAddons(ADDON_PVRDLL, false) &&
+      (g_PVRManager.GetState() == ManagerStateStarted || g_PVRManager.GetState() == ManagerStateStarting))
+  {
+    // No PVR add-ons could be found
+    // You need a tuner, backend software, and an add-on for the backend to be able to use PVR.
+    // Please visit xbmc.org/PVR to learn more.
+    m_bNoAddonWarningDisplayed = true;
+    CGUIDialogOK::ShowAndGetInput(19271, 19272, 19273, 19274);
+  }
+
+  return bReturn;
+}
+
+void CPVRClients::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  if (msg == ObservableMessageAddons)
+  {
+    UpdateAddons();
+    UpdateAndInitialiseClients();
+  }
+}
+
+bool CPVRClients::GetClient(const CStdString &strId, ADDON::AddonPtr &addon) const
+{
+  CSingleLock lock(m_critSection);
+  for (PVR_CLIENTMAP_CITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+  {
+    if (itr->second->ID() == strId)
+    {
+      addon = itr->second;
+      return true;
+    }
+  }
+  return false;
+}
+
+bool CPVRClients::SupportsChannelGroups(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->SupportsChannelGroups();
+}
+
+bool CPVRClients::SupportsChannelScan(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->SupportsChannelScan();
+}
+
+bool CPVRClients::SupportsEPG(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->SupportsEPG();
+}
+
+bool CPVRClients::SupportsLastPlayedPosition(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->SupportsLastPlayedPosition();
+}
+
+bool CPVRClients::SupportsRadio(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->SupportsRadio();
+}
+
+bool CPVRClients::SupportsRecordings(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->SupportsRecordings();
+}
+
+bool CPVRClients::SupportsRecordingFolders(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->SupportsRecordingFolders();
+}
+
+bool CPVRClients::SupportsRecordingPlayCount(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->SupportsRecordingPlayCount();
+}
+
+bool CPVRClients::SupportsTimers(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->SupportsTimers();
+}
+
+bool CPVRClients::SupportsTV(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->SupportsTV();
+}
+
+bool CPVRClients::HandlesDemuxing(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->HandlesDemuxing();
+}
+
+bool CPVRClients::HandlesInputStream(int iClientId) const
+{
+  PVR_CLIENT client;
+  return GetConnectedClient(iClientId, client) && client->HandlesInputStream();
+}
+
+bool CPVRClients::GetPlayingClient(PVR_CLIENT &client) const
+{
+  return GetConnectedClient(GetPlayingClientID(), client);
+}
+
+bool CPVRClients::OpenStream(const CPVRChannel &tag, bool bIsSwitchingChannel)
+{
+  bool bReturn(false);
+  CloseStream();
+
+  /* try to open the stream on the client */
+  PVR_CLIENT client;
+  if (GetConnectedClient(tag.ClientID(), client) &&
+      client->OpenStream(tag, bIsSwitchingChannel))
+  {
+    CSingleLock lock(m_critSection);
+    m_playingClientId = tag.ClientID();
+    m_bIsPlayingLiveTV = true;
+
+    if (tag.ClientID() == PVR_VIRTUAL_CLIENT_ID)
+      m_strPlayingClientName = g_localizeStrings.Get(19209);
+    else if (!tag.IsVirtual() && client.get())
+      m_strPlayingClientName = client->GetFriendlyName();
+    else
+      m_strPlayingClientName = g_localizeStrings.Get(13205);
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CPVRClients::OpenStream(const CPVRRecording &tag)
+{
+  bool bReturn(false);
+  CloseStream();
+
+  /* try to open the recording stream on the client */
+  PVR_CLIENT client;
+  if (GetConnectedClient(tag.m_iClientId, client) &&
+      client->OpenStream(tag))
+  {
+    CSingleLock lock(m_critSection);
+    m_playingClientId = tag.m_iClientId;
+    m_bIsPlayingRecording = true;
+    m_strPlayingClientName = client->GetFriendlyName();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+void CPVRClients::CloseStream(void)
+{
+  PVR_CLIENT playingClient;
+  if (GetPlayingClient(playingClient))
+    playingClient->CloseStream();
+
+  CSingleLock lock(m_critSection);
+  m_bIsPlayingLiveTV     = false;
+  m_bIsPlayingRecording  = false;
+  m_playingClientId      = PVR_INVALID_CLIENT_ID;
+  m_strPlayingClientName = "";
+}
+
+int CPVRClients::ReadStream(void* lpBuf, int64_t uiBufSize)
+{
+  PVR_CLIENT client;
+  if (GetPlayingClient(client))
+    return client->ReadStream(lpBuf, uiBufSize);
+  return -EINVAL;
+}
+
+int64_t CPVRClients::GetStreamLength(void)
+{
+  PVR_CLIENT client;
+  if (GetPlayingClient(client))
+    return client->GetStreamLength();
+  return -EINVAL;
+}
+
+int64_t CPVRClients::SeekStream(int64_t iFilePosition, int iWhence/* = SEEK_SET*/)
+{
+  PVR_CLIENT client;
+  if (GetPlayingClient(client))
+    return client->SeekStream(iFilePosition, iWhence);
+  return -EINVAL;
+}
+
+int64_t CPVRClients::GetStreamPosition(void)
+{
+  PVR_CLIENT client;
+  if (GetPlayingClient(client))
+    return client->GetStreamPosition();
+  return -EINVAL;
+}
+
+CStdString CPVRClients::GetCurrentInputFormat(void) const
+{
+  CStdString strReturn;
+  CPVRChannelPtr currentChannel;
+  if (GetPlayingChannel(currentChannel))
+    strReturn = currentChannel->InputFormat();
+
+  return strReturn;
+}
+
+PVR_STREAM_PROPERTIES CPVRClients::GetCurrentStreamProperties(void)
+{
+  PVR_STREAM_PROPERTIES props;
+  PVR_CLIENT client;
+  if (GetPlayingClient(client))
+    client->GetStreamProperties(&props);
+
+  return props;
+}
+
+bool CPVRClients::IsPlaying(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bIsPlayingRecording || m_bIsPlayingLiveTV;
+}
+
+bool CPVRClients::IsPlayingRadio(void) const
+{
+  PVR_CLIENT client;
+  if (GetPlayingClient(client))
+    return client->IsPlayingLiveRadio();
+  return false;
+}
+
+bool CPVRClients::IsPlayingTV(void) const
+{
+  PVR_CLIENT client;
+  if (GetPlayingClient(client))
+    return client->IsPlayingLiveTV();
+  return false;
+}
+
+bool CPVRClients::IsPlayingRecording(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bIsPlayingRecording;
+}
+
+bool CPVRClients::IsReadingLiveStream(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bIsPlayingLiveTV;
+}
+
+bool CPVRClients::IsEncrypted(void) const
+{
+  PVR_CLIENT client;
+  if (GetPlayingClient(client))
+    return client->IsPlayingEncryptedChannel();
+  return false;
+}
diff --git a/xbmc/pvr/channels/PVRChannel.cpp b/xbmc/pvr/channels/PVRChannel.cpp
new file mode 100644
index 0000000..097891a
--- /dev/null
+++ b/xbmc/pvr/channels/PVRChannel.cpp
@@ -0,0 +1,866 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "FileItem.h"
+#include "guilib/LocalizeStrings.h"
+#include "utils/log.h"
+#include "Util.h"
+#include "filesystem/File.h"
+#include "settings/GUISettings.h"
+#include "utils/StringUtils.h"
+#include "threads/SingleLock.h"
+
+#include "PVRChannelGroupsContainer.h"
+#include "epg/EpgContainer.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/PVRDatabase.h"
+#include "pvr/PVRManager.h"
+#include "pvr/addons/PVRClients.h"
+
+using namespace PVR;
+using namespace EPG;
+
+bool CPVRChannel::operator==(const CPVRChannel &right) const
+{
+  return (m_bIsRadio  == right.m_bIsRadio &&
+          m_iUniqueId == right.m_iUniqueId &&
+          m_iClientId == right.m_iClientId);
+}
+
+bool CPVRChannel::operator!=(const CPVRChannel &right) const
+{
+  return !(*this == right);
+}
+
+CPVRChannel::CPVRChannel(bool bRadio /* = false */)
+{
+  m_iChannelId              = -1;
+  m_bIsRadio                = bRadio;
+  m_bIsHidden               = false;
+  m_bIsUserSetIcon          = false;
+  m_bIsLocked               = false;
+  m_strIconPath             = StringUtils::EmptyString;
+  m_strChannelName          = StringUtils::EmptyString;
+  m_bIsVirtual              = false;
+  m_iLastWatched            = 0;
+  m_bChanged                = false;
+  m_iCachedChannelNumber    = 0;
+
+  m_iEpgId                  = -1;
+  m_bEPGCreated             = false;
+  m_bEPGEnabled             = true;
+  m_strEPGScraper           = "client";
+
+  m_iUniqueId               = -1;
+  m_iClientId               = -1;
+  m_iClientChannelNumber    = -1;
+  m_strClientChannelName    = StringUtils::EmptyString;
+  m_strInputFormat          = StringUtils::EmptyString;
+  m_strStreamURL            = StringUtils::EmptyString;
+  m_strFileNameAndPath      = StringUtils::EmptyString;
+  m_iClientEncryptionSystem = -1;
+}
+
+CPVRChannel::CPVRChannel(const PVR_CHANNEL &channel, unsigned int iClientId)
+{
+  m_iChannelId              = -1;
+  m_bIsRadio                = channel.bIsRadio;
+  m_bIsHidden               = channel.bIsHidden;
+  m_bIsUserSetIcon          = false;
+  m_bIsLocked               = false;
+  m_strIconPath             = channel.strIconPath;
+  m_strChannelName          = channel.strChannelName;
+  m_iUniqueId               = channel.iUniqueId;
+  m_iClientChannelNumber    = channel.iChannelNumber;
+  m_strClientChannelName    = channel.strChannelName;
+  m_strInputFormat          = channel.strInputFormat;
+  m_strStreamURL            = channel.strStreamURL;
+  m_iClientEncryptionSystem = channel.iEncryptionSystem;
+  m_iCachedChannelNumber    = 0;
+  m_iClientId               = iClientId;
+  m_strFileNameAndPath      = StringUtils::EmptyString;
+  m_bIsVirtual              = false;
+  m_iLastWatched            = 0;
+  m_bEPGEnabled             = true;
+  m_strEPGScraper           = "client";
+  m_iEpgId                  = -1;
+  m_bEPGCreated             = false;
+  m_bChanged                = false;
+
+  if (m_strChannelName.IsEmpty())
+    m_strChannelName.Format("%s %d", g_localizeStrings.Get(19029), m_iUniqueId);
+
+  UpdateEncryptionName();
+}
+
+CPVRChannel::CPVRChannel(const CPVRChannel &channel)
+{
+  *this = channel;
+}
+
+CPVRChannel &CPVRChannel::operator=(const CPVRChannel &channel)
+{
+  m_iChannelId              = channel.m_iChannelId;
+  m_bIsRadio                = channel.m_bIsRadio;
+  m_bIsHidden               = channel.m_bIsHidden;
+  m_bIsUserSetIcon          = channel.m_bIsUserSetIcon;
+  m_bIsLocked               = channel.m_bIsLocked;
+  m_strIconPath             = channel.m_strIconPath;
+  m_strChannelName          = channel.m_strChannelName;
+  m_bIsVirtual              = channel.m_bIsVirtual;
+  m_iLastWatched            = channel.m_iLastWatched;
+  m_bEPGEnabled             = channel.m_bEPGEnabled;
+  m_strEPGScraper           = channel.m_strEPGScraper;
+  m_iUniqueId               = channel.m_iUniqueId;
+  m_iClientId               = channel.m_iClientId;
+  m_iClientChannelNumber    = channel.m_iClientChannelNumber;
+  m_strClientChannelName    = channel.m_strClientChannelName;
+  m_strInputFormat          = channel.m_strInputFormat;
+  m_strStreamURL            = channel.m_strStreamURL;
+  m_strFileNameAndPath      = channel.m_strFileNameAndPath;
+  m_iClientEncryptionSystem = channel.m_iClientEncryptionSystem;
+  m_iCachedChannelNumber    = channel.m_iCachedChannelNumber;
+  m_iEpgId                  = channel.m_iEpgId;
+  m_bEPGCreated             = channel.m_bEPGCreated;
+  m_bChanged                = channel.m_bChanged;
+
+  UpdateEncryptionName();
+
+  return *this;
+}
+
+/********** XBMC related channel methods **********/
+
+bool CPVRChannel::Delete(void)
+{
+  bool bReturn = false;
+  CPVRDatabase *database = GetPVRDatabase();
+  if (!database)
+    return bReturn;
+
+  /* delete the EPG table */
+  CEpg *epg = GetEPG();
+  if (epg)
+  {
+    CPVRChannelPtr empty;
+    epg->SetChannel(empty);
+    g_EpgContainer.DeleteEpg(*epg, true);
+    CSingleLock lock(m_critSection);
+    m_bEPGCreated = false;
+  }
+
+  bReturn = database->Delete(*this);
+  return bReturn;
+}
+
+CEpg *CPVRChannel::GetEPG(void) const
+{
+  int iEpgId(-1);
+  {
+    CSingleLock lock(m_critSection);
+    if (!m_bIsHidden && m_bEPGEnabled && m_iEpgId > 0)
+      iEpgId = m_iEpgId;
+  }
+
+  return iEpgId > 0 ? g_EpgContainer.GetById(iEpgId) : NULL;
+}
+
+bool CPVRChannel::UpdateFromClient(const CPVRChannel &channel)
+{
+  SetClientID(channel.ClientID());
+  SetClientChannelNumber(channel.ClientChannelNumber());
+  SetInputFormat(channel.InputFormat());
+  SetStreamURL(channel.StreamURL());
+  SetEncryptionSystem(channel.EncryptionSystem());
+  SetClientChannelName(channel.ClientChannelName());
+
+  CSingleLock lock(m_critSection);
+  if (m_strChannelName.IsEmpty())
+    SetChannelName(channel.ClientChannelName());
+  if (m_strIconPath.IsEmpty()||(!m_strIconPath.Equals(channel.IconPath()) && !IsUserSetIcon()))
+    SetIconPath(channel.IconPath());
+
+  return m_bChanged;
+}
+
+bool CPVRChannel::Persist(bool bQueueWrite /* = false */)
+{
+  {
+    // not changed
+    CSingleLock lock(m_critSection);
+    if (!m_bChanged && m_iChannelId > 0)
+      return true;
+  }
+
+  if (CPVRDatabase *database = GetPVRDatabase())
+  {
+    if (!bQueueWrite)
+    {
+      bool bReturn = database->Persist(*this, false);
+      CSingleLock lock(m_critSection);
+      m_bChanged = !bReturn;
+    }
+    else
+    {
+      return database->Persist(*this, true);
+    }
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetChannelID(int iChannelId)
+{
+  CSingleLock lock(m_critSection);
+  if (m_iChannelId != iChannelId)
+  {
+    /* update the id */
+    m_iChannelId = iChannelId;
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+int CPVRChannel::ChannelNumber(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iCachedChannelNumber;
+}
+
+bool CPVRChannel::SetHidden(bool bIsHidden)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_bIsHidden != bIsHidden)
+  {
+    /* update the hidden flag */
+    m_bIsHidden = bIsHidden;
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetLocked(bool bIsLocked)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_bIsLocked != bIsLocked)
+  {
+    /* update the locked flag */
+    m_bIsLocked = bIsLocked;
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::IsRecording(void) const
+{
+  return g_PVRTimers->IsRecordingOnChannel(*this);
+}
+
+bool CPVRChannel::SetIconPath(const CStdString &strIconPath, bool bIsUserSetIcon /* = false */)
+{
+  CSingleLock lock(m_critSection);
+
+  /* check if the path is valid */
+  if (!CFile::Exists(strIconPath) && !strIconPath.IsEmpty())
+    return false;
+
+  if (m_strIconPath != strIconPath)
+  {
+    /* update the path */
+    m_strIconPath.Format("%s", strIconPath);
+    SetChanged();
+    m_bChanged = true;
+
+    /* did the user change the icon? */
+    if (bIsUserSetIcon)
+      m_bIsUserSetIcon = !m_strIconPath.IsEmpty();
+	  
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetChannelName(const CStdString &strChannelName)
+{
+  CStdString strName(strChannelName);
+
+  if (strName.IsEmpty())
+    strName.Format(g_localizeStrings.Get(19085), ClientChannelNumber());
+
+  CSingleLock lock(m_critSection);
+  if (m_strChannelName != strName)
+  {
+    /* update the channel name */
+    m_strChannelName = strName;
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetVirtual(bool bIsVirtual)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_bIsVirtual != bIsVirtual)
+  {
+    /* update the virtual flag */
+    m_bIsVirtual = bIsVirtual;
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetLastWatched(time_t iLastWatched)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_iLastWatched != iLastWatched)
+  {
+    /* update last watched  */
+    m_iLastWatched = iLastWatched;
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::IsEmpty() const
+{
+  CSingleLock lock(m_critSection);
+  return (m_strFileNameAndPath.IsEmpty() ||
+          m_strStreamURL.IsEmpty());
+}
+
+/********** Client related channel methods **********/
+
+bool CPVRChannel::SetUniqueID(int iUniqueId)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_iUniqueId != iUniqueId)
+  {
+    /* update the unique ID */
+    m_iUniqueId = iUniqueId;
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetClientID(int iClientId)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_iClientId != iClientId)
+  {
+    /* update the client ID */
+    m_iClientId = iClientId;
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetClientChannelNumber(int iClientChannelNumber)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_iClientChannelNumber != iClientChannelNumber && iClientChannelNumber > 0)
+  {
+    /* update the client channel number */
+    m_iClientChannelNumber = iClientChannelNumber;
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetClientChannelName(const CStdString &strClientChannelName)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_strClientChannelName != strClientChannelName)
+  {
+    /* update the client channel name */
+    m_strClientChannelName.Format("%s", strClientChannelName);
+    SetChanged();
+    // this is not persisted, so don't update m_bChanged
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetInputFormat(const CStdString &strInputFormat)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_strInputFormat != strInputFormat)
+  {
+    /* update the input format */
+    m_strInputFormat.Format("%s", strInputFormat);
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetStreamURL(const CStdString &strStreamURL)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_strStreamURL != strStreamURL)
+  {
+    /* update the stream url */
+    m_strStreamURL.Format("%s", strStreamURL);
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+void CPVRChannel::UpdatePath(unsigned int iNewChannelNumber)
+{
+  CStdString strFileNameAndPath;
+  CSingleLock lock(m_critSection);
+  CPVRChannelGroupPtr group = g_PVRChannelGroups->GetGroupAll(m_bIsRadio);
+
+  if (group)
+  {
+    strFileNameAndPath.Format("pvr://channels/%s/%s/%i.pvr", (m_bIsRadio ? "radio" : "tv"), group->GroupName().c_str(), iNewChannelNumber);
+    if (m_strFileNameAndPath != strFileNameAndPath)
+    {
+      m_strFileNameAndPath = strFileNameAndPath;
+      SetChanged();
+    }
+  }
+}
+
+bool CPVRChannel::SetEncryptionSystem(int iClientEncryptionSystem)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_iClientEncryptionSystem != iClientEncryptionSystem)
+  {
+    /* update the client encryption system */
+    m_iClientEncryptionSystem = iClientEncryptionSystem;
+    UpdateEncryptionName();
+    SetChanged();
+    m_bChanged = true;
+
+    return true;
+  }
+
+  return false;
+}
+
+void CPVRChannel::UpdateEncryptionName(void)
+{
+  // http://www.dvb.org/index.php?id=174
+  // http://en.wikipedia.org/wiki/Conditional_access_system
+  CStdString strName;
+  CSingleLock lock(m_critSection);
+
+  if (     m_iClientEncryptionSystem == 0x0000)
+    strName = g_localizeStrings.Get(19013); /* Free To Air */
+  else if (m_iClientEncryptionSystem <  0x0000)
+    strName = g_localizeStrings.Get(13205); /* Unknown */
+  else
+  {
+    if (     m_iClientEncryptionSystem >= 0x0001 &&
+             m_iClientEncryptionSystem <= 0x009F)
+      strName = g_localizeStrings.Get(19014); /* Fixed */
+    else if (m_iClientEncryptionSystem >= 0x00A0 &&
+             m_iClientEncryptionSystem <= 0x00A1)
+      strName = g_localizeStrings.Get(338); /* Analog */
+    else if (m_iClientEncryptionSystem >= 0x00A2 &&
+             m_iClientEncryptionSystem <= 0x00FF)
+      strName = g_localizeStrings.Get(19014); /* Fixed */
+    else if (m_iClientEncryptionSystem >= 0x0100 &&
+             m_iClientEncryptionSystem <= 0x01FF)
+      strName = "SECA Mediaguard";
+    else if (m_iClientEncryptionSystem == 0x0464)
+      strName = "EuroDec";
+    else if (m_iClientEncryptionSystem >= 0x0500 &&
+             m_iClientEncryptionSystem <= 0x05FF)
+      strName = "Viaccess";
+    else if (m_iClientEncryptionSystem >= 0x0600 &&
+             m_iClientEncryptionSystem <= 0x06FF)
+      strName = "Irdeto";
+    else if (m_iClientEncryptionSystem >= 0x0900 &&
+             m_iClientEncryptionSystem <= 0x09FF)
+      strName = "NDS Videoguard";
+    else if (m_iClientEncryptionSystem >= 0x0B00 &&
+             m_iClientEncryptionSystem <= 0x0BFF)
+      strName = "Conax";
+    else if (m_iClientEncryptionSystem >= 0x0D00 &&
+             m_iClientEncryptionSystem <= 0x0DFF)
+      strName = "CryptoWorks";
+    else if (m_iClientEncryptionSystem >= 0x0E00 &&
+             m_iClientEncryptionSystem <= 0x0EFF)
+      strName = "PowerVu";
+    else if (m_iClientEncryptionSystem == 0x1000)
+      strName = "RAS";
+    else if (m_iClientEncryptionSystem >= 0x1200 &&
+             m_iClientEncryptionSystem <= 0x12FF)
+      strName = "NagraVision";
+    else if (m_iClientEncryptionSystem >= 0x1700 &&
+             m_iClientEncryptionSystem <= 0x17FF)
+      strName = "BetaCrypt";
+    else if (m_iClientEncryptionSystem >= 0x1800 &&
+             m_iClientEncryptionSystem <= 0x18FF)
+      strName = "NagraVision";
+    else if (m_iClientEncryptionSystem == 0x22F0)
+      strName = "Codicrypt";
+    else if (m_iClientEncryptionSystem == 0x2600)
+      strName = "BISS";
+    else if (m_iClientEncryptionSystem == 0x4347)
+      strName = "CryptOn";
+    else if (m_iClientEncryptionSystem == 0x4800)
+      strName = "Accessgate";
+    else if (m_iClientEncryptionSystem == 0x4900)
+      strName = "China Crypt";
+    else if (m_iClientEncryptionSystem == 0x4A10)
+      strName = "EasyCas";
+    else if (m_iClientEncryptionSystem == 0x4A20)
+      strName = "AlphaCrypt";
+    else if (m_iClientEncryptionSystem == 0x4A70)
+      strName = "DreamCrypt";
+    else if (m_iClientEncryptionSystem == 0x4A60)
+      strName = "SkyCrypt";
+    else if (m_iClientEncryptionSystem == 0x4A61)
+      strName = "Neotioncrypt";
+    else if (m_iClientEncryptionSystem == 0x4A62)
+      strName = "SkyCrypt";
+    else if (m_iClientEncryptionSystem == 0x4A63)
+      strName = "Neotion SHL";
+    else if (m_iClientEncryptionSystem >= 0x4A64 &&
+             m_iClientEncryptionSystem <= 0x4A6F)
+      strName = "SkyCrypt";
+    else if (m_iClientEncryptionSystem == 0x4A80)
+      strName = "ThalesCrypt";
+    else if (m_iClientEncryptionSystem == 0x4AA1)
+      strName = "KeyFly";
+    else if (m_iClientEncryptionSystem == 0x4ABF)
+      strName = "DG-Crypt";
+    else if (m_iClientEncryptionSystem >= 0x4AD0 &&
+             m_iClientEncryptionSystem <= 0x4AD1)
+      strName = "X-Crypt";
+    else if (m_iClientEncryptionSystem == 0x4AD4)
+      strName = "OmniCrypt";
+    else if (m_iClientEncryptionSystem == 0x4AE0)
+      strName = "RossCrypt";
+    else if (m_iClientEncryptionSystem == 0x5500)
+      strName = "Z-Crypt";
+    else if (m_iClientEncryptionSystem == 0x5501)
+      strName = "Griffin";
+    else
+      strName = g_localizeStrings.Get(19499); /* Unknown */
+
+    strName.AppendFormat(" (%04X)", m_iClientEncryptionSystem);
+  }
+
+  m_strClientEncryptionName = strName;
+}
+
+/********** EPG methods **********/
+
+int CPVRChannel::GetEPG(CFileItemList &results) const
+{
+  CEpg *epg = GetEPG();
+  if (!epg)
+  {
+    CLog::Log(LOGDEBUG, "PVR - %s - cannot get EPG for channel '%s'",
+        __FUNCTION__, m_strChannelName.c_str());
+    return -1;
+  }
+
+  return epg->Get(results);
+}
+
+bool CPVRChannel::ClearEPG() const
+{
+  CEpg *epg = GetEPG();
+  if (epg)
+    epg->Clear();
+
+  return true;
+}
+
+bool CPVRChannel::GetEPGNow(CEpgInfoTag &tag) const
+{
+  CEpg *epg = GetEPG();
+  return epg ? epg->InfoTagNow(tag) : false;
+}
+
+bool CPVRChannel::GetEPGNext(CEpgInfoTag &tag) const
+{
+  CEpg *epg = GetEPG();
+  return epg ? epg->InfoTagNext(tag) : false;
+}
+
+bool CPVRChannel::SetEPGEnabled(bool bEPGEnabled)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_bEPGEnabled != bEPGEnabled)
+  {
+    /* update the EPG flag */
+    m_bEPGEnabled = bEPGEnabled;
+    SetChanged();
+    m_bChanged = true;
+
+    /* clear the previous EPG entries if needed */
+    if (!m_bEPGEnabled && m_bEPGCreated)
+      ClearEPG();
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CPVRChannel::SetEPGScraper(const CStdString &strScraper)
+{
+  CSingleLock lock(m_critSection);
+
+  if (m_strEPGScraper != strScraper)
+  {
+    bool bCleanEPG = !m_strEPGScraper.IsEmpty() || strScraper.IsEmpty();
+
+    /* update the scraper name */
+    m_strEPGScraper.Format("%s", strScraper);
+    SetChanged();
+    m_bChanged = true;
+
+    /* clear the previous EPG entries if needed */
+    if (bCleanEPG && m_bEPGEnabled && m_bEPGCreated)
+      ClearEPG();
+
+    return true;
+  }
+
+  return false;
+}
+
+void CPVRChannel::SetCachedChannelNumber(unsigned int iChannelNumber)
+{
+  CSingleLock lock(m_critSection);
+  m_iCachedChannelNumber = iChannelNumber;
+}
+
+void CPVRChannel::ToSortable(SortItem& sortable) const
+{
+  CSingleLock lock(m_critSection);
+  sortable[FieldChannelName] = m_strChannelName;
+}
+
+int CPVRChannel::ChannelID(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iChannelId;
+}
+
+bool CPVRChannel::IsNew(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iChannelId <= 0;
+}
+
+bool CPVRChannel::IsHidden(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bIsHidden;
+}
+
+bool CPVRChannel::IsLocked(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bIsLocked;
+}
+
+CStdString CPVRChannel::IconPath(void) const
+{
+  CSingleLock lock(m_critSection);
+  CStdString strReturn(m_strIconPath);
+  return strReturn;
+}
+
+bool CPVRChannel::IsUserSetIcon(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bIsUserSetIcon;
+}
+
+CStdString CPVRChannel::ChannelName(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_strChannelName;
+}
+
+bool CPVRChannel::IsVirtual(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bIsVirtual;
+}
+
+time_t CPVRChannel::LastWatched(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iLastWatched;
+}
+
+bool CPVRChannel::IsChanged() const
+{
+  CSingleLock lock(m_critSection);
+  return m_bChanged;
+}
+
+int CPVRChannel::UniqueID(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iUniqueId;
+}
+
+int CPVRChannel::ClientID(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iClientId;
+}
+
+int CPVRChannel::ClientChannelNumber(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iClientChannelNumber;
+}
+
+CStdString CPVRChannel::ClientChannelName(void) const
+{
+  CSingleLock lock(m_critSection);
+  CStdString strReturn(m_strClientChannelName);
+  return strReturn;
+}
+
+CStdString CPVRChannel::InputFormat(void) const
+{
+  CSingleLock lock(m_critSection);
+  CStdString strReturn(m_strInputFormat);
+  return strReturn;
+}
+
+CStdString CPVRChannel::StreamURL(void) const
+{
+  CSingleLock lock(m_critSection);
+  CStdString strReturn(m_strStreamURL);
+  return strReturn;
+}
+
+CStdString CPVRChannel::Path(void) const
+{
+  CSingleLock lock(m_critSection);
+  CStdString strReturn(m_strFileNameAndPath);
+  return strReturn;
+}
+
+bool CPVRChannel::IsEncrypted(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iClientEncryptionSystem > 0;
+}
+
+int CPVRChannel::EncryptionSystem(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iClientEncryptionSystem;
+}
+
+CStdString CPVRChannel::EncryptionName(void) const
+{
+  CSingleLock lock(m_critSection);
+  CStdString strReturn(m_strClientEncryptionName);
+  return strReturn;
+}
+
+int CPVRChannel::EpgID(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_iEpgId;
+}
+
+bool CPVRChannel::EPGEnabled(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bEPGEnabled;
+}
+
+CStdString CPVRChannel::EPGScraper(void) const
+{
+  CSingleLock lock(m_critSection);
+  CStdString strReturn(m_strEPGScraper);
+  return strReturn;
+}
+
+bool CPVRChannel::CanRecord(void) const
+{
+  return g_PVRClients->SupportsRecordings(m_iClientId);
+}
diff --git a/xbmc/pvr/channels/PVRChannelGroup.cpp b/xbmc/pvr/channels/PVRChannelGroup.cpp
new file mode 100644
index 0000000..3608450
--- /dev/null
+++ b/xbmc/pvr/channels/PVRChannelGroup.cpp
@@ -0,0 +1,1153 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/**
+ * TODO:
+ * - use Observable here, so we can use event driven operations later
+ */
+
+#include "settings/GUISettings.h"
+#include "guilib/GUIWindowManager.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "dialogs/GUIDialogOK.h"
+#include "music/tags/MusicInfoTag.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "threads/SingleLock.h"
+
+#include "PVRChannelGroupsContainer.h"
+#include "pvr/PVRDatabase.h"
+#include "pvr/PVRManager.h"
+#include "pvr/addons/PVRClients.h"
+#include "epg/EpgContainer.h"
+
+using namespace PVR;
+using namespace EPG;
+
+CPVRChannelGroup::CPVRChannelGroup(void) :
+    m_bRadio(false),
+    m_iGroupType(PVR_GROUP_TYPE_DEFAULT),
+    m_iGroupId(-1),
+    m_bLoaded(false),
+    m_bChanged(false),
+    m_bUsingBackendChannelOrder(false)
+{
+}
+
+CPVRChannelGroup::CPVRChannelGroup(bool bRadio, unsigned int iGroupId, const CStdString &strGroupName) :
+    m_bRadio(bRadio),
+    m_iGroupType(PVR_GROUP_TYPE_DEFAULT),
+    m_iGroupId(iGroupId),
+    m_strGroupName(strGroupName),
+    m_bLoaded(false),
+    m_bChanged(false),
+    m_bUsingBackendChannelOrder(false)
+{
+}
+
+CPVRChannelGroup::CPVRChannelGroup(const PVR_CHANNEL_GROUP &group) :
+    m_bRadio(group.bIsRadio),
+    m_iGroupType(PVR_GROUP_TYPE_DEFAULT),
+    m_iGroupId(-1),
+    m_strGroupName(group.strGroupName),
+    m_bLoaded(false),
+    m_bChanged(false),
+    m_bUsingBackendChannelOrder(false)
+{
+}
+
+CPVRChannelGroup::~CPVRChannelGroup(void)
+{
+  Unload();
+}
+
+bool CPVRChannelGroup::operator==(const CPVRChannelGroup& right) const
+{
+  return (m_bRadio == right.m_bRadio &&
+      m_iGroupType == right.m_iGroupType &&
+      m_iGroupId == right.m_iGroupId &&
+      m_strGroupName.Equals(right.m_strGroupName));
+}
+
+bool CPVRChannelGroup::operator!=(const CPVRChannelGroup &right) const
+{
+  return !(*this == right);
+}
+
+CPVRChannelGroup::CPVRChannelGroup(const CPVRChannelGroup &group)
+{
+  m_bRadio                      = group.m_bRadio;
+  m_iGroupType                  = group.m_iGroupType;
+  m_iGroupId                    = group.m_iGroupId;
+  m_strGroupName                = group.m_strGroupName;
+  m_bLoaded                     = group.m_bLoaded;
+  m_bChanged                    = group.m_bChanged;
+  m_bUsingBackendChannelOrder   = group.m_bUsingBackendChannelOrder;
+  m_bUsingBackendChannelNumbers = group.m_bUsingBackendChannelNumbers;
+
+  for (int iPtr = 0; iPtr < group.Size(); iPtr++)
+    m_members.push_back(group.m_members.at(iPtr));
+}
+
+int CPVRChannelGroup::Load(void)
+{
+  /* make sure this container is empty before loading */
+  Unload();
+
+  m_bUsingBackendChannelOrder   = g_guiSettings.GetBool("pvrmanager.backendchannelorder");
+  m_bUsingBackendChannelNumbers = g_guiSettings.GetBool("pvrmanager.usebackendchannelnumbers");
+
+  int iChannelCount = m_iGroupId > 0 ? LoadFromDb() : 0;
+  CLog::Log(LOGDEBUG, "PVRChannelGroup - %s - %d channels loaded from the database for group '%s'",
+        __FUNCTION__, iChannelCount, m_strGroupName.c_str());
+
+  Update();
+  if (Size() - iChannelCount > 0)
+  {
+    CLog::Log(LOGDEBUG, "PVRChannelGroup - %s - %d channels added from clients to group '%s'",
+        __FUNCTION__, Size() - iChannelCount, m_strGroupName.c_str());
+  }
+
+  SortByChannelNumber();
+  Renumber();
+
+  g_guiSettings.RegisterObserver(this);
+  m_bLoaded = true;
+
+  return Size();
+}
+
+void CPVRChannelGroup::Unload(void)
+{
+  CSingleLock lock(m_critSection);
+  g_guiSettings.UnregisterObserver(this);
+  m_members.clear();
+}
+
+bool CPVRChannelGroup::Update(void)
+{
+  if (GroupType() == PVR_GROUP_TYPE_USER_DEFINED ||
+      !g_guiSettings.GetBool("pvrmanager.syncchannelgroups"))
+    return false;
+
+  CPVRChannelGroup PVRChannels_tmp(m_bRadio, m_iGroupId, m_strGroupName);
+  PVRChannels_tmp.LoadFromClients();
+
+  return UpdateGroupEntries(PVRChannels_tmp);
+}
+
+bool CPVRChannelGroup::SetChannelNumber(const CPVRChannel &channel, unsigned int iChannelNumber)
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    if (*m_members.at(iChannelPtr).channel == channel)
+    {
+      if (m_members.at(iChannelPtr).iChannelNumber != iChannelNumber)
+      {
+        m_bChanged = true;
+        bReturn = true;
+        m_members.at(iChannelPtr).iChannelNumber = iChannelNumber;
+      }
+      break;
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::MoveChannel(unsigned int iOldChannelNumber, unsigned int iNewChannelNumber, bool bSaveInDb /* = true */)
+{
+  if (iOldChannelNumber == iNewChannelNumber)
+    return true;
+
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  /* make sure the list is sorted by channel number */
+  SortByChannelNumber();
+
+  /* old channel number out of range */
+  if (iOldChannelNumber > m_members.size())
+    return bReturn;
+
+  /* new channel number out of range */
+  if (iNewChannelNumber > m_members.size())
+    iNewChannelNumber = m_members.size();
+
+  /* move the channel in the list */
+  PVRChannelGroupMember entry = m_members.at(iOldChannelNumber - 1);
+  m_members.erase(m_members.begin() + iOldChannelNumber - 1);
+  m_members.insert(m_members.begin() + iNewChannelNumber - 1, entry);
+
+  /* renumber the list */
+  Renumber();
+
+  m_bChanged = true;
+
+  if (bSaveInDb)
+    bReturn = Persist();
+  else
+    bReturn = true;
+
+  CLog::Log(LOGNOTICE, "CPVRChannelGroup - %s - %s channel '%s' moved to channel number '%d'",
+      __FUNCTION__, (m_bRadio ? "radio" : "tv"), entry.channel->ChannelName().c_str(), iNewChannelNumber);
+
+  return true;
+}
+
+void CPVRChannelGroup::SearchAndSetChannelIcons(bool bUpdateDb /* = false */)
+{
+  if (g_guiSettings.GetString("pvrmenu.iconpath").IsEmpty())
+    return;
+
+  CPVRDatabase *database = GetPVRDatabase();
+  if (!database)
+    return;
+
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int ptr = 0; ptr < m_members.size(); ptr++)
+  {
+    PVRChannelGroupMember groupMember = m_members.at(ptr);
+
+    /* skip if an icon is already set */
+    if (!groupMember.channel->IconPath().IsEmpty())
+      continue;
+
+    CStdString strBasePath = g_guiSettings.GetString("pvrmenu.iconpath");
+    CStdString strChannelName = groupMember.channel->ClientChannelName();
+
+    CStdString strIconPath = strBasePath + groupMember.channel->ClientChannelName();
+    CStdString strIconPathLower = strBasePath + strChannelName.ToLower();
+    CStdString strIconPathUid;
+    strIconPathUid.Format("%s/%08d", strBasePath, groupMember.channel->UniqueID());
+
+    groupMember.channel->SetIconPath(strIconPath      + ".tbn") ||
+    groupMember.channel->SetIconPath(strIconPath      + ".jpg") ||
+    groupMember.channel->SetIconPath(strIconPath      + ".png") ||
+
+    groupMember.channel->SetIconPath(strIconPathLower + ".tbn") ||
+    groupMember.channel->SetIconPath(strIconPathLower + ".jpg") ||
+    groupMember.channel->SetIconPath(strIconPathLower + ".png") ||
+
+    groupMember.channel->SetIconPath(strIconPathUid   + ".tbn") ||
+    groupMember.channel->SetIconPath(strIconPathUid   + ".jpg") ||
+    groupMember.channel->SetIconPath(strIconPathUid   + ".png");
+
+    if (bUpdateDb)
+      groupMember.channel->Persist();
+
+    /* TODO: start channel icon scraper here if nothing was found */
+  }
+}
+
+/********** sort methods **********/
+
+struct sortByClientChannelNumber
+{
+  bool operator()(const PVRChannelGroupMember &channel1, const PVRChannelGroupMember &channel2)
+  {
+    return channel1.channel->ClientChannelNumber() < channel2.channel->ClientChannelNumber();
+  }
+};
+
+struct sortByChannelNumber
+{
+  bool operator()(const PVRChannelGroupMember &channel1, const PVRChannelGroupMember &channel2)
+  {
+    return channel1.iChannelNumber < channel2.iChannelNumber;
+  }
+};
+
+void CPVRChannelGroup::SortByClientChannelNumber(void)
+{
+  CSingleLock lock(m_critSection);
+  sort(m_members.begin(), m_members.end(), sortByClientChannelNumber());
+}
+
+void CPVRChannelGroup::SortByChannelNumber(void)
+{
+  CSingleLock lock(m_critSection);
+  sort(m_members.begin(), m_members.end(), sortByChannelNumber());
+}
+
+/********** getters **********/
+
+CPVRChannelPtr CPVRChannelGroup::GetByClient(int iUniqueChannelId, int iClientID) const
+{
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int ptr = 0; ptr < m_members.size(); ptr++)
+  {
+    PVRChannelGroupMember groupMember = m_members.at(ptr);
+    if (groupMember.channel->UniqueID() == iUniqueChannelId &&
+        groupMember.channel->ClientID() == iClientID)
+      return groupMember.channel;
+  }
+
+  CPVRChannelPtr empty;
+  return empty;
+}
+
+CPVRChannelPtr CPVRChannelGroup::GetByChannelID(int iChannelID) const
+{
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int ptr = 0; ptr < m_members.size(); ptr++)
+  {
+    PVRChannelGroupMember groupMember = m_members.at(ptr);
+    if (groupMember.channel->ChannelID() == iChannelID)
+      return groupMember.channel;
+  }
+
+  CPVRChannelPtr empty;
+  return empty;
+}
+
+CPVRChannelPtr CPVRChannelGroup::GetByChannelEpgID(int iEpgID) const
+{
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int ptr = 0; ptr < m_members.size(); ptr++)
+  {
+    PVRChannelGroupMember groupMember = m_members.at(ptr);
+    if (groupMember.channel->EpgID() == iEpgID)
+      return groupMember.channel;
+  }
+
+  CPVRChannelPtr empty;
+  return empty;
+}
+
+CPVRChannelPtr CPVRChannelGroup::GetByUniqueID(int iUniqueID) const
+{
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int ptr = 0; ptr < m_members.size(); ptr++)
+  {
+    PVRChannelGroupMember groupMember = m_members.at(ptr);
+    if (groupMember.channel->UniqueID() == iUniqueID)
+      return groupMember.channel;
+  }
+
+  CPVRChannelPtr empty;
+  return empty;
+}
+
+CFileItemPtr CPVRChannelGroup::GetLastPlayedChannel(unsigned int iCurrentChannel /* = -1 */) const
+{
+  CSingleLock lock(m_critSection);
+
+  time_t tCurrentLastWatched(0), tMaxLastWatched(0);
+  if (iCurrentChannel > 0)
+  {
+    CPVRChannelPtr channel = GetByChannelID(iCurrentChannel);
+    if (channel.get())
+    {
+      CDateTime::GetCurrentDateTime().GetAsTime(tMaxLastWatched);
+      channel->SetLastWatched(tMaxLastWatched);
+      channel->Persist();
+    }
+  }
+
+  CPVRChannelPtr returnChannel;
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    PVRChannelGroupMember groupMember = m_members.at(iChannelPtr);
+
+    if (g_PVRClients->IsConnectedClient(groupMember.channel->ClientID()) &&
+        groupMember.channel->LastWatched() > 0 &&
+        (tMaxLastWatched == 0 || groupMember.channel->LastWatched() < tMaxLastWatched) &&
+        (tCurrentLastWatched == 0 || groupMember.channel->LastWatched() > tCurrentLastWatched))
+    {
+      returnChannel = groupMember.channel;
+      tCurrentLastWatched = returnChannel->LastWatched();
+    }
+  }
+
+  if (returnChannel)
+  {
+    CFileItemPtr retVal = CFileItemPtr(new CFileItem(*returnChannel));
+    return retVal;
+  }
+
+  CFileItemPtr retVal = CFileItemPtr(new CFileItem);
+  return retVal;
+}
+
+
+unsigned int CPVRChannelGroup::GetChannelNumber(const CPVRChannel &channel) const
+{
+  unsigned int iReturn = 0;
+  CSingleLock lock(m_critSection);
+  unsigned int iSize = m_members.size();
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < iSize; iChannelPtr++)
+  {
+    PVRChannelGroupMember member = m_members.at(iChannelPtr);
+    if (member.channel->ChannelID() == channel.ChannelID())
+    {
+      iReturn = member.iChannelNumber;
+      break;
+    }
+  }
+
+  return iReturn;
+}
+
+CFileItemPtr CPVRChannelGroup::GetByChannelNumber(unsigned int iChannelNumber) const
+{
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int ptr = 0; ptr < m_members.size(); ptr++)
+  {
+    PVRChannelGroupMember groupMember = m_members.at(ptr);
+    if (groupMember.iChannelNumber == iChannelNumber)
+    {
+      CFileItemPtr retVal = CFileItemPtr(new CFileItem(*groupMember.channel));
+      return retVal;
+    }
+  }
+
+  CFileItemPtr retVal = CFileItemPtr(new CFileItem);
+  return retVal;
+}
+
+CFileItemPtr CPVRChannelGroup::GetByChannelUpDown(const CFileItem &channel, bool bChannelUp) const
+{
+  if (channel.HasPVRChannelInfoTag())
+  {
+    CSingleLock lock(m_critSection);
+    int iChannelIndex = GetIndex(*channel.GetPVRChannelInfoTag());
+
+    bool bGotChannel(false);
+    while (!bGotChannel)
+    {
+      if (bChannelUp)
+        iChannelIndex++;
+      else
+        iChannelIndex--;
+
+      if (iChannelIndex >= (int)m_members.size())
+        iChannelIndex = 0;
+      else if (iChannelIndex < 0)
+        iChannelIndex = m_members.size() - 1;
+
+      CFileItemPtr current = GetByIndex(iChannelIndex);
+      if (!current || *current->GetPVRChannelInfoTag() == *channel.GetPVRChannelInfoTag())
+        break;
+
+      if (!current->GetPVRChannelInfoTag()->IsHidden())
+        return current;
+    }
+  }
+
+  CFileItemPtr retVal(new CFileItem);
+  return retVal;
+}
+
+CFileItemPtr CPVRChannelGroup::GetByIndex(unsigned int iIndex) const
+{
+  CSingleLock lock(m_critSection);
+  if (iIndex < m_members.size())
+  {
+    CFileItemPtr retVal = CFileItemPtr(new CFileItem(*m_members.at(iIndex).channel));
+    return retVal;
+  }
+
+  CFileItemPtr retVal = CFileItemPtr(new CFileItem);
+  return retVal;
+}
+
+int CPVRChannelGroup::GetIndex(const CPVRChannel &channel) const
+{
+  int iIndex(-1);
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    if (*m_members.at(iChannelPtr).channel == channel)
+    {
+      iIndex = iChannelPtr;
+      break;
+    }
+  }
+
+  return iIndex;
+}
+
+int CPVRChannelGroup::GetMembers(CFileItemList &results, bool bGroupMembers /* = true */) const
+{
+  int iOrigSize = results.Size();
+  CSingleLock lock(m_critSection);
+
+  const CPVRChannelGroup* channels = bGroupMembers ? this : g_PVRChannelGroups->GetGroupAll(m_bRadio).get();
+  for (unsigned int iChannelPtr = 0; iChannelPtr < channels->m_members.size(); iChannelPtr++)
+  {
+    CPVRChannelPtr channel = channels->m_members.at(iChannelPtr).channel;
+    if (!channel)
+      continue;
+
+    if (bGroupMembers || !IsGroupMember(*channel))
+    {
+      CFileItemPtr pFileItem(new CFileItem(*channel));
+      results.Add(pFileItem);
+    }
+  }
+
+  return results.Size() - iOrigSize;
+}
+
+CPVRChannelGroupPtr CPVRChannelGroup::GetNextGroup(void) const
+{
+  return g_PVRChannelGroups->Get(m_bRadio)->GetNextGroup(*this);
+}
+
+CPVRChannelGroupPtr CPVRChannelGroup::GetPreviousGroup(void) const
+{
+  return g_PVRChannelGroups->Get(m_bRadio)->GetPreviousGroup(*this);
+}
+
+/********** private methods **********/
+
+int CPVRChannelGroup::LoadFromDb(bool bCompress /* = false */)
+{
+  CPVRDatabase *database = GetPVRDatabase();
+  if (!database)
+    return -1;
+
+  int iChannelCount = Size();
+
+  database->Get(*this);
+
+  return Size() - iChannelCount;
+}
+
+int CPVRChannelGroup::LoadFromClients(void)
+{
+  int iCurSize = Size();
+
+  /* get the channels from the backends */
+  g_PVRClients->GetChannelGroupMembers(this);
+
+  return Size() - iCurSize;
+}
+
+bool CPVRChannelGroup::AddAndUpdateChannels(const CPVRChannelGroup &channels, bool bUseBackendChannelNumbers)
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  /* go through the channel list and check for new channels.
+     channels will only by updated in CPVRChannelGroupInternal to prevent dupe updates */
+  for (unsigned int iChannelPtr = 0; iChannelPtr < channels.m_members.size(); iChannelPtr++)
+  {
+    PVRChannelGroupMember member = channels.m_members.at(iChannelPtr);
+    if (!member.channel)
+      continue;
+
+    /* check whether this channel is known in the internal group */
+    CPVRChannelPtr existingChannel = g_PVRChannelGroups->GetGroupAll(m_bRadio)->GetByClient(member.channel->UniqueID(), member.channel->ClientID());
+    if (!existingChannel)
+      continue;
+
+    /* if it's found, add the channel to this group */
+    if (!IsGroupMember(*existingChannel))
+    {
+      int iChannelNumber = bUseBackendChannelNumbers ? member.channel->ClientChannelNumber() : 0;
+      AddToGroup(*existingChannel, iChannelNumber, false);
+
+      bReturn = true;
+      CLog::Log(LOGINFO,"PVRChannelGroup - %s - added %s channel '%s' at position %d in group '%s'",
+          __FUNCTION__, m_bRadio ? "radio" : "TV", existingChannel->ChannelName().c_str(), iChannelNumber, GroupName().c_str());
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::RemoveDeletedChannels(const CPVRChannelGroup &channels)
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  /* check for deleted channels */
+  for (int iChannelPtr = m_members.size() - 1; iChannelPtr >= 0; iChannelPtr--)
+  {
+    CPVRChannelPtr channel = m_members.at(iChannelPtr).channel;
+    if (!channel)
+      continue;
+
+    if (channels.GetByClient(channel->UniqueID(), channel->ClientID()) == NULL)
+    {
+      /* channel was not found */
+      CLog::Log(LOGINFO,"PVRChannelGroup - %s - deleted %s channel '%s' from group '%s'",
+          __FUNCTION__, m_bRadio ? "radio" : "TV", channel->ChannelName().c_str(), GroupName().c_str());
+
+      /* remove this channel from all non-system groups if this is the internal group */
+      if (IsInternalGroup())
+      {
+        g_PVRChannelGroups->Get(m_bRadio)->RemoveFromAllGroups(*channel);
+
+        /* since it was not found in the internal group, it was deleted from the backend */
+        channel->Delete();
+      }
+
+      m_members.erase(m_members.begin() + iChannelPtr);
+      m_bChanged = true;
+      bReturn = true;
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::UpdateGroupEntries(const CPVRChannelGroup &channels)
+{
+  bool bReturn(false);
+  bool bChanged(false);
+  bool bRemoved(false);
+
+  CSingleLock lock(m_critSection);
+  /* sort by client channel number if this is the first time or if pvrmanager.backendchannelorder is true */
+  bool bUseBackendChannelNumbers(m_members.size() == 0 || m_bUsingBackendChannelOrder);
+
+  CPVRDatabase *database = GetPVRDatabase();
+  if (!database)
+    return bReturn;
+
+  bRemoved = RemoveDeletedChannels(channels);
+  bChanged = AddAndUpdateChannels(channels, bUseBackendChannelNumbers) || bRemoved;
+
+  if (bChanged)
+  {
+    if (bUseBackendChannelNumbers)
+      SortByClientChannelNumber();
+
+    /* renumber to make sure all channels have a channel number.
+       new channels were added at the back, so they'll get the highest numbers */
+    bool bRenumbered = Renumber();
+
+    SetChanged();
+    lock.Leave();
+
+    NotifyObservers(HasNewChannels() || bRemoved || bRenumbered ? ObservableMessageChannelGroup : ObservableMessageChannelGroupReset);
+
+    bReturn = Persist();
+  }
+  else
+  {
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+void CPVRChannelGroup::RemoveInvalidChannels(void)
+{
+  bool bDelete(false);
+  CSingleLock lock(m_critSection);
+  for (unsigned int ptr = 0; ptr < m_members.size(); ptr--)
+  {
+    bDelete = false;
+    CPVRChannelPtr channel = m_members.at(ptr).channel;
+    if (channel->IsVirtual())
+      continue;
+
+    if (m_members.at(ptr).channel->ClientChannelNumber() <= 0)
+    {
+      CLog::Log(LOGERROR, "PVRChannelGroup - %s - removing invalid channel '%s' from client '%i': no valid client channel number",
+          __FUNCTION__, channel->ChannelName().c_str(), channel->ClientID());
+      bDelete = true;
+    }
+
+    if (!bDelete && channel->UniqueID() <= 0)
+    {
+      CLog::Log(LOGERROR, "PVRChannelGroup - %s - removing invalid channel '%s' from client '%i': no valid unique ID",
+          __FUNCTION__, channel->ChannelName().c_str(), channel->ClientID());
+      bDelete = true;
+    }
+
+    /* remove this channel from all non-system groups if this is the internal group */
+    if (bDelete)
+    {
+      if (IsInternalGroup())
+      {
+        g_PVRChannelGroups->Get(m_bRadio)->RemoveFromAllGroups(*channel);
+        channel->Delete();
+      }
+      else
+      {
+        m_members.erase(m_members.begin() + ptr);
+      }
+      m_bChanged = true;
+    }
+  }
+}
+
+bool CPVRChannelGroup::RemoveFromGroup(const CPVRChannel &channel)
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    if (channel == *m_members.at(iChannelPtr).channel)
+    {
+      // TODO notify observers
+      m_members.erase(m_members.begin() + iChannelPtr);
+      bReturn = true;
+      m_bChanged = true;
+      break;
+    }
+  }
+
+  Renumber();
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::AddToGroup(CPVRChannel &channel, int iChannelNumber /* = 0 */, bool bSortAndRenumber /* = true */)
+{
+  CSingleLock lock(m_critSection);
+
+  bool bReturn(false);
+
+  if (!CPVRChannelGroup::IsGroupMember(channel))
+  {
+    if (iChannelNumber <= 0 || iChannelNumber > (int) m_members.size() + 1)
+      iChannelNumber = m_members.size() + 1;
+
+    CPVRChannelPtr realChannel = (IsInternalGroup()) ?
+        GetByClient(channel.UniqueID(), channel.ClientID()) :
+        g_PVRChannelGroups->GetGroupAll(m_bRadio)->GetByClient(channel.UniqueID(), channel.ClientID());
+
+    if (realChannel)
+    {
+      PVRChannelGroupMember newMember = { realChannel, iChannelNumber };
+      m_members.push_back(newMember);
+      m_bChanged = true;
+
+      if (bSortAndRenumber)
+      {
+        if (m_bUsingBackendChannelOrder)
+          SortByClientChannelNumber();
+        else
+          SortByChannelNumber();
+        Renumber();
+      }
+
+      // TODO notify observers
+      bReturn = true;
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::IsGroupMember(const CPVRChannel &channel) const
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    if (channel == *m_members.at(iChannelPtr).channel)
+    {
+      bReturn = true;
+      break;
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::IsGroupMember(int iChannelId) const
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    if (iChannelId == m_members.at(iChannelPtr).channel->ChannelID())
+    {
+      bReturn = true;
+      break;
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::SetGroupName(const CStdString &strGroupName, bool bSaveInDb /* = false */)
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  if (m_strGroupName != strGroupName)
+  {
+    /* update the name */
+    m_strGroupName = strGroupName;
+    m_bChanged = true;
+//    SetChanged();
+
+    /* persist the changes */
+    if (bSaveInDb)
+      Persist();
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::Persist(void)
+{
+  bool bReturn(true);
+  CSingleLock lock(m_critSection);
+
+  if (!HasChanges())
+    return bReturn;
+
+  if (CPVRDatabase *database = GetPVRDatabase())
+  {
+    CLog::Log(LOGDEBUG, "CPVRChannelGroup - %s - persisting channel group '%s' with %d channels",
+        __FUNCTION__, GroupName().c_str(), (int) m_members.size());
+    m_bChanged = false;
+    lock.Leave();
+
+    bReturn = database->Persist(*this);
+  }
+  else
+  {
+    bReturn = false;
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::Renumber(void)
+{
+  bool bReturn(false);
+  unsigned int iChannelNumber(0);
+  bool bUseBackendChannelNumbers(g_guiSettings.GetBool("pvrmanager.usebackendchannelnumbers") && g_PVRClients->EnabledClientAmount() == 1);
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size();  iChannelPtr++)
+  {
+    unsigned int iCurrentChannelNumber;
+    if (m_members.at(iChannelPtr).channel->IsHidden())
+      iCurrentChannelNumber = 0;
+    else if (bUseBackendChannelNumbers)
+      iCurrentChannelNumber = m_members.at(iChannelPtr).channel->ClientChannelNumber();
+    else
+      iCurrentChannelNumber = ++iChannelNumber;
+
+    if (m_members.at(iChannelPtr).iChannelNumber != iCurrentChannelNumber)
+    {
+      bReturn = true;
+      m_bChanged = true;
+    }
+
+    m_members.at(iChannelPtr).iChannelNumber = iCurrentChannelNumber;
+  }
+
+  SortByChannelNumber();
+  ResetChannelNumberCache();
+
+  return bReturn;
+}
+
+void CPVRChannelGroup::ResetChannelNumberCache(void)
+{
+  CPVRChannelGroupPtr playingGroup = g_PVRManager.GetPlayingGroup(m_bRadio);
+  if (!playingGroup || *this != *playingGroup)
+    return;
+
+  CSingleLock lock(m_critSection);
+
+  /* reset the channel number cache */
+  if (!IsInternalGroup())
+    g_PVRChannelGroups->GetGroupAll(m_bRadio)->ResetChannelNumbers();
+
+  /* set all channel numbers on members of this group */
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+    m_members.at(iChannelPtr).channel->SetCachedChannelNumber(m_members.at(iChannelPtr).iChannelNumber);
+}
+
+bool CPVRChannelGroup::HasChangedChannels(void) const
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    if (m_members.at(iChannelPtr).channel->IsChanged())
+    {
+      bReturn = true;
+      break;
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::HasNewChannels(void) const
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    if (m_members.at(iChannelPtr).channel->ChannelID() <= 0)
+    {
+      bReturn = true;
+      break;
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroup::HasChanges(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_bChanged || HasNewChannels() || HasChangedChannels();
+}
+
+void CPVRChannelGroup::ResetChannelNumbers(void)
+{
+  CSingleLock lock(m_critSection);
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+    m_members.at(iChannelPtr).channel->SetCachedChannelNumber(0);
+}
+
+void CPVRChannelGroup::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  if (msg == ObservableMessageGuiSettings)
+  {
+    CSingleLock lock(m_critSection);
+    bool bUsingBackendChannelOrder   = g_guiSettings.GetBool("pvrmanager.backendchannelorder");
+    bool bUsingBackendChannelNumbers = g_guiSettings.GetBool("pvrmanager.usebackendchannelnumbers");
+    bool bChannelNumbersChanged      = m_bUsingBackendChannelNumbers != bUsingBackendChannelNumbers;
+    bool bChannelOrderChanged        = m_bUsingBackendChannelOrder != bUsingBackendChannelOrder;
+
+    m_bUsingBackendChannelOrder   = bUsingBackendChannelOrder;
+    m_bUsingBackendChannelNumbers = bUsingBackendChannelNumbers;
+
+    /* check whether this channel group has to be renumbered */
+    if (bChannelOrderChanged || bChannelNumbersChanged)
+    {
+      CLog::Log(LOGDEBUG, "CPVRChannelGroup - %s - renumbering group '%s' to use the backend channel order and/or numbers",
+          __FUNCTION__, m_strGroupName.c_str());
+      SortByClientChannelNumber();
+      Renumber();
+      Persist();
+    }
+  }
+}
+
+bool CPVRPersistGroupJob::DoWork(void)
+{
+  return m_group->Persist();
+}
+
+int CPVRChannelGroup::GetEPGSearch(CFileItemList &results, const EpgSearchFilter &filter)
+{
+  int iInitialSize = results.Size();
+
+  /* get filtered results from all tables */
+  g_EpgContainer.GetEPGSearch(results, filter);
+
+  /* remove duplicate entries */
+  if (filter.m_bPreventRepeats)
+    EpgSearchFilter::RemoveDuplicates(results);
+
+  /* filter recordings */
+  if (filter.m_bIgnorePresentRecordings)
+    EpgSearchFilter::FilterRecordings(results);
+
+  /* filter timers */
+  if (filter.m_bIgnorePresentTimers)
+    EpgSearchFilter::FilterTimers(results);
+
+  return results.Size() - iInitialSize;
+}
+
+int CPVRChannelGroup::GetEPGNow(CFileItemList &results)
+{
+  int iInitialSize = results.Size();
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    CPVRChannelPtr channel = m_members.at(iChannelPtr).channel;
+    CEpg *epg = channel->GetEPG();
+    if (!epg || !epg->HasValidEntries() || m_members.at(iChannelPtr).channel->IsHidden())
+      continue;
+
+    CEpgInfoTag epgNow;
+    if (!epg->InfoTagNow(epgNow))
+      continue;
+
+    CFileItemPtr entry(new CFileItem(epgNow));
+    entry->SetLabel2(epgNow.StartAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false));
+    entry->SetPath(channel->ChannelName());
+    entry->SetThumbnailImage(channel->IconPath());
+    results.Add(entry);
+  }
+
+  return results.Size() - iInitialSize;
+}
+
+int CPVRChannelGroup::GetEPGNext(CFileItemList &results)
+{
+  int iInitialSize = results.Size();
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    CPVRChannelPtr channel = m_members.at(iChannelPtr).channel;
+    CEpg *epg = channel->GetEPG();
+    if (!epg || !epg->HasValidEntries() || m_members.at(iChannelPtr).channel->IsHidden())
+      continue;
+
+    CEpgInfoTag epgNow;
+    if (!epg->InfoTagNext(epgNow))
+      continue;
+
+    CFileItemPtr entry(new CFileItem(epgNow));
+    entry->SetLabel2(epgNow.StartAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false));
+    entry->SetPath(channel->ChannelName());
+    entry->SetThumbnailImage(channel->IconPath());
+    results.Add(entry);
+  }
+
+  return results.Size() - iInitialSize;
+}
+
+int CPVRChannelGroup::GetEPGAll(CFileItemList &results)
+{
+  int iInitialSize = results.Size();
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    if (!m_members.at(iChannelPtr).channel || m_members.at(iChannelPtr).channel->IsHidden())
+      continue;
+
+    m_members.at(iChannelPtr).channel->GetEPG(results);
+  }
+
+  return results.Size() - iInitialSize;
+}
+
+int CPVRChannelGroup::Size(void) const
+{
+  return m_members.size();
+}
+
+int CPVRChannelGroup::GroupID(void) const
+{
+  return m_iGroupId;
+}
+
+void CPVRChannelGroup::SetGroupID(int iGroupId)
+{
+  if (iGroupId >= 0)
+    m_iGroupId = iGroupId;
+}
+
+void CPVRChannelGroup::SetGroupType(int iGroupType)
+{
+  m_iGroupType = iGroupType;
+}
+
+int CPVRChannelGroup::GroupType(void) const
+{
+  return m_iGroupType;
+}
+
+CStdString CPVRChannelGroup::GroupName(void) const
+{
+  CSingleLock lock(m_critSection);
+  CStdString strReturn(m_strGroupName);
+  return strReturn;
+}
+
+bool CPVRChannelGroup::UpdateChannel(const CFileItem &item, bool bHidden, bool bVirtual, bool bEPGEnabled, bool bParentalLocked, int iEPGSource, int iChannelNumber, const CStdString &strChannelName, const CStdString &strIconPath, const CStdString &strStreamURL)
+{
+  if (!item.HasPVRChannelInfoTag())
+    return false;
+
+  CSingleLock lock(m_critSection);
+
+  /* get the real channel from the group */
+  CPVRChannelPtr channel = GetByUniqueID(item.GetPVRChannelInfoTag()->UniqueID());
+  if (!channel)
+    return false;
+
+  channel->SetChannelName(strChannelName);
+  channel->SetHidden(bHidden);
+  channel->SetLocked(bParentalLocked);
+  channel->SetIconPath(strIconPath);
+
+  if (bVirtual)
+    channel->SetStreamURL(strStreamURL);
+  if (iEPGSource == 0)
+    channel->SetEPGScraper("client");
+
+  // TODO add other scrapers
+  channel->SetEPGEnabled(bEPGEnabled);
+
+  /* set new values in the channel tag */
+  if (bHidden)
+  {
+    SortByChannelNumber(); // or previous changes will be overwritten
+    RemoveFromGroup(*channel);
+  }
+  else
+  {
+    SetChannelNumber(*channel, iChannelNumber);
+  }
+
+  return true;
+}
+
+bool CPVRChannelGroup::ToggleChannelLocked(const CFileItem &item)
+{
+  if (!item.HasPVRChannelInfoTag())
+    return false;
+
+  CSingleLock lock(m_critSection);
+
+  /* get the real channel from the group */
+  CPVRChannelPtr channel = GetByUniqueID(item.GetPVRChannelInfoTag()->UniqueID());
+  if (!channel)
+    return false;
+
+  channel->SetLocked(!channel->IsLocked());
+
+  return true;
+}
diff --git a/xbmc/pvr/channels/PVRChannelGroupInternal.cpp b/xbmc/pvr/channels/PVRChannelGroupInternal.cpp
new file mode 100644
index 0000000..f2651c6
--- /dev/null
+++ b/xbmc/pvr/channels/PVRChannelGroupInternal.cpp
@@ -0,0 +1,384 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "PVRChannelGroupInternal.h"
+
+#include "settings/GUISettings.h"
+#include "guilib/GUIWindowManager.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "dialogs/GUIDialogOK.h"
+#include "utils/log.h"
+
+#include "PVRChannelGroupsContainer.h"
+#include "pvr/PVRDatabase.h"
+#include "pvr/PVRManager.h"
+#include "epg/EpgContainer.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/addons/PVRClients.h"
+
+using namespace PVR;
+using namespace EPG;
+using namespace std;
+
+CPVRChannelGroupInternal::CPVRChannelGroupInternal(bool bRadio) :
+  CPVRChannelGroup(bRadio, bRadio ? XBMC_INTERNAL_GROUP_RADIO : XBMC_INTERNAL_GROUP_TV, g_localizeStrings.Get(bRadio ? 19216 : 19217))
+{
+  m_iHiddenChannels = 0;
+  m_iGroupType      = PVR_GROUP_TYPE_INTERNAL;
+}
+
+CPVRChannelGroupInternal::CPVRChannelGroupInternal(const CPVRChannelGroup &group) :
+    CPVRChannelGroup(group)
+{
+  m_iHiddenChannels = group.GetNumHiddenChannels();
+}
+
+CPVRChannelGroupInternal::~CPVRChannelGroupInternal(void)
+{
+  Unload();
+}
+
+int CPVRChannelGroupInternal::Load(void)
+{
+  int iChannelCount = CPVRChannelGroup::Load();
+  UpdateChannelPaths();
+  CreateChannelEpgs();
+
+  return iChannelCount;
+}
+
+void CPVRChannelGroupInternal::CheckGroupName(void)
+{
+  CSingleLock lock(m_critSection);
+
+  /* check whether the group name is still correct, or channels will fail to load after the language setting changed */
+  CStdString strNewGroupName = g_localizeStrings.Get(m_bRadio ? 19216 : 19217);
+  if (!m_strGroupName.Equals(strNewGroupName))
+  {
+    SetGroupName(strNewGroupName, true);
+    UpdateChannelPaths();
+  }
+}
+
+void CPVRChannelGroupInternal::UpdateChannelPaths(void)
+{
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    PVRChannelGroupMember member = m_members.at(iChannelPtr);
+    member.channel->UpdatePath(iChannelPtr);
+  }
+}
+
+void CPVRChannelGroupInternal::UpdateFromClient(const CPVRChannel &channel, unsigned int iChannelNumber /* = 0 */)
+{
+  CSingleLock lock(m_critSection);
+  CPVRChannelPtr realChannel = GetByClient(channel.UniqueID(), channel.ClientID());
+  if (realChannel)
+    realChannel->UpdateFromClient(channel);
+  else
+  {
+    PVRChannelGroupMember newMember = { CPVRChannelPtr(new CPVRChannel(channel)), iChannelNumber > 0 ? iChannelNumber : m_members.size() + 1 };
+    m_members.push_back(newMember);
+    m_bChanged = true;
+
+    if (m_bUsingBackendChannelOrder)
+      SortByClientChannelNumber();
+    else
+      SortByChannelNumber();
+    Renumber();
+  }
+}
+
+bool CPVRChannelGroupInternal::InsertInGroup(CPVRChannel &channel, int iChannelNumber /* = 0 */, bool bSortAndRenumber /* = true */)
+{
+  CSingleLock lock(m_critSection);
+  return CPVRChannelGroup::AddToGroup(channel, iChannelNumber, bSortAndRenumber);
+}
+
+bool CPVRChannelGroupInternal::Update(void)
+{
+  CPVRChannelGroupInternal PVRChannels_tmp(m_bRadio);
+  PVRChannels_tmp.LoadFromClients();
+
+  return UpdateGroupEntries(PVRChannels_tmp);
+}
+
+bool CPVRChannelGroupInternal::AddToGroup(CPVRChannel &channel, int iChannelNumber /* = 0 */, bool bSortAndRenumber /* = true */)
+{
+  CSingleLock lock(m_critSection);
+
+  bool bReturn(false);
+
+  /* get the actual channel since this is called from a fileitemlist copy */
+  CPVRChannelPtr realChannel = GetByChannelID(channel.ChannelID());
+  if (!realChannel)
+    return bReturn;
+
+  /* switch the hidden flag */
+  if (realChannel->IsHidden())
+  {
+    realChannel->SetHidden(false);
+    m_iHiddenChannels--;
+
+    if (bSortAndRenumber)
+      Renumber();
+  }
+
+  /* move this channel and persist */
+  bReturn = (iChannelNumber > 0) ?
+    MoveChannel(realChannel->ChannelNumber(), iChannelNumber, true) :
+    MoveChannel(realChannel->ChannelNumber(), m_members.size() - m_iHiddenChannels, true);
+
+  if (m_bLoaded)
+    realChannel->Persist();
+  return bReturn;
+}
+
+bool CPVRChannelGroupInternal::RemoveFromGroup(const CPVRChannel &channel)
+{
+  CSingleLock lock(m_critSection);
+
+  /* check if this channel is currently playing if we are hiding it */
+  CPVRChannelPtr currentChannel;
+  if (g_PVRManager.GetCurrentChannel(currentChannel) && *currentChannel == channel)
+  {
+    CGUIDialogOK::ShowAndGetInput(19098,19101,0,19102);
+    return false;
+  }
+
+  /* get the actual channel since this is called from a fileitemlist copy */
+  CPVRChannelPtr realChannel = GetByChannelID(channel.ChannelID());
+  if (!realChannel)
+    return false;
+
+  /* switch the hidden flag */
+  if (!realChannel->IsHidden())
+  {
+    realChannel->SetHidden(true);
+    ++m_iHiddenChannels;
+  }
+  else
+  {
+    realChannel->SetHidden(false);
+    --m_iHiddenChannels;
+  }
+
+  /* renumber this list */
+  Renumber();
+
+  /* and persist */
+  return realChannel->Persist() &&
+      Persist();
+}
+
+bool CPVRChannelGroupInternal::MoveChannel(unsigned int iOldChannelNumber, unsigned int iNewChannelNumber, bool bSaveInDb /* = true */)
+{
+  CSingleLock lock(m_critSection);
+  /* new channel number out of range */
+  if (iNewChannelNumber > m_members.size() - m_iHiddenChannels)
+    iNewChannelNumber = m_members.size() - m_iHiddenChannels;
+
+  return CPVRChannelGroup::MoveChannel(iOldChannelNumber, iNewChannelNumber, bSaveInDb);
+}
+
+int CPVRChannelGroupInternal::GetMembers(CFileItemList &results, bool bGroupMembers /* = true */) const
+{
+  int iOrigSize = results.Size();
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+  {
+    CPVRChannelPtr channel = m_members.at(iChannelPtr).channel;
+    if (!channel)
+      continue;
+
+    if (bGroupMembers != channel->IsHidden())
+    {
+      CFileItemPtr pFileItem(new CFileItem(*channel));
+      results.Add(pFileItem);
+    }
+  }
+
+  return results.Size() - iOrigSize;
+}
+
+int CPVRChannelGroupInternal::LoadFromDb(bool bCompress /* = false */)
+{
+  CPVRDatabase *database = GetPVRDatabase();
+  if (!database)
+    return -1;
+
+  int iChannelCount = Size();
+
+  if (database->Get(*this) > 0)
+  {
+    if (bCompress)
+      database->Compress(true);
+  }
+  else
+  {
+    CLog::Log(LOGINFO, "PVRChannelGroupInternal - %s - no channels in the database",
+        __FUNCTION__);
+  }
+
+  SortByChannelNumber();
+
+  return Size() - iChannelCount;
+}
+
+int CPVRChannelGroupInternal::LoadFromClients(void)
+{
+  int iCurSize = Size();
+
+  /* get the channels from the backends */
+  g_PVRClients->GetChannels(this);
+
+  return Size() - iCurSize;
+}
+
+bool CPVRChannelGroupInternal::Renumber(void)
+{
+  CSingleLock lock(m_critSection);
+  bool bReturn(CPVRChannelGroup::Renumber());
+
+  m_iHiddenChannels = 0;
+  for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size();  iChannelPtr++)
+  {
+    if (m_members.at(iChannelPtr).channel->IsHidden())
+      m_iHiddenChannels++;
+    else
+      m_members.at(iChannelPtr).channel->UpdatePath(iChannelPtr);
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroupInternal::IsGroupMember(const CPVRChannel &channel) const
+{
+  return !channel.IsHidden();
+}
+
+bool CPVRChannelGroupInternal::UpdateChannel(const CPVRChannel &channel)
+{
+  CSingleLock lock(m_critSection);
+  CPVRChannelPtr updateChannel = GetByUniqueID(channel.UniqueID());
+
+  if (!updateChannel)
+  {
+    updateChannel = CPVRChannelPtr(new CPVRChannel(channel.IsRadio()));
+    PVRChannelGroupMember newMember = { updateChannel, 0 };
+    m_members.push_back(newMember);
+    updateChannel->SetUniqueID(channel.UniqueID());
+  }
+  updateChannel->UpdateFromClient(channel);
+
+  return updateChannel->Persist(!m_bLoaded);
+}
+
+bool CPVRChannelGroupInternal::AddAndUpdateChannels(const CPVRChannelGroup &channels, bool bUseBackendChannelNumbers)
+{
+  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+
+  /* go through the channel list and check for updated or new channels */
+  for (unsigned int iChannelPtr = 0; iChannelPtr < channels.m_members.size(); iChannelPtr++)
+  {
+    PVRChannelGroupMember member = channels.m_members.at(iChannelPtr);
+    if (!member.channel)
+      continue;
+
+    /* check whether this channel is present in this container */
+    CPVRChannelPtr existingChannel = GetByClient(member.channel->UniqueID(), member.channel->ClientID());
+    if (existingChannel)
+    {
+      /* if it's present, update the current tag */
+      if (existingChannel->UpdateFromClient(*member.channel))
+      {
+        bReturn = true;
+        CLog::Log(LOGINFO,"PVRChannelGroupInternal - %s - updated %s channel '%s'", __FUNCTION__, m_bRadio ? "radio" : "TV", member.channel->ChannelName().c_str());
+      }
+    }
+    else
+    {
+      /* new channel */
+      UpdateFromClient(*member.channel, bUseBackendChannelNumbers ? member.channel->ClientChannelNumber() : 0);
+      bReturn = true;
+      CLog::Log(LOGINFO,"PVRChannelGroupInternal - %s - added %s channel '%s'", __FUNCTION__, m_bRadio ? "radio" : "TV", member.channel->ChannelName().c_str());
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRChannelGroupInternal::UpdateGroupEntries(const CPVRChannelGroup &channels)
+{
+  bool bReturn(false);
+
+  if (CPVRChannelGroup::UpdateGroupEntries(channels))
+  {
+    /* try to find channel icons */
+    SearchAndSetChannelIcons();
+    g_PVRTimers->UpdateChannels();
+    Persist();
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+void CPVRChannelGroupInternal::CreateChannelEpg(CPVRChannelPtr channel, bool bForce /* = false */)
+{
+  if (!channel)
+    return;
+
+  CSingleLock lock(channel->m_critSection);
+  if (!channel->m_bEPGCreated || bForce)
+  {
+    CEpg *epg = g_EpgContainer.CreateChannelEpg(channel);
+    if (epg)
+    {
+      channel->m_bEPGCreated = true;
+      if (epg->EpgID() != channel->m_iEpgId)
+      {
+        channel->m_iEpgId = epg->EpgID();
+        channel->m_bChanged = true;
+      }
+    }
+  }
+}
+
+bool CPVRChannelGroupInternal::CreateChannelEpgs(bool bForce /* = false */)
+{
+  {
+    CSingleLock lock(m_critSection);
+    for (unsigned int iChannelPtr = 0; iChannelPtr < m_members.size(); iChannelPtr++)
+      CreateChannelEpg(m_members.at(iChannelPtr).channel);
+  }
+
+  if (HasChangedChannels())
+  {
+    g_EpgContainer.PersistTables();
+    return Persist();
+  }
+
+  return true;
+}
diff --git a/xbmc/pvr/channels/PVRChannelGroups.cpp b/xbmc/pvr/channels/PVRChannelGroups.cpp
new file mode 100644
index 0000000..77f0989
--- /dev/null
+++ b/xbmc/pvr/channels/PVRChannelGroups.cpp
@@ -0,0 +1,462 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "PVRChannelGroups.h"
+
+#include "FileItem.h"
+#include "settings/GUISettings.h"
+#include "guilib/GUIWindowManager.h"
+#include "utils/log.h"
+#include "URL.h"
+#include "filesystem/File.h"
+
+#include "PVRChannelGroupInternal.h"
+#include "pvr/PVRDatabase.h"
+#include "pvr/PVRManager.h"
+#include "pvr/addons/PVRClients.h"
+
+using namespace PVR;
+
+CPVRChannelGroups::CPVRChannelGroups(bool bRadio) :
+    m_bRadio(bRadio)
+{
+}
+
+CPVRChannelGroups::~CPVRChannelGroups(void)
+{
+  Clear();
+}
+
+void CPVRChannelGroups::Clear(void)
+{
+  CSingleLock lock(m_critSection);
+  m_groups.clear();
+}
+
+bool CPVRChannelGroups::GetGroupsFromClients(void)
+{
+  if (! g_guiSettings.GetBool("pvrmanager.syncchannelgroups"))
+    return true;
+
+  return g_PVRClients->GetChannelGroups(this) == PVR_ERROR_NO_ERROR;
+}
+
+bool CPVRChannelGroups::Update(const CPVRChannelGroup &group, bool bSaveInDb)
+{
+  if (group.GroupName().IsEmpty() && group.GroupID() <= 0)
+    return true;
+
+  CPVRChannelGroupPtr updateGroup;
+  {
+    CSingleLock lock(m_critSection);
+    // try to find the group by id
+    if (group.GroupID() > 0)
+      updateGroup = GetById(group.GroupID());
+
+    // try to find the group by name if we didn't find it yet
+    if (!updateGroup)
+      updateGroup = GetByName(group.GroupName());
+
+    if (!updateGroup)
+    {
+      // create a new group if none was found
+      updateGroup = CPVRChannelGroupPtr(new CPVRChannelGroup(m_bRadio, group.GroupID(), group.GroupName()));
+      updateGroup->SetGroupType(group.GroupType());
+      m_groups.push_back(updateGroup);
+    }
+    else
+    {
+      // update existing group
+      updateGroup->SetGroupID(group.GroupID());
+      updateGroup->SetGroupName(group.GroupName());
+      updateGroup->SetGroupType(group.GroupType());
+    }
+  }
+
+  // persist changes
+  if (bSaveInDb && updateGroup)
+    return updateGroup->Persist();
+
+  return true;
+}
+
+CFileItemPtr CPVRChannelGroups::GetByPath(const CStdString &strPath) const
+{
+  // get the filename from curl
+  CURL url(strPath);
+  CStdString strFileName = url.GetFileName();
+  URIUtils::RemoveSlashAtEnd(strFileName);
+
+  CStdString strCheckPath;
+  for (std::vector<CPVRChannelGroupPtr>::const_iterator it = m_groups.begin(); it != m_groups.end(); it++)
+  {
+    // check if the path matches
+    strCheckPath.Format("channels/%s/%s/", (*it)->IsRadio() ? "radio" : "tv", (*it)->GroupName().c_str());
+    if (strFileName.Left(strCheckPath.length()) == strCheckPath)
+    {
+      strFileName.erase(0, strCheckPath.length());
+      return (*it)->GetByIndex(atoi(strFileName.c_str()));
+    }
+  }
+
+  // no match
+  CFileItemPtr retVal(new CFileItem);
+  return retVal;
+}
+
+CPVRChannelGroupPtr CPVRChannelGroups::GetById(int iGroupId) const
+{
+  CSingleLock lock(m_critSection);
+  for (std::vector<CPVRChannelGroupPtr>::const_iterator it = m_groups.begin(); it != m_groups.end(); it++)
+  {
+    if ((*it)->GroupID() == iGroupId)
+      return *it;
+  }
+
+  CPVRChannelGroupPtr empty;
+  return empty;
+}
+
+CPVRChannelGroupPtr CPVRChannelGroups::GetByName(const CStdString &strName) const
+{
+  CSingleLock lock(m_critSection);
+  for (std::vector<CPVRChannelGroupPtr>::const_iterator it = m_groups.begin(); it != m_groups.end(); it++)
+  {
+    if ((*it)->GroupName().Equals(strName))
+      return *it;
+  }
+
+  CPVRChannelGroupPtr empty;
+  return empty;
+}
+
+void CPVRChannelGroups::RemoveFromAllGroups(const CPVRChannel &channel)
+{
+  CSingleLock lock(m_critSection);
+  for (std::vector<CPVRChannelGroupPtr>::const_iterator it = m_groups.begin(); it != m_groups.end(); it++)
+  {
+    // only delete the channel from non-system groups
+    if (!(*it)->IsInternalGroup())
+      (*it)->RemoveFromGroup(channel);
+  }
+}
+
+bool CPVRChannelGroups::Update(bool bChannelsOnly /* = false */)
+{
+  bool bUpdateAllGroups = !bChannelsOnly && g_guiSettings.GetBool("pvrmanager.syncchannelgroups");
+  bool bReturn(true);
+
+  // sync groups
+  if (bUpdateAllGroups)
+    GetGroupsFromClients();
+
+  // sync channels in groups
+  {
+    CSingleLock lock(m_critSection);
+    for (std::vector<CPVRChannelGroupPtr>::iterator it = m_groups.begin(); it != m_groups.end(); it++)
+    {
+      if (bUpdateAllGroups || (*it)->IsInternalGroup())
+        bReturn = (*it)->Update() && bReturn;
+    }
+  }
+
+  // persist changes
+  return PersistAll() && bReturn;
+}
+
+bool CPVRChannelGroups::UpdateGroupsEntries(const CPVRChannelGroups &groups)
+{
+  CSingleLock lock(m_critSection);
+
+  // go through groups list and check for deleted groups
+  for (int iGroupPtr = m_groups.size() - 1; iGroupPtr > 0; iGroupPtr--)
+  {
+    CPVRChannelGroup existingGroup(*m_groups.at(iGroupPtr));
+    CPVRChannelGroupPtr group = groups.GetByName(existingGroup.GroupName());
+    // user defined group wasn't found
+    if (existingGroup.GroupType() == PVR_GROUP_TYPE_DEFAULT && !group)
+    {
+      CLog::Log(LOGDEBUG, "PVR - %s - user defined group %s with id '%u' does not exist on the client anymore; deleting it", __FUNCTION__, existingGroup.GroupName().c_str(), existingGroup.GroupID());
+      DeleteGroup(*m_groups.at(iGroupPtr));
+    }
+  }
+
+  // go through the groups list and check for new groups
+  for (std::vector<CPVRChannelGroupPtr>::const_iterator it = groups.m_groups.begin(); it != m_groups.end(); it++)
+  {
+    // check if this group is present in this container
+    CPVRChannelGroupPtr existingGroup = GetByName((*it)->GroupName());
+
+    // add it if not
+    if (!existingGroup)
+      m_groups.push_back(CPVRChannelGroupPtr(new CPVRChannelGroup(m_bRadio, -1, (*it)->GroupName())));
+  }
+
+  return true;
+}
+
+bool CPVRChannelGroups::LoadUserDefinedChannelGroups(void)
+{
+  CPVRDatabase *database = GetPVRDatabase();
+  if (!database)
+    return false;
+
+  bool bSyncWithBackends = g_guiSettings.GetBool("pvrmanager.syncchannelgroups");
+
+  CSingleLock lock(m_critSection);
+
+  // load the other groups from the database
+  int iSize = m_groups.size();
+  database->Get(*this);
+  CLog::Log(LOGDEBUG, "PVR - %s - %d user defined %s channel groups fetched from the database", __FUNCTION__, (int) (m_groups.size() - iSize), m_bRadio ? "radio" : "TV");
+
+  // load groups from the backends if the option is enabled
+  iSize = m_groups.size();
+  if (bSyncWithBackends)
+  {
+    GetGroupsFromClients();
+    CLog::Log(LOGDEBUG, "PVR - %s - %d new user defined %s channel groups fetched from clients", __FUNCTION__, (int) (m_groups.size() - iSize), m_bRadio ? "radio" : "TV");
+  }
+  else
+    CLog::Log(LOGDEBUG, "PVR - %s - 'synchannelgroups' is disabled; skipping groups from clients", __FUNCTION__);
+
+  // load group members
+  for (std::vector<CPVRChannelGroupPtr>::iterator it = m_groups.begin(); it != m_groups.end(); it++)
+    (*it)->Load();
+
+  // persist changes if we fetched groups from the backends
+  return bSyncWithBackends ? PersistAll() : true;
+}
+
+bool CPVRChannelGroups::Load(void)
+{
+  CSingleLock lock(m_critSection);
+
+  // remove previous contents
+  Clear();
+
+  CLog::Log(LOGDEBUG, "PVR - %s - loading all %s channel groups", __FUNCTION__, m_bRadio ? "radio" : "TV");
+
+  // create and load the internal channel group
+  CPVRChannelGroupPtr internalChannels = CPVRChannelGroupPtr(new CPVRChannelGroupInternal(m_bRadio));
+  m_groups.push_back(internalChannels);
+  internalChannels->Load();
+
+  // load the other groups from the database
+  LoadUserDefinedChannelGroups();
+
+  // set the internal group as selected at startup
+  SetSelectedGroup(internalChannels);
+
+  CLog::Log(LOGDEBUG, "PVR - %s - %d %s channel groups loaded", __FUNCTION__, (int) m_groups.size(), m_bRadio ? "radio" : "TV");
+
+  // need at least 1 group
+  return m_groups.size() > 0;
+}
+
+bool CPVRChannelGroups::PersistAll(void)
+{
+  bool bReturn(true);
+  CLog::Log(LOGDEBUG, "PVR - %s - persisting all changes in channel groups", __FUNCTION__);
+
+  CSingleLock lock(m_critSection);
+  for (std::vector<CPVRChannelGroupPtr>::iterator it = m_groups.begin(); it != m_groups.end(); it++)
+    bReturn &= (*it)->Persist();
+
+  return bReturn;
+}
+
+CPVRChannelGroupPtr CPVRChannelGroups::GetGroupAll(void) const
+{
+  CSingleLock lock(m_critSection);
+  if (m_groups.size() > 0)
+    return m_groups.at(0);
+
+  CPVRChannelGroupPtr empty;
+  return empty;
+}
+
+int CPVRChannelGroups::GetGroupList(CFileItemList* results) const
+{
+  int iReturn(0);
+  CSingleLock lock(m_critSection);
+
+  CStdString strPath;
+  for (std::vector<CPVRChannelGroupPtr>::const_iterator it = m_groups.begin(); it != m_groups.end(); it++)
+  {
+    strPath.Format("channels/%s/%i", m_bRadio ? "radio" : "tv", (*it)->GroupID());
+    CFileItemPtr group(new CFileItem(strPath, true));
+    group->m_strTitle = (*it)->GroupName();
+    results->Add(group);
+    ++iReturn;
+  }
+
+  return iReturn;
+}
+
+CPVRChannelGroupPtr CPVRChannelGroups::GetPreviousGroup(const CPVRChannelGroup &group) const
+{
+  bool bReturnNext(false);
+
+  {
+    CSingleLock lock(m_critSection);
+    for (std::vector<CPVRChannelGroupPtr>::const_reverse_iterator it = m_groups.rbegin(); it != m_groups.rend(); it++)
+    {
+      // return this entry
+      if (bReturnNext)
+        return *it;
+
+      // return the next entry
+      if ((*it)->GroupID() == group.GroupID())
+        bReturnNext = true;
+    }
+  }
+
+  // no match
+  return GetGroupAll();
+}
+
+CPVRChannelGroupPtr CPVRChannelGroups::GetNextGroup(const CPVRChannelGroup &group) const
+{
+  bool bReturnNext(false);
+
+  {
+    CSingleLock lock(m_critSection);
+    for (std::vector<CPVRChannelGroupPtr>::const_iterator it = m_groups.begin(); it != m_groups.end(); it++)
+    {
+      // return this entry
+      if (bReturnNext)
+        return *it;
+
+      // return the next entry
+      if ((*it)->GroupID() == group.GroupID())
+        bReturnNext = true;
+    }
+  }
+
+  // no match
+  return GetGroupAll();
+}
+
+CPVRChannelGroupPtr CPVRChannelGroups::GetSelectedGroup(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_selectedGroup;
+}
+
+void CPVRChannelGroups::SetSelectedGroup(CPVRChannelGroupPtr group)
+{
+  // update the selected group
+  {
+    CSingleLock lock(m_critSection);
+    m_selectedGroup = group;
+  }
+
+  // update the channel number cache
+  group->Renumber();
+}
+
+bool CPVRChannelGroups::AddGroup(const CStdString &strName)
+{
+  bool bPersist(false);
+  CPVRChannelGroupPtr group;
+
+  {
+    CSingleLock lock(m_critSection);
+
+    // check if there's no group with the same name yet
+    group = GetByName(strName);
+    if (!group)
+    {
+      // create a new group
+      group = CPVRChannelGroupPtr(new CPVRChannelGroup(m_bRadio, -1, strName));
+      m_groups.push_back(group);
+      bPersist = true;
+    }
+  }
+
+  // persist in the db if a new group was added
+  return bPersist ? group->Persist() : true;
+}
+
+bool CPVRChannelGroups::DeleteGroup(const CPVRChannelGroup &group)
+{
+  // don't delete internal groups
+  if (group.IsInternalGroup())
+  {
+    CLog::Log(LOGERROR, "PVR - %s - cannot delete internal group '%s'", __FUNCTION__, group.GroupName().c_str());
+    return false;
+  }
+
+  // delete the group in this container
+  CSingleLock lock(m_critSection);
+  for (std::vector<CPVRChannelGroupPtr>::iterator it = m_groups.begin(); it != m_groups.end(); it++)
+  {
+    if ((*it)->GroupID() == group.GroupID())
+    {
+      // update the selected group in the gui if it's deleted
+      CPVRChannelGroupPtr selectedGroup = GetSelectedGroup();
+      if (selectedGroup && *selectedGroup == group)
+        g_PVRManager.SetPlayingGroup(GetGroupAll());
+
+      m_groups.erase(it);
+      break;
+    }
+  }
+
+  // delete the group from the database
+  CPVRDatabase *database = GetPVRDatabase();
+  return database ? database->Delete(group) : false;
+}
+
+void CPVRChannelGroups::FillGroupsGUI(int iWindowId, int iControlId) const
+{
+  int iListGroupPtr(0);
+  int iSelectedGroupPtr(0);
+  CPVRChannelGroupPtr selectedGroup = g_PVRManager.GetPlayingGroup(false);
+  std::vector<CGUIMessage> messages;
+
+  // fetch all groups
+  {
+    CSingleLock lock(m_critSection);
+    for (std::vector<CPVRChannelGroupPtr>::const_iterator it = m_groups.begin(); it != m_groups.end(); it++)
+    {
+      // skip empty groups
+      if ((*it)->Size() == 0)
+        continue;
+
+      if ((*it)->GroupID() == selectedGroup->GroupID())
+        iSelectedGroupPtr = iListGroupPtr;
+
+      CGUIMessage msg(GUI_MSG_LABEL_ADD, iWindowId, iControlId, iListGroupPtr++);
+      msg.SetLabel((*it)->GroupName());
+      messages.push_back(msg);
+    }
+  }
+
+  // send updates
+  for (std::vector<CGUIMessage>::iterator it = messages.begin(); it != messages.end(); it++)
+    g_windowManager.SendMessage(*it);
+
+  // selected group
+  CGUIMessage msgSel(GUI_MSG_ITEM_SELECT, iWindowId, iControlId, iSelectedGroupPtr);
+  g_windowManager.SendMessage(msgSel);
+}
diff --git a/xbmc/pvr/channels/PVRChannelGroupsContainer.cpp b/xbmc/pvr/channels/PVRChannelGroupsContainer.cpp
new file mode 100644
index 0000000..51e5be7
--- /dev/null
+++ b/xbmc/pvr/channels/PVRChannelGroupsContainer.cpp
@@ -0,0 +1,285 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "PVRChannelGroupsContainer.h"
+#include "URL.h"
+#include "dialogs/GUIDialogOK.h"
+#include "guilib/LocalizeStrings.h"
+#include "utils/URIUtils.h"
+#include "utils/log.h"
+#include "pvr/PVRManager.h"
+
+using namespace PVR;
+
+CPVRChannelGroupsContainer::CPVRChannelGroupsContainer(void) :
+    m_groupsRadio(new CPVRChannelGroups(true)),
+    m_groupsTV(new CPVRChannelGroups(false)),
+    m_bUpdateChannelsOnly(false),
+    m_bIsUpdating(false)
+{
+}
+
+CPVRChannelGroupsContainer::~CPVRChannelGroupsContainer(void)
+{
+  delete m_groupsRadio;
+  delete m_groupsTV;
+}
+
+bool CPVRChannelGroupsContainer::Update(bool bChannelsOnly /* = false */)
+{
+  CSingleLock lock(m_critSection);
+  if (m_bIsUpdating)
+    return false;
+  m_bIsUpdating = true;
+  m_bUpdateChannelsOnly = bChannelsOnly;
+  lock.Leave();
+
+  CLog::Log(LOGDEBUG, "CPVRChannelGroupsContainer - %s - updating %s", __FUNCTION__, bChannelsOnly ? "channels" : "channel groups");
+  bool bReturn = m_groupsRadio->Update(bChannelsOnly) &&
+       m_groupsTV->Update(bChannelsOnly);
+
+  lock.Enter();
+  m_bIsUpdating = false;
+  lock.Leave();
+
+  return bReturn;
+}
+
+bool CPVRChannelGroupsContainer::Load(void)
+{
+  Unload();
+
+  return m_groupsRadio->Load() &&
+         m_groupsTV->Load();
+}
+
+void CPVRChannelGroupsContainer::Unload(void)
+{
+  m_groupsRadio->Clear();
+  m_groupsTV->Clear();
+}
+
+CPVRChannelGroups *CPVRChannelGroupsContainer::Get(bool bRadio) const
+{
+  return bRadio ? m_groupsRadio : m_groupsTV;
+}
+
+CPVRChannelGroupPtr CPVRChannelGroupsContainer::GetGroupAll(bool bRadio) const
+{
+  return Get(bRadio)->GetGroupAll();
+}
+
+CPVRChannelGroupPtr CPVRChannelGroupsContainer::GetByIdFromAll(int iGroupId) const
+{
+  CPVRChannelGroupPtr group = m_groupsTV->GetById(iGroupId);
+  if (!group)
+    group = m_groupsRadio->GetById(iGroupId);
+
+  return group;
+}
+
+CPVRChannelPtr CPVRChannelGroupsContainer::GetChannelById(int iChannelId) const
+{
+  CPVRChannelPtr channel = m_groupsTV->GetGroupAll()->GetByChannelID(iChannelId);
+  if (!channel)
+    channel = m_groupsRadio->GetGroupAll()->GetByChannelID(iChannelId);
+
+  return channel;
+}
+
+CPVRChannelPtr CPVRChannelGroupsContainer::GetChannelByEpgId(int iEpgId) const
+{
+  CPVRChannelPtr channel = m_groupsTV->GetGroupAll()->GetByChannelEpgID(iEpgId);
+  if (!channel)
+    channel = m_groupsRadio->GetGroupAll()->GetByChannelEpgID(iEpgId);
+
+  return channel;
+}
+
+bool CPVRChannelGroupsContainer::GetGroupsDirectory(CFileItemList *results, bool bRadio)
+{
+  const CPVRChannelGroups *channelGroups = Get(bRadio);
+  if (channelGroups)
+  {
+    channelGroups->GetGroupList(results);
+    return true;
+  }
+  return false;
+}
+
+CFileItemPtr CPVRChannelGroupsContainer::GetByPath(const CStdString &strPath) const
+{
+  for (unsigned int bRadio = 0; bRadio <= 1; bRadio++)
+  {
+    const CPVRChannelGroups *groups = Get(bRadio == 1);
+    CFileItemPtr retVal = groups->GetByPath(strPath);
+    if (retVal && retVal->HasPVRChannelInfoTag())
+      return retVal;
+  }
+
+  CFileItemPtr retVal(new CFileItem);
+  return retVal;
+}
+
+bool CPVRChannelGroupsContainer::GetDirectory(const CStdString& strPath, CFileItemList &results)
+{
+  CStdString strBase(strPath);
+
+  /* get the filename from curl */
+  CURL url(strPath);
+  CStdString fileName = url.GetFileName();
+  URIUtils::RemoveSlashAtEnd(fileName);
+
+  if (fileName == "channels")
+  {
+    CFileItemPtr item;
+
+    /* all tv channels */
+    item.reset(new CFileItem(strBase + "/tv/", true));
+    item->SetLabel(g_localizeStrings.Get(19020));
+    item->SetLabelPreformated(true);
+    results.Add(item);
+
+    /* all radio channels */
+    item.reset(new CFileItem(strBase + "/radio/", true));
+    item->SetLabel(g_localizeStrings.Get(19021));
+    item->SetLabelPreformated(true);
+    results.Add(item);
+
+    return true;
+  }
+  else if (fileName == "channels/tv")
+  {
+    return GetGroupsDirectory(&results, false);
+  }
+  else if (fileName == "channels/radio")
+  {
+    return GetGroupsDirectory(&results, true);
+  }
+  else if (fileName.Left(12) == "channels/tv/")
+  {
+    CStdString strGroupName(fileName.substr(12));
+    URIUtils::RemoveSlashAtEnd(strGroupName);
+    CPVRChannelGroupPtr group = GetTV()->GetByName(strGroupName);
+    if (!group)
+      group = GetGroupAllTV();
+    if (group)
+      group->GetMembers(results, !fileName.Right(7).Equals(".hidden"));
+    return true;
+  }
+  else if (fileName.Left(15) == "channels/radio/")
+  {
+    CStdString strGroupName(fileName.substr(15));
+    URIUtils::RemoveSlashAtEnd(strGroupName);
+    CPVRChannelGroupPtr group = GetRadio()->GetByName(strGroupName);
+    if (!group)
+      group = GetGroupAllRadio();
+    if (group)
+      group->GetMembers(results, !fileName.Right(7).Equals(".hidden"));
+    return true;
+  }
+
+  return false;
+}
+
+int CPVRChannelGroupsContainer::GetNumChannelsFromAll()
+{
+  return GetGroupAllTV()->Size() + GetGroupAllRadio()->Size();
+}
+
+CPVRChannelGroupPtr CPVRChannelGroupsContainer::GetSelectedGroup(bool bRadio) const
+{
+  return Get(bRadio)->GetSelectedGroup();
+}
+
+CPVRChannelPtr CPVRChannelGroupsContainer::GetByUniqueID(int iClientChannelNumber, int iClientID)
+{
+  CPVRChannelPtr channel;
+  CPVRChannelGroupPtr channelgroup = GetGroupAllTV();
+  if (channelgroup)
+    channel = channelgroup->GetByClient(iClientChannelNumber, iClientID);
+
+  if (!channelgroup || !channel)
+    channelgroup = GetGroupAllRadio();
+  if (channelgroup)
+    channel = channelgroup->GetByClient(iClientChannelNumber, iClientID);
+
+  return channel;
+}
+
+CFileItemPtr CPVRChannelGroupsContainer::GetByChannelIDFromAll(int iChannelID)
+{
+  CPVRChannelPtr channel;
+  CPVRChannelGroupPtr channelgroup = GetGroupAllTV();
+  if (channelgroup)
+    channel = channelgroup->GetByChannelID(iChannelID);
+
+  if (!channel)
+  {
+    channelgroup = GetGroupAllRadio();
+    if (channelgroup)
+      channel = channelgroup->GetByChannelID(iChannelID);
+  }
+
+  if (channel)
+  {
+    CFileItemPtr retVal = CFileItemPtr(new CFileItem(*channel));
+    return retVal;
+  }
+
+  CFileItemPtr retVal = CFileItemPtr(new CFileItem);
+  return retVal;
+}
+
+void CPVRChannelGroupsContainer::SearchMissingChannelIcons(void)
+{
+  CLog::Log(LOGINFO, "PVRChannelGroupsContainer - %s - starting channel icon search", __FUNCTION__);
+
+  // TODO: Add Process dialog here
+  CPVRChannelGroupPtr channelgrouptv  = GetGroupAllTV();
+  CPVRChannelGroupPtr channelgroupradio = GetGroupAllRadio();
+
+  if (channelgrouptv)
+    channelgrouptv->SearchAndSetChannelIcons(true);
+  if (channelgroupradio)
+    channelgroupradio->SearchAndSetChannelIcons(true);
+
+  CGUIDialogOK::ShowAndGetInput(19103,0,20177,0);
+}
+
+CFileItemPtr CPVRChannelGroupsContainer::GetLastPlayedChannel(void) const
+{
+  CFileItemPtr lastChannel = GetGroupAllTV()->GetLastPlayedChannel();
+  bool bHasTVChannel(lastChannel && lastChannel->HasPVRChannelInfoTag());
+
+  CFileItemPtr lastRadioChannel = GetGroupAllRadio()->GetLastPlayedChannel();
+  bool bHasRadioChannel(lastRadioChannel && lastRadioChannel->HasPVRChannelInfoTag());
+
+  if (!bHasTVChannel || (bHasRadioChannel && lastChannel->GetPVRChannelInfoTag()->LastWatched() < lastRadioChannel->GetPVRChannelInfoTag()->LastWatched()))
+    return lastRadioChannel;
+
+  return lastChannel;
+}
+
+bool CPVRChannelGroupsContainer::CreateChannel(const CPVRChannel &channel)
+{
+  return GetGroupAll(channel.IsRadio())->AddNewChannel(channel);
+}
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp b/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
new file mode 100644
index 0000000..cf7108e
--- /dev/null
+++ b/xbmc/pvr/dialogs/GUIDialogPVRChannelManager.cpp
@@ -0,0 +1,854 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogPVRChannelManager.h"
+
+#include "FileItem.h"
+#include "GUIDialogPVRGroupManager.h"
+#include "dialogs/GUIDialogFileBrowser.h"
+#include "guilib/GUIKeyboardFactory.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "dialogs/GUIDialogSelect.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "guilib/GUIEditControl.h"
+#include "guilib/GUIRadioButtonControl.h"
+#include "guilib/GUISpinControlEx.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/addons/PVRClients.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "storage/MediaManager.h"
+
+#define BUTTON_OK                 4
+#define BUTTON_APPLY              5
+#define BUTTON_CANCEL             6
+#define RADIOBUTTON_ACTIVE        7
+#define EDIT_NAME                 8
+#define BUTTON_CHANNEL_LOGO       9
+#define IMAGE_CHANNEL_LOGO        10
+#define RADIOBUTTON_USEEPG        12
+#define SPIN_EPGSOURCE_SELECTION  13
+#define RADIOBUTTON_PARENTAL_LOCK 14
+#define CONTROL_LIST_CHANNELS     20
+#define BUTTON_GROUP_MANAGER      30
+#define BUTTON_EDIT_CHANNEL       31
+#define BUTTON_DELETE_CHANNEL     32
+#define BUTTON_NEW_CHANNEL        33
+#define BUTTON_RADIO_TV           34
+
+using namespace std;
+using namespace PVR;
+
+CGUIDialogPVRChannelManager::CGUIDialogPVRChannelManager(void) :
+    CGUIDialog(WINDOW_DIALOG_PVR_CHANNEL_MANAGER, "DialogPVRChannelManager.xml"),
+    m_bIsRadio(false),
+    m_channelItems(new CFileItemList)
+{
+}
+
+CGUIDialogPVRChannelManager::~CGUIDialogPVRChannelManager(void)
+{
+  delete m_channelItems;
+}
+
+bool CGUIDialogPVRChannelManager::OnActionClose(const CAction &action)
+{
+  bool bReturn(false);
+  int iActionId = action.GetID();
+  if (iActionId == ACTION_PREVIOUS_MENU || iActionId == ACTION_PARENT_DIR)
+  {
+    Close();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRChannelManager::OnActionMove(const CAction &action)
+{
+  bool bReturn(false);
+  int iActionId = action.GetID();
+  if (GetFocusedControlID() == CONTROL_LIST_CHANNELS &&
+      (iActionId == ACTION_MOVE_DOWN || iActionId == ACTION_MOVE_UP ||
+       iActionId == ACTION_PAGE_DOWN || iActionId == ACTION_PAGE_UP))
+  {
+    bReturn = true;
+    if (!m_bMovingMode)
+    {
+      CGUIDialog::OnAction(action);
+      int iSelected = m_viewControl.GetSelectedItem();
+      if (iSelected != m_iSelected)
+      {
+        m_iSelected = iSelected;
+        SetData(m_iSelected);
+      }
+    }
+    else
+    {
+      CStdString strNumber;
+      CGUIDialog::OnAction(action);
+
+      bool bMoveUp        = iActionId == ACTION_PAGE_UP || iActionId == ACTION_MOVE_UP;
+      unsigned int iLines = bMoveUp ? abs(m_iSelected - m_viewControl.GetSelectedItem()) : 1;
+      bool bOutOfBounds   = bMoveUp ? m_iSelected <= 0  : m_iSelected >= m_channelItems->Size() - 1;
+      if (bOutOfBounds)
+      {
+        bMoveUp = !bMoveUp;
+        iLines  = m_channelItems->Size() - 1;
+      }
+
+      for (unsigned int iLine = 0; iLine < iLines; iLine++)
+      {
+        unsigned int iNewSelect = bMoveUp ? m_iSelected - 1 : m_iSelected + 1;
+        if (m_channelItems->Get(iNewSelect)->GetProperty("Number").asString() != "-")
+        {
+          strNumber.Format("%i", m_iSelected+1);
+          m_channelItems->Get(iNewSelect)->SetProperty("Number", strNumber);
+          strNumber.Format("%i", iNewSelect+1);
+          m_channelItems->Get(m_iSelected)->SetProperty("Number", strNumber);
+        }
+        m_channelItems->Swap(iNewSelect, m_iSelected);
+        m_iSelected = iNewSelect;
+      }
+
+      m_viewControl.SetItems(*m_channelItems);
+      m_viewControl.SetSelectedItem(m_iSelected);
+    }
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRChannelManager::OnAction(const CAction& action)
+{
+  return OnActionClose(action) ||
+      OnActionMove(action) ||
+      CGUIDialog::OnAction(action);
+}
+
+bool CGUIDialogPVRChannelManager::OnMessageInit(CGUIMessage &message)
+{
+  CGUIWindow::OnMessage(message);
+  m_iSelected = 0;
+  m_bIsRadio = false;
+  m_bMovingMode = false;
+  m_bContainsChanges = false;
+  SetProperty("IsRadio", "");
+  Update();
+  SetData(m_iSelected);
+
+  return true;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickListChannels(CGUIMessage &message)
+{
+  if (!m_bMovingMode)
+  {
+    int iAction = message.GetParam1();
+    int iItem = m_viewControl.GetSelectedItem();
+
+    /* Check file item is in list range and get his pointer */
+    if (iItem < 0 || iItem >= (int)m_channelItems->Size()) return true;
+
+    /* Process actions */
+    if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+    {
+      /* Show Contextmenu */
+      OnPopupMenu(iItem);
+
+      return true;
+    }
+  }
+  else
+  {
+    CFileItemPtr pItem = m_channelItems->Get(m_iSelected);
+    if (pItem)
+    {
+      pItem->SetProperty("Changed", true);
+      pItem->Select(false);
+      m_bMovingMode = false;
+      m_bContainsChanges = true;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonOK(CGUIMessage &message)
+{
+  SaveList();
+  Close();
+  return true;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonApply(CGUIMessage &message)
+{
+  SaveList();
+  return true;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonCancel(CGUIMessage &message)
+{
+  Close();
+  return true;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonRadioTV(CGUIMessage &message)
+{
+  if (m_bContainsChanges)
+  {
+    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+    if (!pDialog)
+      return true;
+
+    pDialog->SetHeading(20052);
+    pDialog->SetLine(0, "");
+    pDialog->SetLine(1, 19212);
+    pDialog->SetLine(2, 20103);
+    pDialog->DoModal();
+
+    if (pDialog->IsConfirmed())
+      SaveList();
+  }
+
+  m_iSelected = 0;
+  m_bMovingMode = false;
+  m_bContainsChanges = false;
+  m_bIsRadio = !m_bIsRadio;
+  SetProperty("IsRadio", m_bIsRadio ? "true" : "");
+  Update();
+  SetData(m_iSelected);
+  return true;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonRadioActive(CGUIMessage &message)
+{
+  CGUIRadioButtonControl *pRadioButton = (CGUIRadioButtonControl *)GetControl(RADIOBUTTON_ACTIVE);
+  if (pRadioButton)
+  {
+    CFileItemPtr pItem = m_channelItems->Get(m_iSelected);
+    if (pItem)
+    {
+      pItem->SetProperty("Changed", true);
+      pItem->SetProperty("ActiveChannel", pRadioButton->IsSelected());
+      m_bContainsChanges = true;
+      Renumber();
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonRadioParentalLocked(CGUIMessage &message)
+{
+  CGUIRadioButtonControl *pRadioButton = (CGUIRadioButtonControl *)GetControl(RADIOBUTTON_PARENTAL_LOCK);
+
+  // ask for PIN first
+  if (!g_PVRManager.CheckParentalPIN(g_localizeStrings.Get(19262).c_str()))
+  {
+    pRadioButton->SetSelected(!pRadioButton->IsSelected());
+    return false;
+  }
+
+  if (pRadioButton)
+  {
+    CFileItemPtr pItem = m_channelItems->Get(m_iSelected);
+    if (pItem)
+    {
+      pItem->SetProperty("Changed", true);
+      pItem->SetProperty("ParentalLocked", pRadioButton->IsSelected());
+      m_bContainsChanges = true;
+      Renumber();
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonEditName(CGUIMessage &message)
+{
+  CGUIEditControl *pEdit = (CGUIEditControl *)GetControl(EDIT_NAME);
+  if (pEdit)
+  {
+    CFileItemPtr pItem = m_channelItems->Get(m_iSelected);
+    if (pItem)
+    {
+      pItem->SetProperty("Changed", true);
+      pItem->SetProperty("Name", pEdit->GetLabel2());
+      m_bContainsChanges = true;
+
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonChannelLogo(CGUIMessage &message)
+{
+  CFileItemPtr pItem = m_channelItems->Get(m_iSelected);
+  if (!pItem)
+    return false;
+  if (g_settings.GetCurrentProfile().canWriteSources() && !g_passwordManager.IsProfileLockUnlocked())
+    return false;
+  else if (!g_passwordManager.IsMasterLockUnlocked(true))
+    return false;
+
+  // setup our thumb list
+  CFileItemList items;
+
+  // add the current thumb, if available
+  if (!pItem->GetProperty("Icon").asString().empty())
+  {
+    CFileItemPtr current(new CFileItem("thumb://Current", false));
+    current->SetThumbnailImage(pItem->GetPVRChannelInfoTag()->IconPath());
+    current->SetLabel(g_localizeStrings.Get(20016));
+    items.Add(current);
+  }
+  else if (pItem->HasThumbnail())
+  { // already have a thumb that the share doesn't know about - must be a local one, so we mayaswell reuse it.
+    CFileItemPtr current(new CFileItem("thumb://Current", false));
+    current->SetThumbnailImage(pItem->GetThumbnailImage());
+    current->SetLabel(g_localizeStrings.Get(20016));
+    items.Add(current);
+  }
+
+  // and add a "no thumb" entry as well
+  CFileItemPtr nothumb(new CFileItem("thumb://None", false));
+  nothumb->SetIconImage(pItem->GetIconImage());
+  nothumb->SetLabel(g_localizeStrings.Get(20018));
+  items.Add(nothumb);
+
+  CStdString strThumb;
+  VECSOURCES shares;
+  if (g_guiSettings.GetString("pvrmenu.iconpath") != "")
+  {
+    CMediaSource share1;
+    share1.strPath = g_guiSettings.GetString("pvrmenu.iconpath");
+    share1.strName = g_localizeStrings.Get(19018);
+    shares.push_back(share1);
+  }
+  g_mediaManager.GetLocalDrives(shares);
+  if (!CGUIDialogFileBrowser::ShowAndGetImage(items, shares, g_localizeStrings.Get(1030), strThumb))
+    return false;
+
+  if (strThumb == "thumb://Current")
+    return true;
+
+  if (strThumb == "thumb://None")
+    strThumb = "";
+
+  pItem->SetProperty("Icon", strThumb);
+  pItem->SetProperty("Changed", true);
+  m_bContainsChanges = true;
+  return true;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonUseEPG(CGUIMessage &message)
+{
+  CGUIRadioButtonControl *pRadioButton = (CGUIRadioButtonControl *)GetControl(RADIOBUTTON_USEEPG);
+  if (pRadioButton)
+  {
+    CFileItemPtr pItem = m_channelItems->Get(m_iSelected);
+    if (pItem)
+    {
+      pItem->SetProperty("Changed", true);
+      pItem->SetProperty("UseEPG", pRadioButton->IsSelected());
+      m_bContainsChanges = true;
+
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickEPGSourceSpin(CGUIMessage &message)
+{
+  // TODO: Add EPG scraper support
+  return true;
+//  CGUISpinControlEx *pSpin = (CGUISpinControlEx *)GetControl(SPIN_EPGSOURCE_SELECTION);
+//  if (pSpin)
+//  {
+//    CFileItemPtr pItem = m_channelItems->Get(m_iSelected);
+//    if (pItem)
+//    {
+//      pItem->SetProperty("EPGSource", (int)0);
+//      pItem->SetProperty("Changed", true);
+//      m_bContainsChanges = true;
+//      return true;
+//    }
+//  }
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonGroupManager(CGUIMessage &message)
+{
+  /* Load group manager dialog */
+  CGUIDialogPVRGroupManager* pDlgInfo = (CGUIDialogPVRGroupManager*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GROUP_MANAGER);
+  if (!pDlgInfo)
+    return false;
+
+  pDlgInfo->SetRadio(m_bIsRadio);
+
+  /* Open dialog window */
+  pDlgInfo->DoModal();
+
+  Update();
+  return true;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonEditChannel(CGUIMessage &message)
+{
+  CFileItemPtr pItem = m_channelItems->Get(m_iSelected);
+  if (!pItem)
+    return false;
+
+  if (pItem->GetProperty("Virtual").asBoolean())
+  {
+    CStdString strURL = pItem->GetProperty("StreamURL").asString();
+    if (CGUIKeyboardFactory::ShowAndGetInput(strURL, g_localizeStrings.Get(19214), false))
+      pItem->SetProperty("StreamURL", strURL);
+    return true;
+  }
+
+  CGUIDialogOK::ShowAndGetInput(19033,19038,0,0);
+  return true;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonDeleteChannel(CGUIMessage &message)
+{
+  CFileItemPtr pItem = m_channelItems->Get(m_iSelected);
+  if (!pItem)
+    return false;
+
+  CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+  if (!pDialog)
+    return true;
+
+  pDialog->SetHeading(19211);
+  pDialog->SetLine(0, "");
+  pDialog->SetLine(1, 750);
+  pDialog->SetLine(2, "");
+  pDialog->DoModal();
+
+  if (pDialog->IsConfirmed())
+  {
+    if (pItem->GetProperty("Virtual").asBoolean())
+    {
+      pItem->GetPVRChannelInfoTag()->SetVirtual(true);
+      m_channelItems->Remove(m_iSelected);
+      m_viewControl.SetItems(*m_channelItems);
+      Renumber();
+      return true;
+    }
+    CGUIDialogOK::ShowAndGetInput(19033,19038,0,0);
+  }
+  return true;
+}
+
+bool CGUIDialogPVRChannelManager::OnClickButtonNewChannel(CGUIMessage &message)
+{
+  std::vector<long> clients;
+
+  CGUIDialogSelect* pDlgSelect = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+  if (!pDlgSelect)
+    return false;
+
+  pDlgSelect->SetHeading(19213); // Select Client
+  pDlgSelect->Add(g_localizeStrings.Get(19209));
+  clients.push_back(PVR_VIRTUAL_CLIENT_ID);
+
+  PVR_CLIENTMAP clientMap;
+  if (g_PVRClients->GetConnectedClients(clientMap) > 0)
+  {
+    PVR_CLIENTMAP_ITR itr;
+    for (itr = clientMap.begin() ; itr != clientMap.end(); itr++)
+    {
+      clients.push_back((*itr).first);
+      pDlgSelect->Add((*itr).second->Name());
+    }
+  }
+  pDlgSelect->DoModal();
+
+  int selection = pDlgSelect->GetSelectedLabel();
+  if (selection >= 0 && selection <= (int) clients.size())
+  {
+    int clientID = clients[selection];
+    if (clientID == PVR_VIRTUAL_CLIENT_ID)
+    {
+      CStdString strURL = "";
+      if (CGUIKeyboardFactory::ShowAndGetInput(strURL, g_localizeStrings.Get(19214), false))
+      {
+        if (!strURL.IsEmpty())
+        {
+          CPVRChannel *newchannel = new CPVRChannel(m_bIsRadio);
+          newchannel->SetChannelName(g_localizeStrings.Get(19204));
+          newchannel->SetEPGEnabled(false);
+          newchannel->SetVirtual(true);
+          newchannel->SetStreamURL(strURL);
+          newchannel->SetClientID(PVR_VIRTUAL_CLIENT_ID);
+          if (g_PVRChannelGroups->CreateChannel(*newchannel))
+            g_PVRChannelGroups->GetGroupAll(m_bIsRadio)->Persist();
+
+          CFileItemPtr channel(new CFileItem(newchannel));
+          if (channel)
+          {
+            channel->SetProperty("ActiveChannel", true);
+            channel->SetProperty("Name", g_localizeStrings.Get(19204));
+            channel->SetProperty("UseEPG", false);
+            channel->SetProperty("Icon", newchannel->IconPath());
+            channel->SetProperty("EPGSource", (int)0);
+            channel->SetProperty("ClientName", g_localizeStrings.Get(19209));
+            channel->SetProperty("ParentalLocked", false);
+
+            m_channelItems->AddFront(channel, m_iSelected);
+            m_viewControl.SetItems(*m_channelItems);
+            Renumber();
+          }
+        }
+      }
+    }
+    else
+    {
+      CGUIDialogOK::ShowAndGetInput(19033,19038,0,0);
+    }
+  }
+  return true;
+}
+
+bool CGUIDialogPVRChannelManager::OnMessageClick(CGUIMessage &message)
+{
+  int iControl = message.GetSenderId();
+  switch(iControl)
+  {
+  case CONTROL_LIST_CHANNELS:
+    return OnClickListChannels(message);
+  case BUTTON_OK:
+    return OnClickButtonOK(message);
+  case BUTTON_APPLY:
+    return OnClickButtonApply(message);
+  case BUTTON_CANCEL:
+    return OnClickButtonCancel(message);
+  case BUTTON_RADIO_TV:
+    return OnClickButtonRadioTV(message);
+  case RADIOBUTTON_ACTIVE:
+    return OnClickButtonRadioActive(message);
+  case RADIOBUTTON_PARENTAL_LOCK:
+    return OnClickButtonRadioParentalLocked(message);
+  case EDIT_NAME:
+    return OnClickButtonEditName(message);
+  case BUTTON_CHANNEL_LOGO:
+    return OnClickButtonChannelLogo(message);
+  case RADIOBUTTON_USEEPG:
+    return OnClickButtonUseEPG(message);
+  case SPIN_EPGSOURCE_SELECTION:
+    return OnClickEPGSourceSpin(message);
+  case BUTTON_GROUP_MANAGER:
+    return OnClickButtonGroupManager(message);
+  case BUTTON_EDIT_CHANNEL:
+    return OnClickButtonEditChannel(message);
+  case BUTTON_DELETE_CHANNEL:
+    return OnClickButtonDeleteChannel(message);
+  case BUTTON_NEW_CHANNEL:
+    return OnClickButtonNewChannel(message);
+  default:
+    return false;
+  }
+}
+
+bool CGUIDialogPVRChannelManager::OnMessage(CGUIMessage& message)
+{
+  unsigned int iMessage = message.GetMessage();
+
+  switch (iMessage)
+  {
+    case GUI_MSG_WINDOW_DEINIT:
+      Clear();
+      break;
+    case GUI_MSG_WINDOW_INIT:
+      return OnMessageInit(message);
+    case GUI_MSG_CLICKED:
+      return OnMessageClick(message);
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogPVRChannelManager::OnWindowLoaded(void)
+{
+  CGUIDialog::OnWindowLoaded();
+
+  m_viewControl.Reset();
+  m_viewControl.SetParentWindow(GetID());
+  m_viewControl.AddView(GetControl(CONTROL_LIST_CHANNELS));
+}
+
+void CGUIDialogPVRChannelManager::OnWindowUnload(void)
+{
+  CGUIDialog::OnWindowUnload();
+  m_viewControl.Reset();
+}
+
+CFileItemPtr CGUIDialogPVRChannelManager::GetCurrentListItem(int offset)
+{
+  return m_channelItems->Get(m_iSelected);
+}
+
+bool CGUIDialogPVRChannelManager::OnPopupMenu(int iItem)
+{
+  // popup the context menu
+  // grab our context menu
+  CContextButtons buttons;
+
+  // mark the item
+  if (iItem >= 0 && iItem < m_channelItems->Size())
+    m_channelItems->Get(iItem)->Select(true);
+  else
+    return false;
+
+  CFileItemPtr pItem = m_channelItems->Get(iItem);
+  if (!pItem)
+    return false;
+
+  buttons.Add(CONTEXT_BUTTON_MOVE, 116);              /* Move channel up or down */
+  if (pItem->GetProperty("Virtual").asBoolean())
+    buttons.Add(CONTEXT_BUTTON_EDIT_SOURCE, 1027);    /* Edit virtual channel URL */
+
+  int choice = CGUIDialogContextMenu::ShowAndGetChoice(buttons);
+
+  // deselect our item
+  if (iItem >= 0 && iItem < m_channelItems->Size())
+    m_channelItems->Get(iItem)->Select(false);
+
+  if (choice < 0)
+    return false;
+
+  return OnContextButton(iItem, (CONTEXT_BUTTON)choice);
+}
+
+bool CGUIDialogPVRChannelManager::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  /* Check file item is in list range and get his pointer */
+  if (itemNumber < 0 || itemNumber >= (int)m_channelItems->Size()) return false;
+
+  CFileItemPtr pItem = m_channelItems->Get(itemNumber);
+  if (!pItem)
+    return false;
+
+  if (button == CONTEXT_BUTTON_MOVE)
+  {
+    m_bMovingMode = true;
+    pItem->Select(true);
+  }
+  else if (button == CONTEXT_BUTTON_EDIT_SOURCE)
+  {
+    CStdString strURL = pItem->GetProperty("StreamURL").asString();
+    if (CGUIKeyboardFactory::ShowAndGetInput(strURL, g_localizeStrings.Get(19214), false))
+      pItem->SetProperty("StreamURL", strURL);
+  }
+  return true;
+}
+
+void CGUIDialogPVRChannelManager::SetData(int iItem)
+{
+  CGUIEditControl        *pEdit;
+  CGUIRadioButtonControl *pRadioButton;
+
+  /* Check file item is in list range and get his pointer */
+  if (iItem < 0 || iItem >= (int)m_channelItems->Size()) return;
+
+  CFileItemPtr pItem = m_channelItems->Get(iItem);
+  if (!pItem)
+    return;
+
+  pEdit = (CGUIEditControl *)GetControl(EDIT_NAME);
+  if (pEdit)
+  {
+    pEdit->SetLabel2(pItem->GetProperty("Name").asString());
+    pEdit->SetInputType(CGUIEditControl::INPUT_TYPE_TEXT, 19208);
+  }
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(RADIOBUTTON_ACTIVE);
+  if (pRadioButton) pRadioButton->SetSelected(pItem->GetProperty("ActiveChannel").asBoolean());
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(RADIOBUTTON_USEEPG);
+  if (pRadioButton) pRadioButton->SetSelected(pItem->GetProperty("UseEPG").asBoolean());
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(RADIOBUTTON_PARENTAL_LOCK);
+  if (pRadioButton) pRadioButton->SetSelected(pItem->GetProperty("ParentalLocked").asBoolean());
+}
+
+void CGUIDialogPVRChannelManager::Update()
+{
+  // lock our display, as this window is rendered from the player thread
+  g_graphicsContext.Lock();
+  m_viewControl.SetCurrentView(CONTROL_LIST_CHANNELS);
+
+  // empty the lists ready for population
+  Clear();
+
+  CPVRChannelGroupPtr channels = g_PVRChannelGroups->GetGroupAll(m_bIsRadio);
+
+  // No channels available, nothing to do.
+  if(!channels)
+    return;
+
+  for (int iChannelPtr = 0; iChannelPtr < channels->Size(); iChannelPtr++)
+  {
+    CFileItemPtr channelFile = channels->GetByIndex(iChannelPtr);
+    if (!channelFile || !channelFile->HasPVRChannelInfoTag())
+      continue;
+    const CPVRChannel *channel = channelFile->GetPVRChannelInfoTag();
+
+    channelFile->SetProperty("ActiveChannel", !channel->IsHidden());
+    channelFile->SetProperty("Name", channel->ChannelName());
+    channelFile->SetProperty("UseEPG", channel->EPGEnabled());
+    channelFile->SetProperty("Icon", channel->IconPath());
+    channelFile->SetProperty("EPGSource", (int)0);
+    channelFile->SetProperty("ParentalLocked", channel->IsLocked());
+    CStdString number; number.Format("%i", channel->ChannelNumber());
+    channelFile->SetProperty("Number", number);
+
+    if (channel->IsVirtual())
+    {
+      channelFile->SetProperty("Virtual", true);
+      channelFile->SetProperty("StreamURL", channel->StreamURL());
+    }
+
+    CStdString clientName;
+    if (channel->ClientID() == PVR_VIRTUAL_CLIENT_ID) /* XBMC internal */
+      clientName = g_localizeStrings.Get(19209);
+    else
+      g_PVRClients->GetClientName(channel->ClientID(), clientName);
+    channelFile->SetProperty("ClientName", clientName);
+
+    m_channelItems->Add(channelFile);
+  }
+
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx *)GetControl(SPIN_EPGSOURCE_SELECTION);
+  if (pSpin)
+  {
+    pSpin->Clear();
+    pSpin->AddLabel(g_localizeStrings.Get(19210), 0);
+    /// TODO: Add Labels for EPG scrapers here
+  }
+
+  Renumber();
+  m_viewControl.SetItems(*m_channelItems);
+  m_viewControl.SetSelectedItem(m_iSelected);
+
+  g_graphicsContext.Unlock();
+}
+
+void CGUIDialogPVRChannelManager::Clear(void)
+{
+  m_viewControl.Clear();
+  m_channelItems->Clear();
+}
+
+bool CGUIDialogPVRChannelManager::PersistChannel(CFileItemPtr pItem, CPVRChannelGroupPtr group, unsigned int *iChannelNumber)
+{
+  if (!pItem || !pItem->HasPVRChannelInfoTag() || !group)
+    return false;
+
+  /* get values from the form */
+  bool bHidden              = !pItem->GetProperty("ActiveChannel").asBoolean();
+  bool bVirtual             = pItem->GetProperty("Virtual").asBoolean();
+  bool bEPGEnabled          = pItem->GetProperty("UseEPG").asBoolean();
+  bool bParentalLocked      = pItem->GetProperty("ParentalLocked").asBoolean();
+  int iEPGSource            = pItem->GetProperty("EPGSource").asInteger();
+  CStdString strChannelName = pItem->GetProperty("Name").asString();
+  CStdString strIconPath    = pItem->GetProperty("Icon").asString();
+  CStdString strStreamURL   = pItem->GetProperty("StreamURL").asString();
+
+  return group->UpdateChannel(*pItem, bHidden, bVirtual, bEPGEnabled, bParentalLocked, iEPGSource, ++(*iChannelNumber), strChannelName, strIconPath, strStreamURL);
+}
+
+void CGUIDialogPVRChannelManager::SaveList(void)
+{
+  if (!m_bContainsChanges)
+   return;
+
+  /* display the progress dialog */
+  CGUIDialogProgress* pDlgProgress = (CGUIDialogProgress*)g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
+  pDlgProgress->SetHeading(190);
+  pDlgProgress->SetLine(0, "");
+  pDlgProgress->SetLine(1, 328);
+  pDlgProgress->SetLine(2, "");
+  pDlgProgress->StartModal();
+  pDlgProgress->Progress();
+  pDlgProgress->SetPercentage(0);
+
+  /* persist all channels */
+  unsigned int iNextChannelNumber(0);
+  CPVRChannelGroupPtr group = g_PVRChannelGroups->GetGroupAll(m_bIsRadio);
+  if (!group)
+    return;
+  for (int iListPtr = 0; iListPtr < m_channelItems->Size(); iListPtr++)
+  {
+    CFileItemPtr pItem = m_channelItems->Get(iListPtr);
+    PersistChannel(pItem, group, &iNextChannelNumber);
+
+    pDlgProgress->SetPercentage(iListPtr * 100 / m_channelItems->Size());
+  }
+
+  group->SortByChannelNumber();
+  group->Persist();
+  group->ResetChannelNumberCache();
+  m_bContainsChanges = false;
+  SetItemsUnchanged();
+  pDlgProgress->Close();
+}
+
+void CGUIDialogPVRChannelManager::SetItemsUnchanged(void)
+{
+  for (int iItemPtr = 0; iItemPtr < m_channelItems->Size(); iItemPtr++)
+  {
+    CFileItemPtr pItem = m_channelItems->Get(iItemPtr);
+    if (pItem)
+      pItem->SetProperty("Changed", false);
+  }
+}
+
+void CGUIDialogPVRChannelManager::Renumber(void)
+{
+  int iNextChannelNumber(0);
+  CStdString strNumber;
+  CFileItemPtr pItem;
+  for (int iChannelPtr = 0; iChannelPtr < m_channelItems->Size(); iChannelPtr++)
+  {
+    pItem = m_channelItems->Get(iChannelPtr);
+    if (pItem->GetProperty("ActiveChannel").asBoolean())
+    {
+      strNumber.Format("%i", ++iNextChannelNumber);
+      pItem->SetProperty("Number", strNumber);
+    }
+    else
+      pItem->SetProperty("Number", "-");
+  }
+}
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp b/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
new file mode 100644
index 0000000..8c312e4
--- /dev/null
+++ b/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
@@ -0,0 +1,266 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogPVRChannelsOSD.h"
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include "FileItem.h"
+#include "guilib/GUIWindowManager.h"
+#include "dialogs/GUIDialogOK.h"
+#include "GUIDialogPVRGuideInfo.h"
+#include "ViewState.h"
+#include "settings/GUISettings.h"
+#include "GUIInfoManager.h"
+
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "epg/Epg.h"
+#include "pvr/timers/PVRTimerInfoTag.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+
+using namespace std;
+using namespace PVR;
+using namespace EPG;
+
+#define CONTROL_LIST                  11
+
+CGUIDialogPVRChannelsOSD::CGUIDialogPVRChannelsOSD() :
+    CGUIDialog(WINDOW_DIALOG_PVR_OSD_CHANNELS, "DialogPVRChannelsOSD.xml"),
+    Observer()
+{
+  m_vecItems = new CFileItemList;
+}
+
+CGUIDialogPVRChannelsOSD::~CGUIDialogPVRChannelsOSD()
+{
+  delete m_vecItems;
+
+  if (IsObserving(g_infoManager))
+    g_infoManager.UnregisterObserver(this);
+}
+
+bool CGUIDialogPVRChannelsOSD::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+  case GUI_MSG_WINDOW_DEINIT:
+    {
+      Clear();
+    }
+    break;
+
+  case GUI_MSG_WINDOW_INIT:
+    {
+      /* Close dialog immediately if now TV or radio channel is playing */
+      if (!g_PVRManager.IsPlaying())
+      {
+        Close();
+        return true;
+      }
+      CGUIWindow::OnMessage(message);
+      Update();
+      return true;
+    }
+    break;
+
+  case GUI_MSG_CLICKED:
+    {
+      int iControl = message.GetSenderId();
+
+      if (m_viewControl.HasControl(iControl))   // list/thumb control
+      {
+        int iItem = m_viewControl.GetSelectedItem();
+        int iAction = message.GetParam1();
+
+        if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+        {
+          /* Switch to channel */
+          GotoChannel(iItem);
+          return true;
+        }
+        else if (iAction == ACTION_SHOW_INFO || iAction == ACTION_MOUSE_RIGHT_CLICK)
+        {
+          /* Show information Dialog */
+          ShowInfo(iItem);
+          return true;
+        }
+      }
+    }
+    break;
+
+  case GUI_MSG_MOVE:
+    {
+      int iAction = message.GetParam1();
+
+      if (iAction == ACTION_MOVE_RIGHT || iAction == ACTION_MOVE_LEFT)
+      {
+          CPVRChannelPtr channel;
+        g_PVRManager.GetCurrentChannel(channel);
+
+        CPVRChannelGroupPtr group = g_PVRManager.GetPlayingGroup(channel->IsRadio());
+        CPVRChannelGroupPtr nextGroup = iAction == ACTION_MOVE_RIGHT ? group->GetNextGroup() : group->GetPreviousGroup();
+
+        g_PVRManager.SetPlayingGroup(nextGroup);
+
+        Clear();
+        Update();
+
+        return true;
+      }
+    }
+    break;
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogPVRChannelsOSD::Update()
+{
+  // lock our display, as this window is rendered from the player thread
+  g_graphicsContext.Lock();
+
+  if (!IsObserving(g_infoManager))
+    g_infoManager.RegisterObserver(this);
+
+  m_viewControl.SetCurrentView(DEFAULT_VIEW_LIST);
+
+  // empty the list ready for population
+  Clear();
+
+  CPVRChannelPtr channel;
+  g_PVRManager.GetCurrentChannel(channel);
+  CPVRChannelGroupPtr group = g_PVRManager.GetPlayingGroup(channel->IsRadio());
+
+  if (group)
+  {
+    group->GetMembers(*m_vecItems);
+    m_viewControl.SetItems(*m_vecItems);
+    m_viewControl.SetSelectedItem(group->GetIndex(*channel));
+  }
+
+  g_graphicsContext.Unlock();
+}
+
+void CGUIDialogPVRChannelsOSD::Clear()
+{
+  m_viewControl.Clear();
+  m_vecItems->Clear();
+}
+
+void CGUIDialogPVRChannelsOSD::CloseOrSelect(unsigned int iItem)
+{
+  if (g_guiSettings.GetBool("pvrmenu.closechannelosdonswitch"))
+    Close();
+  else
+    m_viewControl.SetSelectedItem(iItem);
+}
+
+void CGUIDialogPVRChannelsOSD::GotoChannel(int item)
+{
+  /* Check file item is in list range and get his pointer */
+  if (item < 0 || item >= (int)m_vecItems->Size()) return;
+  CFileItemPtr pItem = m_vecItems->Get(item);
+
+  if (pItem->GetPath() == g_application.CurrentFile())
+  {
+    CloseOrSelect(item);
+    return;
+  }
+
+  if (g_PVRManager.IsPlaying() && pItem->HasPVRChannelInfoTag() && g_application.m_pPlayer)
+  {
+    CPVRChannel *channel = pItem->GetPVRChannelInfoTag();
+    if (!g_PVRManager.CheckParentalLock(*channel) ||
+        !g_application.m_pPlayer->SwitchChannel(*channel))
+    {
+      Close(true);
+      return;
+    }
+  }
+  else
+    CApplicationMessenger::Get().PlayFile(*pItem);
+
+  CloseOrSelect(item);
+}
+
+void CGUIDialogPVRChannelsOSD::ShowInfo(int item)
+{
+  /* Check file item is in list range and get his pointer */
+  if (item < 0 || item >= (int)m_vecItems->Size()) return;
+
+  CFileItemPtr pItem = m_vecItems->Get(item);
+  if (pItem && pItem->IsPVRChannel())
+  {
+    CPVRChannel *channel = pItem->GetPVRChannelInfoTag();
+    if (!g_PVRManager.CheckParentalLock(*channel))
+      return;
+
+    /* Get the current running show on this channel from the EPG storage */
+    CEpgInfoTag epgnow;
+    if (!channel->GetEPGNow(epgnow))
+      return;
+    CFileItem *itemNow  = new CFileItem(epgnow);
+
+    /* Load programme info dialog */
+    CGUIDialogPVRGuideInfo* pDlgInfo = (CGUIDialogPVRGuideInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GUIDE_INFO);
+    if (!pDlgInfo)
+      return;
+
+    /* inform dialog about the file item and open dialog window */
+    pDlgInfo->SetProgInfo(itemNow);
+    pDlgInfo->DoModal();
+    delete itemNow; /* delete previuosly created FileItem */
+  }
+
+  return;
+}
+
+void CGUIDialogPVRChannelsOSD::OnWindowLoaded()
+{
+  CGUIDialog::OnWindowLoaded();
+  m_viewControl.Reset();
+  m_viewControl.SetParentWindow(GetID());
+  m_viewControl.AddView(GetControl(CONTROL_LIST));
+}
+
+void CGUIDialogPVRChannelsOSD::OnWindowUnload()
+{
+  CGUIDialog::OnWindowUnload();
+  m_viewControl.Reset();
+}
+
+CGUIControl *CGUIDialogPVRChannelsOSD::GetFirstFocusableControl(int id)
+{
+  if (m_viewControl.HasControl(id))
+    id = m_viewControl.GetCurrentControl();
+
+  return CGUIWindow::GetFirstFocusableControl(id);
+}
+
+void CGUIDialogPVRChannelsOSD::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  if (msg == ObservableMessageCurrentItem)
+  {
+    g_graphicsContext.Lock();
+    m_viewControl.SetItems(*m_vecItems);
+    g_graphicsContext.Unlock();
+  }
+}
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRCutterOSD.cpp b/xbmc/pvr/dialogs/GUIDialogPVRCutterOSD.cpp
new file mode 100644
index 0000000..ba4f797
--- /dev/null
+++ b/xbmc/pvr/dialogs/GUIDialogPVRCutterOSD.cpp
@@ -0,0 +1,62 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogPVRCutterOSD.h"
+#include "utils/log.h"
+#include "Application.h"
+
+using namespace std;
+using namespace PVR;
+
+CGUIDialogPVRCutterOSD::CGUIDialogPVRCutterOSD()
+    : CGUIDialog(WINDOW_DIALOG_PVR_OSD_CUTTER, "DialogPVRCutterOSD.xml")
+{
+}
+
+CGUIDialogPVRCutterOSD::~CGUIDialogPVRCutterOSD()
+{
+}
+
+bool CGUIDialogPVRCutterOSD::OnAction(const CAction& action)
+{
+  if (action.GetID() == ACTION_PREVIOUS_MENU || action.GetID() == ACTION_PARENT_DIR)
+  {
+    Close();
+    return true;
+  }
+
+  return CGUIDialog::OnAction(action);
+}
+
+bool CGUIDialogPVRCutterOSD::OnMessage(CGUIMessage& message)
+{
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogPVRCutterOSD::OnInitWindow()
+{
+  CGUIDialog::OnInitWindow();
+}
+
+void CGUIDialogPVRCutterOSD::OnDeinitWindow(int nextWindowID)
+{
+  CGUIDialog::OnDeinitWindow(nextWindowID);
+}
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRDirectorOSD.cpp b/xbmc/pvr/dialogs/GUIDialogPVRDirectorOSD.cpp
new file mode 100644
index 0000000..4e51022
--- /dev/null
+++ b/xbmc/pvr/dialogs/GUIDialogPVRDirectorOSD.cpp
@@ -0,0 +1,68 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * DESCRIPTION:
+ *
+ * Used in Fullscreen view to control, multifeed channel groups.
+ *
+ */
+
+#include "GUIDialogPVRDirectorOSD.h"
+#include "utils/log.h"
+#include "Application.h"
+
+using namespace PVR;
+
+CGUIDialogPVRDirectorOSD::CGUIDialogPVRDirectorOSD()
+    : CGUIDialog(WINDOW_DIALOG_PVR_OSD_DIRECTOR, "DialogPVRDirectorOSD.xml")
+{
+}
+
+CGUIDialogPVRDirectorOSD::~CGUIDialogPVRDirectorOSD()
+{
+}
+
+bool CGUIDialogPVRDirectorOSD::OnAction(const CAction& action)
+{
+  if (action.GetID() == ACTION_PREVIOUS_MENU || action.GetID() == ACTION_PARENT_DIR)
+  {
+    Close();
+    return true;
+  }
+
+  return CGUIDialog::OnAction(action);
+}
+
+bool CGUIDialogPVRDirectorOSD::OnMessage(CGUIMessage& message)
+{
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogPVRDirectorOSD::OnInitWindow()
+{
+  CGUIDialog::OnInitWindow();
+}
+
+void CGUIDialogPVRDirectorOSD::OnDeinitWindow(int nextWindowID)
+{
+  CGUIDialog::OnDeinitWindow(nextWindowID);
+}
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp b/xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
new file mode 100644
index 0000000..b173c1b
--- /dev/null
+++ b/xbmc/pvr/dialogs/GUIDialogPVRGroupManager.cpp
@@ -0,0 +1,385 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogPVRGroupManager.h"
+#include "Application.h"
+#include "FileItem.h"
+#include "guilib/GUIKeyboardFactory.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+
+using namespace std;
+using namespace PVR;
+
+#define CONTROL_LIST_CHANNELS_LEFT    11
+#define CONTROL_LIST_CHANNELS_RIGHT   12
+#define CONTROL_LIST_CHANNEL_GROUPS   13
+#define CONTROL_CURRENT_GROUP_LABEL   20
+#define CONTROL_UNGROUPED_LABEL       21
+#define CONTROL_IN_GROUP_LABEL        22
+#define BUTTON_NEWGROUP               26
+#define BUTTON_RENAMEGROUP            27
+#define BUTTON_DELGROUP               28
+#define BUTTON_OK                     29
+
+CGUIDialogPVRGroupManager::CGUIDialogPVRGroupManager() :
+    CGUIDialog(WINDOW_DIALOG_PVR_GROUP_MANAGER, "DialogPVRGroupManager.xml")
+{
+  m_ungroupedChannels = new CFileItemList;
+  m_groupMembers      = new CFileItemList;
+  m_channelGroups     = new CFileItemList;
+}
+
+CGUIDialogPVRGroupManager::~CGUIDialogPVRGroupManager()
+{
+  delete m_ungroupedChannels;
+  delete m_groupMembers;
+  delete m_channelGroups;
+}
+
+bool CGUIDialogPVRGroupManager::PersistChanges(void)
+{
+  return g_PVRChannelGroups->Get(m_bIsRadio)->PersistAll();
+}
+
+bool CGUIDialogPVRGroupManager::CancelChanges(void)
+{
+  // TODO
+  return false;
+}
+
+bool CGUIDialogPVRGroupManager::ActionButtonOk(CGUIMessage &message)
+{
+  bool bReturn = false;
+  unsigned int iControl = message.GetSenderId();
+
+  if (iControl == BUTTON_OK)
+  {
+    PersistChanges();
+    Close();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGroupManager::ActionButtonNewGroup(CGUIMessage &message)
+{
+  bool bReturn = false;
+  unsigned int iControl = message.GetSenderId();
+
+  if (iControl == BUTTON_NEWGROUP)
+  {
+    CStdString strGroupName = "";
+    /* prompt for a group name */
+    if (CGUIKeyboardFactory::ShowAndGetInput(strGroupName, g_localizeStrings.Get(19139), false))
+    {
+      if (strGroupName != "")
+      {
+        /* add the group if it doesn't already exist */
+        CPVRChannelGroups *groups = ((CPVRChannelGroups *) g_PVRChannelGroups->Get(m_bIsRadio));
+        if (groups->AddGroup(strGroupName))
+        {
+          g_PVRChannelGroups->Get(m_bIsRadio)->GetByName(strGroupName)->SetGroupType(PVR_GROUP_TYPE_USER_DEFINED);
+          m_iSelectedChannelGroup = groups->Size() - 1;
+          Update();
+        }
+      }
+    }
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGroupManager::ActionButtonDeleteGroup(CGUIMessage &message)
+{
+  bool bReturn = false;
+  unsigned int iControl = message.GetSenderId();
+
+  if (iControl == BUTTON_DELGROUP)
+  {
+    if (!m_selectedGroup)
+      return bReturn;
+
+    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+    if (!pDialog)
+      return bReturn;
+
+    pDialog->SetHeading(117);
+    pDialog->SetLine(0, "");
+    pDialog->SetLine(1, m_selectedGroup->GroupName());
+    pDialog->SetLine(2, "");
+    pDialog->DoModal();
+
+    if (pDialog->IsConfirmed())
+    {
+      if (((CPVRChannelGroups *) g_PVRChannelGroups->Get(m_bIsRadio))->DeleteGroup(*m_selectedGroup))
+        Update();
+    }
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGroupManager::ActionButtonRenameGroup(CGUIMessage &message)
+{
+  bool bReturn = false;
+  unsigned int iControl = message.GetSenderId();
+
+  if (iControl == BUTTON_RENAMEGROUP)
+  {
+    if (!m_selectedGroup)
+      return bReturn;
+
+    CStdString strGroupName(m_selectedGroup->GroupName());
+    if (CGUIKeyboardFactory::ShowAndGetInput(strGroupName, g_localizeStrings.Get(19139), false))
+    {
+      if (strGroupName != "")
+      {
+        m_selectedGroup->SetGroupName(strGroupName, true);
+        Update();
+      }
+    }
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGroupManager::ActionButtonUngroupedChannels(CGUIMessage &message)
+{
+  bool bReturn = false;
+  unsigned int iControl = message.GetSenderId();
+
+  if (m_viewUngroupedChannels.HasControl(iControl))   // list/thumb control
+  {
+    m_iSelectedUngroupedChannel = m_viewUngroupedChannels.GetSelectedItem();
+    int iAction     = message.GetParam1();
+
+    if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+    {
+      if (m_channelGroups->GetFileCount() == 0)
+      {
+        CGUIDialogOK::ShowAndGetInput(19033,19137,0,19138);
+      }
+      else if (m_ungroupedChannels->GetFileCount() > 0)
+      {
+        CFileItemPtr pItemChannel = m_ungroupedChannels->Get(m_iSelectedUngroupedChannel);
+        if (m_selectedGroup->AddToGroup(*pItemChannel->GetPVRChannelInfoTag()))
+          Update();
+      }
+    }
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGroupManager::ActionButtonGroupMembers(CGUIMessage &message)
+{
+  bool bReturn = false;
+  unsigned int iControl = message.GetSenderId();
+
+  if (m_viewGroupMembers.HasControl(iControl))   // list/thumb control
+  {
+    m_iSelectedGroupMember = m_viewGroupMembers.GetSelectedItem();
+    int iAction      = message.GetParam1();
+
+    if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+    {
+      if (m_selectedGroup && m_groupMembers->GetFileCount() > 0)
+      {
+        CFileItemPtr pItemChannel = m_groupMembers->Get(m_iSelectedGroupMember);
+        m_selectedGroup->RemoveFromGroup(*pItemChannel->GetPVRChannelInfoTag());
+        Update();
+      }
+    }
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGroupManager::ActionButtonChannelGroups(CGUIMessage &message)
+{
+  bool bReturn = false;
+  unsigned int iControl = message.GetSenderId();
+
+  if (m_viewChannelGroups.HasControl(iControl))   // list/thumb control
+  {
+    int iAction = message.GetParam1();
+
+    if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+    {
+      m_iSelectedChannelGroup = m_viewChannelGroups.GetSelectedItem();
+      Update();
+    }
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGroupManager::OnMessageClick(CGUIMessage &message)
+{
+  return ActionButtonOk(message) ||
+      ActionButtonNewGroup(message) ||
+      ActionButtonDeleteGroup(message) ||
+      ActionButtonRenameGroup(message) ||
+      ActionButtonUngroupedChannels(message) ||
+      ActionButtonGroupMembers(message) ||
+      ActionButtonChannelGroups(message);
+}
+
+bool CGUIDialogPVRGroupManager::OnMessage(CGUIMessage& message)
+{
+  unsigned int iMessage = message.GetMessage();
+
+  switch (iMessage)
+  {
+    case GUI_MSG_WINDOW_DEINIT:
+    {
+      Clear();
+    }
+    break;
+
+    case GUI_MSG_WINDOW_INIT:
+    {
+      CGUIWindow::OnMessage(message);
+      m_iSelectedUngroupedChannel  = 0;
+      m_iSelectedGroupMember = 0;
+      m_iSelectedChannelGroup = 0;
+      Update();
+      return true;
+    }
+    break;
+
+    case GUI_MSG_CLICKED:
+    {
+      OnMessageClick(message);
+    }
+    break;
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogPVRGroupManager::OnWindowLoaded()
+{
+  CGUIDialog::OnWindowLoaded();
+
+  m_viewUngroupedChannels.Reset();
+  m_viewUngroupedChannels.SetParentWindow(GetID());
+  m_viewUngroupedChannels.AddView(GetControl(CONTROL_LIST_CHANNELS_LEFT));
+
+  m_viewGroupMembers.Reset();
+  m_viewGroupMembers.SetParentWindow(GetID());
+  m_viewGroupMembers.AddView(GetControl(CONTROL_LIST_CHANNELS_RIGHT));
+
+  m_viewChannelGroups.Reset();
+  m_viewChannelGroups.SetParentWindow(GetID());
+  m_viewChannelGroups.AddView(GetControl(CONTROL_LIST_CHANNEL_GROUPS));
+}
+
+void CGUIDialogPVRGroupManager::OnWindowUnload()
+{
+  CGUIDialog::OnWindowUnload();
+  m_viewUngroupedChannels.Reset();
+  m_viewGroupMembers.Reset();
+  m_viewChannelGroups.Reset();
+}
+
+void CGUIDialogPVRGroupManager::Update()
+{
+  /* lock our display, as this window is rendered from the player thread */
+  g_graphicsContext.Lock();
+  m_viewUngroupedChannels.SetCurrentView(CONTROL_LIST_CHANNELS_LEFT);
+  m_viewGroupMembers.SetCurrentView(CONTROL_LIST_CHANNELS_RIGHT);
+  m_viewChannelGroups.SetCurrentView(CONTROL_LIST_CHANNEL_GROUPS);
+
+  Clear();
+
+  /* get the groups list */
+  g_PVRChannelGroups->Get(m_bIsRadio)->GetGroupList(m_channelGroups);
+  m_viewChannelGroups.SetItems(*m_channelGroups);
+  m_viewChannelGroups.SetSelectedItem(m_iSelectedChannelGroup);
+
+  /* select a group or select the default group if no group was selected */
+  CFileItemPtr pItem = m_channelGroups->Get(m_viewChannelGroups.GetSelectedItem());
+  m_selectedGroup = g_PVRChannelGroups->Get(m_bIsRadio)->GetByName(pItem->m_strTitle);
+  if (m_selectedGroup)
+  {
+    /* set this group in the pvrmanager, so it becomes the selected group in other dialogs too */
+    g_PVRManager.SetPlayingGroup(m_selectedGroup);
+    SET_CONTROL_LABEL(CONTROL_CURRENT_GROUP_LABEL, m_selectedGroup->GroupName());
+
+    if (m_selectedGroup->IsInternalGroup())
+    {
+      CStdString strNewLabel;
+      strNewLabel.Format("%s %s", g_localizeStrings.Get(19022), m_bIsRadio ? g_localizeStrings.Get(19024) : g_localizeStrings.Get(19023));
+      SET_CONTROL_LABEL(CONTROL_UNGROUPED_LABEL, strNewLabel);
+
+      strNewLabel.Format("%s %s", g_localizeStrings.Get(19218), m_bIsRadio ? g_localizeStrings.Get(19024) : g_localizeStrings.Get(19023));
+      SET_CONTROL_LABEL(CONTROL_IN_GROUP_LABEL, strNewLabel);
+    }
+    else
+    {
+      CStdString strNewLabel;
+      strNewLabel.Format("%s", g_localizeStrings.Get(19219));
+      SET_CONTROL_LABEL(CONTROL_UNGROUPED_LABEL, strNewLabel);
+
+      strNewLabel.Format("%s %s", g_localizeStrings.Get(19220), m_selectedGroup->GroupName());
+      SET_CONTROL_LABEL(CONTROL_IN_GROUP_LABEL, strNewLabel);
+    }
+
+    /* get all channels that are not in this group for the center part */
+    m_selectedGroup->GetMembers(*m_ungroupedChannels, false);
+    m_viewUngroupedChannels.SetItems(*m_ungroupedChannels);
+    m_viewUngroupedChannels.SetSelectedItem(m_iSelectedUngroupedChannel);
+
+    /* get all channels in this group for the right side part */
+    m_selectedGroup->GetMembers(*m_groupMembers, true);
+    m_viewGroupMembers.SetItems(*m_groupMembers);
+    m_viewGroupMembers.SetSelectedItem(m_iSelectedGroupMember);
+  }
+
+  g_graphicsContext.Unlock();
+}
+
+void CGUIDialogPVRGroupManager::Clear()
+{
+  m_viewUngroupedChannels.Clear();
+  m_viewGroupMembers.Clear();
+  m_viewChannelGroups.Clear();
+
+  m_ungroupedChannels->Clear();
+  m_groupMembers->Clear();
+  m_channelGroups->Clear();
+}
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp b/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
new file mode 100644
index 0000000..c8ef0a9
--- /dev/null
+++ b/xbmc/pvr/dialogs/GUIDialogPVRGuideInfo.cpp
@@ -0,0 +1,241 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogPVRGuideInfo.h"
+#include "Application.h"
+#include "guilib/GUIWindowManager.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogYesNo.h"
+
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "epg/EpgInfoTag.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/timers/PVRTimerInfoTag.h"
+
+using namespace std;
+using namespace PVR;
+using namespace EPG;
+
+#define CONTROL_BTN_SWITCH              5
+#define CONTROL_BTN_RECORD              6
+#define CONTROL_BTN_OK                  7
+
+CGUIDialogPVRGuideInfo::CGUIDialogPVRGuideInfo(void)
+    : CGUIDialog(WINDOW_DIALOG_PVR_GUIDE_INFO, "DialogPVRGuideInfo.xml")
+    , m_progItem(new CFileItem)
+{
+}
+
+CGUIDialogPVRGuideInfo::~CGUIDialogPVRGuideInfo(void)
+{
+}
+
+bool CGUIDialogPVRGuideInfo::ActionStartTimer(const CEpgInfoTag *tag)
+{
+  bool bReturn = false;
+
+  CPVRChannelPtr channel;
+  if (tag)
+    channel = tag->ChannelTag();
+  if (!channel || !g_PVRManager.CheckParentalLock(*channel))
+    return false;
+
+  // prompt user for confirmation of channel record
+  CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+  if (pDialog)
+  {
+    pDialog->SetHeading(264);
+    pDialog->SetLine(0, "");
+    pDialog->SetLine(1, tag->Title());
+    pDialog->SetLine(2, "");
+    pDialog->DoModal();
+
+    if (pDialog->IsConfirmed())
+    {
+      Close();
+      CPVRTimerInfoTag *newTimer = CPVRTimerInfoTag::CreateFromEpg(*tag);
+      if (newTimer)
+      {
+        bReturn = CPVRTimers::AddTimer(*newTimer);
+        delete newTimer;
+      }
+      else
+      {
+        bReturn = false;
+      }
+    }
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGuideInfo::ActionCancelTimer(CFileItemPtr timer)
+{
+  bool bReturn = false;
+  if (!timer || !timer->HasPVRTimerInfoTag())
+  {
+    return bReturn;
+  }
+
+  // prompt user for confirmation of timer deletion
+  CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+
+  if (pDialog)
+  {
+    pDialog->SetHeading(265);
+    pDialog->SetLine(0, "");
+    pDialog->SetLine(1, timer->GetPVRTimerInfoTag()->m_strTitle);
+    pDialog->SetLine(2, "");
+    pDialog->DoModal();
+
+    if (pDialog->IsConfirmed())
+    {
+      Close();
+      bReturn = CPVRTimers::DeleteTimer(*timer);
+    }
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGuideInfo::OnClickButtonOK(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (message.GetSenderId() == CONTROL_BTN_OK)
+  {
+    Close();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGuideInfo::OnClickButtonRecord(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (message.GetSenderId() == CONTROL_BTN_RECORD)
+  {
+    bReturn = true;
+
+    const CEpgInfoTag *tag = m_progItem->GetEPGInfoTag();
+    if (!tag || !tag->HasPVRChannel())
+    {
+      /* invalid channel */
+      CGUIDialogOK::ShowAndGetInput(19033,19067,0,0);
+      Close();
+      return bReturn;
+    }
+
+    CFileItemPtr timerTag = g_PVRTimers->GetTimerForEpgTag(m_progItem.get());
+    bool bHasTimer = timerTag != NULL && timerTag->HasPVRTimerInfoTag();
+
+    if (!bHasTimer)
+      ActionStartTimer(tag);
+    else
+      ActionCancelTimer(timerTag);
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGuideInfo::OnClickButtonSwitch(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (message.GetSenderId() == CONTROL_BTN_SWITCH)
+  {
+    Close();
+
+    if (!m_progItem->GetEPGInfoTag()->HasPVRChannel() ||
+        !g_application.PlayFile(CFileItem(*m_progItem->GetEPGInfoTag()->ChannelTag())))
+      CGUIDialogOK::ShowAndGetInput(19033,0,19035,0);
+    else
+      bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIDialogPVRGuideInfo::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+  case GUI_MSG_WINDOW_INIT:
+    CGUIDialog::OnMessage(message);
+    Update();
+    break;
+  case GUI_MSG_CLICKED:
+    return OnClickButtonOK(message) ||
+           OnClickButtonRecord(message) ||
+           OnClickButtonSwitch(message);
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogPVRGuideInfo::SetProgInfo(const CFileItem *item)
+{
+  *m_progItem = *item;
+}
+
+CFileItemPtr CGUIDialogPVRGuideInfo::GetCurrentListItem(int offset)
+{
+  return m_progItem;
+}
+
+void CGUIDialogPVRGuideInfo::Update()
+{
+  const CEpgInfoTag *tag = m_progItem->GetEPGInfoTag();
+  if (!tag)
+  {
+    /* no epg event selected */
+    return;
+  }
+
+  if (tag->EndAsLocalTime() <= CDateTime::GetCurrentDateTime())
+  {
+    /* event has passed. hide the record button */
+    SET_CONTROL_HIDDEN(CONTROL_BTN_RECORD);
+    return;
+  }
+
+  CFileItemPtr match = g_PVRTimers->GetTimerForEpgTag(m_progItem.get());
+  if (!match || !match->HasPVRTimerInfoTag())
+  {
+    /* no timer present on this tag */
+    if (tag->StartAsLocalTime() < CDateTime::GetCurrentDateTime())
+      SET_CONTROL_LABEL(CONTROL_BTN_RECORD, 264);
+    else
+      SET_CONTROL_LABEL(CONTROL_BTN_RECORD, 19061);
+  }
+  else
+  {
+    /* timer present on this tag */
+    if (tag->StartAsLocalTime() < CDateTime::GetCurrentDateTime())
+      SET_CONTROL_LABEL(CONTROL_BTN_RECORD, 19059);
+    else
+      SET_CONTROL_LABEL(CONTROL_BTN_RECORD, 19060);
+  }
+}
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp b/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
new file mode 100644
index 0000000..49dcdf0
--- /dev/null
+++ b/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
@@ -0,0 +1,165 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogPVRGuideOSD.h"
+#include "Application.h"
+#include "FileItem.h"
+#include "GUIDialogPVRGuideInfo.h"
+#include "guilib/GUIWindowManager.h"
+#include "ViewState.h"
+#include "epg/Epg.h"
+
+#include "pvr/PVRManager.h"
+
+using namespace std;
+using namespace PVR;
+
+#define CONTROL_LIST  11
+
+CGUIDialogPVRGuideOSD::CGUIDialogPVRGuideOSD()
+    : CGUIDialog(WINDOW_DIALOG_PVR_OSD_GUIDE, "DialogPVRGuideOSD.xml")
+{
+  m_vecItems = new CFileItemList;
+}
+
+CGUIDialogPVRGuideOSD::~CGUIDialogPVRGuideOSD()
+{
+  delete m_vecItems;
+}
+
+bool CGUIDialogPVRGuideOSD::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+  case GUI_MSG_WINDOW_DEINIT:
+    {
+      Clear();
+    }
+    break;
+
+  case GUI_MSG_WINDOW_INIT:
+    {
+      /* Close dialog immediately if now TV or radio channel is playing */
+      if (!g_PVRManager.IsPlaying())
+      {
+        Close();
+        return true;
+      }
+      CGUIWindow::OnMessage(message);
+      Update();
+      return true;
+    }
+    break;
+
+  case GUI_MSG_CLICKED:
+    {
+      int iControl = message.GetSenderId();
+
+      if (m_viewControl.HasControl(iControl))   // list/thumb control
+      {
+        int iItem = m_viewControl.GetSelectedItem();
+        int iAction = message.GetParam1();
+
+        if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+        {
+          ShowInfo(iItem);
+          return true;
+        }
+      }
+    }
+    break;
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogPVRGuideOSD::Update()
+{
+  // lock our display, as this window is rendered from the player thread
+  g_graphicsContext.Lock();
+  m_viewControl.SetCurrentView(DEFAULT_VIEW_LIST);
+
+  // empty the list ready for population
+  Clear();
+
+  g_PVRManager.GetCurrentEpg(*m_vecItems);
+  m_viewControl.SetItems(*m_vecItems);
+
+  /* select the active entry */
+  unsigned int iSelectedItem = 0;
+  for (int iEpgPtr = 0; iEpgPtr < m_vecItems->Size(); iEpgPtr++)
+  {
+    CFileItemPtr entry = m_vecItems->Get(iEpgPtr);
+    if (entry->GetEPGInfoTag()->IsActive())
+    {
+      iSelectedItem = iEpgPtr;
+      break;
+    }
+  }
+  m_viewControl.SetSelectedItem(iSelectedItem);
+
+  g_graphicsContext.Unlock();
+}
+
+void CGUIDialogPVRGuideOSD::Clear()
+{
+  m_viewControl.Clear();
+  m_vecItems->Clear();
+}
+
+void CGUIDialogPVRGuideOSD::ShowInfo(int item)
+{
+  /* Check file item is in list range and get his pointer */
+  if (item < 0 || item >= (int)m_vecItems->Size()) return;
+
+  CFileItemPtr pItem = m_vecItems->Get(item);
+
+  /* Load programme info dialog */
+  CGUIDialogPVRGuideInfo* pDlgInfo = (CGUIDialogPVRGuideInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GUIDE_INFO);
+  if (!pDlgInfo)
+    return;
+
+  /* inform dialog about the file item and open dialog window */
+  pDlgInfo->SetProgInfo(pItem.get());
+  pDlgInfo->DoModal();
+}
+
+void CGUIDialogPVRGuideOSD::OnWindowLoaded()
+{
+  CGUIDialog::OnWindowLoaded();
+  m_viewControl.Reset();
+  m_viewControl.SetParentWindow(GetID());
+  m_viewControl.AddView(GetControl(CONTROL_LIST));
+}
+
+void CGUIDialogPVRGuideOSD::OnWindowUnload()
+{
+  CGUIDialog::OnWindowUnload();
+  m_viewControl.Reset();
+}
+
+CGUIControl *CGUIDialogPVRGuideOSD::GetFirstFocusableControl(int id)
+{
+  if (m_viewControl.HasControl(id))
+    id = m_viewControl.GetCurrentControl();
+
+  return CGUIWindow::GetFirstFocusableControl(id);
+}
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp b/xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
new file mode 100644
index 0000000..5632586
--- /dev/null
+++ b/xbmc/pvr/dialogs/GUIDialogPVRGuideSearch.cpp
@@ -0,0 +1,369 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogPVRGuideSearch.h"
+#include "Application.h"
+#include "guilib/LocalizeStrings.h"
+#include "guilib/GUIEditControl.h"
+#include "guilib/GUIRadioButtonControl.h"
+#include "guilib/GUISpinControlEx.h"
+#include "guilib/GUIWindowManager.h"
+
+#include "addons/include/xbmc_pvr_types.h"
+#include "pvr/PVRManager.h"
+#include "epg/EpgSearchFilter.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+
+using namespace std;
+using namespace PVR;
+
+#define CONTROL_EDIT_SEARCH       9
+#define CONTROL_BTN_INC_DESC      10
+#define CONTROL_BTN_CASE_SENS     11
+#define CONTROL_SPIN_MIN_DURATION 12
+#define CONTROL_SPIN_MAX_DURATION 13
+#define CONTROL_EDIT_START_DATE   14
+#define CONTROL_EDIT_STOP_DATE    15
+#define CONTROL_EDIT_START_TIME   16
+#define CONTROL_EDIT_STOP_TIME    17
+#define CONTROL_SPIN_GENRE        18
+#define CONTROL_SPIN_NO_REPEATS   19
+#define CONTROL_BTN_UNK_GENRE     20
+#define CONTROL_SPIN_GROUPS       21
+#define CONTROL_BTN_FTA_ONLY      22
+#define CONTROL_SPIN_CHANNELS     23
+#define CONTROL_BTN_IGNORE_TMR    24
+#define CONTROL_BTN_CANCEL        25
+#define CONTROL_BTN_SEARCH        26
+#define CONTROL_BTN_IGNORE_REC    27
+#define CONTROL_BTN_DEFAULTS      28
+
+CGUIDialogPVRGuideSearch::CGUIDialogPVRGuideSearch(void) :
+    CGUIDialog(WINDOW_DIALOG_PVR_GUIDE_SEARCH, "DialogPVRGuideSearch.xml"),
+    m_bConfirmed(false),
+    m_bCanceled(false),
+    m_searchFilter(NULL)
+{
+}
+
+void CGUIDialogPVRGuideSearch::UpdateChannelSpin(void)
+{
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_CHANNELS);
+  CGUISpinControlEx *pSpinGroups = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_GROUPS);
+  if (!pSpin || !pSpinGroups)
+    return;
+
+  int iChannelGroup = pSpin->GetValue();
+
+  pSpin->Clear();
+  pSpin->AddLabel(g_localizeStrings.Get(19217), EPG_SEARCH_UNSET);
+
+  int iGroupId = (iChannelGroup == EPG_SEARCH_UNSET) ?
+      XBMC_INTERNAL_GROUP_TV :
+      iChannelGroup;
+  CPVRChannelGroupPtr group = g_PVRChannelGroups->GetByIdFromAll(iGroupId);
+  if (!group)
+    group = g_PVRChannelGroups->GetGroupAllTV();
+
+  for (int iChannelPtr = 0; iChannelPtr < group->Size(); iChannelPtr++)
+  {
+    CFileItemPtr channel = group->GetByIndex(iChannelPtr);
+    if (!channel || !channel->HasPVRChannelInfoTag())
+      continue;
+
+    int iChannelNumber = group->GetChannelNumber(*channel->GetPVRChannelInfoTag());
+    pSpin->AddLabel(channel->GetPVRChannelInfoTag()->ChannelName().c_str(), iChannelNumber);
+  }
+}
+
+void CGUIDialogPVRGuideSearch::UpdateGroupsSpin(void)
+{
+  CFileItemList groups;
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_GROUPS);
+  if (!pSpin)
+    return;
+
+  /* tv groups */
+  g_PVRChannelGroups->GetTV()->GetGroupList(&groups);
+  for (int iGroupPtr = 0; iGroupPtr < groups.Size(); iGroupPtr++)
+    pSpin->AddLabel(groups[iGroupPtr]->GetLabel(), atoi(groups[iGroupPtr]->GetPath()));
+
+  /* radio groups */
+  groups.ClearItems();
+  g_PVRChannelGroups->GetRadio()->GetGroupList(&groups);
+  for (int iGroupPtr = 0; iGroupPtr < groups.Size(); iGroupPtr++)
+    pSpin->AddLabel(groups[iGroupPtr]->GetLabel(), atoi(groups[iGroupPtr]->GetPath()));
+
+  pSpin->SetValue(m_searchFilter->m_iChannelGroup);
+}
+
+void CGUIDialogPVRGuideSearch::UpdateGenreSpin(void)
+{
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_GENRE);
+  if (!pSpin)
+    return;
+
+  pSpin->Clear();
+  pSpin->AddLabel(g_localizeStrings.Get(593), EPG_SEARCH_UNSET);
+  pSpin->AddLabel(g_localizeStrings.Get(19500), EPG_EVENT_CONTENTMASK_MOVIEDRAMA);
+  pSpin->AddLabel(g_localizeStrings.Get(19516), EPG_EVENT_CONTENTMASK_NEWSCURRENTAFFAIRS);
+  pSpin->AddLabel(g_localizeStrings.Get(19532), EPG_EVENT_CONTENTMASK_SHOW);
+  pSpin->AddLabel(g_localizeStrings.Get(19548), EPG_EVENT_CONTENTMASK_SPORTS);
+  pSpin->AddLabel(g_localizeStrings.Get(19564), EPG_EVENT_CONTENTMASK_CHILDRENYOUTH);
+  pSpin->AddLabel(g_localizeStrings.Get(19580), EPG_EVENT_CONTENTMASK_MUSICBALLETDANCE);
+  pSpin->AddLabel(g_localizeStrings.Get(19596), EPG_EVENT_CONTENTMASK_ARTSCULTURE);
+  pSpin->AddLabel(g_localizeStrings.Get(19612), EPG_EVENT_CONTENTMASK_SOCIALPOLITICALECONOMICS);
+  pSpin->AddLabel(g_localizeStrings.Get(19628), EPG_EVENT_CONTENTMASK_EDUCATIONALSCIENCE);
+  pSpin->AddLabel(g_localizeStrings.Get(19644), EPG_EVENT_CONTENTMASK_LEISUREHOBBIES);
+  pSpin->AddLabel(g_localizeStrings.Get(19660), EPG_EVENT_CONTENTMASK_SPECIAL);
+  pSpin->AddLabel(g_localizeStrings.Get(19499), EPG_EVENT_CONTENTMASK_USERDEFINED);
+  pSpin->SetValue(m_searchFilter->m_iGenreType);
+}
+
+void CGUIDialogPVRGuideSearch::UpdateDurationSpin(void)
+{
+  /* minimum duration */
+  CGUISpinControlEx *pSpin = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_MIN_DURATION);
+  if (!pSpin)
+    return;
+
+  pSpin->Clear();
+  pSpin->AddLabel("-", EPG_SEARCH_UNSET);
+  for (int i = 1; i < 12*60/5; i++)
+  {
+    CStdString string;
+    string.Format(g_localizeStrings.Get(14044), i*5);
+    pSpin->AddLabel(string, i*5);
+  }
+  pSpin->SetValue(m_searchFilter->m_iMinimumDuration);
+
+  /* maximum duration */
+  pSpin = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_MAX_DURATION);
+  if (!pSpin)
+    return;
+
+  pSpin->Clear();
+  pSpin->AddLabel("-", EPG_SEARCH_UNSET);
+  for (int i = 1; i < 12*60/5; i++)
+  {
+    CStdString string;
+    string.Format(g_localizeStrings.Get(14044),i*5);
+    pSpin->AddLabel(string, i*5);
+  }
+  pSpin->SetValue(m_searchFilter->m_iMaximumDuration);
+}
+
+bool CGUIDialogPVRGuideSearch::OnMessage(CGUIMessage& message)
+{
+  CGUIDialog::OnMessage(message);
+
+  switch (message.GetMessage())
+  {
+    case GUI_MSG_WINDOW_INIT:
+    {
+      m_bConfirmed = false;
+      m_bCanceled = false;
+    }
+    break;
+
+    case GUI_MSG_CLICKED:
+    {
+      int iControl = message.GetSenderId();
+      if (iControl == CONTROL_BTN_SEARCH)
+      {
+        OnSearch();
+        m_bConfirmed = true;
+        m_bCanceled = false;
+        Close();
+        return true;
+      }
+      else if (iControl == CONTROL_BTN_CANCEL)
+      {
+        Close();
+        m_bCanceled = true;
+        return true;
+      }
+      else if (iControl == CONTROL_BTN_DEFAULTS)
+      {
+        if (m_searchFilter)
+        {
+          m_searchFilter->Reset();
+          Update();
+        }
+
+        return true;
+      }
+      else if (iControl == CONTROL_SPIN_GROUPS)
+      {
+        UpdateChannelSpin();
+        return true;
+      }
+    }
+    break;
+  }
+
+  return false;
+}
+
+void CGUIDialogPVRGuideSearch::OnWindowLoaded()
+{
+  Update();
+  return CGUIDialog::OnWindowLoaded();
+}
+
+void CGUIDialogPVRGuideSearch::ReadDateTime(const CStdString &strDate, const CStdString &strTime, CDateTime &dateTime) const
+{
+  int iHours, iMinutes;
+  sscanf(strTime, "%d:%d", &iHours, &iMinutes);
+  dateTime.SetFromDBDate(strDate);
+  dateTime.SetDateTime(dateTime.GetYear(), dateTime.GetMonth(), dateTime.GetDay(), iHours, iMinutes, 0);
+}
+
+void CGUIDialogPVRGuideSearch::OnSearch()
+{
+  CStdString              strTmp;
+  CGUISpinControlEx      *pSpin;
+  CGUIEditControl        *pEdit;
+  CGUIRadioButtonControl *pRadioButton;
+
+  if (!m_searchFilter)
+    return;
+
+  pEdit = (CGUIEditControl *)GetControl(CONTROL_EDIT_SEARCH);
+  if (pEdit) m_searchFilter->m_strSearchTerm = pEdit->GetLabel2();
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_INC_DESC);
+  if (pRadioButton) m_searchFilter->m_bSearchInDescription = pRadioButton->IsSelected();
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_CASE_SENS);
+  if (pRadioButton) m_searchFilter->m_bIsCaseSensitive = pRadioButton->IsSelected();
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_FTA_ONLY);
+  if (pRadioButton) m_searchFilter->m_bFTAOnly = pRadioButton->IsSelected();
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_UNK_GENRE);
+  if (pRadioButton) m_searchFilter->m_bIncludeUnknownGenres = pRadioButton->IsSelected();
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_IGNORE_REC);
+  if (pRadioButton) m_searchFilter->m_bIgnorePresentRecordings = pRadioButton->IsSelected();
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_IGNORE_TMR);
+  if (pRadioButton) m_searchFilter->m_bIgnorePresentTimers = pRadioButton->IsSelected();
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_SPIN_NO_REPEATS);
+  if (pRadioButton) m_searchFilter->m_bPreventRepeats = pRadioButton->IsSelected();
+
+  pSpin = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_GENRE);
+  if (pSpin) m_searchFilter->m_iGenreType = pSpin->GetValue();
+
+  pSpin = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_MIN_DURATION);
+  if (pSpin) m_searchFilter->m_iMinimumDuration = pSpin->GetValue();
+
+  pSpin = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_MAX_DURATION);
+  if (pSpin) m_searchFilter->m_iMaximumDuration = pSpin->GetValue();
+
+  pSpin = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_CHANNELS);
+  if (pSpin) m_searchFilter->m_iChannelNumber = pSpin->GetValue();
+
+  pSpin = (CGUISpinControlEx *)GetControl(CONTROL_SPIN_GROUPS);
+  if (pSpin) m_searchFilter->m_iChannelGroup = pSpin->GetValue();
+
+  pEdit = (CGUIEditControl *)GetControl(CONTROL_EDIT_START_TIME);
+  if (pEdit) strTmp = pEdit->GetLabel2();
+
+  pEdit = (CGUIEditControl *)GetControl(CONTROL_EDIT_START_DATE);
+  if (pEdit) ReadDateTime(pEdit->GetLabel2(), strTmp, m_searchFilter->m_startDateTime);
+  strTmp.clear();
+
+  pEdit = (CGUIEditControl *)GetControl(CONTROL_EDIT_STOP_TIME);
+  if (pEdit) strTmp = pEdit->GetLabel2();
+
+  pEdit = (CGUIEditControl *)GetControl(CONTROL_EDIT_STOP_DATE);
+  if (pEdit) ReadDateTime(pEdit->GetLabel2(), strTmp, m_searchFilter->m_endDateTime);
+}
+
+void CGUIDialogPVRGuideSearch::Update()
+{
+  CGUIEditControl        *pEdit;
+  CGUIRadioButtonControl *pRadioButton;
+
+  if (!m_searchFilter)
+    return;
+
+  pEdit = (CGUIEditControl *)GetControl(CONTROL_EDIT_SEARCH);
+  if (pEdit)
+  {
+    pEdit->SetLabel2(m_searchFilter->m_strSearchTerm);
+    pEdit->SetInputType(CGUIEditControl::INPUT_TYPE_TEXT, 16017);
+  }
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_CASE_SENS);
+  if (pRadioButton) pRadioButton->SetSelected(m_searchFilter->m_bIsCaseSensitive);
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_INC_DESC);
+  if (pRadioButton) pRadioButton->SetSelected(m_searchFilter->m_bSearchInDescription);
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_FTA_ONLY);
+  if (pRadioButton) pRadioButton->SetSelected(m_searchFilter->m_bFTAOnly);
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_UNK_GENRE);
+  if (pRadioButton) pRadioButton->SetSelected(m_searchFilter->m_bIncludeUnknownGenres);
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_IGNORE_REC);
+  if (pRadioButton) pRadioButton->SetSelected(m_searchFilter->m_bIgnorePresentRecordings);
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_BTN_IGNORE_TMR);
+  if (pRadioButton) pRadioButton->SetSelected(m_searchFilter->m_bIgnorePresentTimers);
+
+  pRadioButton = (CGUIRadioButtonControl *)GetControl(CONTROL_SPIN_NO_REPEATS);
+  if (pRadioButton) pRadioButton->SetSelected(m_searchFilter->m_bPreventRepeats);
+
+  /* Set time fields */
+  pEdit = (CGUIEditControl *)GetControl(CONTROL_EDIT_START_TIME);
+  if (pEdit)
+  {
+    pEdit->SetLabel2(m_searchFilter->m_endDateTime.GetAsLocalizedTime("", false));
+    pEdit->SetInputType(CGUIEditControl::INPUT_TYPE_TIME, 14066);
+  }
+  pEdit = (CGUIEditControl *)GetControl(CONTROL_EDIT_STOP_TIME);
+  if (pEdit)
+  {
+    pEdit->SetLabel2(m_searchFilter->m_startDateTime.GetAsLocalizedTime("", false));
+    pEdit->SetInputType(CGUIEditControl::INPUT_TYPE_TIME, 14066);
+  }
+  pEdit = (CGUIEditControl *)GetControl(CONTROL_EDIT_START_DATE);
+  if (pEdit)
+  {
+    pEdit->SetLabel2(m_searchFilter->m_startDateTime.GetAsDBDate());
+    pEdit->SetInputType(CGUIEditControl::INPUT_TYPE_DATE, 14067);
+  }
+  pEdit = (CGUIEditControl *)GetControl(CONTROL_EDIT_STOP_DATE);
+  if (pEdit)
+  {
+    pEdit->SetLabel2(m_searchFilter->m_endDateTime.GetAsDBDate());
+    pEdit->SetInputType(CGUIEditControl::INPUT_TYPE_DATE, 14067);
+  }
+
+  UpdateDurationSpin();
+  UpdateGroupsSpin();
+  UpdateChannelSpin();
+  UpdateGenreSpin();
+}
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp b/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp
new file mode 100644
index 0000000..99947ba
--- /dev/null
+++ b/xbmc/pvr/dialogs/GUIDialogPVRRecordingInfo.cpp
@@ -0,0 +1,61 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogPVRRecordingInfo.h"
+#include "guilib/GUIWindowManager.h"
+#include "FileItem.h"
+
+using namespace std;
+using namespace PVR;
+
+#define CONTROL_BTN_OK  10
+
+CGUIDialogPVRRecordingInfo::CGUIDialogPVRRecordingInfo(void)
+  : CGUIDialog(WINDOW_DIALOG_PVR_RECORDING_INFO, "DialogPVRRecordingInfo.xml")
+  , m_recordItem(new CFileItem)
+{
+}
+
+bool CGUIDialogPVRRecordingInfo::OnMessage(CGUIMessage& message)
+{
+  if (message.GetMessage() == GUI_MSG_CLICKED)
+  {
+    int iControl = message.GetSenderId();
+
+    if (iControl == CONTROL_BTN_OK)
+    {
+      Close();
+      return true;
+    }
+  }
+
+  return CGUIDialog::OnMessage(message);
+}
+
+void CGUIDialogPVRRecordingInfo::SetRecording(const CFileItem *item)
+{
+  *m_recordItem = *item;
+}
+
+CFileItemPtr CGUIDialogPVRRecordingInfo::GetCurrentListItem(int offset)
+{
+  return m_recordItem;
+}
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp b/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
new file mode 100644
index 0000000..6a82a7c
--- /dev/null
+++ b/xbmc/pvr/dialogs/GUIDialogPVRTimerSettings.cpp
@@ -0,0 +1,370 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIDialogPVRTimerSettings.h"
+#include "guilib/GUIKeyboardFactory.h"
+#include "dialogs/GUIDialogNumeric.h"
+#include "settings/GUISettings.h"
+#include "guilib/LocalizeStrings.h"
+
+#include "pvr/PVRManager.h"
+#include "pvr/timers/PVRTimerInfoTag.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+
+using namespace std;
+using namespace PVR;
+
+#define CONTROL_TMR_ACTIVE              20
+#define CONTROL_TMR_CHNAME_TV           21
+#define CONTROL_TMR_DAY                 22
+#define CONTROL_TMR_BEGIN               23
+#define CONTROL_TMR_END                 24
+#define CONTROL_TMR_PRIORITY            26
+#define CONTROL_TMR_LIFETIME            27
+#define CONTROL_TMR_FIRST_DAY           28
+#define CONTROL_TMR_NAME                29
+#define CONTROL_TMR_DIR                 30
+#define CONTROL_TMR_RADIO               50
+#define CONTROL_TMR_CHNAME_RADIO        51
+
+CGUIDialogPVRTimerSettings::CGUIDialogPVRTimerSettings(void)
+  : CGUIDialogSettings(WINDOW_DIALOG_PVR_TIMER_SETTING, "DialogPVRTimerSettings.xml")
+{
+  m_cancelled = true;
+  m_tmp_day   = 11;
+}
+
+void CGUIDialogPVRTimerSettings::AddChannelNames(CFileItemList &channelsList, SETTINGSTRINGS &channelNames, bool bRadio)
+{
+  g_PVRChannelGroups->GetGroupAll(bRadio)->GetMembers(channelsList);
+
+  channelNames.push_back("0 dummy");
+  for (int i = 0; i < channelsList.Size(); i++)
+  {
+    CStdString string;
+    CFileItemPtr item = channelsList[i];
+    const CPVRChannel *channel = item->GetPVRChannelInfoTag();
+    string.Format("%i %s", channel->ChannelNumber(), channel->ChannelName().c_str());
+    channelNames.push_back(string);
+  }
+
+  int iControl = bRadio ? CONTROL_TMR_CHNAME_RADIO : CONTROL_TMR_CHNAME_TV;
+  AddSpin(iControl, 19078, &m_timerItem->GetPVRTimerInfoTag()->m_iChannelNumber, channelNames.size(), channelNames);
+  EnableSettings(iControl, m_timerItem->GetPVRTimerInfoTag()->m_bIsRadio == bRadio);
+}
+
+void CGUIDialogPVRTimerSettings::SetWeekdaySettingFromTimer(const CPVRTimerInfoTag &timer)
+{
+  if (timer.m_bIsRepeating)
+  {
+    if (timer.m_iWeekdays == 0x01)
+      m_tmp_day = 0;
+    else if (timer.m_iWeekdays == 0x02)
+      m_tmp_day = 1;
+    else if (timer.m_iWeekdays == 0x04)
+      m_tmp_day = 2;
+    else if (timer.m_iWeekdays == 0x08)
+      m_tmp_day = 3;
+    else if (timer.m_iWeekdays == 0x10)
+      m_tmp_day = 4;
+    else if (timer.m_iWeekdays == 0x20)
+      m_tmp_day = 5;
+    else if (timer.m_iWeekdays == 0x40)
+      m_tmp_day = 6;
+    else if (timer.m_iWeekdays == 0x1F)
+      m_tmp_day = 7;
+    else if (timer.m_iWeekdays == 0x3F)
+      m_tmp_day = 8;
+    else if (timer.m_iWeekdays == 0x7F)
+      m_tmp_day = 9;
+    else if (timer.m_iWeekdays == 0x60)
+      m_tmp_day = 10;
+  }
+}
+
+void CGUIDialogPVRTimerSettings::SetTimerFromWeekdaySetting(CPVRTimerInfoTag &timer)
+{
+  timer.m_bIsRepeating = true;
+
+  if (m_tmp_day == 0)
+    timer.m_iWeekdays = 0x01;
+  else if (m_tmp_day == 1)
+    timer.m_iWeekdays = 0x02;
+  else if (m_tmp_day == 2)
+    timer.m_iWeekdays = 0x04;
+  else if (m_tmp_day == 3)
+    timer.m_iWeekdays = 0x08;
+  else if (m_tmp_day == 4)
+    timer.m_iWeekdays = 0x10;
+  else if (m_tmp_day == 5)
+    timer.m_iWeekdays = 0x20;
+  else if (m_tmp_day == 6)
+    timer.m_iWeekdays = 0x40;
+  else if (m_tmp_day == 7)
+    timer.m_iWeekdays = 0x1F;
+  else if (m_tmp_day == 8)
+    timer.m_iWeekdays = 0x3F;
+  else if (m_tmp_day == 9)
+    timer.m_iWeekdays = 0x7F;
+  else if (m_tmp_day == 10)
+    timer.m_iWeekdays = 0x60;
+  else
+    timer.m_iWeekdays = 0;
+}
+
+void CGUIDialogPVRTimerSettings::CreateSettings()
+{
+  CPVRTimerInfoTag* tag = m_timerItem->GetPVRTimerInfoTag();
+
+  // clear out any old settings
+  m_settings.clear();
+
+  // create our settings controls
+  m_bTimerActive = tag->IsActive();
+  AddBool(CONTROL_TMR_ACTIVE, 19074, &m_bTimerActive);
+  AddButton(CONTROL_TMR_NAME, 19075, &tag->m_strTitle, true);
+
+  if (tag->SupportsFolders())
+    AddButton(CONTROL_TMR_DIR, 19076, &tag->m_strDirectory, true);
+
+  AddBool(CONTROL_TMR_RADIO, 19077, &tag->m_bIsRadio);
+
+  /// Channel names
+  {
+    // For TV
+    CFileItemList channelslist_tv;
+    SETTINGSTRINGS channelstrings_tv;
+    AddChannelNames(channelslist_tv, channelstrings_tv, false);
+
+    // For Radio
+    CFileItemList channelslist_radio;
+    SETTINGSTRINGS channelstrings_radio;
+    AddChannelNames(channelslist_radio, channelstrings_radio, true);
+  }
+
+  /// Day
+  {
+    SETTINGSTRINGS daystrings;
+    tm time_cur;
+    tm time_tmr;
+
+    for (unsigned int iDayPtr = 19086; iDayPtr <= 19096; iDayPtr++)
+      daystrings.push_back(g_localizeStrings.Get(iDayPtr));
+    CDateTime time = CDateTime::GetCurrentDateTime();
+    CDateTime timestart = tag->StartAsLocalTime();
+
+    /* get diffence of timer in days between today and timer start date */
+    time.GetAsTm(time_cur);
+    timestart.GetAsTm(time_tmr);
+
+    m_tmp_day += time_tmr.tm_yday - time_cur.tm_yday;
+    if (time_tmr.tm_yday - time_cur.tm_yday < 0)
+      m_tmp_day += 365;
+
+    for (int i = 1; i < 365; ++i)
+    {
+      CStdString string = time.GetAsLocalizedDate();
+      daystrings.push_back(string);
+      time += CDateTimeSpan(1, 0, 0, 0);
+    }
+
+    SetWeekdaySettingFromTimer(*tag);
+
+    AddSpin(CONTROL_TMR_DAY, 19079, &m_tmp_day, daystrings.size(), daystrings);
+  }
+
+  AddButton(CONTROL_TMR_BEGIN, 19080, &timerStartTimeStr, true);
+  AddButton(CONTROL_TMR_END, 19081, &timerEndTimeStr, true);
+  AddSpin(CONTROL_TMR_PRIORITY, 19082, &tag->m_iPriority, 0, 99);
+  AddSpin(CONTROL_TMR_LIFETIME, 19083, &tag->m_iLifetime, 0, 365);
+
+  /// First day
+  {
+    SETTINGSTRINGS daystrings;
+    tm time_cur;
+    tm time_tmr;
+
+    CDateTime time = CDateTime::GetCurrentDateTime();
+    CDateTime timestart = tag->FirstDayAsLocalTime();
+
+    /* get diffence of timer in days between today and timer start date */
+    if (time < timestart)
+    {
+      time.GetAsTm(time_cur);
+      timestart.GetAsTm(time_tmr);
+
+      m_tmp_iFirstDay += time_tmr.tm_yday - time_cur.tm_yday + 1;
+      if (time_tmr.tm_yday - time_cur.tm_yday < 0)
+        m_tmp_iFirstDay += 365;
+    }
+
+    daystrings.push_back(g_localizeStrings.Get(19030));
+
+    for (int i = 1; i < 365; ++i)
+    {
+      CStdString string = time.GetAsLocalizedDate();
+      daystrings.push_back(string);
+      time += CDateTimeSpan(1, 0, 0, 0);
+    }
+
+    AddSpin(CONTROL_TMR_FIRST_DAY, 19084, &m_tmp_iFirstDay, daystrings.size(), daystrings);
+
+    if (tag->m_bIsRepeating)
+      EnableSettings(CONTROL_TMR_FIRST_DAY, true);
+    else
+      EnableSettings(CONTROL_TMR_FIRST_DAY, false);
+  }
+}
+
+void CGUIDialogPVRTimerSettings::OnSettingChanged(SettingInfo &setting)
+{
+  CPVRTimerInfoTag* tag = m_timerItem->GetPVRTimerInfoTag();
+
+  if (setting.id == CONTROL_TMR_NAME)
+  {
+    if (CGUIKeyboardFactory::ShowAndGetInput(tag->m_strTitle, g_localizeStrings.Get(19097), false))
+    {
+      UpdateSetting(CONTROL_TMR_NAME);
+    }
+  }
+  if (setting.id == CONTROL_TMR_DIR && CGUIKeyboardFactory::ShowAndGetInput(tag->m_strDirectory, g_localizeStrings.Get(19104), false))
+      UpdateSetting(CONTROL_TMR_DIR);
+  else if (setting.id == CONTROL_TMR_RADIO || setting.id == CONTROL_TMR_CHNAME_TV || setting.id == CONTROL_TMR_CHNAME_RADIO)
+  {
+    if (setting.id == CONTROL_TMR_RADIO)
+    {
+      EnableSettings(CONTROL_TMR_CHNAME_TV, !tag->m_bIsRadio);
+      EnableSettings(CONTROL_TMR_CHNAME_RADIO, tag->m_bIsRadio);
+    }
+
+    CFileItemPtr channel = g_PVRChannelGroups->GetGroupAll(tag->m_bIsRadio)->GetByChannelNumber(tag->m_iChannelNumber);
+    if (channel && channel->HasPVRChannelInfoTag())
+    {
+      tag->m_iClientChannelUid = channel->GetPVRChannelInfoTag()->UniqueID();
+      tag->m_iClientId         = channel->GetPVRChannelInfoTag()->ClientID();
+      tag->m_bIsRadio          = channel->GetPVRChannelInfoTag()->IsRadio();
+      tag->m_iChannelNumber    = channel->GetPVRChannelInfoTag()->ChannelNumber();
+    }
+  }
+  else if (setting.id == CONTROL_TMR_DAY && m_tmp_day > 10)
+  {
+    CDateTime time = CDateTime::GetCurrentDateTime();
+    CDateTime timestart = timerStartTime;
+    CDateTime timestop = timerEndTime;
+    int m_tmp_diff;
+    tm time_cur;
+    tm time_tmr;
+
+    /* get diffence of timer in days between today and timer start date */
+    time.GetAsTm(time_cur);
+    timestart.GetAsTm(time_tmr);
+
+    m_tmp_diff = time_tmr.tm_yday - time_cur.tm_yday;
+    if (time_tmr.tm_yday - time_cur.tm_yday < 0)
+      m_tmp_diff = 365;
+
+    CDateTime newStart = timestart + CDateTimeSpan(m_tmp_day-11-m_tmp_diff, 0, 0, 0);
+    CDateTime newEnd = timestop  + CDateTimeSpan(m_tmp_day-11-m_tmp_diff, 0, 0, 0);
+    tag->SetStartFromLocalTime(newStart);
+    tag->SetEndFromLocalTime(newEnd);
+
+    EnableSettings(CONTROL_TMR_FIRST_DAY, false);
+
+    tag->m_bIsRepeating = false;
+    tag->m_iWeekdays = 0;
+  }
+  else if (setting.id == CONTROL_TMR_DAY && m_tmp_day <= 10)
+  {
+    EnableSettings(CONTROL_TMR_FIRST_DAY, true);
+    SetTimerFromWeekdaySetting(*tag);
+  }
+  else if (setting.id == CONTROL_TMR_BEGIN)
+  {
+    if (CGUIDialogNumeric::ShowAndGetTime(timerStartTime, g_localizeStrings.Get(14066)))
+    {
+      CDateTime timestart = timerStartTime;
+      int start_day       = tag->StartAsLocalTime().GetDay();
+      int start_month     = tag->StartAsLocalTime().GetMonth();
+      int start_year      = tag->StartAsLocalTime().GetYear();
+      int start_hour      = timestart.GetHour();
+      int start_minute    = timestart.GetMinute();
+      CDateTime newStart(start_year, start_month, start_day, start_hour, start_minute, 0);
+      tag->SetStartFromLocalTime(newStart);
+
+      timerStartTimeStr = tag->StartAsLocalTime().GetAsLocalizedTime("", false);
+      UpdateSetting(CONTROL_TMR_BEGIN);
+    }
+  }
+  else if (setting.id == CONTROL_TMR_END)
+  {
+    if (CGUIDialogNumeric::ShowAndGetTime(timerEndTime, g_localizeStrings.Get(14066)))
+    {
+      CDateTime timestop = timerEndTime;
+      int start_day       = tag->EndAsLocalTime().GetDay();
+      int start_month     = tag->EndAsLocalTime().GetMonth();
+      int start_year      = tag->EndAsLocalTime().GetYear();
+      int start_hour      = timestop.GetHour();
+      int start_minute    = timestop.GetMinute();
+      CDateTime newEnd(start_year, start_month, start_day, start_hour, start_minute, 0);
+      tag->SetEndFromLocalTime(newEnd);
+
+      timerEndTimeStr = tag->EndAsLocalTime().GetAsLocalizedTime("", false);
+      UpdateSetting(CONTROL_TMR_END);
+    }
+  }
+  else if (setting.id == CONTROL_TMR_FIRST_DAY && m_tmp_day <= 10)
+  {
+    CDateTime newFirstDay;
+    if (m_tmp_iFirstDay > 0)
+      newFirstDay = CDateTime::GetCurrentDateTime() + CDateTimeSpan(m_tmp_iFirstDay-1, 0, 0, 0);
+
+    tag->SetFirstDayFromLocalTime(newFirstDay);
+  }
+
+  tag->UpdateSummary();
+}
+
+void CGUIDialogPVRTimerSettings::SetTimer(CFileItem *item)
+{
+  m_timerItem         = item;
+  m_cancelled         = true;
+
+  m_timerItem->GetPVRTimerInfoTag()->StartAsLocalTime().GetAsSystemTime(timerStartTime);
+  m_timerItem->GetPVRTimerInfoTag()->EndAsLocalTime().GetAsSystemTime(timerEndTime);
+  timerStartTimeStr   = m_timerItem->GetPVRTimerInfoTag()->StartAsLocalTime().GetAsLocalizedTime("", false);
+  timerEndTimeStr     = m_timerItem->GetPVRTimerInfoTag()->EndAsLocalTime().GetAsLocalizedTime("", false);
+
+  m_tmp_iFirstDay     = 0;
+  m_tmp_day           = 11;
+}
+
+void CGUIDialogPVRTimerSettings::OnOkay()
+{
+  m_cancelled = false;
+  CPVRTimerInfoTag* tag = m_timerItem->GetPVRTimerInfoTag();
+  if (tag->m_strTitle == g_localizeStrings.Get(19056))
+    tag->m_strTitle = g_PVRChannelGroups->GetByUniqueID(tag->m_iClientChannelUid, tag->m_iClientId)->ChannelName();
+
+  if (m_bTimerActive)
+    tag->m_state = PVR_TIMER_STATE_SCHEDULED;
+  else
+    tag->m_state = PVR_TIMER_STATE_CANCELLED;
+}
diff --git a/xbmc/pvr/recordings/PVRRecording.cpp b/xbmc/pvr/recordings/PVRRecording.cpp
new file mode 100644
index 0000000..bee6155
--- /dev/null
+++ b/xbmc/pvr/recordings/PVRRecording.cpp
@@ -0,0 +1,219 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "dialogs/GUIDialogOK.h"
+#include "pvr/PVRManager.h"
+#include "settings/AdvancedSettings.h"
+#include "PVRRecordings.h"
+#include "pvr/addons/PVRClients.h"
+#include "utils/StringUtils.h"
+
+#include "epg/Epg.h"
+
+using namespace PVR;
+using namespace EPG;
+
+CPVRRecording::CPVRRecording()
+{
+  Reset();
+}
+
+CPVRRecording::CPVRRecording(const PVR_RECORDING &recording, unsigned int iClientId)
+{
+  Reset();
+
+  m_strRecordingId = recording.strRecordingId;
+  m_strTitle       = recording.strTitle;
+  m_iClientId      = iClientId;
+  m_recordingTime  = recording.recordingTime + g_advancedSettings.m_iPVRTimeCorrection;
+  m_duration       = CDateTimeSpan(0, 0, recording.iDuration / 60, recording.iDuration % 60);
+  m_iPriority      = recording.iPriority;
+  m_iLifetime      = recording.iLifetime;
+  m_strDirectory   = recording.strDirectory;
+  m_strPlot        = recording.strPlot;
+  m_strPlotOutline = recording.strPlotOutline;
+  m_strStreamURL   = recording.strStreamURL;
+  m_strChannelName = recording.strChannelName;
+  m_genre          = StringUtils::Split(CEpg::ConvertGenreIdToString(recording.iGenreType, recording.iGenreSubType), g_advancedSettings.m_videoItemSeparator);
+  m_iRecPlayCount  = recording.iPlayCount;
+}
+
+bool CPVRRecording::operator ==(const CPVRRecording& right) const
+{
+  return (this == &right) ||
+      (m_strRecordingId     == right.m_strRecordingId &&
+       m_iClientId          == right.m_iClientId &&
+       m_strChannelName     == right.m_strChannelName &&
+       m_recordingTime      == right.m_recordingTime &&
+       m_duration           == right.m_duration &&
+       m_strPlotOutline     == right.m_strPlotOutline &&
+       m_strPlot            == right.m_strPlot &&
+       m_strStreamURL       == right.m_strStreamURL &&
+       m_iPriority          == right.m_iPriority &&
+       m_iLifetime          == right.m_iLifetime &&
+       m_strDirectory       == right.m_strDirectory &&
+       m_strFileNameAndPath == right.m_strFileNameAndPath &&
+       m_strTitle           == right.m_strTitle &&
+       m_iRecPlayCount      == right.m_iRecPlayCount);
+}
+
+bool CPVRRecording::operator !=(const CPVRRecording& right) const
+{
+  return !(*this == right);
+}
+
+void CPVRRecording::Reset(void)
+{
+  m_strRecordingId     = StringUtils::EmptyString;
+  m_iClientId          = 0;
+  m_strChannelName     = StringUtils::EmptyString;
+  m_strDirectory       = StringUtils::EmptyString;
+  m_strStreamURL       = StringUtils::EmptyString;
+  m_iPriority          = -1;
+  m_iLifetime          = -1;
+  m_strFileNameAndPath = StringUtils::EmptyString;
+  m_iRecPlayCount      = 0;
+
+  m_recordingTime.Reset();
+  CVideoInfoTag::Reset();
+}
+
+int CPVRRecording::GetDuration() const
+{
+  return (m_duration.GetDays() * 60*60*24 +
+      m_duration.GetHours() * 60*60 +
+      m_duration.GetMinutes() * 60 +
+      m_duration.GetSeconds());
+}
+
+bool CPVRRecording::Delete(void)
+{
+  PVR_ERROR error = g_PVRClients->DeleteRecording(*this);
+  if (error != PVR_ERROR_NO_ERROR)
+  {
+    DisplayError(error);
+    return false;
+  }
+
+  return true;
+}
+
+bool CPVRRecording::Rename(const CStdString &strNewName)
+{
+  m_strTitle.Format("%s", strNewName);
+  PVR_ERROR error = g_PVRClients->RenameRecording(*this);
+  if (error != PVR_ERROR_NO_ERROR)
+  {
+    DisplayError(error);
+    return false;
+  }
+
+  return true;
+}
+
+bool CPVRRecording::SetPlayCount(int count)
+{
+  PVR_ERROR error;
+  m_iRecPlayCount = count;
+  if (g_PVRClients->SupportsRecordingPlayCount(m_iClientId) &&
+      !g_PVRClients->SetRecordingPlayCount(*this, count, &error))
+  {
+    DisplayError(error);
+    return false;
+  }
+
+  return true;
+}
+
+void CPVRRecording::DisplayError(PVR_ERROR err) const
+{
+  if (err == PVR_ERROR_SERVER_ERROR)
+    CGUIDialogOK::ShowAndGetInput(19033,19111,19110,0); /* print info dialog "Server error!" */
+  else if (err == PVR_ERROR_REJECTED)
+    CGUIDialogOK::ShowAndGetInput(19033,19068,19110,0); /* print info dialog "Couldn't delete recording!" */
+  else
+    CGUIDialogOK::ShowAndGetInput(19033,19147,19110,0); /* print info dialog "Unknown error!" */
+
+  return;
+}
+
+void CPVRRecording::Update(const CPVRRecording &tag)
+{
+  m_strRecordingId = tag.m_strRecordingId;
+  m_iClientId      = tag.m_iClientId;
+  m_strTitle       = tag.m_strTitle;
+  m_recordingTime  = tag.m_recordingTime;
+  m_duration       = tag.m_duration;
+  m_iPriority      = tag.m_iPriority;
+  m_iLifetime      = tag.m_iLifetime;
+  m_strDirectory   = tag.m_strDirectory;
+  m_strPlot        = tag.m_strPlot;
+  m_strPlotOutline = tag.m_strPlotOutline;
+  m_strStreamURL   = tag.m_strStreamURL;
+  m_strChannelName = tag.m_strChannelName;
+  m_genre          = tag.m_genre;
+  m_iRecPlayCount  = tag.m_iRecPlayCount;
+
+  CStdString strShow;
+  strShow.Format("%s - ", g_localizeStrings.Get(20364).c_str());
+  if (m_strPlotOutline.Left(strShow.size()).Equals(strShow))
+  {
+    CStdString strEpisode = m_strPlotOutline;
+    CStdString strTitle = m_strDirectory;
+    
+    int pos = strTitle.ReverseFind('/');
+    strTitle.erase(0, pos + 1);
+    strEpisode.erase(0, strShow.size());
+    m_strTitle.Format("%s - %s", strTitle.c_str(), strEpisode);
+    pos = strEpisode.Find('-');
+    strEpisode.erase(0, pos + 2);
+    m_strPlotOutline = strEpisode;
+  }
+  UpdatePath();
+}
+
+void CPVRRecording::UpdatePath(void)
+{
+  if (!m_strStreamURL.IsEmpty())
+  {
+    m_strFileNameAndPath = m_strStreamURL;
+  }
+  else
+  {
+    CStdString strTitle(m_strTitle);
+    CStdString strDatetime(m_recordingTime.GetAsSaveString());
+    strTitle.Replace('/','-');
+    strTitle.Remove('?');
+
+    if (m_strDirectory != StringUtils::EmptyString)
+      m_strFileNameAndPath.Format("pvr://recordings/%s/%s/%s.pvr", m_strDirectory.c_str(), strDatetime.c_str(), strTitle.c_str());
+    else
+      m_strFileNameAndPath.Format("pvr://recordings/%s/%s.pvr", strDatetime.c_str(), strTitle.c_str());
+  }
+}
+
+const CDateTime &CPVRRecording::RecordingTimeAsLocalTime(void) const
+{
+  static CDateTime tmp;
+  tmp.SetFromUTCDateTime(m_recordingTime);
+
+  return tmp;
+}
diff --git a/xbmc/pvr/recordings/PVRRecordings.cpp b/xbmc/pvr/recordings/PVRRecordings.cpp
new file mode 100644
index 0000000..d7c5725
--- /dev/null
+++ b/xbmc/pvr/recordings/PVRRecordings.cpp
@@ -0,0 +1,544 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "FileItem.h"
+#include "dialogs/GUIDialogOK.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "Util.h"
+#include "URL.h"
+#include "utils/log.h"
+#include "threads/SingleLock.h"
+#include "video/VideoDatabase.h"
+
+#include "utils/URIUtils.h"
+#include "pvr/PVRManager.h"
+#include "pvr/addons/PVRClients.h"
+#include "PVRRecordings.h"
+
+using namespace PVR;
+
+CPVRRecordings::CPVRRecordings(void) :
+    m_bIsUpdating(false),
+    m_strDirectoryHistory("pvr://recordings/")
+{
+    m_thumbLoader.SetNumOfWorkers(1); 
+}
+
+void CPVRRecordings::UpdateFromClients(void)
+{
+  CSingleLock lock(m_critSection);
+  Clear();
+  g_PVRClients->GetRecordings(this);
+}
+
+CStdString CPVRRecordings::TrimSlashes(const CStdString &strOrig) const
+{
+  CStdString strReturn(strOrig);
+  while (strReturn.Left(1) == "/")
+    strReturn.erase(0, 1);
+
+  URIUtils::RemoveSlashAtEnd(strReturn);
+
+  return strReturn;
+}
+
+const CStdString CPVRRecordings::GetDirectoryFromPath(const CStdString &strPath, const CStdString &strBase) const
+{
+  CStdString strReturn;
+  CStdString strUsePath = TrimSlashes(strPath);
+  CStdString strUseBase = TrimSlashes(strBase);
+
+  /* strip the base or return an empty value if it doesn't fit or match */
+  if (!strUseBase.IsEmpty())
+  {
+    /* adding "/" to make sure that base matches the complete folder name and not only parts of it */
+    if (strUsePath.GetLength() <= strUseBase.GetLength() || strUsePath.Left(strUseBase.GetLength() + 1) != strUseBase + "/")
+      return strReturn;
+    strUsePath.erase(0, strUseBase.GetLength());
+  }
+
+  /* check for more occurences */
+  int iDelimiter = strUsePath.Find('/');
+  if (iDelimiter > 0)
+    strReturn = strUsePath.Left(iDelimiter);
+  else
+    strReturn = strUsePath;
+
+  return TrimSlashes(strReturn);
+}
+
+bool CPVRRecordings::IsDirectoryMember(const CStdString &strDirectory, const CStdString &strEntryDirectory, bool bDirectMember /* = true */) const
+{
+  CStdString strUseDirectory = TrimSlashes(strDirectory);
+  CStdString strUseEntryDirectory = TrimSlashes(strEntryDirectory);
+
+  return strUseEntryDirectory.Left(strUseDirectory.GetLength()).Equals(strUseDirectory) &&
+      (!bDirectMember || strUseEntryDirectory.Equals(strUseDirectory));
+}
+
+void CPVRRecordings::GetContents(const CStdString &strDirectory, CFileItemList *results)
+{
+  for (unsigned int iRecordingPtr = 0; iRecordingPtr < m_recordings.size(); iRecordingPtr++)
+  {
+    CPVRRecording *current = m_recordings.at(iRecordingPtr);
+    bool directMember = !HasAllRecordingsPathExtension(strDirectory);
+    if (!IsDirectoryMember(RemoveAllRecordingsPathExtension(strDirectory), current->m_strDirectory, directMember))
+      continue;
+
+    CFileItemPtr pFileItem(new CFileItem(*current));
+    pFileItem->SetLabel2(current->RecordingTimeAsLocalTime().GetAsLocalizedDateTime(true, false));
+    pFileItem->m_dateTime = current->RecordingTimeAsLocalTime();
+    pFileItem->SetPath(current->m_strFileNameAndPath);
+
+    // Set the play count either directly from client (if supported) or from video db
+    if (g_PVRClients->SupportsRecordingPlayCount(pFileItem->GetPVRRecordingInfoTag()->m_iClientId))
+    {
+      pFileItem->GetPVRRecordingInfoTag()->m_playCount=pFileItem->GetPVRRecordingInfoTag()->m_iRecPlayCount;
+    }
+    else
+    {
+      CVideoDatabase db;
+      if (db.Open())
+      pFileItem->GetPVRRecordingInfoTag()->m_playCount=db.GetPlayCount(*pFileItem);
+    }
+    pFileItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED, pFileItem->GetPVRRecordingInfoTag()->m_playCount > 0);
+
+    results->Add(pFileItem);
+  }
+}
+
+void CPVRRecordings::GetSubDirectories(const CStdString &strBase, CFileItemList *results, bool bAutoSkip /* = true */)
+{
+  CStdString strUseBase = TrimSlashes(strBase);
+
+  std::set<CStdString> unwatchedFolders;
+
+  for (unsigned int iRecordingPtr = 0; iRecordingPtr < m_recordings.size(); iRecordingPtr++)
+  {
+    CPVRRecording *current = m_recordings.at(iRecordingPtr);
+    const CStdString strCurrent = GetDirectoryFromPath(current->m_strDirectory, strUseBase);
+    if (strCurrent.IsEmpty())
+      continue;
+
+    CStdString strFilePath;
+    if(strUseBase.empty())
+      strFilePath.Format("pvr://recordings/%s/", strCurrent.c_str());
+    else
+      strFilePath.Format("pvr://recordings/%s/%s/", strUseBase.c_str(), strCurrent.c_str());
+
+    if (!results->Contains(strFilePath))
+    {
+      CFileItemPtr pFileItem;
+      pFileItem.reset(new CFileItem(strCurrent, true));
+      pFileItem->SetPath(strFilePath);
+      pFileItem->SetLabel(strCurrent);
+      pFileItem->SetLabelPreformated(true);
+      pFileItem->m_dateTime = current->RecordingTimeAsLocalTime();
+
+      // Initialize folder overlay from play count (either directly from client or from video database)
+      CVideoDatabase db;
+      bool supportsPlayCount = g_PVRClients->SupportsRecordingPlayCount(current->m_iClientId);
+      if ((supportsPlayCount && current->m_iRecPlayCount > 0) ||
+          (!supportsPlayCount && db.Open() && db.GetPlayCount(*pFileItem) > 0))
+      {
+        pFileItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_WATCHED, false);
+      }
+      else
+      {
+        unwatchedFolders.insert(strFilePath);
+      }
+
+      results->Add(pFileItem);
+    }
+    else
+    {
+      CFileItemPtr pFileItem;
+      pFileItem=results->Get(strFilePath);
+      if (pFileItem->m_dateTime<current->RecordingTimeAsLocalTime())
+        pFileItem->m_dateTime  = current->RecordingTimeAsLocalTime();
+
+      // Unset folder overlay if recording is unwatched
+      if (unwatchedFolders.find(strFilePath) == unwatchedFolders.end()) {
+        CVideoDatabase db;
+        bool supportsPlayCount = g_PVRClients->SupportsRecordingPlayCount(current->m_iClientId);
+        if ((supportsPlayCount && current->m_iRecPlayCount == 0) || (!supportsPlayCount && db.Open() && db.GetPlayCount(*pFileItem) == 0))
+        {
+          pFileItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED, false);
+          unwatchedFolders.insert(strFilePath);
+        }
+      }
+    }
+  }
+
+  int subDirectories = results->Size();
+  CFileItemList files;
+  GetContents(strBase, &files);
+
+  if (bAutoSkip && results->Size() == 1 && files.Size() == 0)
+  {
+    CStdString strGetPath;
+    strGetPath.Format("%s/%s/", strUseBase.c_str(), results->Get(0)->GetLabel());
+
+    results->Clear();
+
+    CLog::Log(LOGDEBUG, "CPVRRecordings - %s - '%s' only has 1 subdirectory, selecting that directory ('%s')",
+        __FUNCTION__, strUseBase.c_str(), strGetPath.c_str());
+    GetSubDirectories(strGetPath, results, true);
+    return;
+  }
+
+  results->Append(files);
+
+  // Add 'All Recordings' item (if we have at least one subdirectory in the list)
+  if (subDirectories > 0)
+  {
+    CStdString strLabel(g_localizeStrings.Get(19270)); // "* All recordings"
+    CFileItemPtr pItem(new CFileItem(strLabel));
+    CStdString strAllPath;
+    if(strUseBase.empty())
+      strAllPath = "pvr://recordings";
+    else
+      strAllPath.Format("pvr://recordings/%s", strUseBase.c_str());
+    pItem->SetPath(AddAllRecordingsPathExtension(strAllPath));
+    pItem->SetSpecialSort(SortSpecialOnTop);
+    pItem->SetLabelPreformated(true);
+    pItem->m_bIsFolder = true;
+    pItem->m_bIsShareOrDrive = false;
+    for(int i=0; i<results->Size(); ++i)
+    {
+      if(pItem->m_dateTime < results->Get(i)->m_dateTime)
+        pItem->m_dateTime = results->Get(i)->m_dateTime;
+    }
+    results->AddFront(pItem, 0);
+  }
+
+  if (!strUseBase.IsEmpty())
+  {
+    CStdString strLabel("..");
+    CFileItemPtr pItem(new CFileItem(strLabel));
+    pItem->SetPath(m_strDirectoryHistory);
+    pItem->m_bIsFolder = true;
+    pItem->m_bIsShareOrDrive = false;
+    results->AddFront(pItem, 0);
+  }
+  m_strDirectoryHistory.Format("pvr://recordings/%s", strUseBase.c_str());
+}
+
+bool CPVRRecordings::HasAllRecordingsPathExtension(const CStdString &strDirectory)
+{
+  CStdString strUseDir = TrimSlashes(strDirectory);
+  CStdString strAllRecordingsPathExtension(PVR_ALL_RECORDINGS_PATH_EXTENSION);
+
+  if (strUseDir.GetLength() < strAllRecordingsPathExtension.GetLength())
+    return false;
+
+  if (strUseDir.GetLength() == strAllRecordingsPathExtension.GetLength())
+    return strUseDir.Equals(strAllRecordingsPathExtension);
+
+  return strUseDir.Right(strAllRecordingsPathExtension.GetLength() + 1).Equals("/" + strAllRecordingsPathExtension);
+}
+
+CStdString CPVRRecordings::AddAllRecordingsPathExtension(const CStdString &strDirectory)
+{
+  if (HasAllRecordingsPathExtension(strDirectory))
+    return strDirectory;
+
+  CStdString strResult = strDirectory;
+  if (!strDirectory.Right(1).Equals("/"))
+    strResult = strResult + "/";
+
+  return strResult + PVR_ALL_RECORDINGS_PATH_EXTENSION + "/";
+}
+
+CStdString CPVRRecordings::RemoveAllRecordingsPathExtension(const CStdString &strDirectory)
+{
+  if (!HasAllRecordingsPathExtension(strDirectory))
+    return strDirectory;
+
+  return strDirectory.Left(strDirectory.GetLength() - strlen(PVR_ALL_RECORDINGS_PATH_EXTENSION) - 1);
+}
+
+int CPVRRecordings::Load(void)
+{
+  Update();
+
+  return m_recordings.size();
+}
+
+void CPVRRecordings::Unload()
+{
+  Clear();
+}
+
+void CPVRRecordings::Update(void)
+{
+  CSingleLock lock(m_critSection);
+  if (m_bIsUpdating)
+    return;
+  m_bIsUpdating = true;
+  lock.Leave();
+
+  CLog::Log(LOGDEBUG, "CPVRRecordings - %s - updating recordings", __FUNCTION__);
+  UpdateFromClients();
+
+  lock.Enter();
+  m_bIsUpdating = false;
+  SetChanged();
+  lock.Leave();
+
+  NotifyObservers(ObservableMessageRecordings);
+}
+
+int CPVRRecordings::GetNumRecordings()
+{
+  CSingleLock lock(m_critSection);
+  return m_recordings.size();
+}
+
+int CPVRRecordings::GetRecordings(CFileItemList* results)
+{
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iRecordingPtr = 0; iRecordingPtr < m_recordings.size(); iRecordingPtr++)
+  {
+    CFileItemPtr pFileItem(new CFileItem(*m_recordings.at(iRecordingPtr)));
+    results->Add(pFileItem);
+  }
+
+  return m_recordings.size();
+}
+
+bool CPVRRecordings::DeleteRecording(const CFileItem &item)
+{
+  if (!item.IsPVRRecording())
+  {
+    CLog::Log(LOGERROR, "CPVRRecordings - %s - cannot delete file: no valid recording tag", __FUNCTION__);
+    return false;
+  }
+
+  CPVRRecording *tag = (CPVRRecording *)item.GetPVRRecordingInfoTag();
+  return tag->Delete();
+}
+
+bool CPVRRecordings::RenameRecording(CFileItem &item, CStdString &strNewName)
+{
+  bool bReturn = false;
+
+  if (!item.IsPVRRecording())
+  {
+    CLog::Log(LOGERROR, "CPVRRecordings - %s - cannot rename file: no valid recording tag", __FUNCTION__);
+    return bReturn;
+  }
+
+  CPVRRecording* tag = item.GetPVRRecordingInfoTag();
+  return tag->Rename(strNewName);
+}
+
+bool CPVRRecordings::SetRecordingsPlayCount(const CFileItemPtr &item, int count)
+{
+  bool bResult = false;
+
+  CVideoDatabase database;
+  if (database.Open())
+  {
+    bResult = true;
+
+    CLog::Log(LOGDEBUG, "CPVRRecordings - %s - item path %s", __FUNCTION__, item->GetPath().c_str());
+    CFileItemList items;
+    if (item->m_bIsFolder)
+    {
+      CStdString strPath = item->GetPath();
+      CDirectory::GetDirectory(strPath, items);
+    }
+    else
+      items.Add(item);
+
+    CLog::Log(LOGDEBUG, "CPVRRecordings - %s - will set watched for %d items", __FUNCTION__, items.Size());
+    for (int i=0;i<items.Size();++i)
+    {
+      CLog::Log(LOGDEBUG, "CPVRRecordings - %s - setting watched for item %d", __FUNCTION__, i);
+
+      CFileItemPtr pItem=items[i];
+      if (pItem->m_bIsFolder)
+      {
+        CLog::Log(LOGDEBUG, "CPVRRecordings - %s - path %s is a folder, will call recursively", __FUNCTION__, pItem->GetPath().c_str());
+        if (pItem->GetLabel() != "..")
+        {
+          SetRecordingsPlayCount(pItem, count);
+        }
+        continue;
+      }
+
+      pItem->GetPVRRecordingInfoTag()->SetPlayCount(count);
+
+      // Clear resume bookmark
+      if (count > 0)
+        database.ClearBookMarksOfFile(pItem->GetPath(), CBookmark::RESUME);
+
+      database.SetPlayCount(*pItem, count);
+    }
+
+    database.Close();
+  }
+
+  return bResult;
+}
+
+bool CPVRRecordings::GetDirectory(const CStdString& strPath, CFileItemList &items)
+{
+  bool bSuccess(false);
+  CFileItemList files;
+
+  {
+    CSingleLock lock(m_critSection);
+
+    CURL url(strPath);
+    CStdString strFileName = url.GetFileName();
+    URIUtils::RemoveSlashAtEnd(strFileName);
+
+    if (strFileName.Left(10) == "recordings")
+    {
+      strFileName.erase(0, 10);
+      GetSubDirectories(strFileName, &items, true);
+      GetContents(strFileName, &files);
+      bSuccess = true;
+    }
+  }
+
+  if(bSuccess)
+  {
+    for (int i = 0; i < files.Size(); i++)
+    {
+      CFileItemPtr pFileItem = files.Get(i);
+      CFileItemPtr pThumbItem = items.Get(pFileItem->GetPath());
+      if (!pThumbItem->HasThumbnail())
+        m_thumbLoader.LoadItem(pThumbItem.get());
+    }
+  }
+
+  return bSuccess;
+}
+
+void CPVRRecordings::SetPlayCount(const CFileItem &item, int iPlayCount)
+{
+  if (!item.HasPVRRecordingInfoTag())
+    return;
+
+  const CPVRRecording *recording = item.GetPVRRecordingInfoTag();
+  CSingleLock lock(m_critSection);
+  for (unsigned int iRecordingPtr = 0; iRecordingPtr < m_recordings.size(); iRecordingPtr++)
+  {
+    CPVRRecording *current = m_recordings.at(iRecordingPtr);
+    if (*current == *recording)
+    {
+      current->SetPlayCount(iPlayCount);
+      break;
+    }
+  }
+}
+
+void CPVRRecordings::GetAll(CFileItemList &items)
+{
+  CSingleLock lock(m_critSection);
+  for (unsigned int iRecordingPtr = 0; iRecordingPtr < m_recordings.size(); iRecordingPtr++)
+  {
+    CPVRRecording *current = m_recordings.at(iRecordingPtr);
+
+    CFileItemPtr pFileItem(new CFileItem(*current));
+    pFileItem->SetLabel2(current->RecordingTimeAsLocalTime().GetAsLocalizedDateTime(true, false));
+    pFileItem->m_dateTime = current->RecordingTimeAsLocalTime();
+    pFileItem->SetPath(current->m_strFileNameAndPath);
+
+    // Set the play count either directly from client (if supported) or from video db
+    if (g_PVRClients->SupportsRecordingPlayCount(pFileItem->GetPVRRecordingInfoTag()->m_iClientId))
+    {
+      pFileItem->GetPVRRecordingInfoTag()->m_playCount=pFileItem->GetPVRRecordingInfoTag()->m_iRecPlayCount;
+    }
+    else
+    {
+      CVideoDatabase db;
+      if (db.Open())
+      pFileItem->GetPVRRecordingInfoTag()->m_playCount=db.GetPlayCount(*pFileItem);
+    }
+    pFileItem->SetOverlayImage(CGUIListItem::ICON_OVERLAY_UNWATCHED, pFileItem->GetPVRRecordingInfoTag()->m_playCount > 0);
+
+    items.Add(pFileItem);
+  }
+}
+
+CFileItemPtr CPVRRecordings::GetByPath(const CStdString &path)
+{
+  CURL url(path);
+  CStdString fileName = url.GetFileName();
+  URIUtils::RemoveSlashAtEnd(fileName);
+
+  CSingleLock lock(m_critSection);
+
+  if (fileName.Left(11) == "recordings/")
+  {
+    for (unsigned int iRecordingPtr = 0; iRecordingPtr < m_recordings.size(); iRecordingPtr++)
+    {
+      if(path.Equals(m_recordings.at(iRecordingPtr)->m_strFileNameAndPath))
+      {
+        CFileItemPtr fileItem(new CFileItem(*m_recordings.at(iRecordingPtr)));
+        return fileItem;
+      }
+    }
+  }
+
+  CFileItemPtr fileItem(new CFileItem);
+  return fileItem;
+}
+
+void CPVRRecordings::Clear()
+{
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iRecordingPtr = 0; iRecordingPtr < m_recordings.size(); iRecordingPtr++)
+    delete m_recordings.at(iRecordingPtr);
+  m_recordings.erase(m_recordings.begin(), m_recordings.end());
+}
+
+void CPVRRecordings::UpdateEntry(const CPVRRecording &tag)
+{
+  bool bFound = false;
+  CSingleLock lock(m_critSection);
+
+  for (unsigned int iRecordingPtr = 0; iRecordingPtr < m_recordings.size(); iRecordingPtr++)
+  {
+    CPVRRecording *currentTag = m_recordings.at(iRecordingPtr);
+    if (currentTag->m_iClientId == tag.m_iClientId &&
+        currentTag->m_strRecordingId.Equals(tag.m_strRecordingId))
+    {
+      currentTag->Update(tag);
+      bFound = true;
+      break;
+    }
+  }
+
+  if (!bFound)
+  {
+    CPVRRecording *newTag = new CPVRRecording();
+    newTag->Update(tag);
+    m_recordings.push_back(newTag);
+  }
+}
diff --git a/xbmc/pvr/timers/PVRTimerInfoTag.cpp b/xbmc/pvr/timers/PVRTimerInfoTag.cpp
new file mode 100644
index 0000000..258cf9f
--- /dev/null
+++ b/xbmc/pvr/timers/PVRTimerInfoTag.cpp
@@ -0,0 +1,598 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Application.h"
+#include "settings/GUISettings.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "settings/AdvancedSettings.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+
+#include "PVRTimers.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/channels/PVRChannelGroupInternal.h"
+#include "epg/EpgContainer.h"
+#include "pvr/addons/PVRClients.h"
+
+#include "epg/Epg.h"
+
+using namespace std;
+using namespace PVR;
+using namespace EPG;
+
+CPVRTimerInfoTag::CPVRTimerInfoTag(void)
+{
+  m_strTitle           = StringUtils::EmptyString;
+  m_strDirectory       = "/";
+  m_strSummary         = StringUtils::EmptyString;
+  m_iClientId          = g_PVRClients->GetFirstConnectedClientID();
+  m_iClientIndex       = -1;
+  m_iClientChannelUid  = -1;
+  m_iPriority          = g_guiSettings.GetInt("pvrrecord.defaultpriority");
+  m_iLifetime          = g_guiSettings.GetInt("pvrrecord.defaultlifetime");
+  m_bIsRepeating       = false;
+  m_iWeekdays          = 0;
+  m_strFileNameAndPath = StringUtils::EmptyString;
+  m_iChannelNumber     = 0;
+  m_bIsRadio           = false;
+  CEpgInfoTagPtr emptyTag;
+  m_epgTag             = emptyTag;
+  m_iMarginStart       = g_guiSettings.GetInt("pvrrecord.marginstart");
+  m_iMarginEnd         = g_guiSettings.GetInt("pvrrecord.marginend");
+  m_iGenreType         = 0;
+  m_iGenreSubType      = 0;
+  m_StartTime          = CDateTime::GetUTCDateTime();
+  m_StopTime           = m_StartTime;
+  m_state              = PVR_TIMER_STATE_SCHEDULED;
+  m_FirstDay.SetValid(false);
+}
+
+CPVRTimerInfoTag::CPVRTimerInfoTag(const PVR_TIMER &timer, CPVRChannelPtr channel, unsigned int iClientId)
+{
+  m_strTitle           = timer.strTitle;
+  m_strDirectory       = timer.strDirectory;
+  m_strSummary         = StringUtils::EmptyString;
+  m_iClientId          = iClientId;
+  m_iClientIndex       = timer.iClientIndex;
+  m_iClientChannelUid  = channel ? channel->UniqueID() : timer.iClientChannelUid;
+  m_iChannelNumber     = channel ? g_PVRChannelGroups->GetGroupAll(channel->IsRadio())->GetChannelNumber(*channel) : 0;
+  m_StartTime          = timer.startTime + g_advancedSettings.m_iPVRTimeCorrection;
+  m_StopTime           = timer.endTime + g_advancedSettings.m_iPVRTimeCorrection;
+  m_bIsRepeating       = timer.bIsRepeating;
+  m_FirstDay           = timer.firstDay + g_advancedSettings.m_iPVRTimeCorrection;
+  m_iWeekdays          = timer.iWeekdays;
+  m_iPriority          = timer.iPriority;
+  m_iLifetime          = timer.iLifetime;
+  m_iMarginStart       = timer.iMarginStart;
+  m_iMarginEnd         = timer.iMarginEnd;
+  m_genre              = StringUtils::Split(CEpg::ConvertGenreIdToString(timer.iGenreType, timer.iGenreSubType), g_advancedSettings.m_videoItemSeparator);
+  m_iGenreType         = timer.iGenreType;
+  m_iGenreSubType      = timer.iGenreSubType;
+  CEpgInfoTagPtr emptyTag;
+  m_epgTag             = emptyTag;
+  m_channel            = channel;
+  m_bIsRadio           = channel && channel->IsRadio();
+  m_state              = timer.state;
+  m_strFileNameAndPath.Format("pvr://client%i/timers/%i", m_iClientId, m_iClientIndex);
+
+  UpdateSummary();
+}
+
+bool CPVRTimerInfoTag::operator ==(const CPVRTimerInfoTag& right) const
+{
+  bool bChannelsMatch = true;
+  if (m_channel && right.m_channel)
+    bChannelsMatch = *m_channel == *right.m_channel;
+  else if (m_channel != right.m_channel)
+    bChannelsMatch = false;
+
+  return (bChannelsMatch &&
+          m_iClientIndex       == right.m_iClientIndex &&
+          m_strSummary         == right.m_strSummary &&
+          m_iClientChannelUid  == right.m_iClientChannelUid &&
+          m_bIsRepeating       == right.m_bIsRepeating &&
+          m_StartTime          == right.m_StartTime &&
+          m_StopTime           == right.m_StopTime &&
+          m_FirstDay           == right.m_FirstDay &&
+          m_iWeekdays          == right.m_iWeekdays &&
+          m_iPriority          == right.m_iPriority &&
+          m_iLifetime          == right.m_iLifetime &&
+          m_strFileNameAndPath == right.m_strFileNameAndPath &&
+          m_strTitle           == right.m_strTitle &&
+          m_strDirectory       == right.m_strDirectory &&
+          m_iClientId          == right.m_iClientId &&
+          m_iMarginStart       == right.m_iMarginStart &&
+          m_iMarginEnd         == right.m_iMarginEnd &&
+          m_state              == right.m_state);
+}
+
+CPVRTimerInfoTag &CPVRTimerInfoTag::operator=(const CPVRTimerInfoTag &orig)
+{
+  m_channel            = orig.m_channel;
+  m_iClientIndex       = orig.m_iClientIndex;
+  m_strSummary         = orig.m_strSummary;
+  m_iClientChannelUid  = orig.m_iClientChannelUid;
+  m_bIsRepeating       = orig.m_bIsRepeating;
+  m_StartTime          = orig.m_StartTime;
+  m_StopTime           = orig.m_StopTime;
+  m_FirstDay           = orig.m_FirstDay;
+  m_iWeekdays          = orig.m_iWeekdays;
+  m_iPriority          = orig.m_iPriority;
+  m_iLifetime          = orig.m_iLifetime;
+  m_strFileNameAndPath = orig.m_strFileNameAndPath;
+  m_strTitle           = orig.m_strTitle;
+  m_strDirectory       = orig.m_strDirectory;
+  m_iClientId          = orig.m_iClientId;
+  m_iMarginStart       = orig.m_iMarginStart;
+  m_iMarginEnd         = orig.m_iMarginEnd;
+  m_state              = orig.m_state;
+  m_iChannelNumber     = orig.m_iChannelNumber;
+
+  return *this;
+}
+
+CPVRTimerInfoTag::~CPVRTimerInfoTag(void)
+{
+  ClearEpgTag();
+}
+
+/**
+ * Compare not equal for two CPVRTimerInfoTag
+ */
+bool CPVRTimerInfoTag::operator !=(const CPVRTimerInfoTag& right) const
+{
+  return !(*this == right);
+}
+
+int CPVRTimerInfoTag::Compare(const CPVRTimerInfoTag &timer) const
+{
+  CSingleLock lock(m_critSection);
+  int iTimerDelta = 0;
+  if (StartAsUTC() != timer.StartAsUTC())
+  {
+    CDateTimeSpan timerDelta = StartAsUTC() - timer.StartAsUTC();
+    iTimerDelta = (timerDelta.GetSeconds() + timerDelta.GetMinutes() * 60 + timerDelta.GetHours() * 3600 + timerDelta.GetDays() * 86400);
+  }
+
+  /* if the start times are equal, compare the priority of the timers */
+  return iTimerDelta == 0 ?
+    timer.m_iPriority - m_iPriority :
+    iTimerDelta;
+}
+
+void CPVRTimerInfoTag::UpdateSummary(void)
+{
+  CSingleLock lock(m_critSection);
+  m_strSummary.clear();
+
+  if (!m_bIsRepeating || !m_iWeekdays)
+  {
+    m_strSummary.Format("%s %s %s %s %s",
+        StartAsLocalTime().GetAsLocalizedDate(),
+        g_localizeStrings.Get(19159),
+        StartAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false),
+        g_localizeStrings.Get(19160),
+        EndAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false));
+  }
+  else if (m_FirstDay.IsValid())
+  {
+    m_strSummary.Format("%s-%s-%s-%s-%s-%s-%s %s %s %s %s %s %s",
+        m_iWeekdays & 0x01 ? g_localizeStrings.Get(19149) : "__",
+        m_iWeekdays & 0x02 ? g_localizeStrings.Get(19150) : "__",
+        m_iWeekdays & 0x04 ? g_localizeStrings.Get(19151) : "__",
+        m_iWeekdays & 0x08 ? g_localizeStrings.Get(19152) : "__",
+        m_iWeekdays & 0x10 ? g_localizeStrings.Get(19153) : "__",
+        m_iWeekdays & 0x20 ? g_localizeStrings.Get(19154) : "__",
+        m_iWeekdays & 0x40 ? g_localizeStrings.Get(19155) : "__",
+        g_localizeStrings.Get(19156),
+        FirstDayAsLocalTime().GetAsLocalizedDate(false),
+        g_localizeStrings.Get(19159),
+        StartAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false),
+        g_localizeStrings.Get(19160),
+        EndAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false));
+  }
+  else
+  {
+    m_strSummary.Format("%s-%s-%s-%s-%s-%s-%s %s %s %s %s",
+        m_iWeekdays & 0x01 ? g_localizeStrings.Get(19149) : "__",
+        m_iWeekdays & 0x02 ? g_localizeStrings.Get(19150) : "__",
+        m_iWeekdays & 0x04 ? g_localizeStrings.Get(19151) : "__",
+        m_iWeekdays & 0x08 ? g_localizeStrings.Get(19152) : "__",
+        m_iWeekdays & 0x10 ? g_localizeStrings.Get(19153) : "__",
+        m_iWeekdays & 0x20 ? g_localizeStrings.Get(19154) : "__",
+        m_iWeekdays & 0x40 ? g_localizeStrings.Get(19155) : "__",
+        g_localizeStrings.Get(19159),
+        StartAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false),
+        g_localizeStrings.Get(19160),
+        EndAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false));
+  }
+}
+
+/**
+ * Get the status string of this Timer, is used by the GUIInfoManager
+ */
+CStdString CPVRTimerInfoTag::GetStatus() const
+{
+  CStdString strReturn = g_localizeStrings.Get(305);
+  CSingleLock lock(m_critSection);
+  if (m_strFileNameAndPath == "pvr://timers/add.timer")
+    strReturn = g_localizeStrings.Get(19026);
+  else if (m_state == PVR_TIMER_STATE_CANCELLED || m_state == PVR_TIMER_STATE_ABORTED)
+    strReturn = g_localizeStrings.Get(13106);
+  else if (m_state == PVR_TIMER_STATE_RECORDING)
+    strReturn = g_localizeStrings.Get(19162);
+
+  return strReturn;
+}
+
+bool CPVRTimerInfoTag::AddToClient(void) const
+{
+  PVR_ERROR error = g_PVRClients->AddTimer(*this);
+  if (error != PVR_ERROR_NO_ERROR)
+  {
+    DisplayError(error);
+    return false;
+  }
+
+  return true;
+}
+
+bool CPVRTimerInfoTag::DeleteFromClient(bool bForce /* = false */) const
+{
+  PVR_ERROR error = g_PVRClients->DeleteTimer(*this, bForce);
+  if (error == PVR_ERROR_RECORDING_RUNNING)
+  {
+    // recording running. ask the user if it should be deleted anyway
+    if (!CGUIDialogYesNo::ShowAndGetInput(122,0,19122,0))
+      return false;
+
+    error = g_PVRClients->DeleteTimer(*this, true);
+  }
+
+  if (error != PVR_ERROR_NO_ERROR)
+  {
+    DisplayError(error);
+    return false;
+  }
+
+
+  return true;
+}
+
+bool CPVRTimerInfoTag::RenameOnClient(const CStdString &strNewName)
+{
+  {
+    CSingleLock lock(m_critSection);
+    m_strTitle = strNewName;
+  }
+
+  PVR_ERROR error = g_PVRClients->RenameTimer(*this, strNewName);
+  if (error != PVR_ERROR_NO_ERROR)
+  {
+    if (error == PVR_ERROR_NOT_IMPLEMENTED)
+      return UpdateOnClient();
+
+    DisplayError(error);
+    return false;
+  }
+
+  return true;
+}
+
+bool CPVRTimerInfoTag::UpdateEntry(const CPVRTimerInfoTag &tag)
+{
+  CSingleLock lock(m_critSection);
+
+  m_iClientId         = tag.m_iClientId;
+  m_iClientIndex      = tag.m_iClientIndex;
+  m_strTitle          = tag.m_strTitle;
+  m_strDirectory      = tag.m_strDirectory;
+  m_iClientChannelUid = tag.m_iClientChannelUid;
+  m_StartTime         = tag.m_StartTime;
+  m_StopTime          = tag.m_StopTime;
+  m_FirstDay          = tag.m_FirstDay;
+  m_iPriority         = tag.m_iPriority;
+  m_iLifetime         = tag.m_iLifetime;
+  m_state             = tag.m_state;
+  m_bIsRepeating      = tag.m_bIsRepeating;
+  m_iWeekdays         = tag.m_iWeekdays;
+  m_iChannelNumber    = tag.m_iChannelNumber;
+  m_bIsRadio          = tag.m_bIsRadio;
+  m_iMarginStart      = tag.m_iMarginStart;
+  m_iMarginEnd        = tag.m_iMarginEnd;
+  m_epgTag            = tag.m_epgTag;
+  m_genre             = tag.m_genre;
+  m_iGenreType        = tag.m_iGenreType;
+  m_iGenreSubType     = tag.m_iGenreSubType;
+  m_strSummary        = tag.m_strSummary;
+
+  if (m_strSummary.IsEmpty())
+    UpdateSummary();
+
+  return true;
+}
+
+bool CPVRTimerInfoTag::UpdateOnClient()
+{
+  PVR_ERROR error = g_PVRClients->UpdateTimer(*this);
+  if (error != PVR_ERROR_NO_ERROR)
+  {
+    DisplayError(error);
+    return false;
+  }
+
+  return true;
+}
+
+void CPVRTimerInfoTag::DisplayError(PVR_ERROR err) const
+{
+  if (err == PVR_ERROR_SERVER_ERROR)
+    CGUIDialogOK::ShowAndGetInput(19033,19111,19110,0); /* print info dialog "Server error!" */
+  else if (err == PVR_ERROR_REJECTED)
+    CGUIDialogOK::ShowAndGetInput(19033,19109,19110,0); /* print info dialog "Couldn't delete timer!" */
+  else if (err == PVR_ERROR_ALREADY_PRESENT)
+    CGUIDialogOK::ShowAndGetInput(19033,19109,0,19067); /* print info dialog */
+  else
+    CGUIDialogOK::ShowAndGetInput(19033,19147,19110,0); /* print info dialog "Unknown error!" */
+}
+
+void CPVRTimerInfoTag::SetEpgInfoTag(CEpgInfoTagPtr tag)
+{
+  CSingleLock lock(m_critSection);
+  if (tag && m_epgTag != tag)
+    CLog::Log(LOGINFO, "cPVRTimerInfoTag: timer %s set to epg event %s", m_strTitle.c_str(), tag->Title().c_str());
+  else if (!tag && m_epgTag)
+    CLog::Log(LOGINFO, "cPVRTimerInfoTag: timer %s set to no epg event", m_strTitle.c_str());
+  m_epgTag = tag;
+}
+
+int CPVRTimerInfoTag::ChannelNumber() const
+{
+  CPVRChannelPtr channeltag = ChannelTag();
+  return channeltag ? channeltag->ChannelNumber() : 0;
+}
+
+CStdString CPVRTimerInfoTag::ChannelName() const
+{
+  CStdString strReturn;
+  CPVRChannelPtr channeltag = ChannelTag();
+  if (channeltag)
+    strReturn = channeltag->ChannelName();
+  return strReturn;
+}
+
+CStdString CPVRTimerInfoTag::ChannelIcon() const
+{
+  CStdString strReturn;
+  CPVRChannelPtr channeltag = ChannelTag();
+  if (channeltag)
+    strReturn = channeltag->IconPath();
+  return strReturn;
+}
+
+bool CPVRTimerInfoTag::SetDuration(int iDuration)
+{
+  CSingleLock lock(m_critSection);
+  if (m_StartTime.IsValid())
+  {
+    m_StopTime = m_StartTime + CDateTimeSpan(0, iDuration / 60, iDuration % 60, 0);
+    return true;
+  }
+
+  return false;
+}
+
+CPVRTimerInfoTag *CPVRTimerInfoTag::CreateFromEpg(const CEpgInfoTag &tag)
+{
+  /* create a new timer */
+  CPVRTimerInfoTag *newTag = new CPVRTimerInfoTag();
+  if (!newTag)
+  {
+    CLog::Log(LOGERROR, "%s - couldn't create new timer", __FUNCTION__);
+    return NULL;
+  }
+
+  /* check if a valid channel is set */
+  CPVRChannelPtr channel = tag.ChannelTag();
+  if (!channel)
+  {
+    CLog::Log(LOGERROR, "%s - no channel set", __FUNCTION__);
+    return NULL;
+  }
+
+  /* check if the epg end date is in the future */
+  if (tag.EndAsLocalTime() < CDateTime::GetCurrentDateTime())
+  {
+    CLog::Log(LOGERROR, "%s - end time is in the past", __FUNCTION__);
+    return NULL;
+  }
+
+  /* set the timer data */
+  CDateTime newStart = tag.StartAsUTC();
+  CDateTime newEnd = tag.EndAsUTC();
+  newTag->m_iClientIndex      = -1;
+  newTag->m_strTitle          = tag.Title().empty() ? channel->ChannelName() : tag.Title();
+  newTag->m_iChannelNumber    = channel->ChannelNumber();
+  newTag->m_iClientChannelUid = channel->UniqueID();
+  newTag->m_iClientId         = channel->ClientID();
+  newTag->m_bIsRadio          = channel->IsRadio();
+  newTag->m_iGenreType        = tag.GenreType();
+  newTag->m_iGenreSubType     = tag.GenreSubType();
+  newTag->m_channel           = channel;
+  newTag->SetStartFromUTC(newStart);
+  newTag->SetEndFromUTC(newEnd);
+
+  if (tag.Plot().empty())
+  {
+      newTag->m_strSummary.Format("%s %s %s %s %s",
+        newTag->StartAsLocalTime().GetAsLocalizedDate(),
+        g_localizeStrings.Get(19159),
+        newTag->StartAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false),
+        g_localizeStrings.Get(19160),
+        newTag->EndAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false));
+  }
+  else
+  {
+    newTag->m_strSummary = tag.Plot();
+  }
+
+  newTag->m_epgTag = g_EpgContainer.GetById(tag.EpgID())->GetTag(tag.StartAsUTC());
+
+  /* unused only for reference */
+  newTag->m_strFileNameAndPath = "pvr://timers/new";
+
+  return newTag;
+}
+
+CDateTime CPVRTimerInfoTag::StartAsUTC(void) const
+{
+  CDateTime retVal = m_StartTime;
+  return retVal;
+}
+
+CDateTime CPVRTimerInfoTag::StartAsLocalTime(void) const
+{
+  CDateTime retVal;
+  retVal.SetFromUTCDateTime(m_StartTime);
+  return retVal;
+}
+
+CDateTime CPVRTimerInfoTag::EndAsUTC(void) const
+{
+  CDateTime retVal = m_StopTime;
+  return retVal;
+}
+
+CDateTime CPVRTimerInfoTag::EndAsLocalTime(void) const
+{
+  CDateTime retVal;
+  retVal.SetFromUTCDateTime(m_StopTime);
+  return retVal;
+}
+
+CDateTime CPVRTimerInfoTag::FirstDayAsUTC(void) const
+{
+  CDateTime retVal = m_FirstDay;
+  return retVal;
+}
+
+CDateTime CPVRTimerInfoTag::FirstDayAsLocalTime(void) const
+{
+  CDateTime retVal;
+  retVal.SetFromUTCDateTime(m_FirstDay);
+  return retVal;
+}
+
+void CPVRTimerInfoTag::GetNotificationText(CStdString &strText) const
+{
+  CSingleLock lock(m_critSection);
+  switch (m_state)
+  {
+  case PVR_TIMER_STATE_ABORTED:
+  case PVR_TIMER_STATE_CANCELLED:
+    strText.Format("%s: '%s'", g_localizeStrings.Get(19224), m_strTitle.c_str());
+    break;
+  case PVR_TIMER_STATE_SCHEDULED:
+    strText.Format("%s: '%s'", g_localizeStrings.Get(19225), m_strTitle.c_str());
+    break;
+  case PVR_TIMER_STATE_RECORDING:
+    strText.Format("%s: '%s'", g_localizeStrings.Get(19226), m_strTitle.c_str());
+    break;
+  case PVR_TIMER_STATE_COMPLETED:
+    strText.Format("%s: '%s'", g_localizeStrings.Get(19227), m_strTitle.c_str());
+    break;
+  default:
+    break;
+  }
+}
+
+void CPVRTimerInfoTag::QueueNotification(void) const
+{
+  if (g_guiSettings.GetBool("pvrrecord.timernotifications"))
+  {
+    CStdString strMessage;
+    GetNotificationText(strMessage);
+
+    if (!strMessage.IsEmpty())
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(19166), strMessage);
+  }
+}
+
+CEpgInfoTagPtr CPVRTimerInfoTag::GetEpgInfoTag(void) const
+{
+  return m_epgTag;
+}
+
+bool CPVRTimerInfoTag::SupportsFolders() const
+{
+  return g_PVRClients->SupportsRecordingFolders(m_iClientId);
+}
+
+void CPVRTimerInfoTag::ClearEpgTag(void)
+{
+  CEpgInfoTagPtr deletedTag;
+
+  {
+    CSingleLock lock(m_critSection);
+    deletedTag = m_epgTag;
+
+    CEpgInfoTagPtr emptyTag;
+    m_epgTag = emptyTag;
+  }
+
+  if (deletedTag)
+    deletedTag->ClearTimer();
+}
+
+CPVRChannelPtr CPVRTimerInfoTag::ChannelTag(void) const
+{
+  return m_channel;
+}
+
+void CPVRTimerInfoTag::UpdateChannel(void)
+{
+  CSingleLock lock(m_critSection);
+  m_channel = g_PVRChannelGroups->Get(m_bIsRadio)->GetGroupAll()->GetByClient(m_iClientChannelUid, m_iClientId);
+}
+
+CStdString CPVRTimerInfoTag::Title(void) const
+{
+  CStdString strReturn;
+  strReturn = m_strTitle;
+  return strReturn;
+}
+
+CStdString CPVRTimerInfoTag::Summary(void) const
+{
+  CStdString strReturn;
+  strReturn = m_strSummary;
+  return strReturn;
+}
+
+CStdString CPVRTimerInfoTag::Path(void) const
+{
+  CStdString strReturn;
+  strReturn = m_strFileNameAndPath;
+  return strReturn;
+}
diff --git a/xbmc/pvr/timers/PVRTimers.cpp b/xbmc/pvr/timers/PVRTimers.cpp
new file mode 100644
index 0000000..b976f8e
--- /dev/null
+++ b/xbmc/pvr/timers/PVRTimers.cpp
@@ -0,0 +1,736 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Application.h"
+#include "FileItem.h"
+#include "settings/GUISettings.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "dialogs/GUIDialogOK.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "utils/URIUtils.h"
+#include "utils/StringUtils.h"
+#include "URL.h"
+
+#include "PVRTimers.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "epg/EpgContainer.h"
+#include "pvr/addons/PVRClients.h"
+
+using namespace std;
+using namespace PVR;
+using namespace EPG;
+
+CPVRTimers::CPVRTimers(void)
+{
+  m_bIsUpdating = false;
+}
+
+CPVRTimers::~CPVRTimers(void)
+{
+  Unload();
+}
+
+bool CPVRTimers::Load(void)
+{
+  // unload previous timers
+  Unload();
+
+  // (re)register observer
+  g_EpgContainer.RegisterObserver(this);
+
+  // update from clients
+  return Update();
+}
+
+void CPVRTimers::Unload()
+{
+  // unregister observer
+  g_EpgContainer.UnregisterObserver(this);
+
+  // remove all tags
+  CSingleLock lock(m_critSection);
+  m_tags.clear();
+}
+
+bool CPVRTimers::Update(void)
+{
+  {
+    CSingleLock lock(m_critSection);
+    if (m_bIsUpdating)
+      return false;
+    m_bIsUpdating = true;
+  }
+
+  CLog::Log(LOGDEBUG, "CPVRTimers - %s - updating timers", __FUNCTION__);
+  CPVRTimers newTimerList;
+  g_PVRClients->GetTimers(&newTimerList);
+  return UpdateEntries(newTimerList);
+}
+
+bool CPVRTimers::IsRecording(void) const
+{
+  CSingleLock lock(m_critSection);
+
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+    for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+      if ((*timerIt)->IsRecording())
+        return true;
+
+  return false;
+}
+
+bool CPVRTimers::UpdateEntries(const CPVRTimers &timers)
+{
+  bool bChanged(false);
+  bool bAddedOrDeleted(false);
+  vector<CStdString> timerNotifications;
+
+  CSingleLock lock(m_critSection);
+
+  /* go through the timer list and check for updated or new timers */
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = timers.m_tags.begin(); it != timers.m_tags.end(); it++)
+  {
+    for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+    {
+      /* check if this timer is present in this container */
+      CPVRTimerInfoTagPtr existingTimer = GetByClient((*timerIt)->m_iClientId, (*timerIt)->m_iClientIndex);
+      if (existingTimer)
+      {
+        /* if it's present, update the current tag */
+        bool bStateChanged(existingTimer->m_state != (*timerIt)->m_state);
+        if (existingTimer->UpdateEntry(*(*timerIt)))
+        {
+          bChanged = true;
+          UpdateEpgEvent(existingTimer);
+
+          if (bStateChanged && g_PVRManager.IsStarted())
+          {
+            CStdString strMessage;
+            existingTimer->GetNotificationText(strMessage);
+            timerNotifications.push_back(strMessage);
+          }
+
+          CLog::Log(LOGDEBUG,"PVRTimers - %s - updated timer %d on client %d",
+              __FUNCTION__, (*timerIt)->m_iClientIndex, (*timerIt)->m_iClientId);
+        }
+      }
+      else
+      {
+        /* new timer */
+        CPVRTimerInfoTagPtr newTimer = CPVRTimerInfoTagPtr(new CPVRTimerInfoTag);
+        newTimer->UpdateEntry(*(*timerIt));
+        UpdateEpgEvent(newTimer);
+
+        vector<CPVRTimerInfoTagPtr>* addEntry = NULL;
+        map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::iterator itr = m_tags.find(newTimer->StartAsUTC());
+        if (itr == m_tags.end())
+        {
+          addEntry = new vector<CPVRTimerInfoTagPtr>;
+          m_tags.insert(make_pair(newTimer->StartAsUTC(), addEntry));
+        }
+        else
+        {
+          addEntry = itr->second;
+        }
+
+        addEntry->push_back(newTimer);
+        UpdateEpgEvent(newTimer);
+        bChanged = true;
+        bAddedOrDeleted = true;
+
+        if (g_PVRManager.IsStarted())
+        {
+          CStdString strMessage;
+          newTimer->GetNotificationText(strMessage);
+          timerNotifications.push_back(strMessage);
+        }
+
+        CLog::Log(LOGDEBUG,"PVRTimers - %s - added timer %d on client %d",
+            __FUNCTION__, (*timerIt)->m_iClientIndex, (*timerIt)->m_iClientId);
+      }
+    }
+  }
+
+  /* to collect timer with changed starting time */
+  vector<CPVRTimerInfoTagPtr> timersToMove;
+  
+  /* check for deleted timers */
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::iterator it = m_tags.begin(); it != m_tags.end();)
+  {
+    for (int iTimerPtr = it->second->size() - 1; iTimerPtr >= 0; iTimerPtr--)
+    {
+      CPVRTimerInfoTagPtr timer = it->second->at(iTimerPtr);
+      if (!timers.GetByClient(timer->m_iClientId, timer->m_iClientIndex))
+      {
+        /* timer was not found */
+        CLog::Log(LOGDEBUG,"PVRTimers - %s - deleted timer %d on client %d",
+            __FUNCTION__, timer->m_iClientIndex, timer->m_iClientId);
+
+        if (g_PVRManager.IsStarted())
+        {
+          CStdString strMessage;
+          strMessage.Format("%s: '%s'",
+              (timer->EndAsUTC() <= CDateTime::GetCurrentDateTime().GetAsUTCDateTime()) ?
+                  g_localizeStrings.Get(19227) :
+                  g_localizeStrings.Get(19228),
+                  timer->m_strTitle.c_str());
+          timerNotifications.push_back(strMessage);
+        }
+
+        it->second->erase(it->second->begin() + iTimerPtr);
+
+        bChanged = true;
+        bAddedOrDeleted = true;
+      }
+      else if (timer->StartAsUTC() != it->first)
+      {
+        /* timer start has changed */
+        CLog::Log(LOGDEBUG,"PVRTimers - %s - changed start time timer %d on client %d",
+            __FUNCTION__, timer->m_iClientIndex, timer->m_iClientId);
+
+        timer->ClearEpgTag();
+
+        /* remember timer */
+        timersToMove.push_back(timer);
+        
+        /* remove timer for now, reinsert later */
+        it->second->erase(it->second->begin() + iTimerPtr);
+
+        bChanged = true;
+        bAddedOrDeleted = true;
+      }
+    }
+    if (it->second->size() == 0)
+      m_tags.erase(it++);
+    else
+      ++it;
+  }
+
+  /* reinsert timers with changed timer start */
+  for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = timersToMove.begin(); timerIt != timersToMove.end(); timerIt++)
+  {
+      vector<CPVRTimerInfoTagPtr>* addEntry = NULL;
+      map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator itr = m_tags.find((*timerIt)->StartAsUTC());
+      if (itr == m_tags.end())
+      {
+        addEntry = new vector<CPVRTimerInfoTagPtr>;
+        m_tags.insert(make_pair((*timerIt)->StartAsUTC(), addEntry));
+      }
+      else
+      {
+        addEntry = itr->second;
+      }
+
+      addEntry->push_back(*timerIt);
+      UpdateEpgEvent(*timerIt);
+  }
+
+  m_bIsUpdating = false;
+  if (bChanged)
+  {
+    UpdateChannels();
+    SetChanged();
+    lock.Leave();
+
+    NotifyObservers(bAddedOrDeleted ? ObservableMessageTimersReset : ObservableMessageTimers, false);
+
+    if (g_guiSettings.GetBool("pvrrecord.timernotifications"))
+    {
+      /* queue notifications */
+      for (unsigned int iNotificationPtr = 0; iNotificationPtr < timerNotifications.size(); iNotificationPtr++)
+      {
+        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info,
+            g_localizeStrings.Get(19166),
+            timerNotifications.at(iNotificationPtr));
+      }
+    }
+  }
+
+  return bChanged;
+}
+
+bool CPVRTimers::UpdateFromClient(const CPVRTimerInfoTag &timer)
+{
+  CSingleLock lock(m_critSection);
+  CPVRTimerInfoTagPtr tag = GetByClient(timer.m_iClientId, timer.m_iClientIndex);
+  if (!tag)
+  {
+    tag = CPVRTimerInfoTagPtr(new CPVRTimerInfoTag());
+    vector<CPVRTimerInfoTagPtr>* addEntry = NULL;
+    map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::iterator itr = m_tags.find(timer.StartAsUTC());
+    if (itr == m_tags.end())
+    {
+      addEntry = new vector<CPVRTimerInfoTagPtr>;
+      m_tags.insert(make_pair(timer.StartAsUTC(), addEntry));
+    }
+    else
+    {
+      addEntry = itr->second;
+    }
+    addEntry->push_back(tag);
+  }
+
+  UpdateEpgEvent(tag);
+
+  return tag->UpdateEntry(timer);
+}
+
+/********** getters **********/
+
+CFileItemPtr CPVRTimers::GetNextActiveTimer(void) const
+{
+  CSingleLock lock(m_critSection);
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+  {
+    for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+    {
+      CPVRTimerInfoTagPtr current = *timerIt;
+      if (current->IsActive() && !current->IsRecording())
+      {
+        CFileItemPtr fileItem(new CFileItem(*current));
+        return fileItem;
+      }
+    }
+  }
+
+  CFileItemPtr fileItem;
+  return fileItem;
+}
+
+vector<CFileItemPtr> CPVRTimers::GetActiveTimers(void) const
+{
+  vector<CFileItemPtr> tags;
+  CSingleLock lock(m_critSection);
+
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+  {
+    for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+    {
+      CPVRTimerInfoTagPtr current = *timerIt;
+      if (current->IsActive())
+      {
+        CFileItemPtr fileItem(new CFileItem(*current));
+        tags.push_back(fileItem);
+      }
+    }
+  }
+
+  return tags;
+}
+
+int CPVRTimers::AmountActiveTimers(void) const
+{
+  int iReturn(0);
+  CSingleLock lock(m_critSection);
+
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+    for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+      if ((*timerIt)->IsActive())
+        ++iReturn;
+
+  return iReturn;
+}
+
+std::vector<CFileItemPtr> CPVRTimers::GetActiveRecordings(void) const
+{
+  std::vector<CFileItemPtr> tags;
+  CSingleLock lock(m_critSection);
+
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+  {
+    for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+    {
+      CPVRTimerInfoTagPtr current = *timerIt;
+      if (current->IsRecording())
+      {
+        CFileItemPtr fileItem(new CFileItem(*current));
+        tags.push_back(fileItem);
+      }
+    }
+  }
+
+  return tags;
+}
+
+int CPVRTimers::AmountActiveRecordings(void) const
+{
+  int iReturn(0);
+  CSingleLock lock(m_critSection);
+
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+    for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+      if ((*timerIt)->IsRecording())
+        ++iReturn;
+
+  return iReturn;
+}
+
+bool CPVRTimers::HasActiveTimers(void) const
+{
+  CSingleLock lock(m_critSection);
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+    for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+      if ((*timerIt)->IsActive())
+        return true;
+
+  return false;
+}
+
+bool CPVRTimers::GetDirectory(const CStdString& strPath, CFileItemList &items) const
+{
+  CStdString base(strPath);
+  URIUtils::RemoveSlashAtEnd(base);
+
+  CURL url(strPath);
+  CStdString fileName = url.GetFileName();
+  URIUtils::RemoveSlashAtEnd(fileName);
+
+  if (fileName == "timers")
+  {
+    CFileItemPtr item;
+
+    item.reset(new CFileItem(base + "/add.timer", false));
+    item->SetLabel(g_localizeStrings.Get(19026));
+    item->SetLabelPreformated(true);
+    items.Add(item);
+
+    CSingleLock lock(m_critSection);
+    for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+    {
+      for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+      {
+        CPVRTimerInfoTagPtr current = *timerIt;
+        item.reset(new CFileItem(*current));
+        items.Add(item);
+      }
+    }
+
+    return true;
+  }
+  return false;
+}
+
+/********** channel methods **********/
+
+bool CPVRTimers::DeleteTimersOnChannel(const CPVRChannel &channel, bool bDeleteRepeating /* = true */, bool bCurrentlyActiveOnly /* = false */)
+{
+  bool bReturn = false;
+  CSingleLock lock(m_critSection);
+
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::reverse_iterator it = m_tags.rbegin(); it != m_tags.rend(); it++)
+  {
+    for (vector<CPVRTimerInfoTagPtr>::iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+    {
+      CPVRTimerInfoTagPtr timer = (*timerIt);
+
+      if (bCurrentlyActiveOnly &&
+          (CDateTime::GetCurrentDateTime() < timer->StartAsLocalTime() ||
+           CDateTime::GetCurrentDateTime() > timer->EndAsLocalTime()))
+        continue;
+
+      if (!bDeleteRepeating && timer->m_bIsRepeating)
+        continue;
+
+      if (timer->ChannelNumber() == channel.ChannelNumber() && timer->m_bIsRadio == channel.IsRadio())
+      {
+        bReturn = timer->DeleteFromClient(true) || bReturn;
+        it->second->erase(timerIt);
+      }
+    }
+  }
+
+  return bReturn;
+}
+
+bool CPVRTimers::InstantTimer(const CPVRChannel &channel)
+{
+  if (!g_PVRManager.CheckParentalLock(channel))
+    return false;
+
+  CEpgInfoTag epgTag;
+  bool bHasEpgNow = channel.GetEPGNow(epgTag);
+  CPVRTimerInfoTag *newTimer = bHasEpgNow ? CPVRTimerInfoTag::CreateFromEpg(epgTag) : NULL;
+  if (!newTimer)
+  {
+    newTimer = new CPVRTimerInfoTag;
+    /* set the timer data */
+    newTimer->m_iClientIndex      = -1;
+    newTimer->m_strTitle          = channel.ChannelName();
+    newTimer->m_strSummary        = g_localizeStrings.Get(19056);
+    newTimer->m_iChannelNumber    = channel.ChannelNumber();
+    newTimer->m_iClientChannelUid = channel.UniqueID();
+    newTimer->m_iClientId         = channel.ClientID();
+    newTimer->m_bIsRadio          = channel.IsRadio();
+
+    /* generate summary string */
+    newTimer->m_strSummary.Format("%s %s %s %s %s",
+        newTimer->StartAsLocalTime().GetAsLocalizedDate(),
+        g_localizeStrings.Get(19159),
+        newTimer->StartAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false),
+        g_localizeStrings.Get(19160),
+        newTimer->EndAsLocalTime().GetAsLocalizedTime(StringUtils::EmptyString, false));
+  }
+
+  CDateTime startTime(0);
+  newTimer->SetStartFromUTC(startTime);
+  newTimer->m_iMarginStart = 0; /* set the start margin to 0 for instant timers */
+
+  int iDuration = g_guiSettings.GetInt("pvrrecord.instantrecordtime");
+  CDateTime endTime = CDateTime::GetUTCDateTime() + CDateTimeSpan(0, 0, iDuration ? iDuration : 120, 0);
+  newTimer->SetEndFromUTC(endTime);
+
+  /* unused only for reference */
+  newTimer->m_strFileNameAndPath = "pvr://timers/new";
+
+  bool bReturn = newTimer->AddToClient();
+  if (!bReturn)
+    CLog::Log(LOGERROR, "PVRTimers - %s - unable to add an instant timer on the client", __FUNCTION__);
+
+  delete newTimer;
+
+  return bReturn;
+}
+
+/********** static methods **********/
+
+bool CPVRTimers::AddTimer(const CPVRTimerInfoTag &item)
+{
+  if (!item.m_channel)
+    return false;
+
+  if (!g_PVRClients->SupportsTimers(item.m_iClientId))
+  {
+    CGUIDialogOK::ShowAndGetInput(19033,0,19215,0);
+    return false;
+  }
+
+  if (!g_PVRManager.CheckParentalLock(*item.m_channel))
+    return false;
+
+  return item.AddToClient();
+}
+
+bool CPVRTimers::DeleteTimer(const CFileItem &item, bool bForce /* = false */)
+{
+  /* Check if a CPVRTimerInfoTag is inside file item */
+  if (!item.IsPVRTimer())
+  {
+    CLog::Log(LOGERROR, "PVRTimers - %s - no TimerInfoTag given", __FUNCTION__);
+    return false;
+  }
+
+  const CPVRTimerInfoTag *tag = item.GetPVRTimerInfoTag();
+  if (!tag)
+    return false;
+
+  return tag->DeleteFromClient(bForce);
+}
+
+bool CPVRTimers::RenameTimer(CFileItem &item, const CStdString &strNewName)
+{
+  /* Check if a CPVRTimerInfoTag is inside file item */
+  if (!item.IsPVRTimer())
+  {
+    CLog::Log(LOGERROR, "PVRTimers - %s - no TimerInfoTag given", __FUNCTION__);
+    return false;
+  }
+
+  CPVRTimerInfoTag *tag = item.GetPVRTimerInfoTag();
+  if (!tag)
+    return false;
+
+  return tag->RenameOnClient(strNewName);
+}
+
+bool CPVRTimers::UpdateTimer(CFileItem &item)
+{
+  /* Check if a CPVRTimerInfoTag is inside file item */
+  if (!item.IsPVRTimer())
+  {
+    CLog::Log(LOGERROR, "PVRTimers - %s - no TimerInfoTag given", __FUNCTION__);
+    return false;
+  }
+
+  CPVRTimerInfoTag *tag = item.GetPVRTimerInfoTag();
+  if (!tag)
+    return false;
+
+  return tag->UpdateOnClient();
+}
+
+CPVRTimerInfoTagPtr CPVRTimers::GetByClient(int iClientId, int iClientTimerId) const
+{
+  CSingleLock lock(m_critSection);
+
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+  {
+    for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+    {
+      if ((*timerIt)->m_iClientId == iClientId &&
+          (*timerIt)->m_iClientIndex == iClientTimerId)
+        return *timerIt;
+    }
+  }
+
+  CPVRTimerInfoTagPtr empty;
+  return empty;
+}
+
+bool CPVRTimers::IsRecordingOnChannel(const CPVRChannel &channel) const
+{
+  CSingleLock lock(m_critSection);
+
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+  {
+    for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+    {
+      if ((*timerIt)->IsRecording() &&
+          (*timerIt)->m_iClientChannelUid == channel.UniqueID() &&
+          (*timerIt)->m_iClientId == channel.ClientID())
+        return true;
+    }
+  }
+
+  return false;
+}
+
+CFileItemPtr CPVRTimers::GetTimerForEpgTag(const CFileItem *item) const
+{
+  if (item && item->HasEPGInfoTag() && item->GetEPGInfoTag()->ChannelTag())
+  {
+    const CEpgInfoTag *epgTag = item->GetEPGInfoTag();
+    const CPVRChannelPtr channel = epgTag->ChannelTag();
+    CSingleLock lock(m_critSection);
+
+    for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::const_iterator it = m_tags.begin(); it != m_tags.end(); it++)
+    {
+      for (vector<CPVRTimerInfoTagPtr>::const_iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+      {
+        CPVRTimerInfoTagPtr timer = *timerIt;
+        if (timer->m_iClientChannelUid == channel->UniqueID() &&
+            timer->m_bIsRadio == channel->IsRadio() &&
+            timer->StartAsUTC() <= epgTag->StartAsUTC() &&
+            timer->EndAsUTC() >= epgTag->EndAsUTC())
+        {
+          CFileItemPtr fileItem(new CFileItem(*timer));
+          return fileItem;
+        }
+      }
+    }
+  }
+
+  CFileItemPtr fileItem;
+  return fileItem;
+}
+
+void CPVRTimers::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  g_PVRManager.TriggerTimersUpdate();
+}
+
+CDateTime CPVRTimers::GetNextEventTime(void) const
+{
+  const bool dailywakup = g_guiSettings.GetBool("pvrpowermanagement.dailywakeup");
+  const CDateTime now = CDateTime::GetUTCDateTime();
+  const CDateTimeSpan prewakeup(0, 0, g_guiSettings.GetInt("pvrpowermanagement.prewakeup"), 0);
+  const CDateTimeSpan idle(0, 0, g_guiSettings.GetInt("pvrpowermanagement.backendidletime"), 0);
+
+  CDateTime wakeuptime;
+
+  /* Check next active time */
+  CFileItemPtr item = GetNextActiveTimer();
+  if (item && item->HasPVRTimerInfoTag())
+  {
+    const CDateTime start = item->GetPVRTimerInfoTag()->StartAsUTC();
+    wakeuptime = ((start - idle) > now) ?
+        start - prewakeup:
+        now + idle;
+  }
+
+  /* check daily wake up */
+  if (dailywakup)
+  {
+    CDateTime dailywakeuptime;
+    dailywakeuptime.SetFromDBTime(g_guiSettings.GetString("pvrpowermanagement.dailywakeuptime", false));
+    dailywakeuptime = dailywakeuptime.GetAsUTCDateTime();
+
+    dailywakeuptime.SetDateTime(
+      now.GetYear(), now.GetMonth(), now.GetDay(),
+      dailywakeuptime.GetHour(), dailywakeuptime.GetMinute(), dailywakeuptime.GetSecond()
+    );
+
+    if ((dailywakeuptime - idle) < now)
+    {
+      const CDateTimeSpan oneDay(1,0,0,0);
+      dailywakeuptime += oneDay;
+    }
+    if (dailywakeuptime < wakeuptime)
+      wakeuptime = dailywakeuptime;
+  }
+
+  const CDateTime retVal(wakeuptime);
+  return retVal;
+}
+
+void CPVRTimers::UpdateEpgEvent(CPVRTimerInfoTagPtr timer)
+{
+  CSingleLock lock(timer->m_critSection);
+
+  /* already got an epg event set */
+  if (timer->m_epgTag)
+    return;
+
+  /* try to get the channel */
+  CPVRChannelPtr channel = g_PVRChannelGroups->GetByUniqueID(timer->m_iClientChannelUid, timer->m_iClientId);
+  if (!channel)
+    return;
+
+  /* try to get the EPG table */
+  CEpg *epg = channel->GetEPG();
+  if (!epg)
+    return;
+
+  /* try to set the timer on the epg tag that matches with a 2 minute margin */
+  CEpgInfoTagPtr epgTag = epg->GetTagBetween(timer->StartAsUTC() - CDateTimeSpan(0, 0, 2, 0), timer->EndAsUTC() + CDateTimeSpan(0, 0, 2, 0));
+  if (!epgTag)
+    epgTag = epg->GetTagAround(timer->StartAsUTC());
+
+  if (epgTag)
+  {
+    timer->m_epgTag = epgTag;
+    timer->m_genre = epgTag->Genre();
+    timer->m_iGenreType = epgTag->GenreType();
+    timer->m_iGenreSubType = epgTag->GenreSubType();
+    epgTag->SetTimer(timer);
+  }
+}
+
+void CPVRTimers::UpdateChannels(void)
+{
+  CSingleLock lock(m_critSection);
+  for (map<CDateTime, vector<CPVRTimerInfoTagPtr>* >::iterator it = m_tags.begin(); it != m_tags.end(); it++)
+  {
+    for (vector<CPVRTimerInfoTagPtr>::iterator timerIt = it->second->begin(); timerIt != it->second->end(); timerIt++)
+      (*timerIt)->UpdateChannel();
+  }
+}
diff --git a/xbmc/pvr/windows/GUIViewStatePVR.cpp b/xbmc/pvr/windows/GUIViewStatePVR.cpp
new file mode 100644
index 0000000..886de45
--- /dev/null
+++ b/xbmc/pvr/windows/GUIViewStatePVR.cpp
@@ -0,0 +1,69 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIViewStatePVR.h"
+#include "GUIWindowPVR.h"
+#include "GUIWindowPVRCommon.h"
+#include "guilib/GUIWindowManager.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+
+using namespace PVR;
+
+CGUIViewStatePVR::CGUIViewStatePVR(const CFileItemList& items) :
+  CGUIViewState(items)
+{
+  PVRWindow ActiveView = GetActiveView();
+  if (ActiveView == PVR_WINDOW_RECORDINGS)
+  {
+    if (g_guiSettings.GetBool("filelists.ignorethewhensorting"))
+      AddSortMethod(SORT_METHOD_LABEL_IGNORE_THE, 551, LABEL_MASKS("%L", "%I", "%L", ""));  // FileName, Size | Foldername, e
+    else
+      AddSortMethod(SORT_METHOD_LABEL, 551, LABEL_MASKS("%L", "%I", "%L", ""));  // FileName, Size | Foldername, empty
+    AddSortMethod(SORT_METHOD_SIZE, 553, LABEL_MASKS("%L", "%I", "%L", "%I"));  // FileName, Size | Foldername, Size
+    AddSortMethod(SORT_METHOD_DATE, 552, LABEL_MASKS("%L", "%J", "%L", "%J"));  // FileName, Date | Foldername, Date
+    AddSortMethod(SORT_METHOD_FILE, 561, LABEL_MASKS("%L", "%I", "%L", ""));  // Filename, Size | FolderName, empty
+  }
+
+  LoadViewState(items.GetPath(), ActiveView == PVR_WINDOW_UNKNOWN ? WINDOW_PVR : WINDOW_PVR + 100 - ActiveView );
+}
+
+PVRWindow CGUIViewStatePVR::GetActiveView()
+{
+  PVRWindow returnWindow = PVR_WINDOW_UNKNOWN;
+
+  int iActiveWindow = g_windowManager.GetActiveWindow();
+  if (iActiveWindow == WINDOW_PVR)
+  {
+    CGUIWindowPVR *pWindow = (CGUIWindowPVR *) g_windowManager.GetWindow(WINDOW_PVR);
+    CGUIWindowPVRCommon *pActiveView = NULL;
+    if (pWindow && (pActiveView = pWindow->GetActiveView()) != NULL)
+      returnWindow = pActiveView->GetWindowId();
+  }
+
+  return returnWindow;
+}
+
+void CGUIViewStatePVR::SaveViewState(void) 
+{
+  PVRWindow ActiveView = GetActiveView();
+  SaveViewToDb(m_items.GetPath(), ActiveView == PVR_WINDOW_UNKNOWN ? WINDOW_PVR : WINDOW_PVR + 100 - ActiveView, NULL);
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVR.cpp b/xbmc/pvr/windows/GUIWindowPVR.cpp
new file mode 100644
index 0000000..c97061c
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVR.cpp
@@ -0,0 +1,292 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIWindowPVR.h"
+
+#include "GUIWindowPVRChannels.h"
+#include "GUIWindowPVRGuide.h"
+#include "GUIWindowPVRRecordings.h"
+#include "GUIWindowPVRSearch.h"
+#include "GUIWindowPVRTimers.h"
+
+#include "pvr/PVRManager.h"
+#include "pvr/addons/PVRClients.h"
+#include "guilib/GUIMessage.h"
+#include "guilib/GUIWindowManager.h"
+#include "dialogs/GUIDialogBusy.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "threads/SingleLock.h"
+
+using namespace PVR;
+
+CGUIWindowPVR::CGUIWindowPVR(void) :
+  CGUIMediaWindow(WINDOW_PVR, "MyPVR.xml"),
+  m_guideGrid(NULL),
+  m_currentSubwindow(NULL),
+  m_savedSubwindow(NULL),
+  m_windowChannelsTV(NULL),
+  m_windowChannelsRadio(NULL),
+  m_windowGuide(NULL),
+  m_windowRecordings(NULL),
+  m_windowSearch(NULL),
+  m_windowTimers(NULL)
+{
+}
+
+CGUIWindowPVR::~CGUIWindowPVR(void)
+{
+  Cleanup();
+}
+
+CGUIWindowPVRCommon *CGUIWindowPVR::GetActiveView(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_currentSubwindow;
+}
+
+void CGUIWindowPVR::SetActiveView(CGUIWindowPVRCommon *window)
+{
+  CSingleLock lock(m_critSection);
+  m_currentSubwindow = window;
+}
+
+void CGUIWindowPVR::GetContextButtons(int itemNumber, CContextButtons &buttons)
+{
+  CGUIWindowPVRCommon *view = GetActiveView();
+  if (view)
+    view->GetContextButtons(itemNumber, buttons);
+
+  CGUIMediaWindow::GetContextButtons(itemNumber, buttons);
+}
+
+CGUIWindowPVRCommon *CGUIWindowPVR::GetSavedView(void) const
+{
+  CSingleLock lock(m_critSection);
+  return m_savedSubwindow;
+}
+
+bool CGUIWindowPVR::OnAction(const CAction &action)
+{
+  CGUIWindowPVRCommon *view = GetActiveView();
+  return (view && view->OnAction(action)) ||
+      CGUIMediaWindow::OnAction(action);
+}
+
+bool CGUIWindowPVR::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  CGUIWindowPVRCommon *view = GetActiveView();
+  return (view && view->OnContextButton(itemNumber, button)) ||
+      CGUIMediaWindow::OnContextButton(itemNumber, button);
+}
+
+void CGUIWindowPVR::OnInitWindow(void)
+{
+  if (!g_PVRManager.IsStarted() || !g_PVRClients->HasConnectedClients())
+  {
+    g_windowManager.PreviousWindow();
+    CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Warning,
+        g_localizeStrings.Get(19045),
+        g_localizeStrings.Get(19044));
+    return;
+  }
+
+  CreateViews();
+
+  CSingleLock graphicsLock(g_graphicsContext);
+  SET_CONTROL_VISIBLE(CONTROL_LIST_TIMELINE);
+
+  CSingleLock lock(m_critSection);
+  if (m_savedSubwindow)
+    m_savedSubwindow->OnInitWindow();
+  lock.Leave();
+  graphicsLock.Leave();
+
+  CGUIMediaWindow::OnInitWindow();
+}
+
+bool CGUIWindowPVR::OnMessage(CGUIMessage& message)
+{
+  return (OnMessageFocus(message) ||OnMessageClick(message) ||
+      CGUIMediaWindow::OnMessage(message));
+}
+
+void CGUIWindowPVR::OnWindowLoaded(void)
+{
+  CreateViews();
+
+  CGUIMediaWindow::OnWindowLoaded();
+  m_viewControl.Reset();
+  m_viewControl.SetParentWindow(GetID());
+
+  m_viewControl.AddView(GetControl(CONTROL_LIST_CHANNELS_TV));
+  m_viewControl.AddView(GetControl(CONTROL_LIST_CHANNELS_RADIO));
+  m_viewControl.AddView(GetControl(CONTROL_LIST_RECORDINGS));
+  m_viewControl.AddView(GetControl(CONTROL_LIST_TIMERS));
+  m_viewControl.AddView(GetControl(CONTROL_LIST_GUIDE_CHANNEL));
+  m_viewControl.AddView(GetControl(CONTROL_LIST_GUIDE_NOW_NEXT));
+  m_viewControl.AddView(GetControl(CONTROL_LIST_TIMELINE));
+  m_viewControl.AddView(GetControl(CONTROL_LIST_SEARCH));
+}
+
+void CGUIWindowPVR::OnWindowUnload(void)
+{
+  CGUIWindowPVRCommon *view = GetActiveView();
+  if (view)
+  {
+    view->OnWindowUnload();
+    m_savedSubwindow = view;
+  }
+  else
+  {
+    m_savedSubwindow = NULL;
+  }
+
+  m_currentSubwindow = NULL;
+
+  m_viewControl.Reset();
+  CGUIMediaWindow::OnWindowUnload();
+}
+
+void CGUIWindowPVR::SetLabel(int iControl, const CStdString &strLabel)
+{
+  SET_CONTROL_LABEL(iControl, strLabel);
+}
+
+void CGUIWindowPVR::SetLabel(int iControl, int iLabel)
+{
+  SET_CONTROL_LABEL(iControl, iLabel);
+}
+
+void CGUIWindowPVR::UpdateButtons(void)
+{
+  m_windowGuide->UpdateButtons();
+}
+
+bool CGUIWindowPVR::OnMessageFocus(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (message.GetMessage() == GUI_MSG_FOCUSED)
+  {
+    m_windowChannelsRadio->OnMessageFocus(message) ||
+        m_windowChannelsTV->OnMessageFocus(message) ||
+        m_windowGuide->OnMessageFocus(message) ||
+        m_windowRecordings->OnMessageFocus(message) ||
+        m_windowSearch->OnMessageFocus(message) ||
+        m_windowTimers->OnMessageFocus(message);
+
+    m_savedSubwindow = NULL;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVR::OnMessageClick(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (message.GetMessage() == GUI_MSG_CLICKED)
+  {
+    bReturn = m_windowChannelsRadio->OnClickButton(message) ||
+        m_windowChannelsTV->OnClickButton(message) ||
+        m_windowGuide->OnClickButton(message) ||
+        m_windowRecordings->OnClickButton(message) ||
+        m_windowSearch->OnClickButton(message) ||
+        m_windowTimers->OnClickButton(message) ||
+
+        m_windowChannelsRadio->OnClickList(message) ||
+        m_windowChannelsTV->OnClickList(message) ||
+        m_windowGuide->OnClickList(message) ||
+        m_windowRecordings->OnClickList(message) ||
+        m_windowSearch->OnClickList(message) ||
+        m_windowTimers->OnClickList(message);
+  }
+
+  return bReturn;
+}
+
+void CGUIWindowPVR::CreateViews(void)
+{
+  CSingleLock lock(m_critSection);
+  if (!m_windowChannelsRadio)
+    m_windowChannelsRadio = new CGUIWindowPVRChannels(this, true);
+
+  if (!m_windowChannelsTV)
+    m_windowChannelsTV = new CGUIWindowPVRChannels(this, false);
+
+  if (!m_windowGuide)
+    m_windowGuide = new CGUIWindowPVRGuide(this);
+
+  if (!m_windowRecordings)
+    m_windowRecordings = new CGUIWindowPVRRecordings(this);
+
+  if (!m_windowSearch)
+    m_windowSearch = new CGUIWindowPVRSearch(this);
+
+  if (!m_windowTimers)
+    m_windowTimers = new CGUIWindowPVRTimers(this);
+}
+
+void CGUIWindowPVR::Reset(void)
+{
+  CSingleLock graphicsLock(g_graphicsContext);
+  CSingleLock lock(m_critSection);
+
+  Cleanup();
+  CreateViews();
+
+  m_windowChannelsRadio->ResetObservers();
+  m_windowChannelsTV->ResetObservers();
+  m_windowGuide->ResetObservers();
+  m_windowRecordings->ResetObservers();
+  m_windowTimers->ResetObservers();
+}
+
+void CGUIWindowPVR::Cleanup(void)
+{
+  if (m_windowChannelsRadio)
+    m_windowChannelsRadio->UnregisterObservers();
+  SAFE_DELETE(m_windowChannelsRadio);
+
+  if (m_windowChannelsTV)
+    m_windowChannelsTV->UnregisterObservers();
+  SAFE_DELETE(m_windowChannelsTV);
+
+  if (m_windowGuide)
+    m_windowGuide->UnregisterObservers();
+  SAFE_DELETE(m_windowGuide);
+
+  if (m_windowRecordings)
+    m_windowRecordings->UnregisterObservers();
+  SAFE_DELETE(m_windowRecordings);
+
+  SAFE_DELETE(m_windowSearch);
+
+  if (m_windowTimers)
+    m_windowTimers->UnregisterObservers();
+  SAFE_DELETE(m_windowTimers);
+
+  m_currentSubwindow = NULL;
+  m_savedSubwindow = NULL;
+
+  ClearFileItems();
+  FreeResources();
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVRChannels.cpp b/xbmc/pvr/windows/GUIWindowPVRChannels.cpp
new file mode 100644
index 0000000..10e3955
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVRChannels.cpp
@@ -0,0 +1,613 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIWindowPVRChannels.h"
+
+#include "dialogs/GUIDialogFileBrowser.h"
+#include "dialogs/GUIDialogNumeric.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "guilib/GUIKeyboardFactory.h"
+#include "guilib/GUIWindowManager.h"
+#include "GUIInfoManager.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/dialogs/GUIDialogPVRGroupManager.h"
+#include "pvr/windows/GUIWindowPVR.h"
+#include "pvr/addons/PVRClients.h"
+#include "pvr/timers/PVRTimers.h"
+#include "epg/EpgContainer.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "storage/MediaManager.h"
+#include "utils/log.h"
+#include "threads/SingleLock.h"
+
+using namespace PVR;
+using namespace EPG;
+
+CGUIWindowPVRChannels::CGUIWindowPVRChannels(CGUIWindowPVR *parent, bool bRadio) :
+  CGUIWindowPVRCommon(parent,
+                      bRadio ? PVR_WINDOW_CHANNELS_RADIO : PVR_WINDOW_CHANNELS_TV,
+                      bRadio ? CONTROL_BTNCHANNELS_RADIO : CONTROL_BTNCHANNELS_TV,
+                      bRadio ? CONTROL_LIST_CHANNELS_RADIO: CONTROL_LIST_CHANNELS_TV),
+  CThread("PVR Channel Window")
+{
+  m_bRadio              = bRadio;
+  m_bShowHiddenChannels = false;
+  m_bThreadCreated      = false;
+}
+
+CGUIWindowPVRChannels::~CGUIWindowPVRChannels(void)
+{
+  if (m_bThreadCreated)
+    StopThread(true);
+}
+
+void CGUIWindowPVRChannels::ResetObservers(void)
+{
+  CSingleLock lock(m_critSection);
+  g_EpgContainer.RegisterObserver(this);
+  g_PVRTimers->RegisterObserver(this);
+  g_infoManager.RegisterObserver(this);
+}
+
+void CGUIWindowPVRChannels::UnregisterObservers(void)
+{
+  CSingleLock lock(m_critSection);
+  g_EpgContainer.UnregisterObserver(this);
+  if (g_PVRTimers)
+    g_PVRTimers->UnregisterObserver(this);
+  g_infoManager.UnregisterObserver(this);
+}
+
+void CGUIWindowPVRChannels::GetContextButtons(int itemNumber, CContextButtons &buttons) const
+{
+  if (itemNumber < 0 || itemNumber >= m_parent->m_vecItems->Size())
+    return;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+  CPVRChannel *channel = pItem->GetPVRChannelInfoTag();
+
+  if (pItem->GetPath() == "pvr://channels/.add.channel")
+  {
+    /* If yes show only "New Channel" on context menu */
+    buttons.Add(CONTEXT_BUTTON_ADD, 19046);                                           /* add new channel */
+  }
+  else
+  {
+    buttons.Add(CONTEXT_BUTTON_INFO, 19047);                                          /* channel info */
+    buttons.Add(CONTEXT_BUTTON_FIND, 19003);                                          /* find similar program */
+    buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 19000);                                     /* switch to channel */
+    buttons.Add(CONTEXT_BUTTON_RECORD_ITEM, channel->IsRecording() ? 19256 : 19255);  /* start/stop recording on channel */
+    buttons.Add(CONTEXT_BUTTON_SET_THUMB, 20019);                                     /* change icon */
+    buttons.Add(CONTEXT_BUTTON_GROUP_MANAGER, 19048);                                 /* group manager */
+    buttons.Add(CONTEXT_BUTTON_HIDE, m_bShowHiddenChannels ? 19049 : 19054);          /* show/hide channel */
+
+    if (m_parent->m_vecItems->Size() > 1 && !m_bShowHiddenChannels)
+      buttons.Add(CONTEXT_BUTTON_MOVE, 116);                                          /* move channel up or down */
+
+    if (m_bShowHiddenChannels || g_PVRChannelGroups->GetGroupAllTV()->GetNumHiddenChannels() > 0)
+      buttons.Add(CONTEXT_BUTTON_SHOW_HIDDEN, m_bShowHiddenChannels ? 19050 : 19051); /* show hidden/visible channels */
+
+    if (g_PVRClients->HasMenuHooks(pItem->GetPVRChannelInfoTag()->ClientID()))
+      buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);                                  /* PVR client specific action */
+
+    CPVRChannel *channel = pItem->GetPVRChannelInfoTag();
+    buttons.Add(CONTEXT_BUTTON_ADD_LOCK, channel->IsLocked() ? 19258 : 19257);        /* show lock/unlock channel */
+
+    buttons.Add(CONTEXT_BUTTON_FILTER, 19249);                                        /* filter channels */
+    buttons.Add(CONTEXT_BUTTON_UPDATE_EPG, 19251);                                    /* update EPG information */
+  }
+}
+
+bool CGUIWindowPVRChannels::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  if (itemNumber < 0 || itemNumber >= (int) m_parent->m_vecItems->Size())
+    return false;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+
+  return OnContextButtonPlay(pItem.get(), button) ||
+      OnContextButtonMove(pItem.get(), button) ||
+      OnContextButtonHide(pItem.get(), button) ||
+      OnContextButtonShowHidden(pItem.get(), button) ||
+      OnContextButtonSetThumb(pItem.get(), button) ||
+      OnContextButtonAdd(pItem.get(), button) ||
+      OnContextButtonInfo(pItem.get(), button) ||
+      OnContextButtonGroupManager(pItem.get(), button) ||
+      OnContextButtonFilter(pItem.get(), button) ||
+      OnContextButtonUpdateEpg(pItem.get(), button) ||
+      OnContextButtonRecord(pItem.get(), button) ||
+      OnContextButtonLock(pItem.get(), button) ||
+      CGUIWindowPVRCommon::OnContextButton(itemNumber, button);
+}
+
+CPVRChannelGroupPtr CGUIWindowPVRChannels::SelectedGroup(void)
+{
+  if (!m_selectedGroup)
+    SetSelectedGroup(g_PVRManager.GetPlayingGroup(m_bRadio));
+
+  return m_selectedGroup;
+}
+
+void CGUIWindowPVRChannels::SetSelectedGroup(CPVRChannelGroupPtr group)
+{
+  if (!group)
+    return;
+
+  if (m_selectedGroup)
+    m_selectedGroup->UnregisterObserver(this);
+  m_selectedGroup = group;
+  m_selectedGroup->RegisterObserver(this);
+  g_PVRManager.SetPlayingGroup(m_selectedGroup);
+}
+
+void CGUIWindowPVRChannels::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  if (msg == ObservableMessageChannelGroup || msg == ObservableMessageTimers || msg == ObservableMessageEpgActiveItem || msg == ObservableMessageCurrentItem)
+  {
+    if (IsVisible())
+      SetInvalid();
+    else
+      m_bUpdateRequired = true;
+  }
+  else if (msg == ObservableMessageChannelGroupReset)
+  {
+    if (IsVisible())
+      UpdateData(false);
+    else
+      m_bUpdateRequired = true;
+  }
+}
+
+CPVRChannelGroupPtr CGUIWindowPVRChannels::SelectNextGroup(void)
+{
+  CPVRChannelGroupPtr currentGroup = SelectedGroup();
+  CPVRChannelGroupPtr nextGroup = currentGroup->GetNextGroup();
+  while (nextGroup && *nextGroup != *currentGroup && nextGroup->Size() == 0)
+    nextGroup = nextGroup->GetNextGroup();
+
+  /* always update so users can reset the list */
+  if (nextGroup)
+  {
+    SetSelectedGroup(nextGroup);
+    UpdateData();
+  }
+
+  return m_selectedGroup;
+}
+
+void CGUIWindowPVRChannels::UpdateData(bool bUpdateSelectedFile /* = true */)
+{
+  CSingleLock lock(m_critSection);
+  CLog::Log(LOGDEBUG, "CGUIWindowPVRChannels - %s - update window '%s'. set view to %d",
+      __FUNCTION__, GetName(), m_iControlList);
+  m_bUpdateRequired = false;
+
+  /* lock the graphics context while updating */
+  CSingleLock graphicsLock(g_graphicsContext);
+
+  m_iSelected = m_parent->m_viewControl.GetSelectedItem();
+  m_parent->m_viewControl.Clear();
+  m_parent->m_vecItems->Clear();
+  m_parent->m_viewControl.SetCurrentView(m_iControlList);
+
+  CPVRChannelGroupPtr currentGroup = g_PVRManager.GetPlayingGroup(m_bRadio);
+  if (!currentGroup)
+    return;
+
+  CStdString strPath;
+  strPath.Format("pvr://channels/%s/%s/",
+      m_bRadio ? "radio" : "tv",
+      m_bShowHiddenChannels ? ".hidden" : currentGroup->GroupName());
+
+  m_parent->m_vecItems->SetPath(strPath);
+  m_parent->Update(m_parent->m_vecItems->GetPath());
+  m_parent->m_viewControl.SetItems(*m_parent->m_vecItems);
+
+  if (bUpdateSelectedFile)
+  {
+    if (!SelectPlayingFile())
+      m_parent->m_viewControl.SetSelectedItem(m_iSelected);
+  }
+
+  /* empty list */
+  if (m_parent->m_vecItems->Size() == 0)
+  {
+    if (m_bShowHiddenChannels)
+    {
+      /* show the visible channels instead */
+      m_bShowHiddenChannels = false;
+      graphicsLock.Leave();
+      lock.Leave();
+
+      UpdateData(bUpdateSelectedFile);
+      return;
+    }
+    else if (currentGroup->GroupID() > 0)
+    {
+      if (*currentGroup != *SelectNextGroup())
+        return;
+    }
+  }
+
+  m_parent->SetLabel(CONTROL_LABELHEADER, g_localizeStrings.Get(m_bRadio ? 19024 : 19023));
+  if (m_bShowHiddenChannels)
+    m_parent->SetLabel(CONTROL_LABELGROUP, g_localizeStrings.Get(19022));
+  else
+    m_parent->SetLabel(CONTROL_LABELGROUP, currentGroup->GroupName());
+
+  if (!m_bThreadCreated)
+  {
+    m_bThreadCreated = true;
+    Create();
+    SetPriority(-1);
+  }
+}
+
+bool CGUIWindowPVRChannels::OnClickButton(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (IsSelectedButton(message))
+  {
+    bReturn = true;
+    SelectNextGroup();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnClickList(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (IsSelectedList(message))
+  {
+    bReturn = true;
+    int iAction = message.GetParam1();
+    int iItem = m_parent->m_viewControl.GetSelectedItem();
+
+    if (iItem < 0 || iItem >= (int) m_parent->m_vecItems->Size())
+      return bReturn;
+    CFileItemPtr pItem = m_parent->m_vecItems->Get(iItem);
+
+    /* process actions */
+    if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK || iAction == ACTION_PLAY)
+      ActionPlayChannel(pItem.get());
+    else if (iAction == ACTION_SHOW_INFO)
+      ShowEPGInfo(pItem.get());
+    else if (iAction == ACTION_DELETE_ITEM)
+      ActionDeleteChannel(pItem.get());
+    else if (iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+      m_parent->OnPopupMenu(iItem);
+    else
+      bReturn = false;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_ADD)
+  {
+    CGUIDialogOK::ShowAndGetInput(19033,0,19038,0);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonGroupManager(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_GROUP_MANAGER)
+  {
+    ShowGroupManager();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonHide(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_HIDE)
+  {
+    CPVRChannel *channel = item->GetPVRChannelInfoTag();
+    if (!channel || channel->IsRadio() != m_bRadio)
+      return bReturn;
+
+    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+    if (!pDialog)
+      return bReturn;
+
+    pDialog->SetHeading(19039);
+    pDialog->SetLine(0, "");
+    pDialog->SetLine(1, channel->ChannelName());
+    pDialog->SetLine(2, "");
+    pDialog->DoModal();
+
+    if (!pDialog->IsConfirmed())
+      return bReturn;
+
+    g_PVRManager.GetPlayingGroup(m_bRadio)->RemoveFromGroup(*channel);
+    UpdateData();
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonLock(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_ADD_LOCK)
+  {
+    // ask for PIN first
+    if (!g_PVRManager.CheckParentalPIN(g_localizeStrings.Get(19262).c_str()))
+      return bReturn;
+
+    CPVRChannelGroupPtr group = g_PVRChannelGroups->GetGroupAll(m_bRadio);
+    if (!group)
+      return bReturn;
+
+    group->ToggleChannelLocked(*item);
+    UpdateData();
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_INFO)
+  {
+    ShowEPGInfo(item);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonMove(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_MOVE)
+  {
+    CPVRChannel *channel = item->GetPVRChannelInfoTag();
+    if (!channel || channel->IsRadio() != m_bRadio)
+      return bReturn;
+
+    CStdString strIndex;
+    strIndex.Format("%i", channel->ChannelNumber());
+    CGUIDialogNumeric::ShowAndGetNumber(strIndex, g_localizeStrings.Get(19052));
+    int newIndex = atoi(strIndex.c_str());
+
+    if (newIndex != channel->ChannelNumber())
+    {
+      g_PVRManager.GetPlayingGroup()->MoveChannel(channel->ChannelNumber(), newIndex);
+      UpdateData();
+    }
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonPlay(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_PLAY_ITEM)
+  {
+    /* play channel */
+    bReturn = PlayFile(item, g_guiSettings.GetBool("pvrplayback.playminimized"));
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonSetThumb(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_SET_THUMB)
+  {
+    if (g_settings.GetCurrentProfile().canWriteSources() && !g_passwordManager.IsProfileLockUnlocked())
+      return bReturn;
+    else if (!g_passwordManager.IsMasterLockUnlocked(true))
+      return bReturn;
+
+    /* setup our thumb list */
+    CFileItemList items;
+    CPVRChannel *channel = item->GetPVRChannelInfoTag();
+
+    if (!channel->IconPath().IsEmpty())
+    {
+      /* add the current thumb, if available */
+      CFileItemPtr current(new CFileItem("thumb://Current", false));
+      current->SetThumbnailImage(channel->IconPath());
+      current->SetLabel(g_localizeStrings.Get(20016));
+      items.Add(current);
+    }
+    else if (item->HasThumbnail())
+    {
+      /* already have a thumb that the share doesn't know about - must be a local one, so we may as well reuse it */
+      CFileItemPtr current(new CFileItem("thumb://Current", false));
+      current->SetThumbnailImage(item->GetThumbnailImage());
+      current->SetLabel(g_localizeStrings.Get(20016));
+      items.Add(current);
+    }
+
+    /* and add a "no thumb" entry as well */
+    CFileItemPtr nothumb(new CFileItem("thumb://None", false));
+    nothumb->SetIconImage(item->GetIconImage());
+    nothumb->SetLabel(g_localizeStrings.Get(20018));
+    items.Add(nothumb);
+
+    CStdString strThumb;
+    VECSOURCES shares;
+    if (g_guiSettings.GetString("pvrmenu.iconpath") != "")
+    {
+      CMediaSource share1;
+      share1.strPath = g_guiSettings.GetString("pvrmenu.iconpath");
+      share1.strName = g_localizeStrings.Get(19018);
+      shares.push_back(share1);
+    }
+    g_mediaManager.GetLocalDrives(shares);
+    if (!CGUIDialogFileBrowser::ShowAndGetImage(items, shares, g_localizeStrings.Get(1030), strThumb))
+      return bReturn;
+
+    if (strThumb != "thumb://Current")
+    {
+      if (strThumb == "thumb://None")
+        strThumb = "";
+
+      channel->SetIconPath(strThumb, true);
+      channel->Persist();
+      UpdateData();
+    }
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonShowHidden(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_SHOW_HIDDEN)
+  {
+    m_bShowHiddenChannels = !m_bShowHiddenChannels;
+    UpdateData();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonFilter(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_FILTER)
+  {
+    CStdString filter = m_parent->GetProperty("filter").asString();
+    CGUIKeyboardFactory::ShowAndGetFilter(filter, false);
+    m_parent->OnFilterItems(filter);
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonRecord(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn(false);
+  
+  if (button == CONTEXT_BUTTON_RECORD_ITEM)
+  {
+    CPVRChannel *channel = item->GetPVRChannelInfoTag();
+
+    if (channel)
+      return g_PVRManager.ToggleRecordingOnChannel(channel->ChannelID());
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRChannels::OnContextButtonUpdateEpg(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_UPDATE_EPG)
+  {
+    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+    if (!pDialog)
+      return bReturn;
+
+    CPVRChannel *channel = item->GetPVRChannelInfoTag();
+    pDialog->SetHeading(19251);
+    pDialog->SetLine(0, g_localizeStrings.Get(19252));
+    pDialog->SetLine(1, channel->ChannelName());
+    pDialog->SetLine(2, "");
+    pDialog->DoModal();
+
+    if (!pDialog->IsConfirmed())
+      return bReturn;
+
+    bReturn = UpdateEpgForChannel(item);
+
+    CStdString strMessage;
+    strMessage.Format("%s: '%s'", g_localizeStrings.Get(bReturn ? 19253 : 19254), channel->ChannelName());
+    CGUIDialogKaiToast::QueueNotification(bReturn ? CGUIDialogKaiToast::Info : CGUIDialogKaiToast::Error,
+        g_localizeStrings.Get(19166),
+        strMessage);
+  }
+
+  return bReturn;
+}
+
+void CGUIWindowPVRChannels::ShowGroupManager(void)
+{
+  /* Load group manager dialog */
+  CGUIDialogPVRGroupManager* pDlgInfo = (CGUIDialogPVRGroupManager*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GROUP_MANAGER);
+  if (!pDlgInfo)
+    return;
+
+  pDlgInfo->SetRadio(m_bRadio);
+  pDlgInfo->DoModal();
+
+  return;
+}
+
+void CGUIWindowPVRChannels::Process(void)
+{
+  // ugly hack to refresh the progress bars and item contents every 5 seconds
+  int iCount(0);
+  while (!m_bStop)
+  {
+    if (++iCount == 100)
+    {
+      iCount = 0;
+      SetInvalid();
+    }
+    Sleep(50);
+  }
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVRCommon.cpp b/xbmc/pvr/windows/GUIWindowPVRCommon.cpp
new file mode 100644
index 0000000..026f66a
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVRCommon.cpp
@@ -0,0 +1,862 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIWindowPVRCommon.h"
+
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "filesystem/StackDirectory.h"
+#include "guilib/GUIMessage.h"
+#include "guilib/GUIWindowManager.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/dialogs/GUIDialogPVRGuideInfo.h"
+#include "pvr/dialogs/GUIDialogPVRRecordingInfo.h"
+#include "pvr/dialogs/GUIDialogPVRTimerSettings.h"
+#include "epg/Epg.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/addons/PVRClients.h"
+#include "pvr/windows/GUIWindowPVR.h"
+#include "pvr/windows/GUIWindowPVRSearch.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "utils/log.h"
+#include "utils/URIUtils.h"
+#include "GUIUserMessages.h"
+
+using namespace std;
+using namespace PVR;
+using namespace EPG;
+
+CGUIWindowPVRCommon::CGUIWindowPVRCommon(CGUIWindowPVR *parent, PVRWindow window,
+    unsigned int iControlButton, unsigned int iControlList)
+{
+  m_parent          = parent;
+  m_window          = window;
+  m_iControlButton  = iControlButton;
+  m_iControlList    = iControlList;
+  m_bUpdateRequired = false;
+  m_iSelected       = 0;
+  m_iSortOrder      = SortOrderAscending;
+  m_iSortMethod     = SORT_METHOD_DATE;
+  if( m_parent->GetViewState() )
+  {
+    m_iSortOrder      = m_parent->GetViewState()->GetSortOrder();
+    m_iSortMethod     = m_parent->GetViewState()->GetSortMethod();
+  }
+}
+
+bool CGUIWindowPVRCommon::operator ==(const CGUIWindowPVRCommon &right) const
+{
+  return (this == &right || m_window == right.m_window);
+}
+
+bool CGUIWindowPVRCommon::operator !=(const CGUIWindowPVRCommon &right) const
+{
+  return !(*this == right);
+}
+
+const char *CGUIWindowPVRCommon::GetName(void) const
+{
+  switch(m_window)
+  {
+  case PVR_WINDOW_EPG:
+    return "epg";
+  case PVR_WINDOW_CHANNELS_RADIO:
+    return "radio";
+  case PVR_WINDOW_CHANNELS_TV:
+    return "tv";
+  case PVR_WINDOW_RECORDINGS:
+    return "recordings";
+  case PVR_WINDOW_SEARCH:
+    return "search";
+  case PVR_WINDOW_TIMERS:
+    return "timers";
+  default:
+    return "unknown";
+  }
+}
+
+bool CGUIWindowPVRCommon::IsFocused(void) const
+{
+  return !g_application.IsPlayingFullScreenVideo() &&
+      g_windowManager.GetFocusedWindow() == WINDOW_PVR &&
+      IsActive();
+}
+
+bool CGUIWindowPVRCommon::IsVisible(void) const
+{
+  return !g_application.IsPlayingFullScreenVideo() &&
+      g_windowManager.GetActiveWindow() == WINDOW_PVR &&
+      IsActive();
+}
+
+bool CGUIWindowPVRCommon::IsActive(void) const
+{
+  CGUIWindowPVRCommon *window = m_parent->GetActiveView();
+  return (window && *window == *this);
+}
+
+bool CGUIWindowPVRCommon::IsSavedView(void) const
+{
+  CGUIWindowPVRCommon *window = m_parent->GetSavedView();
+  return (window && *window == *this);
+}
+
+bool CGUIWindowPVRCommon::IsSelectedButton(CGUIMessage &message) const
+{
+  return (message.GetSenderId() == (int) m_iControlButton);
+}
+
+bool CGUIWindowPVRCommon::IsSelectedControl(CGUIMessage &message) const
+{
+  return (message.GetControlId() == (int) m_iControlButton);
+}
+
+bool CGUIWindowPVRCommon::IsSelectedList(CGUIMessage &message) const
+{
+  return (message.GetSenderId() == (int) m_iControlList);
+}
+
+void CGUIWindowPVRCommon::SetInvalid()
+{
+  for (int iItemPtr = 0; iItemPtr < m_parent->m_vecItems->Size(); iItemPtr++)
+    m_parent->m_vecItems->Get(iItemPtr)->SetInvalid();
+  m_parent->SetInvalid();
+}
+
+void CGUIWindowPVRCommon::OnInitWindow()
+{
+  m_parent->m_viewControl.SetCurrentView(m_iControlList);
+}
+
+bool CGUIWindowPVRCommon::SelectPlayingFile(void)
+{
+  bool bReturn(false);
+
+  if (g_PVRManager.IsPlaying())
+  {
+    m_parent->m_viewControl.SetSelectedItem(g_application.CurrentFile());
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::OnMessageFocus(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (message.GetMessage() == GUI_MSG_FOCUSED &&
+      (IsSelectedControl(message) || IsSavedView()))
+  {
+    CLog::Log(LOGDEBUG, "CGUIWindowPVRCommon - %s - focus set to window '%s'", __FUNCTION__, GetName());
+    bool bIsActive = IsActive();
+    m_parent->SetActiveView(this);
+
+    if (!bIsActive || m_bUpdateRequired)
+      UpdateData();
+    else
+      m_iSelected = m_parent->m_viewControl.GetSelectedItem();
+
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+void CGUIWindowPVRCommon::OnWindowUnload(void)
+{
+  m_iSelected = m_parent->m_viewControl.GetSelectedItem();
+}
+
+bool CGUIWindowPVRCommon::OnAction(const CAction &action)
+{
+  bool bReturn = false;
+
+  if (action.GetID() == ACTION_NAV_BACK ||
+      action.GetID() == ACTION_PARENT_DIR)
+  {
+    g_windowManager.PreviousWindow();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  if (itemNumber < 0 || itemNumber >= (int) m_parent->m_vecItems->Size())
+    return false;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+
+  return (OnContextButtonSortAsc(pItem.get(), button) ||
+      OnContextButtonSortBy(pItem.get(), button) ||
+      OnContextButtonSortByChannel(pItem.get(), button) ||
+      OnContextButtonSortByName(pItem.get(), button) ||
+      OnContextButtonSortByDate(pItem.get(), button) ||
+      OnContextButtonFind(pItem.get(), button) ||
+      OnContextButtonMenuHooks(pItem.get(), button));
+}
+
+bool CGUIWindowPVRCommon::OnContextButtonSortByDate(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_SORTBY_DATE)
+  {
+    bReturn = true;
+
+    if (m_iSortMethod != SORT_METHOD_DATE)
+    {
+      m_iSortMethod = SORT_METHOD_DATE;
+      m_iSortOrder  = SortOrderAscending;
+      CGUIMessage message(GUI_MSG_CHANGE_SORT_METHOD, m_parent->GetID(), 0, m_iSortMethod, 0); 
+      m_parent->OnMessage(message);
+    }
+    else
+    {
+      m_iSortOrder = m_iSortOrder == SortOrderAscending ? SortOrderDescending : SortOrderAscending;
+    }
+    CGUIMessage message(GUI_MSG_CHANGE_SORT_DIRECTION, m_parent->GetID(), 0, m_iSortOrder, 0); 
+    m_parent->OnMessage(message);
+    UpdateData();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::OnContextButtonSortByName(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_SORTBY_NAME)
+  {
+    bReturn = true;
+
+    if (m_iSortMethod != SORT_METHOD_LABEL)
+    {
+      m_iSortMethod = SORT_METHOD_LABEL;
+      m_iSortOrder  = SortOrderAscending;
+      CGUIMessage message(GUI_MSG_CHANGE_SORT_METHOD, m_parent->GetID(), 0, m_iSortMethod, 0); 
+      m_parent->OnMessage(message);
+    }
+    else
+    {
+      m_iSortOrder = m_iSortOrder == SortOrderAscending ? SortOrderDescending : SortOrderAscending;
+    }
+    CGUIMessage message(GUI_MSG_CHANGE_SORT_DIRECTION, m_parent->GetID(), 0, m_iSortOrder, 0); 
+    m_parent->OnMessage(message);
+    UpdateData();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::OnContextButtonSortByChannel(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_SORTBY_CHANNEL)
+  {
+    bReturn = true;
+
+    if (m_iSortMethod != SORT_METHOD_CHANNEL)
+    {
+      m_iSortMethod = SORT_METHOD_CHANNEL;
+      m_iSortOrder  = SortOrderAscending;
+    }
+    else
+    {
+      m_iSortOrder = m_iSortOrder == SortOrderAscending ? SortOrderDescending : SortOrderAscending;
+    }
+
+    UpdateData();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::OnContextButtonSortAsc(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_SORTASC)
+  {
+    bReturn = true;
+
+    if (m_parent->m_guiState.get())
+      m_parent->m_guiState->SetNextSortOrder();
+    m_parent->UpdateFileList();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::OnContextButtonSortBy(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_SORTBY)
+  {
+    bReturn = true;
+
+    if (m_parent->m_guiState.get())
+      m_parent->m_guiState->SetNextSortMethod();
+
+    m_parent->UpdateFileList();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::OnContextButtonMenuHooks(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_MENU_HOOKS)
+  {
+    bReturn = true;
+
+    if (item->IsEPG() && item->GetEPGInfoTag()->HasPVRChannel())
+      g_PVRClients->ProcessMenuHooks(item->GetEPGInfoTag()->ChannelTag()->ClientID());
+    else if (item->IsPVRChannel())
+      g_PVRClients->ProcessMenuHooks(item->GetPVRChannelInfoTag()->ClientID());
+    else if (item->IsPVRRecording())
+      g_PVRClients->ProcessMenuHooks(item->GetPVRRecordingInfoTag()->m_iClientId);
+    else if (item->IsPVRTimer())
+      g_PVRClients->ProcessMenuHooks(item->GetPVRTimerInfoTag()->m_iClientId);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::ActionDeleteTimer(CFileItem *item)
+{
+  /* check if the timer tag is valid */
+  CPVRTimerInfoTag *timerTag = item->GetPVRTimerInfoTag();
+  if (!timerTag || timerTag->m_iClientIndex < 0)
+    return false;
+
+  /* show a confirmation dialog */
+  CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+  if (!pDialog)
+    return false;
+  pDialog->SetHeading(122);
+  pDialog->SetLine(0, 19040);
+  pDialog->SetLine(1, "");
+  pDialog->SetLine(2, timerTag->m_strTitle);
+  pDialog->DoModal();
+
+  /* prompt for the user's confirmation */
+  if (!pDialog->IsConfirmed())
+    return false;
+
+  /* delete the timer */
+  return g_PVRTimers->DeleteTimer(*item);
+}
+
+bool CGUIWindowPVRCommon::ShowNewTimerDialog(void)
+{
+  bool bReturn(false);
+
+  CPVRTimerInfoTag *newTimer = new CPVRTimerInfoTag;
+  CFileItem *newItem = new CFileItem(*newTimer);
+  if (ShowTimerSettings(newItem))
+  {
+    /* Add timer to backend */
+    bReturn = g_PVRTimers->AddTimer(*newItem->GetPVRTimerInfoTag());
+  }
+
+  delete newItem;
+  delete newTimer;
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::ActionShowTimer(CFileItem *item)
+{
+  bool bReturn = false;
+
+  /* Check if "Add timer..." entry is pressed by OK, if yes
+     create a new timer and open settings dialog, otherwise
+     open settings for selected timer entry */
+  if (item->GetPath() == "pvr://timers/add.timer")
+  {
+    bReturn = ShowNewTimerDialog();
+  }
+  else
+  {
+    if (ShowTimerSettings(item))
+    {
+      /* Update timer on pvr backend */
+      bReturn = g_PVRTimers->UpdateTimer(*item);
+    }
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::ActionRecord(CFileItem *item)
+{
+  bool bReturn = false;
+
+  CEpgInfoTag *epgTag = item->GetEPGInfoTag();
+  if (!epgTag)
+    return bReturn;
+
+  CPVRChannelPtr channel = epgTag->ChannelTag();
+  if (!channel || !g_PVRManager.CheckParentalLock(*channel))
+    return bReturn;
+
+  if (epgTag->Timer() == NULL)
+  {
+    /* create a confirmation dialog */
+    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*) g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+    if (!pDialog)
+      return bReturn;
+
+    pDialog->SetHeading(264);
+    pDialog->SetLine(0, "");
+    pDialog->SetLine(1, epgTag->Title());
+    pDialog->SetLine(2, "");
+    pDialog->DoModal();
+
+    /* prompt for the user's confirmation */
+    if (!pDialog->IsConfirmed())
+      return bReturn;
+
+    CPVRTimerInfoTag *newTimer = CPVRTimerInfoTag::CreateFromEpg(*epgTag);
+    if (newTimer)
+    {
+      bReturn = g_PVRTimers->AddTimer(*newTimer);
+      delete newTimer;
+    }
+    else
+    {
+      bReturn = false;
+    }
+  }
+  else
+  {
+    CGUIDialogOK::ShowAndGetInput(19033,19034,0,0);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+
+bool CGUIWindowPVRCommon::ActionDeleteRecording(CFileItem *item)
+{
+  bool bReturn = false;
+
+  /* check if the recording tag is valid */
+  CPVRRecording *recTag = (CPVRRecording *) item->GetPVRRecordingInfoTag();
+  if (!recTag || recTag->m_strRecordingId.IsEmpty())
+    return bReturn;
+
+  /* show a confirmation dialog */
+  CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+  if (!pDialog)
+    return bReturn;
+  pDialog->SetHeading(122);
+  pDialog->SetLine(0, 19043);
+  pDialog->SetLine(1, "");
+  pDialog->SetLine(2, recTag->m_strTitle);
+  pDialog->DoModal();
+
+  /* prompt for the user's confirmation */
+  if (!pDialog->IsConfirmed())
+    return bReturn;
+
+  /* delete the recording */
+  if (g_PVRRecordings->DeleteRecording(*item))
+  {
+    g_PVRManager.TriggerRecordingsUpdate();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::ActionPlayChannel(CFileItem *item)
+{
+  bool bReturn = false;
+
+  if (item->GetPath() == "pvr://channels/.add.channel")
+  {
+    /* show "add channel" dialog */
+    CGUIDialogOK::ShowAndGetInput(19033,0,19038,0);
+    bReturn = true;
+  }
+  else
+  {
+    /* open channel */
+    bReturn = PlayFile(item, g_guiSettings.GetBool("pvrplayback.playminimized"));
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::ActionPlayEpg(CFileItem *item)
+{
+  bool bReturn = false;
+
+  CEpgInfoTag *epgTag = item->GetEPGInfoTag();
+  if (!epgTag)
+    return bReturn;
+
+  CPVRChannelPtr channel = epgTag->ChannelTag();
+  if (!channel || channel->ChannelNumber() > 0 ||
+      !g_PVRManager.CheckParentalLock(*channel))
+    return bReturn;
+
+  bReturn = g_application.PlayFile(CFileItem(*channel));
+
+  if (!bReturn)
+  {
+    /* cannot play file */
+    CGUIDialogOK::ShowAndGetInput(19033,0,19035,0);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::ActionDeleteChannel(CFileItem *item)
+{
+  CPVRChannel *channel = item->GetPVRChannelInfoTag();
+
+  /* check if the channel tag is valid */
+  if (!channel || channel->ChannelNumber() <= 0)
+    return false;
+
+  /* show a confirmation dialog */
+  CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*) g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+  if (pDialog)
+    return false;
+  pDialog->SetHeading(19039);
+  pDialog->SetLine(0, "");
+  pDialog->SetLine(1, channel->ChannelName());
+  pDialog->SetLine(2, "");
+  pDialog->DoModal();
+
+  /* prompt for the user's confirmation */
+  if (!pDialog->IsConfirmed())
+    return false;
+
+  g_PVRChannelGroups->GetGroupAll(channel->IsRadio())->RemoveFromGroup(*channel);
+  UpdateData();
+
+  return true;
+}
+
+bool CGUIWindowPVRCommon::UpdateEpgForChannel(CFileItem *item)
+{
+  CPVRChannel *channel = item->GetPVRChannelInfoTag();
+  CEpg *epg = channel->GetEPG();
+  if (!epg)
+    return false;
+
+  epg->ForceUpdate();
+  return true;
+}
+
+bool CGUIWindowPVRCommon::ShowTimerSettings(CFileItem *item)
+{
+  /* Check item is TV timer information tag */
+  if (!item->IsPVRTimer())
+  {
+    CLog::Log(LOGERROR, "CGUIWindowPVRTimers: Can't open timer settings dialog, no timer info tag!");
+    return false;
+  }
+
+  /* Load timer settings dialog */
+  CGUIDialogPVRTimerSettings* pDlgInfo = (CGUIDialogPVRTimerSettings*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_TIMER_SETTING);
+
+  if (!pDlgInfo)
+    return false;
+
+  /* inform dialog about the file item */
+  pDlgInfo->SetTimer(item);
+
+  /* Open dialog window */
+  pDlgInfo->DoModal();
+
+  /* Get modify flag from window and return it to caller */
+  return pDlgInfo->GetOK();
+}
+
+
+bool CGUIWindowPVRCommon::PlayRecording(CFileItem *item, bool bPlayMinimized /* = false */)
+{
+  if (item->GetPath().Left(17) != "pvr://recordings/")
+    return false;
+
+  CStdString stream = item->GetPVRRecordingInfoTag()->m_strStreamURL;
+  if (stream == "")
+    return false;
+
+  /* Isolate the folder from the filename */
+  size_t found = stream.find_last_of("/");
+  if (found == CStdString::npos)
+    found = stream.find_last_of("\\");
+
+  if (found != CStdString::npos)
+  {
+    /* Check here for asterisk at the begin of the filename */
+    if (stream[found+1] == '*')
+    {
+      /* Create a "stack://" url with all files matching the extension */
+      CStdString ext = URIUtils::GetExtension(stream);
+      CStdString dir = stream.substr(0, found).c_str();
+
+      CFileItemList items;
+      CDirectory::GetDirectory(dir, items);
+      items.Sort(SORT_METHOD_FILE, SortOrderAscending);
+
+      vector<int> stack;
+      for (int i = 0; i < items.Size(); ++i)
+      {
+        if (URIUtils::GetExtension(items[i]->GetPath()) == ext)
+          stack.push_back(i);
+      }
+
+      if (stack.size() > 0)
+      {
+        /* If we have a stack change the path of the item to it */
+        CStackDirectory dir;
+        CStdString stackPath = dir.ConstructStackPath(items, stack);
+        item->SetPath(stackPath);
+      }
+    }
+    else
+    {
+      /* If no asterisk is present play only the given stream URL */
+      item->SetPath(stream);
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "PVRManager - %s - can't open recording: no valid filename", __FUNCTION__);
+    CGUIDialogOK::ShowAndGetInput(19033,0,19036,0);
+    return false;
+  }
+
+  CApplicationMessenger::Get().PlayFile(*item, false);
+
+  return true;
+}
+
+bool CGUIWindowPVRCommon::PlayFile(CFileItem *item, bool bPlayMinimized /* = false */)
+{
+  if (item->GetPath() == g_application.CurrentFile())
+  {
+    CGUIMessage msg(GUI_MSG_FULLSCREEN, 0, m_parent->GetID());
+    g_windowManager.SendMessage(msg);
+    return true;
+  }
+
+  g_settings.m_bStartVideoWindowed = bPlayMinimized;
+
+  if (item->GetPath().Left(17) == "pvr://recordings/")
+  {
+    return PlayRecording(item, bPlayMinimized);
+  }
+  else
+  {
+    bool bSwitchSuccessful(false);
+
+    CPVRChannel *channel = item->HasPVRChannelInfoTag() ? item->GetPVRChannelInfoTag() : NULL;
+
+    if (g_PVRManager.CheckParentalLock(*channel))
+    {
+      /* try a fast switch */
+      if (channel && (g_PVRManager.IsPlayingTV() || g_PVRManager.IsPlayingRadio()) &&
+         (channel->IsRadio() == g_PVRManager.IsPlayingRadio()) && g_application.m_pPlayer)
+      {
+        if (channel->StreamURL().IsEmpty())
+          bSwitchSuccessful = g_application.m_pPlayer->SwitchChannel(*channel);
+      }
+
+      if (!bSwitchSuccessful)
+      {
+        CApplicationMessenger::Get().PlayFile(*item, false);
+        return true;
+      }
+    }
+
+    if (!bSwitchSuccessful)
+    {
+      CGUIDialogOK::ShowAndGetInput(19033,0,19035,0);
+      return false;
+    }
+  }
+
+  return true;
+}
+
+bool CGUIWindowPVRCommon::StartRecordFile(CFileItem *item)
+{
+  if (!item->HasEPGInfoTag())
+    return false;
+
+  CEpgInfoTag *tag = item->GetEPGInfoTag();
+  CPVRChannelPtr channel;
+  if (tag)
+    channel = tag->ChannelTag();
+
+  if (!channel || !g_PVRManager.CheckParentalLock(*channel))
+    return false;
+
+  CFileItemPtr timer = g_PVRTimers->GetTimerForEpgTag(item);
+  if (timer && timer->HasPVRTimerInfoTag())
+  {
+    CGUIDialogOK::ShowAndGetInput(19033,19034,0,0);
+    return false;
+  }
+
+  CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+  if (!pDialog)
+    return false;
+  pDialog->SetHeading(264);
+  pDialog->SetLine(0, tag->PVRChannelName());
+  pDialog->SetLine(1, "");
+  pDialog->SetLine(2, tag->Title());
+  pDialog->DoModal();
+
+  if (!pDialog->IsConfirmed())
+    return false;
+
+  CPVRTimerInfoTag *newTimer = CPVRTimerInfoTag::CreateFromEpg(*tag);
+  bool bReturn(false);
+  if (newTimer)
+  {
+    bReturn = g_PVRTimers->AddTimer(*newTimer);
+    delete newTimer;
+  }
+  return bReturn;
+}
+
+bool CGUIWindowPVRCommon::StopRecordFile(CFileItem *item)
+{
+  if (!item->HasEPGInfoTag())
+    return false;
+
+  CEpgInfoTag *tag = item->GetEPGInfoTag();
+  if (!tag || !tag->HasPVRChannel())
+    return false;
+
+  CFileItemPtr timer = g_PVRTimers->GetTimerForEpgTag(item);
+  if (!timer || !timer->HasPVRTimerInfoTag() || timer->GetPVRTimerInfoTag()->m_bIsRepeating)
+    return false;
+
+  return g_PVRTimers->DeleteTimer(*timer);
+}
+
+void CGUIWindowPVRCommon::ShowEPGInfo(CFileItem *item)
+{
+  CFileItem *tag = NULL;
+  bool bHasChannel(false);
+  CPVRChannel channel;
+  if (item->IsEPG())
+  {
+    tag = new CFileItem(*item);
+    if (item->GetEPGInfoTag()->HasPVRChannel())
+    {
+      channel = *item->GetEPGInfoTag()->ChannelTag();
+      bHasChannel = true;
+    }
+  }
+  else if (item->IsPVRChannel())
+  {
+    CEpgInfoTag epgnow;
+    channel = *item->GetPVRChannelInfoTag();
+    bHasChannel = true;
+    if (!item->GetPVRChannelInfoTag()->GetEPGNow(epgnow))
+    {
+      CGUIDialogOK::ShowAndGetInput(19033,0,19055,0);
+      return;
+    }
+    tag = new CFileItem(epgnow);
+  }
+
+  if (tag)
+  {
+    if (!bHasChannel || g_PVRManager.CheckParentalLock(channel))
+    {
+      CGUIDialogPVRGuideInfo* pDlgInfo = (CGUIDialogPVRGuideInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GUIDE_INFO);
+      if (pDlgInfo)
+      {
+        pDlgInfo->SetProgInfo(tag);
+        pDlgInfo->DoModal();
+
+        UpdateData();
+      }
+    }
+    delete tag;
+  }
+}
+
+void CGUIWindowPVRCommon::ShowRecordingInfo(CFileItem *item)
+{
+  if (!item->IsPVRRecording())
+    return;
+
+  CGUIDialogPVRRecordingInfo* pDlgInfo = (CGUIDialogPVRRecordingInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_RECORDING_INFO);
+  if (!pDlgInfo)
+    return;
+
+  pDlgInfo->SetRecording(item);
+  pDlgInfo->DoModal();
+}
+
+bool CGUIWindowPVRCommon::OnContextButtonFind(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_FIND)
+  {
+    bReturn = true;
+    if (m_parent->m_windowSearch)
+    {
+      CEpgInfoTag tag;
+      m_parent->m_windowSearch->m_searchfilter.Reset();
+      if (item->IsEPG())
+        m_parent->m_windowSearch->m_searchfilter.m_strSearchTerm = "\"" + item->GetEPGInfoTag()->Title() + "\"";
+      else if (item->IsPVRChannel() && item->GetPVRChannelInfoTag()->GetEPGNow(tag))
+        m_parent->m_windowSearch->m_searchfilter.m_strSearchTerm = "\"" + tag.Title() + "\"";
+      else if (item->IsPVRRecording())
+        m_parent->m_windowSearch->m_searchfilter.m_strSearchTerm = "\"" + item->GetPVRRecordingInfoTag()->m_strTitle + "\"";
+
+      m_parent->m_windowSearch->m_bSearchConfirmed = true;
+      m_parent->SetLabel(m_iControlButton, 0);
+      m_parent->SetActiveView(m_parent->m_windowSearch);
+      m_parent->m_windowSearch->UpdateData();
+      m_parent->SetLabel(m_iControlList, 0);
+    }
+  }
+
+  return bReturn;
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
new file mode 100644
index 0000000..5a58526
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
@@ -0,0 +1,486 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIWindowPVRGuide.h"
+
+#include "Application.h"
+#include "dialogs/GUIDialogOK.h"
+#include "guilib/GUIWindowManager.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "epg/EpgContainer.h"
+#include "pvr/windows/GUIWindowPVR.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "pvr/addons/PVRClients.h"
+#include "pvr/timers/PVRTimers.h"
+
+using namespace PVR;
+using namespace EPG;
+
+CGUIWindowPVRGuide::CGUIWindowPVRGuide(CGUIWindowPVR *parent) :
+  CGUIWindowPVRCommon(parent, PVR_WINDOW_EPG, CONTROL_BTNGUIDE, CONTROL_LIST_GUIDE_NOW_NEXT),
+  Observer(),
+  m_iGuideView(g_guiSettings.GetInt("epg.defaultguideview"))
+{
+  m_cachedTimeline = new CFileItemList;
+  m_cachedChannelGroup = CPVRChannelGroupPtr(new CPVRChannelGroup);
+}
+
+CGUIWindowPVRGuide::~CGUIWindowPVRGuide(void)
+{
+  delete m_cachedTimeline;
+}
+
+void CGUIWindowPVRGuide::UnregisterObservers(void)
+{
+  g_EpgContainer.UnregisterObserver(this);
+}
+
+void CGUIWindowPVRGuide::ResetObservers(void)
+{
+  g_EpgContainer.RegisterObserver(this);
+}
+
+void CGUIWindowPVRGuide::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  if (msg == ObservableMessageEpg)
+  {
+    m_bUpdateRequired = true;
+
+    /* update the current window if the EPG timeline view is visible */
+    if (IsFocused() && m_iGuideView == GUIDE_VIEW_TIMELINE)
+      UpdateData(false);
+  }
+  else if (msg == ObservableMessageEpgActiveItem)
+  {
+    if (IsVisible() && m_iGuideView != GUIDE_VIEW_TIMELINE)
+      SetInvalid();
+    else
+      m_bUpdateRequired = true;
+  }
+}
+
+void CGUIWindowPVRGuide::GetContextButtons(int itemNumber, CContextButtons &buttons) const
+{
+  if (itemNumber < 0 || itemNumber >= m_parent->m_vecItems->Size())
+    return;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+
+  CFileItemPtr timer = g_PVRTimers->GetTimerForEpgTag(pItem.get());
+  if (timer && timer->HasPVRTimerInfoTag())
+  {
+    if (timer->GetPVRTimerInfoTag()->IsRecording())
+      buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059);  /* stop recording */
+    else
+      buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19060);  /* delete timer */
+  }
+  else if (pItem->GetEPGInfoTag()->EndAsLocalTime() > CDateTime::GetCurrentDateTime())
+  {
+    if (pItem->GetEPGInfoTag()->StartAsLocalTime() < CDateTime::GetCurrentDateTime())
+      buttons.Add(CONTEXT_BUTTON_START_RECORD, 264);   /* record */
+    else
+      buttons.Add(CONTEXT_BUTTON_START_RECORD, 19061); /* add timer */
+  }
+
+  buttons.Add(CONTEXT_BUTTON_INFO, 19047);              /* epg info */
+  buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 19000);         /* switch channel */
+  buttons.Add(CONTEXT_BUTTON_FIND, 19003);              /* find similar program */
+  if (m_iGuideView == GUIDE_VIEW_TIMELINE)
+  {
+    buttons.Add(CONTEXT_BUTTON_BEGIN, 19063);           /* go to begin */
+    buttons.Add(CONTEXT_BUTTON_END, 19064);             /* go to end */
+  }
+  if (pItem->GetEPGInfoTag()->HasPVRChannel() &&
+      g_PVRClients->HasMenuHooks(pItem->GetEPGInfoTag()->ChannelTag()->ClientID()))
+    buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);      /* PVR client specific action */
+}
+
+
+bool CGUIWindowPVRGuide::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  if (itemNumber < 0 || itemNumber >= (int) m_parent->m_vecItems->Size())
+    return false;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+
+  return OnContextButtonPlay(pItem.get(), button) ||
+      OnContextButtonInfo(pItem.get(), button) ||
+      OnContextButtonStartRecord(pItem.get(), button) ||
+      OnContextButtonStopRecord(pItem.get(), button) ||
+      OnContextButtonBegin(pItem.get(), button) ||
+      OnContextButtonEnd(pItem.get(), button) ||
+      CGUIWindowPVRCommon::OnContextButton(itemNumber, button);
+}
+
+void CGUIWindowPVRGuide::UpdateViewChannel(bool bUpdateSelectedFile)
+{
+  CPVRChannelPtr CurrentChannel;
+  bool bGotCurrentChannel = g_PVRManager.GetCurrentChannel(CurrentChannel);
+
+  m_parent->m_guideGrid = NULL;
+  m_parent->m_viewControl.SetCurrentView(CONTROL_LIST_GUIDE_CHANNEL);
+
+  m_parent->SetLabel(m_iControlButton, g_localizeStrings.Get(19222) + ": " + g_localizeStrings.Get(19029));
+  if (bGotCurrentChannel)
+    m_parent->SetLabel(CONTROL_LABELGROUP, CurrentChannel->ChannelName().c_str());
+
+  if (!bGotCurrentChannel || g_PVRManager.GetCurrentEpg(*m_parent->m_vecItems) == 0)
+  {
+    CFileItemPtr item;
+    item.reset(new CFileItem("pvr://guide/" + CurrentChannel->ChannelName() + "/empty.epg", false));
+    item->SetLabel(g_localizeStrings.Get(19028));
+    item->SetLabelPreformated(true);
+    m_parent->m_vecItems->Add(item);
+  }
+  m_parent->m_viewControl.SetItems(*m_parent->m_vecItems);
+}
+
+void CGUIWindowPVRGuide::UpdateViewNow(bool bUpdateSelectedFile)
+{
+  CPVRChannelPtr CurrentChannel;
+  bool bGotCurrentChannel = g_PVRManager.GetCurrentChannel(CurrentChannel);
+  bool bRadio = bGotCurrentChannel ? CurrentChannel->IsRadio() : false;
+
+  m_parent->m_guideGrid = NULL;
+  m_parent->m_viewControl.SetCurrentView(CONTROL_LIST_GUIDE_NOW_NEXT);
+
+  m_parent->SetLabel(m_iControlButton, g_localizeStrings.Get(19222) + ": " + g_localizeStrings.Get(19030));
+  m_parent->SetLabel(CONTROL_LABELGROUP, g_localizeStrings.Get(19030));
+
+  int iEpgItems = g_PVRManager.GetPlayingGroup(bRadio)->GetEPGNow(*m_parent->m_vecItems);
+  if (iEpgItems == 0 && bRadio)
+    // if we didn't get any events for radio, get tv instead
+    iEpgItems = g_PVRManager.GetPlayingGroup(false)->GetEPGNow(*m_parent->m_vecItems);
+
+  if (iEpgItems == 0)
+  {
+    CFileItemPtr item;
+    item.reset(new CFileItem("pvr://guide/now/empty.epg", false));
+    item->SetLabel(g_localizeStrings.Get(19028));
+    item->SetLabelPreformated(true);
+    m_parent->m_vecItems->Add(item);
+  }
+  m_parent->m_viewControl.SetItems(*m_parent->m_vecItems);
+}
+
+void CGUIWindowPVRGuide::UpdateViewNext(bool bUpdateSelectedFile)
+{
+  CPVRChannelPtr CurrentChannel;
+  bool bGotCurrentChannel = g_PVRManager.GetCurrentChannel(CurrentChannel);
+  bool bRadio = bGotCurrentChannel ? CurrentChannel->IsRadio() : false;
+
+  m_parent->m_guideGrid = NULL;
+  m_parent->m_viewControl.SetCurrentView(CONTROL_LIST_GUIDE_NOW_NEXT);
+
+  m_parent->SetLabel(m_iControlButton, g_localizeStrings.Get(19222) + ": " + g_localizeStrings.Get(19031));
+  m_parent->SetLabel(CONTROL_LABELGROUP, g_localizeStrings.Get(19031));
+
+  int iEpgItems = g_PVRManager.GetPlayingGroup(bRadio)->GetEPGNext(*m_parent->m_vecItems);
+  if (iEpgItems == 0 && bRadio)
+    // if we didn't get any events for radio, get tv instead
+    iEpgItems = g_PVRManager.GetPlayingGroup(false)->GetEPGNext(*m_parent->m_vecItems);
+
+  if (iEpgItems)
+  {
+    CFileItemPtr item;
+    item.reset(new CFileItem("pvr://guide/next/empty.epg", false));
+    item->SetLabel(g_localizeStrings.Get(19028));
+    item->SetLabelPreformated(true);
+    m_parent->m_vecItems->Add(item);
+  }
+  m_parent->m_viewControl.SetItems(*m_parent->m_vecItems);
+}
+
+void CGUIWindowPVRGuide::UpdateViewTimeline(bool bUpdateSelectedFile)
+{
+  m_parent->m_guideGrid = (CGUIEPGGridContainer*) m_parent->GetControl(CONTROL_LIST_TIMELINE);
+  if (!m_parent->m_guideGrid)
+    return;
+
+  CPVRChannelPtr CurrentChannel;
+  bool bGotCurrentChannel = g_PVRManager.GetCurrentChannel(CurrentChannel);
+  bool bRadio = bGotCurrentChannel ? CurrentChannel->IsRadio() : false;
+
+  if (m_bUpdateRequired || m_cachedTimeline->IsEmpty() ||
+      *m_cachedChannelGroup != *g_PVRManager.GetPlayingGroup(bRadio))
+  {
+    m_bUpdateRequired = false;
+
+    m_cachedTimeline->Clear();
+    m_cachedChannelGroup = g_PVRManager.GetPlayingGroup(bRadio);
+    if (m_cachedChannelGroup->GetEPGAll(*m_cachedTimeline) == 0 && bRadio)
+    {
+      // if we didn't get any events for radio, get tv instead
+      m_cachedChannelGroup = g_PVRManager.GetPlayingGroup(false);
+      m_cachedChannelGroup->GetEPGAll(*m_cachedTimeline);
+    }
+  }
+
+  m_parent->m_vecItems->RemoveDiscCache(m_parent->GetID());
+  m_parent->m_vecItems->Assign(*m_cachedTimeline, false);
+
+  CDateTime gridStart = CDateTime::GetCurrentDateTime().GetAsUTCDateTime();
+  CDateTime firstDate(g_EpgContainer.GetFirstEPGDate());
+  CDateTime lastDate(g_EpgContainer.GetLastEPGDate());
+  m_parent->m_guideGrid->SetStartEnd(firstDate > gridStart ? firstDate : gridStart, lastDate);
+
+  m_parent->SetLabel(m_iControlButton, g_localizeStrings.Get(19222) + ": " + g_localizeStrings.Get(19032));
+  m_parent->SetLabel(CONTROL_LABELGROUP, g_localizeStrings.Get(19032));
+  m_parent->m_viewControl.SetCurrentView(CONTROL_LIST_TIMELINE, true);
+
+  if (bUpdateSelectedFile)
+    SelectPlayingFile();
+}
+
+bool CGUIWindowPVRGuide::SelectPlayingFile(void)
+{
+  if (m_iGuideView == GUIDE_VIEW_TIMELINE)
+  {
+    if (m_parent->m_guideGrid && g_PVRManager.IsPlaying())
+      m_parent->m_guideGrid->SetChannel(g_application.CurrentFile());
+    return true;
+  }
+  return false;
+}
+
+void CGUIWindowPVRGuide::UpdateData(bool bUpdateSelectedFile /* = true */)
+{
+  CSingleLock lock(m_critSection);
+  CLog::Log(LOGDEBUG, "CGUIWindowPVRGuide - %s - update window '%s'. set view to %d", __FUNCTION__, GetName(), m_iControlList);
+
+  /* lock the graphics context while updating */
+  CSingleLock graphicsLock(g_graphicsContext);
+  m_parent->m_viewControl.Clear();
+  m_parent->m_vecItems->Clear();
+
+  if (m_iGuideView == GUIDE_VIEW_CHANNEL)
+    UpdateViewChannel(bUpdateSelectedFile);
+  else if (m_iGuideView == GUIDE_VIEW_NOW)
+    UpdateViewNow(bUpdateSelectedFile);
+  else if (m_iGuideView == GUIDE_VIEW_NEXT)
+    UpdateViewNext(bUpdateSelectedFile);
+  else if (m_iGuideView == GUIDE_VIEW_TIMELINE)
+    UpdateViewTimeline(bUpdateSelectedFile);
+
+  m_bUpdateRequired = false;
+  m_parent->SetLabel(CONTROL_LABELHEADER, g_localizeStrings.Get(19222));
+  UpdateButtons();
+}
+
+bool CGUIWindowPVRGuide::IsSelectedButton(CGUIMessage &message) const
+{
+  unsigned int iControl = message.GetSenderId();
+  return (iControl == CONTROL_BTNGUIDE ||
+      iControl == CONTROL_BTNGUIDE_CHANNEL ||
+      iControl == CONTROL_BTNGUIDE_NOW ||
+      iControl == CONTROL_BTNGUIDE_NEXT ||
+      iControl == CONTROL_BTNGUIDE_TIMELINE);
+}
+
+bool CGUIWindowPVRGuide::IsSelectedList(CGUIMessage &message) const
+{
+  return ((message.GetSenderId() == CONTROL_LIST_TIMELINE && m_iGuideView == GUIDE_VIEW_TIMELINE) ||
+      (message.GetSenderId() == CONTROL_LIST_GUIDE_CHANNEL && m_iGuideView == GUIDE_VIEW_CHANNEL) ||
+      (message.GetSenderId() == CONTROL_LIST_GUIDE_NOW_NEXT && (m_iGuideView == GUIDE_VIEW_NOW || m_iGuideView == GUIDE_VIEW_NEXT)));
+}
+
+bool CGUIWindowPVRGuide::OnClickButton(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (IsSelectedButton(message))
+  {
+    unsigned int iControl = message.GetSenderId();
+    bReturn = true;
+
+    if (iControl == CONTROL_BTNGUIDE)
+    {
+      if (++m_iGuideView > GUIDE_VIEW_TIMELINE)
+        m_iGuideView = GUIDE_VIEW_CHANNEL;
+    }
+    else if (iControl == CONTROL_BTNGUIDE_CHANNEL)
+      m_iGuideView = GUIDE_VIEW_CHANNEL;
+    else if (iControl == CONTROL_BTNGUIDE_NOW)
+      m_iGuideView = GUIDE_VIEW_NOW;
+    else if (iControl == CONTROL_BTNGUIDE_NEXT)
+      m_iGuideView = GUIDE_VIEW_NEXT;
+    else if (iControl == CONTROL_BTNGUIDE_TIMELINE)
+      m_iGuideView = GUIDE_VIEW_TIMELINE;
+    else
+      bReturn = false;
+
+    if (bReturn)
+      UpdateData();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRGuide::OnClickList(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (IsSelectedList(message))
+  {
+    int iAction = message.GetParam1();
+    int iItem = m_parent->m_viewControl.GetSelectedItem();
+
+    /* get the fileitem pointer */
+    if (iItem < 0 || iItem >= (int) m_parent->m_vecItems->Size())
+      return bReturn;
+    CFileItemPtr pItem = m_parent->m_vecItems->Get(iItem);
+
+    /* process actions */
+    bReturn = true;
+    if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+    {
+      if (g_advancedSettings.m_bPVRShowEpgInfoOnEpgItemSelect)
+        ShowEPGInfo(pItem.get());
+      else
+        PlayEpgItem(pItem.get());
+    }
+    else if (iAction == ACTION_SHOW_INFO)
+      ShowEPGInfo(pItem.get());
+    else if (iAction == ACTION_RECORD)
+      ActionRecord(pItem.get());
+    else if (iAction == ACTION_PLAY)
+      ActionPlayEpg(pItem.get());
+    else if (iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+      m_parent->OnPopupMenu(iItem);
+    else
+      bReturn = false;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRGuide::OnContextButtonBegin(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_BEGIN)
+  {
+    CGUIWindowPVR *pWindow = (CGUIWindowPVR *) g_windowManager.GetWindow(WINDOW_PVR);
+    if (pWindow)
+      pWindow->m_guideGrid->GoToBegin();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRGuide::OnContextButtonEnd(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_END)
+  {
+    CGUIWindowPVR *pWindow = (CGUIWindowPVR *) g_windowManager.GetWindow(WINDOW_PVR);
+    if (pWindow)
+      pWindow->m_guideGrid->GoToEnd();
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRGuide::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_INFO)
+  {
+    ShowEPGInfo(item);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRGuide::PlayEpgItem(CFileItem *item)
+{
+  CPVRChannelPtr channel;
+  if (item && item->HasEPGInfoTag() && item->GetEPGInfoTag()->HasPVRChannel())
+    channel = item->GetEPGInfoTag()->ChannelTag();
+
+  if (!channel || !g_PVRManager.CheckParentalLock(*channel))
+    return false;
+
+  CLog::Log(LOGDEBUG, "play channel '%s'", channel->ChannelName().c_str());
+  bool bReturn = g_application.PlayFile(CFileItem(*channel));
+  if (!bReturn)
+    CGUIDialogOK::ShowAndGetInput(19033,0,19035,0);
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRGuide::OnContextButtonPlay(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_PLAY_ITEM)
+  {
+    bReturn = PlayEpgItem(item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRGuide::OnContextButtonStartRecord(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_START_RECORD)
+  {
+    StartRecordFile(item);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRGuide::OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_STOP_RECORD)
+  {
+    StopRecordFile(item);
+    bReturn = true;
+  }
+
+  return bReturn;
+}
+
+void CGUIWindowPVRGuide::UpdateButtons(void)
+{
+  if (m_iGuideView == GUIDE_VIEW_CHANNEL)
+    m_parent->SetLabel(m_iControlButton, g_localizeStrings.Get(19222) + ": " + g_localizeStrings.Get(19029));
+  else if (m_iGuideView == GUIDE_VIEW_NOW)
+    m_parent->SetLabel(m_iControlButton, g_localizeStrings.Get(19222) + ": " + g_localizeStrings.Get(19030));
+  else if (m_iGuideView == GUIDE_VIEW_NEXT)
+    m_parent->SetLabel(m_iControlButton, g_localizeStrings.Get(19222) + ": " + g_localizeStrings.Get(19031));
+  else if (m_iGuideView == GUIDE_VIEW_TIMELINE)
+    m_parent->SetLabel(m_iControlButton, g_localizeStrings.Get(19222) + ": " + g_localizeStrings.Get(19032));
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp b/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
new file mode 100644
index 0000000..88da494
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
@@ -0,0 +1,397 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIWindowPVRRecordings.h"
+
+#include "guilib/GUIKeyboardFactory.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "GUIInfoManager.h"
+#include "pvr/PVRManager.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/windows/GUIWindowPVR.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "threads/SingleLock.h"
+#include "video/VideoDatabase.h"
+
+using namespace PVR;
+
+CGUIWindowPVRRecordings::CGUIWindowPVRRecordings(CGUIWindowPVR *parent) :
+  CGUIWindowPVRCommon(parent, PVR_WINDOW_RECORDINGS, CONTROL_BTNRECORDINGS, CONTROL_LIST_RECORDINGS)
+{
+  m_strSelectedPath = "pvr://recordings/";
+}
+
+void CGUIWindowPVRRecordings::UnregisterObservers(void)
+{
+  CSingleLock lock(m_critSection);
+  if(g_PVRRecordings)
+    g_PVRRecordings->UnregisterObserver(this);
+  if(g_PVRTimers)
+    g_PVRTimers->UnregisterObserver(this);
+  g_infoManager.UnregisterObserver(this);
+}
+
+void CGUIWindowPVRRecordings::ResetObservers(void)
+{
+  CSingleLock lock(m_critSection);
+  g_PVRRecordings->RegisterObserver(this);
+  g_PVRTimers->RegisterObserver(this);
+  g_infoManager.RegisterObserver(this);
+}
+
+CStdString CGUIWindowPVRRecordings::GetResumeString(CFileItem item)
+{
+  CStdString resumeString;
+  if (item.IsPVRRecording())
+  {
+
+    // First try to find the resume position on the back-end, if that fails use video database
+    CPVRRecording recording = *item.GetPVRRecordingInfoTag();
+    int positionInSeconds = g_PVRManager.GetRecordingLastPlayedPosition(recording);
+    // If the back-end does report a saved position then make sure there is a corresponding resume bookmark
+    if (positionInSeconds > 0)
+    {
+      CBookmark bookmark;
+      bookmark.timeInSeconds = positionInSeconds;
+      CVideoDatabase db;
+      if (db.Open())
+      {
+        CStdString itemPath(item.GetPVRRecordingInfoTag()->m_strFileNameAndPath);
+        db.AddBookMarkToFile(itemPath, bookmark, CBookmark::RESUME);
+        db.Close();
+      }
+    }
+    else if (positionInSeconds < 0)
+    {
+      CVideoDatabase db;
+      if (db.Open())
+      {
+        CBookmark bookmark;
+        CStdString itemPath(item.GetPVRRecordingInfoTag()->m_strFileNameAndPath);
+        if (db.GetResumeBookMark(itemPath, bookmark) )
+          positionInSeconds = lrint(bookmark.timeInSeconds);
+        db.Close();
+      }
+    }
+
+    // Suppress resume from 0
+    if (positionInSeconds > 0)
+      resumeString.Format(g_localizeStrings.Get(12022).c_str(), StringUtils::SecondsToTimeString(positionInSeconds).c_str());
+  }
+  return resumeString;
+}
+
+void CGUIWindowPVRRecordings::GetContextButtons(int itemNumber, CContextButtons &buttons) const
+{
+  if (itemNumber < 0 || itemNumber >= m_parent->m_vecItems->Size())
+    return;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+
+  if (pItem->HasPVRRecordingInfoTag())
+  {
+    buttons.Add(CONTEXT_BUTTON_INFO, 19053);      /* Get Information of this recording */
+    buttons.Add(CONTEXT_BUTTON_FIND, 19003);      /* Find similar program */
+    buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 12021); /* Play this recording */
+    CStdString resumeString = GetResumeString(*pItem);
+    if (!resumeString.IsEmpty())
+    {
+      buttons.Add(CONTEXT_BUTTON_RESUME_ITEM, resumeString);
+    }
+  }
+  if (pItem->m_bIsFolder)
+  {
+    // Have both options for folders since we don't know whether all childs are watched/unwatched
+    buttons.Add(CONTEXT_BUTTON_MARK_UNWATCHED, 16104); /* Mark as UnWatched */
+    buttons.Add(CONTEXT_BUTTON_MARK_WATCHED, 16103);   /* Mark as Watched */
+  }
+  if (pItem->HasPVRRecordingInfoTag())
+  {
+    if (pItem->GetPVRRecordingInfoTag()->m_playCount > 0)
+      buttons.Add(CONTEXT_BUTTON_MARK_UNWATCHED, 16104); /* Mark as UnWatched */
+    else
+      buttons.Add(CONTEXT_BUTTON_MARK_WATCHED, 16103);   /* Mark as Watched */
+
+    buttons.Add(CONTEXT_BUTTON_RENAME, 118);      /* Rename this recording */
+    buttons.Add(CONTEXT_BUTTON_DELETE, 117);      /* Delete this recording */
+  }
+  buttons.Add(CONTEXT_BUTTON_SORTBY_NAME, 103);       /* sort by name */
+  buttons.Add(CONTEXT_BUTTON_SORTBY_DATE, 104);       /* sort by date */
+  // Update sort by button
+//if (m_guiState->GetSortMethod()!=SORT_METHOD_NONE)
+//{
+//  CStdString sortLabel;
+//  sortLabel.Format(g_localizeStrings.Get(550).c_str(), g_localizeStrings.Get(m_guiState->GetSortMethodLabel()).c_str());
+//  buttons.Add(CONTEXT_BUTTON_SORTBY, sortLabel);   /* Sort method */
+//
+//  if (m_guiState->GetDisplaySortOrder()==SORT_ORDER_ASC)
+//    buttons.Add(CONTEXT_BUTTON_SORTASC, 584);        /* Sort up or down */
+//  else
+//    buttons.Add(CONTEXT_BUTTON_SORTASC, 585);        /* Sort up or down */
+//}
+}
+
+bool CGUIWindowPVRRecordings::OnAction(const CAction &action)
+{
+  if (action.GetID() == ACTION_PARENT_DIR ||
+      action.GetID() == ACTION_NAV_BACK)
+  {
+    if (m_parent->m_vecItems->GetPath() != "pvr://recordings/")
+      m_parent->GoParentFolder();
+    else
+      g_windowManager.PreviousWindow();
+
+    return true;
+  }
+
+  return CGUIWindowPVRCommon::OnAction(action);
+}
+
+bool CGUIWindowPVRRecordings::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  if (itemNumber < 0 || itemNumber >= m_parent->m_vecItems->Size())
+    return false;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+
+  return OnContextButtonPlay(pItem.get(), button) ||
+      OnContextButtonRename(pItem.get(), button) ||
+      OnContextButtonDelete(pItem.get(), button) ||
+      OnContextButtonInfo(pItem.get(), button) ||
+      OnContextButtonMarkWatched(pItem, button) ||
+      CGUIWindowPVRCommon::OnContextButton(itemNumber, button);
+}
+
+void CGUIWindowPVRRecordings::OnWindowUnload(void)
+{
+  m_strSelectedPath = m_parent->m_vecItems->GetPath();
+  CGUIWindowPVRCommon::OnWindowUnload();
+}
+
+void CGUIWindowPVRRecordings::UpdateData(bool bUpdateSelectedFile /* = true */)
+{
+  CSingleLock lock(m_critSection);
+  CLog::Log(LOGDEBUG, "CGUIWindowPVRRecordings - %s - update window '%s'. set view to %d", __FUNCTION__, GetName(), m_iControlList);
+  m_bUpdateRequired = false;
+
+  /* lock the graphics context while updating */
+  CSingleLock graphicsLock(g_graphicsContext);
+
+  m_iSelected = m_parent->m_viewControl.GetSelectedItem();
+  if (m_parent->m_vecItems->GetPath().Left(17) != "pvr://recordings/")
+    m_strSelectedPath = "pvr://recordings/";
+  else
+    m_strSelectedPath = m_parent->m_vecItems->GetPath();
+
+  m_parent->m_viewControl.Clear();
+  m_parent->m_vecItems->Clear();
+  m_parent->m_viewControl.SetCurrentView(m_iControlList);
+  m_parent->m_vecItems->SetPath(m_strSelectedPath);
+  m_parent->Update(m_strSelectedPath);
+  m_parent->m_viewControl.SetItems(*m_parent->m_vecItems);
+
+  if (bUpdateSelectedFile)
+  {
+    if (!SelectPlayingFile())
+      m_parent->m_viewControl.SetSelectedItem(m_iSelected);
+  }
+
+  m_parent->SetLabel(CONTROL_LABELHEADER, g_localizeStrings.Get(19017));
+  m_parent->SetLabel(CONTROL_LABELGROUP, "");
+}
+
+void CGUIWindowPVRRecordings::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  if (msg == ObservableMessageRecordings || msg == ObservableMessageTimers || msg == ObservableMessageCurrentItem)
+  {
+    if (IsVisible())
+      SetInvalid();
+    else
+      m_bUpdateRequired = true;
+  }
+  else if (msg == ObservableMessageRecordings || msg == ObservableMessageTimersReset)
+  {
+    if (IsVisible())
+      UpdateData(false);
+    else
+      m_bUpdateRequired = true;
+  }
+}
+
+bool CGUIWindowPVRRecordings::OnClickButton(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (IsSelectedButton(message))
+  {
+    bReturn = true;
+    g_PVRManager.TriggerRecordingsUpdate();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRRecordings::OnClickList(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (IsSelectedList(message))
+  {
+    bReturn = true;
+    int iAction = message.GetParam1();
+    int iItem = m_parent->m_viewControl.GetSelectedItem();
+
+    /* get the fileitem pointer */
+    if (iItem < 0 || iItem >= (int) m_parent->m_vecItems->Size())
+      return bReturn;
+    CFileItemPtr pItem = m_parent->m_vecItems->Get(iItem);
+
+    /* process actions */
+    if (iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK || iAction == ACTION_PLAY)
+    {
+      int choice = CONTEXT_BUTTON_PLAY_ITEM;
+      CStdString resumeString = GetResumeString(*pItem);
+      if (!resumeString.IsEmpty())
+      {
+        CContextButtons choices;
+        choices.Add(CONTEXT_BUTTON_RESUME_ITEM, resumeString);
+        choices.Add(CONTEXT_BUTTON_PLAY_ITEM, 12021);
+        choice = CGUIDialogContextMenu::ShowAndGetChoice(choices);
+      }
+      if (choice < 0)
+        bReturn = true;
+      else
+        bReturn = OnContextButtonPlay(pItem.get(), (CONTEXT_BUTTON)choice);
+    }
+    else if (iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+      m_parent->OnPopupMenu(iItem);
+    else if (iAction == ACTION_SHOW_INFO)
+      ShowRecordingInfo(pItem.get());
+    else if (iAction == ACTION_DELETE_ITEM)
+      bReturn = ActionDeleteRecording(pItem.get());
+    else
+      bReturn = false;
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRRecordings::OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_DELETE)
+  {
+    bReturn = false;
+
+    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+    if (!pDialog)
+      return bReturn;
+    pDialog->SetHeading(122);
+    pDialog->SetLine(0, 19043);
+    pDialog->SetLine(1, "");
+    pDialog->SetLine(2, item->GetPVRRecordingInfoTag()->m_strTitle);
+    pDialog->DoModal();
+
+    if (!pDialog->IsConfirmed())
+      return bReturn;
+
+    bReturn = g_PVRRecordings->DeleteRecording(*item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRRecordings::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_INFO)
+  {
+    bReturn = true;
+    ShowRecordingInfo(item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRRecordings::OnContextButtonPlay(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if ((button == CONTEXT_BUTTON_PLAY_ITEM) ||
+      (button == CONTEXT_BUTTON_RESUME_ITEM))
+  {
+    item->m_lStartOffset = button == CONTEXT_BUTTON_RESUME_ITEM ? STARTOFFSET_RESUME : 0;
+    bReturn = PlayFile(item, false); /* play recording */
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRRecordings::OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_RENAME)
+  {
+    bReturn = true;
+
+    CPVRRecording *recording = item->GetPVRRecordingInfoTag();
+    CStdString strNewName = recording->m_strTitle;
+    if (CGUIKeyboardFactory::ShowAndGetInput(strNewName, g_localizeStrings.Get(19041), false))
+    {
+      if (g_PVRRecordings->RenameRecording(*item, strNewName))
+        UpdateData();
+    }
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRRecordings::OnContextButtonMarkWatched(const CFileItemPtr &item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_MARK_WATCHED)
+  {
+    bReturn = true;
+
+    int newSelection = m_parent->m_viewControl.GetSelectedItem();
+    g_PVRRecordings->SetRecordingsPlayCount(item, 1);
+    m_parent->m_viewControl.SetSelectedItem(newSelection);
+
+    UpdateData();
+  }
+
+  if (button == CONTEXT_BUTTON_MARK_UNWATCHED)
+  {
+    bReturn = true;
+
+    g_PVRRecordings->SetRecordingsPlayCount(item, 0);
+
+    UpdateData();
+  }
+
+  return bReturn;
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVRSearch.cpp b/xbmc/pvr/windows/GUIWindowPVRSearch.cpp
new file mode 100644
index 0000000..7a53bd3
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVRSearch.cpp
@@ -0,0 +1,290 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIWindowPVRSearch.h"
+
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "guilib/GUIWindowManager.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+#include "pvr/dialogs/GUIDialogPVRGuideSearch.h"
+#include "epg/EpgContainer.h"
+#include "pvr/recordings/PVRRecordings.h"
+#include "GUIWindowPVR.h"
+#include "utils/log.h"
+#include "pvr/addons/PVRClients.h"
+
+using namespace PVR;
+using namespace EPG;
+
+CGUIWindowPVRSearch::CGUIWindowPVRSearch(CGUIWindowPVR *parent) :
+  CGUIWindowPVRCommon(parent, PVR_WINDOW_SEARCH, CONTROL_BTNSEARCH, CONTROL_LIST_SEARCH),
+  m_bSearchStarted(false),
+  m_bSearchConfirmed(false)
+{
+}
+
+void CGUIWindowPVRSearch::GetContextButtons(int itemNumber, CContextButtons &buttons) const
+{
+  if (itemNumber < 0 || itemNumber >= m_parent->m_vecItems->Size())
+    return;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+
+  if (pItem->GetLabel() != g_localizeStrings.Get(19027))
+  {
+    if (pItem->GetEPGInfoTag()->EndAsLocalTime() > CDateTime::GetCurrentDateTime())
+    {
+      if (!pItem->GetEPGInfoTag()->HasTimer())
+      {
+        if (pItem->GetEPGInfoTag()->StartAsLocalTime() < CDateTime::GetCurrentDateTime())
+          buttons.Add(CONTEXT_BUTTON_START_RECORD, 264);   /* RECORD programme */
+        else
+          buttons.Add(CONTEXT_BUTTON_START_RECORD, 19061); /* Create a Timer */
+      }
+      else
+      {
+        if (pItem->GetEPGInfoTag()->StartAsLocalTime() < CDateTime::GetCurrentDateTime())
+          buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19059); /* Stop recording */
+        else
+          buttons.Add(CONTEXT_BUTTON_STOP_RECORD, 19060); /* Delete Timer */
+      }
+    }
+
+    buttons.Add(CONTEXT_BUTTON_INFO, 19047);              /* Epg info button */
+    buttons.Add(CONTEXT_BUTTON_SORTBY_CHANNEL, 19062);    /* Sort by channel */
+    buttons.Add(CONTEXT_BUTTON_SORTBY_NAME, 103);         /* Sort by Name */
+    buttons.Add(CONTEXT_BUTTON_SORTBY_DATE, 104);         /* Sort by Date */
+    buttons.Add(CONTEXT_BUTTON_CLEAR, 19232);             /* Clear search results */
+    if (pItem->GetEPGInfoTag()->HasPVRChannel() &&
+        g_PVRClients->HasMenuHooks(pItem->GetEPGInfoTag()->ChannelTag()->ClientID()))
+      buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);      /* PVR client specific action */
+  }
+}
+
+bool CGUIWindowPVRSearch::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  if (itemNumber < 0 || itemNumber >= m_parent->m_vecItems->Size())
+    return false;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+
+  return OnContextButtonClear(pItem.get(), button) ||
+      OnContextButtonInfo(pItem.get(), button) ||
+      OnContextButtonStopRecord(pItem.get(), button) ||
+      OnContextButtonStartRecord(pItem.get(), button) ||
+      CGUIWindowPVRCommon::OnContextButton(itemNumber, button);
+}
+
+void CGUIWindowPVRSearch::UpdateData(bool bUpdateSelectedFile /* = true */)
+{
+  CLog::Log(LOGDEBUG, "CGUIWindowPVRSearch - %s - update window '%s'. set view to %d", __FUNCTION__, GetName(), m_iControlList);
+  m_bUpdateRequired = false;
+
+  /* lock the graphics context while updating */
+  CSingleLock graphicsLock(g_graphicsContext);
+
+  m_iSelected = m_parent->m_viewControl.GetSelectedItem();
+  m_parent->m_viewControl.Clear();
+  m_parent->m_vecItems->Clear();
+  m_parent->m_viewControl.SetCurrentView(m_iControlList);
+
+  if (m_bSearchConfirmed)
+  {
+    CGUIDialogProgress* dlgProgress = (CGUIDialogProgress*)g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
+    if (dlgProgress)
+    {
+      dlgProgress->SetHeading(194);
+      dlgProgress->SetLine(0, m_searchfilter.m_strSearchTerm);
+      dlgProgress->SetLine(1, "");
+      dlgProgress->SetLine(2, "");
+      dlgProgress->StartModal();
+      dlgProgress->Progress();
+    }
+
+    // TODO get this from the selected channel group
+    g_EpgContainer.GetEPGSearch(*m_parent->m_vecItems, m_searchfilter);
+    if (dlgProgress)
+      dlgProgress->Close();
+
+    if (m_parent->m_vecItems->Size() == 0)
+    {
+      CGUIDialogOK::ShowAndGetInput(194, 284, 0, 0);
+      m_bSearchConfirmed = false;
+    }
+  }
+
+  if (m_parent->m_vecItems->Size() == 0)
+  {
+    CFileItemPtr item;
+    item.reset(new CFileItem("pvr://guide/searchresults/empty.epg", false));
+    item->SetLabel(g_localizeStrings.Get(19027));
+    item->SetLabelPreformated(true);
+    m_parent->m_vecItems->Add(item);
+  }
+  else
+  {
+    m_parent->m_vecItems->Sort(m_iSortMethod, m_iSortOrder);
+  }
+
+  m_parent->m_viewControl.SetItems(*m_parent->m_vecItems);
+
+  if (bUpdateSelectedFile)
+    m_parent->m_viewControl.SetSelectedItem(m_iSelected);
+
+  m_parent->SetLabel(CONTROL_LABELHEADER, g_localizeStrings.Get(283));
+  m_parent->SetLabel(CONTROL_LABELGROUP, "");
+}
+
+bool CGUIWindowPVRSearch::OnClickButton(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (IsSelectedButton(message))
+  {
+    bReturn = true;
+    ShowSearchResults();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRSearch::OnClickList(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (IsSelectedList(message))
+  {
+    bReturn = true;
+    int iAction = message.GetParam1();
+    int iItem = m_parent->m_viewControl.GetSelectedItem();
+
+    /* get the fileitem pointer */
+    if (iItem < 0 || iItem >= m_parent->m_vecItems->Size())
+      return bReturn;
+    CFileItemPtr pItem = m_parent->m_vecItems->Get(iItem);
+
+    /* process actions */
+    if (iAction == ACTION_SHOW_INFO || iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+      ActionShowSearch(pItem.get());
+    else if (iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+      m_parent->OnPopupMenu(iItem);
+    else if (iAction == ACTION_RECORD)
+      ActionRecord(pItem.get());
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRSearch::OnContextButtonClear(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_CLEAR)
+  {
+    bReturn = true;
+
+    m_bSearchStarted = false;
+    m_bSearchConfirmed = false;
+    m_searchfilter.Reset();
+
+    UpdateData();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRSearch::OnContextButtonInfo(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_INFO)
+  {
+    bReturn = true;
+
+    ShowEPGInfo(item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRSearch::OnContextButtonStartRecord(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_START_RECORD)
+  {
+    bReturn = true;
+
+    StartRecordFile(item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRSearch::OnContextButtonStopRecord(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_STOP_RECORD)
+  {
+    bReturn = true;
+
+    StopRecordFile(item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRSearch::ActionShowSearch(CFileItem *item)
+{
+  if (item->GetPath() == "pvr://guide/searchresults/empty.epg")
+    ShowSearchResults();
+  else
+    ShowEPGInfo(item);
+
+  return true;
+}
+
+void CGUIWindowPVRSearch::ShowSearchResults()
+{
+  /* Load timer settings dialog */
+  CGUIDialogPVRGuideSearch* pDlgInfo = (CGUIDialogPVRGuideSearch*)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_GUIDE_SEARCH);
+
+  if (!pDlgInfo)
+    return;
+
+  if (!m_bSearchStarted)
+  {
+    m_bSearchStarted = true;
+    m_searchfilter.Reset();
+  }
+
+  pDlgInfo->SetFilterData(&m_searchfilter);
+
+  /* Open dialog window */
+  pDlgInfo->DoModal();
+
+  if (pDlgInfo->IsConfirmed())
+  {
+    m_bSearchConfirmed = true;
+    UpdateData();
+  }
+}
diff --git a/xbmc/pvr/windows/GUIWindowPVRTimers.cpp b/xbmc/pvr/windows/GUIWindowPVRTimers.cpp
new file mode 100644
index 0000000..e2586d2
--- /dev/null
+++ b/xbmc/pvr/windows/GUIWindowPVRTimers.cpp
@@ -0,0 +1,284 @@
+/*
+ *      Copyright (C) 2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "GUIWindowPVRTimers.h"
+
+#include "guilib/GUIKeyboardFactory.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "guilib/GUIWindowManager.h"
+#include "pvr/PVRManager.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/addons/PVRClients.h"
+#include "GUIWindowPVR.h"
+#include "threads/SingleLock.h"
+
+using namespace PVR;
+
+CGUIWindowPVRTimers::CGUIWindowPVRTimers(CGUIWindowPVR *parent) :
+  CGUIWindowPVRCommon(parent, PVR_WINDOW_TIMERS, CONTROL_BTNTIMERS, CONTROL_LIST_TIMERS)
+{
+}
+
+void CGUIWindowPVRTimers::UnregisterObservers(void)
+{
+  CSingleLock lock(m_critSection);
+  if (g_PVRTimers)
+    g_PVRTimers->UnregisterObserver(this);
+}
+
+void CGUIWindowPVRTimers::ResetObservers(void)
+{
+  CSingleLock lock(m_critSection);
+  g_PVRTimers->RegisterObserver(this);
+}
+
+void CGUIWindowPVRTimers::GetContextButtons(int itemNumber, CContextButtons &buttons) const
+{
+  if (itemNumber < 0 || itemNumber >= m_parent->m_vecItems->Size())
+    return;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+
+  /* Check for a empty file item list, means only a
+     file item with the name "Add timer..." is present */
+  if (pItem->GetPath() == "pvr://timers/add.timer")
+  {
+    buttons.Add(CONTEXT_BUTTON_ADD, 19056);             /* new timer */
+    if (m_parent->m_vecItems->Size() > 1)
+    {
+      buttons.Add(CONTEXT_BUTTON_SORTBY_NAME, 103);     /* sort by name */
+      buttons.Add(CONTEXT_BUTTON_SORTBY_DATE, 104);     /* sort by date */
+    }
+  }
+  else
+  {
+    buttons.Add(CONTEXT_BUTTON_EDIT, 19057);            /* edit timer */
+    buttons.Add(CONTEXT_BUTTON_ADD, 19056);             /* new timer */
+    buttons.Add(CONTEXT_BUTTON_ACTIVATE, 19058);        /* activate/deactivate */
+    buttons.Add(CONTEXT_BUTTON_RENAME, 118);            /* rename timer */
+    buttons.Add(CONTEXT_BUTTON_DELETE, 117);            /* delete timer */
+    buttons.Add(CONTEXT_BUTTON_SORTBY_NAME, 103);       /* sort by name */
+    buttons.Add(CONTEXT_BUTTON_SORTBY_DATE, 104);       /* sort by date */
+    if (g_PVRClients->HasMenuHooks(pItem->GetPVRTimerInfoTag()->m_iClientId))
+      buttons.Add(CONTEXT_BUTTON_MENU_HOOKS, 19195);    /* PVR client specific action */
+  }
+}
+
+bool CGUIWindowPVRTimers::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  if (itemNumber < 0 || itemNumber >= m_parent->m_vecItems->Size())
+    return false;
+  CFileItemPtr pItem = m_parent->m_vecItems->Get(itemNumber);
+
+  return OnContextButtonActivate(pItem.get(), button) ||
+      OnContextButtonAdd(pItem.get(), button) ||
+      OnContextButtonDelete(pItem.get(), button) ||
+      OnContextButtonEdit(pItem.get(), button) ||
+      OnContextButtonRename(pItem.get(), button) ||
+      CGUIWindowPVRCommon::OnContextButton(itemNumber, button);
+}
+
+void CGUIWindowPVRTimers::UpdateData(bool bUpdateSelectedFile /* = true */)
+{
+  CSingleLock lock(m_critSection);
+  CLog::Log(LOGDEBUG, "CGUIWindowPVRTimers - %s - update window '%s'. set view to %d", __FUNCTION__, GetName(), m_iControlList);
+  m_bUpdateRequired = false;
+
+  /* lock the graphics context while updating */
+  CSingleLock graphicsLock(g_graphicsContext);
+
+  m_iSelected = m_parent->m_viewControl.GetSelectedItem();
+  m_parent->m_viewControl.Clear();
+  m_parent->m_vecItems->Clear();
+  m_parent->m_viewControl.SetCurrentView(m_iControlList);
+  m_parent->m_vecItems->SetPath("pvr://timers/");
+  m_parent->Update(m_parent->m_vecItems->GetPath());
+  m_parent->m_vecItems->Sort(m_iSortMethod, m_iSortOrder);
+  m_parent->m_viewControl.SetItems(*m_parent->m_vecItems);
+
+  if (bUpdateSelectedFile)
+    m_parent->m_viewControl.SetSelectedItem(m_iSelected);
+
+  m_parent->SetLabel(CONTROL_LABELHEADER, g_localizeStrings.Get(19025));
+  m_parent->SetLabel(CONTROL_LABELGROUP, "");
+}
+
+bool CGUIWindowPVRTimers::OnClickButton(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (IsSelectedButton(message))
+  {
+    bReturn = true;
+    g_PVRManager.TriggerTimersUpdate();
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimers::OnClickList(CGUIMessage &message)
+{
+  bool bReturn = false;
+
+  if (IsSelectedList(message))
+  {
+    bReturn = true;
+    int iAction = message.GetParam1();
+    int iItem = m_parent->m_viewControl.GetSelectedItem();
+
+    /* get the fileitem pointer */
+    if (iItem < 0 || iItem >= m_parent->m_vecItems->Size())
+      return bReturn;
+    CFileItemPtr pItem = m_parent->m_vecItems->Get(iItem);
+
+    /* process actions */
+    if (iAction == ACTION_SHOW_INFO || iAction == ACTION_SELECT_ITEM || iAction == ACTION_MOUSE_LEFT_CLICK)
+      ActionShowTimer(pItem.get());
+    else if (iAction == ACTION_CONTEXT_MENU || iAction == ACTION_MOUSE_RIGHT_CLICK)
+      m_parent->OnPopupMenu(iItem);
+    else if (iAction == ACTION_DELETE_ITEM)
+      ActionDeleteTimer(pItem.get());
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimers::OnContextButtonActivate(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_ACTIVATE)
+  {
+    bReturn = true;
+    if (!item->HasPVRTimerInfoTag())
+      return bReturn;
+
+    CPVRTimerInfoTag *timer = item->GetPVRTimerInfoTag();
+    int iLabelId;
+    if (timer->IsActive())
+    {
+      timer->m_state = PVR_TIMER_STATE_CANCELLED;
+      iLabelId = 13106;
+    }
+    else
+    {
+      timer->m_state = PVR_TIMER_STATE_SCHEDULED;
+      iLabelId = 305;
+    }
+
+    CGUIDialogOK::ShowAndGetInput(19033, 19040, 0, iLabelId);
+    g_PVRTimers->UpdateTimer(*item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimers::OnContextButtonAdd(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_ADD)
+    bReturn = ShowNewTimerDialog();
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimers::OnContextButtonDelete(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_DELETE)
+  {
+    bReturn = true;
+    if (!item->HasPVRTimerInfoTag())
+      return bReturn;
+
+    CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+    if (!pDialog)
+      return bReturn;
+    pDialog->SetHeading(122);
+    pDialog->SetLine(0, 19040);
+    pDialog->SetLine(1, "");
+    pDialog->SetLine(2, item->GetPVRTimerInfoTag()->m_strTitle);
+    pDialog->DoModal();
+
+    if (!pDialog->IsConfirmed())
+      return bReturn;
+
+    g_PVRTimers->DeleteTimer(*item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimers::OnContextButtonEdit(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_EDIT)
+  {
+    bReturn = true;
+    if (!item->HasPVRTimerInfoTag())
+      return bReturn;
+
+    if (ShowTimerSettings(item))
+      g_PVRTimers->UpdateTimer(*item);
+  }
+
+  return bReturn;
+}
+
+bool CGUIWindowPVRTimers::OnContextButtonRename(CFileItem *item, CONTEXT_BUTTON button)
+{
+  bool bReturn = false;
+
+  if (button == CONTEXT_BUTTON_RENAME)
+  {
+    bReturn = true;
+    if (!item->HasPVRTimerInfoTag())
+      return bReturn;
+    CPVRTimerInfoTag *timer = item->GetPVRTimerInfoTag();
+
+    CStdString strNewName(timer->m_strTitle);
+    if (CGUIKeyboardFactory::ShowAndGetInput(strNewName, g_localizeStrings.Get(19042), false))
+      g_PVRTimers->RenameTimer(*item, strNewName);
+  }
+
+  return bReturn;
+}
+
+void CGUIWindowPVRTimers::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  if (msg == ObservableMessageTimers)
+  {
+    if (IsVisible())
+      SetInvalid();
+    else
+      m_bUpdateRequired = true;
+  }
+  else if (msg == ObservableMessageTimersReset)
+  {
+    if (IsVisible())
+      UpdateData(false);
+    else
+      m_bUpdateRequired = true;
+  }
+}
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 1108b41..9726cf3 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -234,2 +234,10 @@ void CAdvancedSettings::Initialize()
 
+  m_iEpgLingerTime = 60;           /* keep 1 hour by default */
+  m_iEpgUpdateCheckInterval = 300; /* check if tables need to be updated every 5 minutes */
+  m_iEpgCleanupInterval = 900;     /* remove old entries from the EPG every 15 minutes */
+  m_iEpgActiveTagCheckInterval = 60; /* check for updated active tags every minute */
+  m_iEpgRetryInterruptedUpdateInterval = 30; /* retry an interrupted epg update after 30 seconds */
+  m_bEpgDisplayUpdatePopup = true; /* display a progress popup while updating EPG data from clients */
+  m_bEpgDisplayIncrementalUpdatePopup = false; /* also display a progress popup while doing incremental EPG updates */
+
   m_bEdlMergeShortCommBreaks = false;      // Off by default
@@ -282,2 +290,9 @@ void CAdvancedSettings::Initialize()
 
+  m_iPVRTimeCorrection             = 0;
+  m_iPVRInfoToggleInterval         = 3000;
+  m_bPVRShowEpgInfoOnEpgItemSelect = true;
+  m_iPVRMinVideoCacheLevel         = 5;
+  m_iPVRMinAudioCacheLevel         = 5;
+  m_bPVRCacheInDvdPlayer           = true;
+
   m_measureRefreshrate = false;
@@ -764,2 +779,15 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
 
+  // EPG
+  pElement = pRootElement->FirstChildElement("epg");
+  if (pElement)
+  {
+    XMLUtils::GetInt(pElement, "lingertime", m_iEpgLingerTime);
+    XMLUtils::GetInt(pElement, "updatecheckinterval", m_iEpgUpdateCheckInterval);
+    XMLUtils::GetInt(pElement, "cleanupinterval", m_iEpgCleanupInterval);
+    XMLUtils::GetInt(pElement, "activetagcheckinterval", m_iEpgActiveTagCheckInterval);
+    XMLUtils::GetInt(pElement, "retryinterruptedupdateinterval", m_iEpgRetryInterruptedUpdateInterval);
+    XMLUtils::GetBoolean(pElement, "displayupdatepopup", m_bEpgDisplayUpdatePopup);
+    XMLUtils::GetBoolean(pElement, "displayincrementalupdatepopup", m_bEpgDisplayIncrementalUpdatePopup);
+  }
+
   // EDL commercial break handling
@@ -940,2 +968,13 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
 
+  TiXmlElement *pPVR = pRootElement->FirstChildElement("pvr");
+  if (pPVR)
+  {
+    XMLUtils::GetInt(pPVR, "timecorrection", m_iPVRTimeCorrection, 0, 1440);
+    XMLUtils::GetInt(pPVR, "infotoggleinterval", m_iPVRInfoToggleInterval, 0, 30000);
+    XMLUtils::GetBoolean(pPVR, "showepginfoonselect", m_bPVRShowEpgInfoOnEpgItemSelect);
+    XMLUtils::GetInt(pPVR, "minvideocachelevel", m_iPVRMinVideoCacheLevel, 0, 100);
+    XMLUtils::GetInt(pPVR, "minaudiocachelevel", m_iPVRMinAudioCacheLevel, 0, 100);
+    XMLUtils::GetBoolean(pPVR, "cacheindvdplayer", m_bPVRCacheInDvdPlayer);
+  }
+
   XMLUtils::GetBoolean(pRootElement, "measurerefreshrate", m_measureRefreshrate);
@@ -965,2 +1004,24 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
 
+  pDatabase = pRootElement->FirstChildElement("tvdatabase");
+  if (pDatabase)
+  {
+    XMLUtils::GetString(pDatabase, "type", m_databaseTV.type);
+    XMLUtils::GetString(pDatabase, "host", m_databaseTV.host);
+    XMLUtils::GetString(pDatabase, "port", m_databaseTV.port);
+    XMLUtils::GetString(pDatabase, "user", m_databaseTV.user);
+    XMLUtils::GetString(pDatabase, "pass", m_databaseTV.pass);
+    XMLUtils::GetString(pDatabase, "name", m_databaseTV.name);
+  }
+
+  pDatabase = pRootElement->FirstChildElement("epgdatabase");
+  if (pDatabase)
+  {
+    XMLUtils::GetString(pDatabase, "type", m_databaseEpg.type);
+    XMLUtils::GetString(pDatabase, "host", m_databaseEpg.host);
+    XMLUtils::GetString(pDatabase, "port", m_databaseEpg.port);
+    XMLUtils::GetString(pDatabase, "user", m_databaseEpg.user);
+    XMLUtils::GetString(pDatabase, "pass", m_databaseEpg.pass);
+    XMLUtils::GetString(pDatabase, "name", m_databaseEpg.name);
+  }
+
   pElement = pRootElement->FirstChildElement("enablemultimediakeys");
diff --git a/xbmc/settings/GUIDialogSettings.cpp b/xbmc/settings/GUIDialogSettings.cpp
index 4c1f563..3c998af 100644
--- a/xbmc/settings/GUIDialogSettings.cpp
+++ b/xbmc/settings/GUIDialogSettings.cpp
@@ -22,2 +22,3 @@
 #include "GUIDialogSettings.h"
+#include "guilib/GUIEditControl.h"
 #include "guilib/GUISpinControlEx.h"
@@ -40,2 +41,4 @@
 #define CONTROL_DEFAULT_SEPARATOR  11
+#define CONTROL_DEFAULT_EDIT       12
+#define CONTROL_DEFAULT_EDIT_NUM   13
 #define CONTROL_OKAY_BUTTON        28
@@ -50,2 +53,4 @@ CGUIDialogSettings::CGUIDialogSettings(int id, const char *xmlFile)
 {
+  m_pOriginalEdit = NULL;
+  m_pOriginalEditNum = NULL;
   m_pOriginalSpin = NULL;
@@ -90,2 +95,4 @@ void CGUIDialogSettings::SetupPage()
   FreeControls();
+  m_pOriginalEdit = (CGUIEditControl*)GetControl(CONTROL_DEFAULT_EDIT);
+  m_pOriginalEditNum = (CGUIEditControl*)GetControl(CONTROL_DEFAULT_EDIT_NUM);
   m_pOriginalSpin = (CGUISpinControlEx*)GetControl(CONTROL_DEFAULT_SPIN);
@@ -95,2 +102,4 @@ void CGUIDialogSettings::SetupPage()
   m_pOriginalSeparator = (CGUIImage *)GetControl(CONTROL_DEFAULT_SEPARATOR);
+  if (m_pOriginalEdit) m_pOriginalEdit->SetVisible(false);
+  if (m_pOriginalEditNum) m_pOriginalEditNum->SetVisible(false);
   if (m_pOriginalSpin) m_pOriginalSpin->SetVisible(false);
@@ -102,3 +111,10 @@ void CGUIDialogSettings::SetupPage()
   // update our settings label
+  if (GetID() == WINDOW_DIALOG_PVR_TIMER_SETTING)
+  {
+    SET_CONTROL_LABEL(CONTROL_SETTINGS_LABEL, g_localizeStrings.Get(19057));
+  }
+  else
+  {
   SET_CONTROL_LABEL(CONTROL_SETTINGS_LABEL, g_localizeStrings.Get(13395 + GetID() - WINDOW_DIALOG_VIDEO_OSD_SETTINGS));
+  }
 
@@ -187,7 +203,21 @@ void CGUIDialogSettings::UpdateSetting(unsigned int id)
   }
-  else if (setting.type == SettingInfo::BUTTON)
+  else if (setting.type == SettingInfo::BUTTON_DIALOG)
   {
     SET_CONTROL_LABEL(controlID,setting.name);
-    if (m_usePopupSliders && setting.data && setting.formatFunction)
-      SET_CONTROL_LABEL2(controlID,setting.formatFunction(*(float *)setting.data, setting.interval));
+    CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(controlID);
+    if (pControl && setting.data) pControl->SetLabel2(*(CStdString *)setting.data);
+  }
+  else if (setting.type == SettingInfo::EDIT)
+  {
+    CGUIEditControl *pControl = (CGUIEditControl *)GetControl(controlID);
+    if (pControl && setting.data) pControl->SetLabel2(*(CStdString *)setting.data);
+  }
+  else if (setting.type == SettingInfo::EDIT_NUM)
+  {
+    CGUIEditControl *pControl = (CGUIEditControl *)GetControl(controlID);
+    if (pControl && setting.data) {
+      CStdString strIndex;
+      strIndex.Format("%i", *(int *)setting.data);
+      pControl->SetLabel2(strIndex);
+    }
   }
@@ -240,2 +270,20 @@ void CGUIDialogSettings::OnClick(int iID)
   }
+  else if (setting.type == SettingInfo::BUTTON_DIALOG)
+  {
+    CGUIButtonControl *pControl = (CGUIButtonControl *)GetControl(iID);
+    if (setting.data) *(CStdString *)setting.data = pControl->GetLabel2();
+  }
+  else if (setting.type == SettingInfo::EDIT)
+  {
+    CGUIEditControl *pControl = (CGUIEditControl *)GetControl(iID);
+    if (setting.data) *(CStdString *)setting.data = pControl->GetLabel2();
+  }
+  else if (setting.type == SettingInfo::EDIT_NUM)
+  {
+    CGUIEditControl *pControl = (CGUIEditControl *)GetControl(iID);
+    if (setting.data) {
+        CStdString strIndex = pControl->GetLabel2();
+        *(int *)setting.data = atol(strIndex.c_str());
+    }
+  }
   else if (setting.type == SettingInfo::CHECK)
@@ -287,3 +335,11 @@ void CGUIDialogSettings::AddSetting(SettingInfo &setting, float width, int iCont
   CGUIControl *pControl = NULL;
-  if (setting.type == SettingInfo::BUTTON && m_pOriginalSettingsButton)
+  if (setting.type == SettingInfo::BUTTON_DIALOG && m_pOriginalSettingsButton)
+  {
+    pControl = new CGUIButtonControl(*m_pOriginalSettingsButton);
+    if (!pControl) return ;
+    ((CGUIButtonControl *)pControl)->SetLabel(setting.name);
+    pControl->SetWidth(width);
+	if (setting.data) ((CGUIButtonControl *)pControl)->SetLabel2(*(CStdString *)setting.data);
+  }
+  else if (setting.type == SettingInfo::BUTTON && m_pOriginalSettingsButton)
   {
@@ -296,2 +352,23 @@ void CGUIDialogSettings::AddSetting(SettingInfo &setting, float width, int iCont
   }
+  else if (setting.type == SettingInfo::EDIT && m_pOriginalEdit)
+  {
+    pControl = new CGUIEditControl(*m_pOriginalEdit);
+    if (!pControl) return ;
+    ((CGUIEditControl *)pControl)->SetLabel(setting.name);
+    pControl->SetWidth(width);
+    if (setting.data) ((CGUIEditControl *)pControl)->SetLabel2(*(CStdString *)setting.data);
+  }
+  else if (setting.type == SettingInfo::EDIT_NUM && m_pOriginalEditNum)
+  {
+    pControl = new CGUIEditControl(*m_pOriginalEditNum);
+    if (!pControl) return ;
+    ((CGUIEditControl *)pControl)->SetLabel(setting.name);
+    pControl->SetWidth(width);
+    ((CGUIEditControl *)pControl)->SetInputType(CGUIEditControl::INPUT_TYPE_NUMBER, 0);
+    if (setting.data) {
+        CStdString strIndex;
+        strIndex.Format("%i", *(int *)setting.data);
+        ((CGUIEditControl *)pControl)->SetLabel2(strIndex);
+    }
+  }
   else if (setting.type == SettingInfo::SEPARATOR && m_pOriginalSeparator)
@@ -362,2 +439,24 @@ void CGUIDialogSettings::AddSetting(SettingInfo &setting, float width, int iCont
 
+void CGUIDialogSettings::AddEdit(unsigned int id, int label, CStdString *str, bool enabled)
+{
+  SettingInfo setting;
+  setting.id = id;
+  setting.name = g_localizeStrings.Get(label);
+  setting.type = SettingInfo::EDIT;
+  setting.enabled  = enabled;
+  setting.data = str;
+  m_settings.push_back(setting);
+}
+
+void CGUIDialogSettings::AddNumEdit(unsigned int id, int label, int *current, bool enabled)
+{
+  SettingInfo setting;
+  setting.id = id;
+  setting.name = g_localizeStrings.Get(label);
+  setting.type = SettingInfo::EDIT_NUM;
+  setting.enabled  = enabled;
+  setting.data = current;
+  m_settings.push_back(setting);
+}
+
 void CGUIDialogSettings::AddButton(unsigned int id, int label, float *current, float min, float interval, float max, FORMATFUNCTION function)
@@ -376,2 +475,13 @@ void CGUIDialogSettings::AddButton(unsigned int id, int label, float *current, f
 
+void CGUIDialogSettings::AddButton(unsigned int id, int label, CStdString *str, bool bOn)
+{
+  SettingInfo setting;
+  setting.id = id;
+  setting.name = g_localizeStrings.Get(label);
+  setting.type = SettingInfo::BUTTON_DIALOG;
+  setting.enabled  = bOn;
+  setting.data = str;
+  m_settings.push_back(setting);
+}
+
 void CGUIDialogSettings::AddString(unsigned int id, int label, CStdString *current)
@@ -398,2 +508,14 @@ void CGUIDialogSettings::AddBool(unsigned int id, int label, bool *on, bool enab
 
+void CGUIDialogSettings::AddSpin(unsigned int id, int label, int *current, unsigned int max, const SETTINGSTRINGS &entries)
+{
+  SettingInfo setting;
+  setting.id = id;
+  setting.name = g_localizeStrings.Get(label);
+  setting.type = SettingInfo::SPIN;
+  setting.data = current;
+  for (unsigned int i = 0; i < max; i++)
+    setting.entry.push_back(make_pair(i, entries[i]));
+  m_settings.push_back(setting);
+}
+
 void CGUIDialogSettings::AddSpin(unsigned int id, int label, int *current, unsigned int max, const int *entries)
diff --git a/xbmc/settings/GUISettings.cpp b/xbmc/settings/GUISettings.cpp
index 41cce36..8edd76c 100644
--- a/xbmc/settings/GUISettings.cpp
+++ b/xbmc/settings/GUISettings.cpp
@@ -49,2 +49,3 @@
 #include "LangInfo.h"
+#include "pvr/PVRManager.h"
 #include "utils/XMLUtils.h"
@@ -57,4 +58,7 @@ using namespace std;
 using namespace ADDON;
+using namespace PVR;
 
 // String id's of the masks
+#define MASK_DAYS   17999
+#define MASK_HOURS  17998
 #define MASK_MINS   14044
@@ -64,2 +68,3 @@ using namespace ADDON;
 #define MASK_KBPS   14048
+#define MASK_MB    17997
 #define MASK_KB    14049
@@ -235,2 +240,12 @@ void CSettingsGroup::GetCategories(vecSettingsCategory &vecCategories)
 
+#define SETTINGS_PICTURES     WINDOW_SETTINGS_MYPICTURES - WINDOW_SETTINGS_START
+#define SETTINGS_PROGRAMS     WINDOW_SETTINGS_MYPROGRAMS - WINDOW_SETTINGS_START
+#define SETTINGS_WEATHER      WINDOW_SETTINGS_MYWEATHER - WINDOW_SETTINGS_START
+#define SETTINGS_MUSIC        WINDOW_SETTINGS_MYMUSIC - WINDOW_SETTINGS_START
+#define SETTINGS_SYSTEM       WINDOW_SETTINGS_SYSTEM - WINDOW_SETTINGS_START
+#define SETTINGS_VIDEOS       WINDOW_SETTINGS_MYVIDEOS - WINDOW_SETTINGS_START
+#define SETTINGS_SERVICE      WINDOW_SETTINGS_SERVICE - WINDOW_SETTINGS_START
+#define SETTINGS_APPEARANCE   WINDOW_SETTINGS_APPEARANCE - WINDOW_SETTINGS_START
+#define SETTINGS_PVR          WINDOW_SETTINGS_MYPVR - WINDOW_SETTINGS_START
+
 // Settings are case sensitive
@@ -245,4 +260,4 @@ void CGUISettings::Initialize()
   // Pictures settings
-  AddGroup(0, 1);
-  CSettingsCategory* pic = AddCategory(0, "pictures", 14081);
+  AddGroup(SETTINGS_PICTURES, 1);
+  CSettingsCategory* pic = AddCategory(SETTINGS_PICTURES, "pictures", 14081);
   AddBool(pic, "pictures.usetags", 14082, true);
@@ -254,3 +269,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* cat = AddCategory(0, "slideshow", 108);
+  CSettingsCategory* cat = AddCategory(SETTINGS_PICTURES, "slideshow", 108);
   AddInt(cat, "slideshow.staytime", 12378, 5, 1, 1, 100, SPIN_CONTROL_INT_PLUS, MASK_SECS);
@@ -263,4 +278,4 @@ void CGUISettings::Initialize()
   // My Weather settings
-  AddGroup(2, 8);
-  CSettingsCategory* wea = AddCategory(2, "weather", 16000);
+  AddGroup(SETTINGS_WEATHER, 8);
+  CSettingsCategory* wea = AddCategory(SETTINGS_WEATHER, "weather", 16000);
   AddInt(NULL, "weather.currentlocation", 0, 1, 1, 1, 3, SPIN_CONTROL_INT_PLUS);
@@ -270,4 +285,4 @@ void CGUISettings::Initialize()
   // My Music Settings
-  AddGroup(3, 2);
-  CSettingsCategory* ml = AddCategory(3,"musiclibrary",14022);
+  AddGroup(SETTINGS_MUSIC, 2);
+  CSettingsCategory* ml = AddCategory(SETTINGS_MUSIC,"musiclibrary",14022);
   AddBool(NULL, "musiclibrary.enabled", 418, true);
@@ -285,3 +300,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* mp = AddCategory(3, "musicplayer", 14086);
+  CSettingsCategory* mp = AddCategory(SETTINGS_MUSIC, "musicplayer", 14086);
   AddBool(mp, "musicplayer.autoplaynextitem", 489, true);
@@ -304,3 +319,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* mf = AddCategory(3, "musicfiles", 14081);
+  CSettingsCategory* mf = AddCategory(SETTINGS_MUSIC, "musicfiles", 14081);
   AddBool(mf, "musicfiles.usetags", 258, true);
@@ -315,3 +330,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* scr = AddCategory(3, "scrobbler", 15221);
+  CSettingsCategory* scr = AddCategory(SETTINGS_MUSIC, "scrobbler", 15221);
   AddBool(scr, "scrobbler.lastfmsubmit", 15201, false);
@@ -325,3 +340,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* acd = AddCategory(3, "audiocds", 620);
+  CSettingsCategory* acd = AddCategory(SETTINGS_MUSIC, "audiocds", 620);
   map<int,int> autocd;
@@ -359,3 +374,3 @@ void CGUISettings::Initialize()
 #ifdef HAS_KARAOKE
-  CSettingsCategory* kar = AddCategory(3, "karaoke", 13327);
+  CSettingsCategory* kar = AddCategory(SETTINGS_MUSIC, "karaoke", 13327);
   AddBool(kar, "karaoke.enabled", 13323, false);
@@ -377,4 +392,4 @@ void CGUISettings::Initialize()
   // System settings
-  AddGroup(4, 13000);
-  CSettingsCategory* vs = AddCategory(4, "videoscreen", 21373);
+  AddGroup(SETTINGS_SYSTEM, 13000);
+  CSettingsCategory* vs = AddCategory(SETTINGS_SYSTEM, "videoscreen", 21373);
 
@@ -441,3 +456,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* ao = AddCategory(4, "audiooutput", 772);
+  CSettingsCategory* ao = AddCategory(SETTINGS_SYSTEM, "audiooutput", 772);
 
@@ -499,3 +514,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* in = AddCategory(4, "input", 14094);
+  CSettingsCategory* in = AddCategory(SETTINGS_SYSTEM, "input", 14094);
   AddString(in, "input.peripherals", 35000, "", BUTTON_CONTROL_STANDARD);
@@ -526,3 +541,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* net = AddCategory(4, "network", 798);
+  CSettingsCategory* net = AddCategory(SETTINGS_SYSTEM, "network", 798);
   if (g_application.IsStandAlone())
@@ -564,3 +579,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* pwm = AddCategory(4, "powermanagement", 14095);
+  CSettingsCategory* pwm = AddCategory(SETTINGS_SYSTEM, "powermanagement", 14095);
   // Note: Application.cpp might hide powersaving settings if not supported.
@@ -589,3 +604,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* dbg = AddCategory(4, "debug", 14092);
+  CSettingsCategory* dbg = AddCategory(SETTINGS_SYSTEM, "debug", 14092);
   AddBool(dbg, "debug.showloginfo", 20191, false);
@@ -593,3 +608,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* mst = AddCategory(4, "masterlock", 12360);
+  CSettingsCategory* mst = AddCategory(SETTINGS_SYSTEM, "masterlock", 12360);
   AddString(mst, "masterlock.lockcode"       , 20100, "-", BUTTON_CONTROL_STANDARD);
@@ -599,3 +614,3 @@ void CGUISettings::Initialize()
 
-  AddCategory(4, "cache", 439);
+  AddCategory(SETTINGS_SYSTEM, "cache", 439);
   AddInt(NULL, "cache.harddisk", 14025, 256, 0, 256, 4096, SPIN_CONTROL_INT_PLUS, MASK_KB, TEXT_OFF);
@@ -616,4 +631,4 @@ void CGUISettings::Initialize()
   // video settings
-  AddGroup(5, 3);
-  CSettingsCategory* vdl = AddCategory(5, "videolibrary", 14022);
+  AddGroup(SETTINGS_VIDEOS, 3);
+  CSettingsCategory* vdl = AddCategory(SETTINGS_VIDEOS, "videolibrary", 14022);
   AddBool(NULL, "videolibrary.enabled", 418, true);
@@ -637,3 +652,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* vp = AddCategory(5, "videoplayer", 14086);
+  CSettingsCategory* vp = AddCategory(SETTINGS_VIDEOS, "videoplayer", 14086);
 
@@ -742,3 +757,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* vid = AddCategory(5, "myvideos", 14081);
+  CSettingsCategory* vid = AddCategory(SETTINGS_VIDEOS, "myvideos", 14081);
 
@@ -755,3 +770,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* sub = AddCategory(5, "subtitles", 287);
+  CSettingsCategory* sub = AddCategory(SETTINGS_VIDEOS, "subtitles", 287);
   AddString(sub, "subtitles.font", 14089, "arial.ttf", SPIN_CONTROL_TEXT);
@@ -780,3 +795,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* dvd = AddCategory(5, "dvds", 14087);
+  CSettingsCategory* dvd = AddCategory(SETTINGS_VIDEOS, "dvds", 14087);
   AddBool(dvd, "dvds.autorun", 14088, false);
@@ -790,8 +805,8 @@ void CGUISettings::Initialize()
   // service settings
-  AddGroup(6, 14036);
+  AddGroup(SETTINGS_SERVICE, 14036);
 
-  CSettingsCategory* srvGeneral = AddCategory(6, "general", 16000);
+  CSettingsCategory* srvGeneral = AddCategory(SETTINGS_SERVICE, "general", 16000);
   AddString(srvGeneral,"services.devicename", 1271, "XBMC", EDIT_CONTROL_INPUT);
 
-  CSettingsCategory* srvUpnp = AddCategory(6, "upnp", 20187);
+  CSettingsCategory* srvUpnp = AddCategory(SETTINGS_SERVICE, "upnp", 20187);
   AddBool(srvUpnp, "services.upnpserver", 21360, false);
@@ -800,3 +815,3 @@ void CGUISettings::Initialize()
 #ifdef HAS_WEB_SERVER
-  CSettingsCategory* srvWeb = AddCategory(6, "webserver", 33101);
+  CSettingsCategory* srvWeb = AddCategory(SETTINGS_SERVICE, "webserver", 33101);
   AddBool(srvWeb,  "services.webserver",        263, false);
@@ -808,3 +823,3 @@ void CGUISettings::Initialize()
 #ifdef HAS_EVENT_SERVER
-  CSettingsCategory* srvEvent = AddCategory(6, "remotecontrol", 790);
+  CSettingsCategory* srvEvent = AddCategory(SETTINGS_SERVICE, "remotecontrol", 790);
   AddBool(srvEvent,  "services.esenabled",         791, true);
@@ -818,3 +833,3 @@ void CGUISettings::Initialize()
 #ifdef HAS_ZEROCONF
-  CSettingsCategory* srvZeroconf = AddCategory(6, "zeroconf", 1259);
+  CSettingsCategory* srvZeroconf = AddCategory(SETTINGS_SERVICE, "zeroconf", 1259);
 #ifdef TARGET_WINDOWS
@@ -827,3 +842,3 @@ void CGUISettings::Initialize()
 #ifdef HAS_AIRPLAY
-  CSettingsCategory* srvAirplay = AddCategory(6, "airplay", 1273);
+  CSettingsCategory* srvAirplay = AddCategory(SETTINGS_SERVICE, "airplay", 1273);
   AddBool(srvAirplay, "services.airplay", 1270, false);
@@ -834,3 +849,3 @@ void CGUISettings::Initialize()
 #ifndef _WIN32
-  CSettingsCategory* srvSmb = AddCategory(6, "smb", 1200);
+  CSettingsCategory* srvSmb = AddCategory(SETTINGS_SERVICE, "smb", 1200);
   AddString(srvSmb, "smb.winsserver",  1207,   "",  EDIT_CONTROL_IP_INPUT);
@@ -840,4 +855,4 @@ void CGUISettings::Initialize()
   // appearance settings
-  AddGroup(7, 480);
-  CSettingsCategory* laf = AddCategory(7,"lookandfeel", 166);
+  AddGroup(SETTINGS_APPEARANCE, 480);
+  CSettingsCategory* laf = AddCategory(SETTINGS_APPEARANCE,"lookandfeel", 166);
   AddDefaultAddon(laf, "lookandfeel.skin",166,DEFAULT_SKIN, ADDON_SKIN);
@@ -853,3 +868,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* loc = AddCategory(7, "locale", 14090);
+  CSettingsCategory* loc = AddCategory(SETTINGS_APPEARANCE, "locale", 14090);
   AddString(loc, "locale.language",248,"english", SPIN_CONTROL_TEXT);
@@ -884,3 +899,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* fl = AddCategory(7, "filelists", 14081);
+  CSettingsCategory* fl = AddCategory(SETTINGS_APPEARANCE, "filelists", 14081);
   AddBool(fl, "filelists.showparentdiritems", 13306, true);
@@ -892,3 +907,3 @@ void CGUISettings::Initialize()
 
-  CSettingsCategory* ss = AddCategory(7, "screensaver", 360);
+  CSettingsCategory* ss = AddCategory(SETTINGS_APPEARANCE, "screensaver", 360);
   AddInt(ss, "screensaver.time", 355, 3, 1, 1, 60, SPIN_CONTROL_INT_PLUS, MASK_MINS);
@@ -901,3 +916,3 @@ void CGUISettings::Initialize()
 
-  AddCategory(7, "window", 0);
+  AddCategory(SETTINGS_APPEARANCE, "window", 0);
   AddInt(NULL, "window.width",  0, 720, 10, 1, INT_MAX, SPIN_CONTROL_INT);
@@ -907,4 +922,70 @@ void CGUISettings::Initialize()
 
-  // PVR-related setting typically used by skins that are aimed at PVR and non-PVR builds
-  AddBool(NULL, "pvrmanager.enabled", 449, false);
+  // tv settings (access over TV menu from home window)
+  AddGroup(SETTINGS_PVR, 19180);
+  CSettingsCategory* pvr = AddCategory(SETTINGS_PVR, "pvrmanager", 128);
+  AddBool(pvr, "pvrmanager.enabled", 449, false);
+  AddSeparator(pvr, "pvrmanager.sep1");
+  AddBool(pvr, "pvrmanager.syncchannelgroups", 19221, true);
+  AddBool(pvr, "pvrmanager.backendchannelorder", 19231, false);
+  AddBool(pvr, "pvrmanager.usebackendchannelnumbers", 19234, false);
+  AddSeparator(pvr, "pvrmanager.sep2");
+  AddString(pvr, "pvrmanager.channelmanager", 19199, "", BUTTON_CONTROL_STANDARD);
+  AddString(pvr, "pvrmanager.channelscan", 19117, "", BUTTON_CONTROL_STANDARD);
+  AddString(pvr, "pvrmanager.resetdb", 19185, "", BUTTON_CONTROL_STANDARD);
+  AddSeparator(pvr, "pvrmanager.sep3");
+  AddBool(pvr, "pvrmanager.hideconnectionlostwarning", 19269, false);
+
+  CSettingsCategory* pvrm = AddCategory(SETTINGS_PVR, "pvrmenu", 19181);
+  AddBool(pvrm, "pvrmenu.infoswitch", 19178, true);
+  AddBool(pvrm, "pvrmenu.infotimeout", 19179, true);
+  AddBool(pvrm, "pvrmenu.closechannelosdonswitch", 19229, false);
+  AddInt(pvrm, "pvrmenu.infotime", 19184, 5, 1, 1, 10, SPIN_CONTROL_INT_PLUS, MASK_SECS);
+  AddBool(pvrm, "pvrmenu.hidevideolength", 19169, true);
+  AddSeparator(pvrm, "pvrmenu.sep1");
+  AddString(pvrm, "pvrmenu.iconpath", 19018, "", BUTTON_CONTROL_PATH_INPUT, false, 657);
+  AddString(pvrm, "pvrmenu.searchicons", 19167, "", BUTTON_CONTROL_STANDARD);
+
+  CSettingsCategory* pvre = AddCategory(SETTINGS_PVR, "epg", 19069);
+  AddInt(pvre, "epg.defaultguideview", 19065, GUIDE_VIEW_NOW, GUIDE_VIEW_CHANNEL, 1, GUIDE_VIEW_TIMELINE, SPIN_CONTROL_TEXT);
+  AddInt(pvre, "epg.daystodisplay", 19182, 2, 1, 1, 14, SPIN_CONTROL_INT_PLUS, MASK_DAYS);
+  AddSeparator(pvre, "epg.sep1");
+  AddInt(pvre, "epg.epgupdate", 19071, 120, 15, 15, 480, SPIN_CONTROL_INT_PLUS, MASK_MINS);
+  AddBool(pvre, "epg.preventupdateswhileplayingtv", 19230, false);
+  AddBool(pvre, "epg.ignoredbforclient", 19072, false);
+  AddBool(pvre, "epg.hidenoinfoavailable", 19268, true);
+  AddString(pvre, "epg.resetepg", 19187, "", BUTTON_CONTROL_STANDARD);
+
+  CSettingsCategory* pvrp = AddCategory(SETTINGS_PVR, "pvrplayback", 19177);
+  AddBool(pvrp, "pvrplayback.playminimized", 19171, true);
+  AddInt(pvrp, "pvrplayback.startlast", 19189, START_LAST_CHANNEL_OFF, START_LAST_CHANNEL_OFF, 1, START_LAST_CHANNEL_ON, SPIN_CONTROL_TEXT);
+  AddBool(pvrp, "pvrplayback.switchautoclose", 19168, true);
+  AddBool(pvrp, "pvrplayback.signalquality", 19037, true);
+  AddSeparator(pvrp, "pvrplayback.sep1");
+  AddInt(pvrp, "pvrplayback.scantime", 19170, 15, 1, 1, 60, SPIN_CONTROL_INT_PLUS, MASK_SECS);
+  AddInt(pvrp, "pvrplayback.channelentrytimeout", 19073, 0, 0, 250, 2000, SPIN_CONTROL_INT_PLUS, MASK_MS);
+
+  CSettingsCategory* pvrr = AddCategory(SETTINGS_PVR, "pvrrecord", 19043);
+  AddInt(pvrr, "pvrrecord.instantrecordtime", 19172, 180, 1, 1, 720, SPIN_CONTROL_INT_PLUS, MASK_MINS);
+  AddInt(pvrr, "pvrrecord.defaultpriority", 19173, 50, 1, 1, 100, SPIN_CONTROL_INT_PLUS);
+  AddInt(pvrr, "pvrrecord.defaultlifetime", 19174, 99, 1, 1, 365, SPIN_CONTROL_INT_PLUS, MASK_DAYS);
+  AddInt(pvrr, "pvrrecord.marginstart", 19175, 2, 0, 1, 60, SPIN_CONTROL_INT_PLUS, MASK_MINS);
+  AddInt(pvrr, "pvrrecord.marginend", 19176, 10, 0, 1, 60, SPIN_CONTROL_INT_PLUS, MASK_MINS);
+  AddSeparator(pvrr, "pvrrecord.sep1");
+  AddBool(pvrr, "pvrrecord.timernotifications", 19233, true);
+
+  CSettingsCategory* pvrpwr = AddCategory(SETTINGS_PVR, "pvrpowermanagement", 14095);
+  AddBool(pvrpwr, "pvrpowermanagement.enabled", 305, false);
+  AddSeparator(pvrpwr, "pvrpowermanagement.sep1");
+  AddInt(pvrpwr, "pvrpowermanagement.backendidletime", 19244, 15, 0, 5, 360, SPIN_CONTROL_INT_PLUS, MASK_MINS, TEXT_OFF);
+  AddString(pvrpwr, "pvrpowermanagement.setwakeupcmd", 19245, "/usr/bin/setwakeup.sh", EDIT_CONTROL_INPUT, true);
+  AddInt(pvrpwr, "pvrpowermanagement.prewakeup", 19246, 15, 0, 1, 60, SPIN_CONTROL_INT_PLUS, MASK_MINS, TEXT_OFF);
+  AddSeparator(pvrpwr, "pvrpowermanagement.sep2");
+  AddBool(pvrpwr, "pvrpowermanagement.dailywakeup", 19247, false);
+  AddString(pvrpwr, "pvrpowermanagement.dailywakeuptime", 19248, "00:00:00", EDIT_CONTROL_INPUT);
+
+  CSettingsCategory* pvrpa = AddCategory(SETTINGS_PVR, "pvrparental", 19259);
+  AddBool(pvrpa, "pvrparental.enabled", 449  , false);
+  AddSeparator(pvrpa, "pvrparental.sep1");
+  AddString(pvrpa, "pvrparental.pin", 19261, "", EDIT_CONTROL_HIDDEN_NUMBER_VERIFY_NEW, true);
+  AddInt(pvrpa, "pvrparental.duration", 19260, 300, 5, 5, 1200, SPIN_CONTROL_INT_PLUS, MASK_SECS);
 }
@@ -997,2 +1078,5 @@ void CGUISettings::SetBool(const char *strSetting, bool bSetting)
     ((CSettingBool*)(*it).second)->SetData(bSetting);
+
+    SetChanged();
+
     return ;
@@ -1010,2 +1094,5 @@ void CGUISettings::ToggleBool(const char *strSetting)
     ((CSettingBool*)(*it).second)->SetData(!((CSettingBool *)(*it).second)->GetData());
+
+    SetChanged();
+
     return ;
@@ -1045,2 +1132,5 @@ void CGUISettings::SetFloat(const char *strSetting, float fSetting)
     ((CSettingFloat *)(*it).second)->SetData(fSetting);
+
+    SetChanged();
+
     return ;
@@ -1116,2 +1206,5 @@ void CGUISettings::SetInt(const char *strSetting, int iSetting)
     ((CSettingInt *)(*it).second)->SetData(iSetting);
+
+    SetChanged();
+
     return ;
@@ -1187,2 +1280,5 @@ void CGUISettings::SetString(const char *strSetting, const char *strData)
     ((CSettingString *)(*it).second)->SetData(strData);
+
+    SetChanged();
+
     return ;
@@ -1329,2 +1425,4 @@ void CGUISettings::LoadFromXML(TiXmlElement *pRootElement, mapIter &it, bool adv
   }
+
+  SetChanged();
 }
@@ -1365,2 +1463,4 @@ void CGUISettings::SaveXML(TiXmlNode *pRootNode)
   }
+
+  SetChanged();
 }
@@ -1375,2 +1475,4 @@ void CGUISettings::Clear()
   settingsGroups.clear();
+
+  SetChanged();
 }
@@ -1441,2 +1543,4 @@ void CGUISettings::SetResolution(RESOLUTION res)
   m_LookAndFeelResolution = res;
+
+  SetChanged();
 }
@@ -1472,2 +1576,3 @@ bool CGUISettings::SetLanguage(const CStdString &strLanguage)
     g_weatherManager.Refresh();
+    g_PVRManager.LocalizationChanged();
     g_application.ReloadSkin();
diff --git a/xbmc/settings/GUIWindowSettingsCategory.cpp b/xbmc/settings/GUIWindowSettingsCategory.cpp
index 8e84b1c..179791ed 100644
--- a/xbmc/settings/GUIWindowSettingsCategory.cpp
+++ b/xbmc/settings/GUIWindowSettingsCategory.cpp
@@ -47,2 +47,5 @@
 #include "GUIPassword.h"
+#include "GUIInfoManager.h"
+#include "dialogs/GUIDialogGamepad.h"
+#include "dialogs/GUIDialogNumeric.h"
 #include "dialogs/GUIDialogFileBrowser.h"
@@ -103,2 +106,5 @@
 #include "windowing/WindowingFactory.h"
+#include "pvr/dialogs/GUIDialogPVRChannelManager.h"
+#include "pvr/PVRManager.h"
+#include "pvr/addons/PVRClients.h"
 
@@ -119,2 +125,3 @@ using namespace XFILE;
 using namespace ADDON;
+using namespace PVR;
 using namespace PERIPHERALS;
@@ -145,3 +152,13 @@ CGUIWindowSettingsCategory::CGUIWindowSettingsCategory(void)
   // set the correct ID range...
-  m_idRange = 8;
+  m_idRange.clear();
+  m_idRange.push_back(WINDOW_SETTINGS_MYPICTURES);
+  m_idRange.push_back(WINDOW_SETTINGS_MYPROGRAMS);
+  m_idRange.push_back(WINDOW_SETTINGS_MYWEATHER);
+  m_idRange.push_back(WINDOW_SETTINGS_MYMUSIC);
+  m_idRange.push_back(WINDOW_SETTINGS_SYSTEM);
+  m_idRange.push_back(WINDOW_SETTINGS_MYVIDEOS);
+  m_idRange.push_back(WINDOW_SETTINGS_SERVICE);
+  m_idRange.push_back(WINDOW_SETTINGS_APPEARANCE);
+  m_idRange.push_back(WINDOW_SETTINGS_MYPVR);
+
   m_iScreen = 0;
@@ -199,2 +216,11 @@ bool CGUIWindowSettingsCategory::OnMessage(CGUIMessage &message)
         }
+        if (m_vecSections[focusedControl-CONTROL_START_BUTTONS]->m_strCategory == "pvrparental")
+        {
+          if (!g_PVRManager.CheckParentalPIN(g_localizeStrings.Get(19262).c_str()))
+          { // unable to go to this category - focus the previous one
+            SET_CONTROL_FOCUS(CONTROL_START_BUTTONS + m_iSection, 0);
+            return false;
+          }
+        }
+
         m_iSection = focusedControl - CONTROL_START_BUTTONS;
@@ -381,2 +407,6 @@ void CGUIWindowSettingsCategory::CreateSettings()
         FillInResolutions(strSetting, g_guiSettings.GetInt("videoscreen.screen"), g_guiSettings.GetResolution(), false);
+      else if (strSetting.Equals("epg.defaultguideview"))
+        FillInEpgGuideView(pSetting);
+      else if (strSetting.Equals("pvrplayback.startlast"))
+        FillInPvrStartLastChannel(pSetting);
       continue;
@@ -680,2 +710,18 @@ void CGUIWindowSettingsCategory::UpdateSettings()
     }
+    else if (strSetting.Equals("pvrmanager.channelscan"))
+    {
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("pvrmanager.enabled") && g_PVRClients->GetClientsSupportingChannelScan().size() > 0);
+    }
+    else if (strSetting.Equals("pvrmanager.channelmanager") || strSetting.Equals("pvrmenu.searchicons"))
+    {
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("pvrmanager.enabled"));
+    }
+    else if (!strSetting.Equals("pvrparental.enabled") &&
+        (strSetting.Equals("pvrparental.pin") || strSetting.Equals("pvrparental.duration")))
+    {
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(g_guiSettings.GetBool("pvrparental.enabled"));
+    }
     else if (!strSetting.Equals("services.esenabled")
@@ -965,2 +1011,5 @@ void CGUIWindowSettingsCategory::UpdateSettings()
   }
+
+  g_guiSettings.SetChanged();
+  g_guiSettings.NotifyObservers(ObservableMessageGuiSettings, true);
 }
@@ -1540,3 +1589,3 @@ void CGUIWindowSettingsCategory::OnSettingChanged(CBaseSettingControl *pSettingC
   }
-  else if (strSetting.Equals("debug.screenshotpath") || strSetting.Equals("audiocds.recordingpath") || strSetting.Equals("subtitles.custompath"))
+  else if (strSetting.Equals("debug.screenshotpath") || strSetting.Equals("audiocds.recordingpath") || strSetting.Equals("subtitles.custompath") || strSetting.Equals("pvrmenu.iconpath"))
   {
@@ -1548,3 +1597,7 @@ void CGUIWindowSettingsCategory::OnSettingChanged(CBaseSettingControl *pSettingC
 
-    if (strSetting.Equals("subtitles.custompath"))
+    if (strSetting.Equals("pvrmenu.iconpath"))
+    {
+      bWriteOnly = false;
+    }
+    else if (strSetting.Equals("subtitles.custompath"))
     {
@@ -1707,2 +1760,9 @@ void CGUIWindowSettingsCategory::OnSettingChanged(CBaseSettingControl *pSettingC
   }
+  else if (strSetting.Equals("pvrmanager.enabled"))
+  {
+    if (g_guiSettings.GetBool("pvrmanager.enabled"))
+      g_application.StartPVRManager();
+    else
+      g_application.StopPVRManager();
+  }
   else if (strSetting.Equals("masterlock.lockcode"))
@@ -1834,2 +1894,30 @@ void CGUIWindowSettingsCategory::OnSettingChanged(CBaseSettingControl *pSettingC
   }
+  else if (strSetting.Equals("pvrmenu.searchicons") && g_PVRManager.IsStarted())
+  {
+    g_PVRManager.SearchMissingChannelIcons();
+  }
+  else if (strSetting.Equals("pvrmanager.resetdb"))
+  {
+    if (g_PVRManager.CheckParentalPIN(g_localizeStrings.Get(19262).c_str()) &&
+        CGUIDialogYesNo::ShowAndGetInput(19098, 19186, 750, 0))
+      g_PVRManager.ResetDatabase();
+  }
+  else if (strSetting.Equals("epg.resetepg"))
+  {
+    if (CGUIDialogYesNo::ShowAndGetInput(19098, 19188, 750, 0))
+      g_PVRManager.ResetEPG();
+  }
+  else if (strSetting.Equals("pvrmanager.channelscan") && g_PVRManager.IsStarted())
+  {
+    if (CGUIDialogYesNo::ShowAndGetInput(19098, 19118, 19194, 0))
+      g_PVRManager.StartChannelScan();
+  }
+  else if (strSetting.Equals("pvrmanager.channelmanager") && g_PVRManager.IsStarted())
+  {
+    CGUIDialogPVRChannelManager *dialog = (CGUIDialogPVRChannelManager *)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_CHANNEL_MANAGER);
+    if (dialog)
+    {
+       dialog->DoModal();
+    }
+  }
   else if (strSetting.compare(0, 12, "audiooutput.") == 0)
@@ -1855,2 +1943,20 @@ void CGUIWindowSettingsCategory::OnSettingChanged(CBaseSettingControl *pSettingC
   }
+  else if (strSetting.Equals("pvrparental.enabled"))
+  {
+    if (g_guiSettings.GetBool("pvrparental.enabled") && g_guiSettings.GetString("pvrparental.pin").GetLength() == 0)
+    {
+      CStdString newPassword = "";
+      bool bNewPassword = CGUIDialogNumeric::ShowAndVerifyNewPassword(newPassword);
+      if (bNewPassword)
+      {
+        // password set... save it
+        g_guiSettings.SetString("pvrparental.pin", newPassword);
+      }
+      else
+      {
+        // password not set... disable parental
+        g_guiSettings.SetBool("pvrparental.enabled", false);
+      }
+    }
+  }
 
@@ -1921,3 +2027,4 @@ CGUIControl* CGUIWindowSettingsCategory::AddSetting(CSetting *pSetting, float wi
            pSetting->GetControlType() == EDIT_CONTROL_NUMBER_INPUT ||
-           pSetting->GetControlType() == EDIT_CONTROL_IP_INPUT)
+           pSetting->GetControlType() == EDIT_CONTROL_IP_INPUT ||
+           pSetting->GetControlType() == EDIT_CONTROL_HIDDEN_NUMBER_VERIFY_NEW )
   {
@@ -2683,2 +2790,29 @@ void CGUIWindowSettingsCategory::FillInNetworkInterfaces(CSetting *pSetting, flo
 
+void CGUIWindowSettingsCategory::FillInEpgGuideView(CSetting *pSetting)
+{
+  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
+  pControl->Clear();
+
+  pControl->AddLabel(g_localizeStrings.Get(19029), GUIDE_VIEW_CHANNEL);
+  pControl->AddLabel(g_localizeStrings.Get(19030), GUIDE_VIEW_NOW);
+  pControl->AddLabel(g_localizeStrings.Get(19031), GUIDE_VIEW_NEXT);
+  pControl->AddLabel(g_localizeStrings.Get(19032), GUIDE_VIEW_TIMELINE);
+
+  pControl->SetValue(pSettingInt->GetData());
+}
+
+void CGUIWindowSettingsCategory::FillInPvrStartLastChannel(CSetting *pSetting)
+{
+  CSettingInt *pSettingInt = (CSettingInt*)pSetting;
+  CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
+  pControl->Clear();
+
+  pControl->AddLabel(g_localizeStrings.Get(106),   START_LAST_CHANNEL_OFF);
+  pControl->AddLabel(g_localizeStrings.Get(19190), START_LAST_CHANNEL_MIN);
+  pControl->AddLabel(g_localizeStrings.Get(107),   START_LAST_CHANNEL_ON);
+
+  pControl->SetValue(pSettingInt->GetData());
+}
+
 void CGUIWindowSettingsCategory::FillInAudioDevices(CSetting* pSetting, bool Passthrough)
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 3d6b19d..a8837c5 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -107,2 +107,4 @@ void CSettings::Initialize()
   m_musicExtensions += "|.sidstream|.oggstream|.nsfstream|.asapstream|.cdda";
+  // internal video extensions
+  m_videoExtensions += "|.pvr";
 
diff --git a/xbmc/settings/SettingsControls.cpp b/xbmc/settings/SettingsControls.cpp
index 760d8a7..fb44ca1 100644
--- a/xbmc/settings/SettingsControls.cpp
+++ b/xbmc/settings/SettingsControls.cpp
@@ -196,2 +196,4 @@ CEditSettingControl::CEditSettingControl(CGUIEditControl *pEdit, int id, CSettin
     m_pEdit->SetInputType(CGUIEditControl::INPUT_TYPE_NUMBER, heading);
+  else if (pSetting->GetControlType() == EDIT_CONTROL_HIDDEN_NUMBER_VERIFY_NEW)
+    m_pEdit->SetInputType(CGUIEditControl::INPUT_TYPE_PASSWORD_NUMBER_VERIFY_NEW, heading);
   else
diff --git a/xbmc/utils/Observer.cpp b/xbmc/utils/Observer.cpp
new file mode 100644
index 0000000..4903e0e
--- /dev/null
+++ b/xbmc/utils/Observer.cpp
@@ -0,0 +1,200 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "Application.h"
+#include "Observer.h"
+#include "threads/SingleLock.h"
+#include "utils/JobManager.h"
+
+using namespace std;
+using namespace ANNOUNCEMENT;
+
+class ObservableMessageJob : public CJob
+{
+private:
+  Observable        m_observable;
+  ObservableMessage m_message;
+public:
+  ObservableMessageJob(const Observable &obs, const ObservableMessage message);
+  virtual ~ObservableMessageJob() {}
+  virtual const char *GetType() const { return "observable-message-job"; }
+
+  virtual bool DoWork();
+};
+
+Observer::~Observer(void)
+{
+  StopObserving();
+}
+
+void Observer::StopObserving(void)
+{
+  CSingleLock lock(m_obsCritSection);
+  for (unsigned int iObsPtr = 0; iObsPtr < m_observables.size(); iObsPtr++)
+    m_observables.at(iObsPtr)->UnregisterObserver(this);
+  m_observables.clear();
+}
+
+bool Observer::IsObserving(const Observable &obs) const
+{
+  CSingleLock lock(m_obsCritSection);
+  return find(m_observables.begin(), m_observables.end(), &obs) != m_observables.end();
+}
+
+void Observer::RegisterObservable(Observable *obs)
+{
+  CSingleLock lock(m_obsCritSection);
+  if (!IsObserving(*obs))
+    m_observables.push_back(obs);
+}
+
+void Observer::UnregisterObservable(Observable *obs)
+{
+  CSingleLock lock(m_obsCritSection);
+  vector<Observable *>::iterator it = find(m_observables.begin(), m_observables.end(), obs);
+  if (it != m_observables.end())
+    m_observables.erase(it);
+}
+
+Observable::Observable() :
+    m_bObservableChanged(false),
+    m_bAsyncAllowed(true)
+{
+  CAnnouncementManager::AddAnnouncer(this);
+}
+
+Observable::~Observable()
+{
+  CAnnouncementManager::RemoveAnnouncer(this);
+  StopObserver();
+}
+
+Observable &Observable::operator=(const Observable &observable)
+{
+  CSingleLock lock(m_obsCritSection);
+
+  m_bObservableChanged = observable.m_bObservableChanged;
+  m_observers.clear();
+  for (unsigned int iObsPtr = 0; iObsPtr < observable.m_observers.size(); iObsPtr++)
+    m_observers.push_back(observable.m_observers.at(iObsPtr));
+
+  return *this;
+}
+
+void Observable::StopObserver(void)
+{
+  CSingleLock lock(m_obsCritSection);
+  for (unsigned int iObsPtr = 0; iObsPtr < m_observers.size(); iObsPtr++)
+    m_observers.at(iObsPtr)->UnregisterObservable(this);
+  m_observers.clear();
+}
+
+bool Observable::IsObserving(const Observer &obs) const
+{
+  CSingleLock lock(m_obsCritSection);
+  return find(m_observers.begin(), m_observers.end(), &obs) != m_observers.end();
+}
+
+void Observable::RegisterObserver(Observer *obs)
+{
+  CSingleLock lock(m_obsCritSection);
+  if (!IsObserving(*obs))
+  {
+    m_observers.push_back(obs);
+    obs->RegisterObservable(this);
+  }
+}
+
+void Observable::UnregisterObserver(Observer *obs)
+{
+  CSingleLock lock(m_obsCritSection);
+  vector<Observer *>::iterator it = find(m_observers.begin(), m_observers.end(), obs);
+  if (it != m_observers.end())
+  {
+    obs->UnregisterObservable(this);
+    m_observers.erase(it);
+  }
+}
+
+void Observable::NotifyObservers(const ObservableMessage message /* = ObservableMessageNone */, bool bAsync /* = false */)
+{
+  bool bNotify(false);
+  {
+    CSingleLock lock(m_obsCritSection);
+    if (m_bObservableChanged && !g_application.m_bStop)
+      bNotify = true;
+    m_bObservableChanged = false;
+  }
+
+  if (bNotify)
+  {
+    if (bAsync && m_bAsyncAllowed)
+      CJobManager::GetInstance().AddJob(new ObservableMessageJob(*this, message), NULL);
+    else
+      SendMessage(*this, message);
+  }
+}
+
+void Observable::SetChanged(bool SetTo)
+{
+  CSingleLock lock(m_obsCritSection);
+  m_bObservableChanged = SetTo;
+}
+
+void Observable::Announce(AnnouncementFlag flag, const char *sender, const char *message, const CVariant &data)
+{
+  if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "ApplicationStop"))
+  {
+    CSingleLock lock(m_obsCritSection);
+    m_bAsyncAllowed = false;
+  }
+}
+
+void Observable::SendMessage(const Observable& obs, const ObservableMessage message)
+{
+  CSingleLock lock(obs.m_obsCritSection);
+  for(int ptr = obs.m_observers.size() - 1; ptr >= 0; ptr--)
+  {
+    if (ptr < obs.m_observers.size())
+    {
+      Observer *observer = obs.m_observers.at(ptr);
+      if (observer)
+      {
+        lock.Leave();
+        observer->Notify(obs, message);
+        lock.Enter();
+      }
+    }
+  }
+}
+
+ObservableMessageJob::ObservableMessageJob(const Observable &obs, const ObservableMessage message)
+{
+  m_message = message;
+  m_observable = obs;
+}
+
+bool ObservableMessageJob::DoWork()
+{
+  Observable::SendMessage(m_observable, m_message);
+
+  return true;
+}
diff --git a/xbmc/utils/SortUtils.cpp b/xbmc/utils/SortUtils.cpp
index ec5e152..59db0b3 100644
--- a/xbmc/utils/SortUtils.cpp
+++ b/xbmc/utils/SortUtils.cpp
@@ -401,2 +401,7 @@ string ByRandom(SortAttribute attributes, const SortItem &values)
 
+string ByChannel(SortAttribute attributes, const SortItem &values)
+{
+  return values.at(FieldChannelName).asString();
+}
+
 bool preliminarySort(const SortItem &left, const SortItem &right, bool handleFolder, bool &result, std::wstring &labelLeft, std::wstring &labelRight)
@@ -555,2 +560,3 @@ map<SortBy, SortUtils::SortPreparator> fillPreparators()
   preparators[SortByRandom]                   = ByRandom;
+  preparators[SortByChannel]                  = ByChannel;
 
@@ -621,2 +627,3 @@ map<SortBy, Fields> fillSortingFields()
   sortingFields[SortByBitrate].insert(FieldBitrate);
+  sortingFields[SortByChannel].insert(FieldChannelName);
   sortingFields.insert(pair<SortBy, Fields>(SortByRandom, Fields()));
diff --git a/xbmc/utils/TextSearch.cpp b/xbmc/utils/TextSearch.cpp
new file mode 100644
index 0000000..6477ab5
--- /dev/null
+++ b/xbmc/utils/TextSearch.cpp
@@ -0,0 +1,166 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "TextSearch.h"
+
+using namespace std;
+
+CTextSearch::CTextSearch(const CStdString &strSearchTerms, bool bCaseSensitive /* = false */, TextSearchDefault defaultSearchMode /* = SEARCH_DEFAULT_OR */)
+{
+  m_bCaseSensitive = bCaseSensitive;
+  ExtractSearchTerms(strSearchTerms, defaultSearchMode);
+}
+
+CTextSearch::~CTextSearch(void)
+{
+  m_AND.clear();
+  m_OR.clear();
+  m_NOT.clear();
+}
+
+bool CTextSearch::IsValid(void) const
+{
+  return m_AND.size() > 0 || m_OR.size() > 0 || m_NOT.size() > 0;
+}
+
+bool CTextSearch::Search(const CStdString &strHaystack) const
+{
+  if (strHaystack.IsEmpty() || !IsValid())
+    return false;
+
+  CStdString strSearch(strHaystack);
+  if (!m_bCaseSensitive)
+    strSearch = strSearch.ToLower();
+
+  /* check whether any of the NOT terms matches and return false if there's a match */
+  for (unsigned int iNotPtr = 0; iNotPtr < m_NOT.size(); iNotPtr++)
+  {
+    if (strSearch.Find(m_NOT.at(iNotPtr)) != -1)
+      return false;
+  }
+
+  /* check whether at least one of the OR terms matches and return false if there's no match found */
+  bool bFound(m_OR.size() == 0);
+  for (unsigned int iOrPtr = 0; iOrPtr < m_OR.size(); iOrPtr++)
+  {
+    if (strSearch.Find(m_OR.at(iOrPtr)) != -1)
+    {
+      bFound = true;
+      break;
+    }
+  }
+  if (!bFound)
+    return false;
+
+  /* check whether all of the AND terms match and return false if one of them wasn't found */
+  for (unsigned int iAndPtr = 0; iAndPtr < m_AND.size(); iAndPtr++)
+  {
+    if (strSearch.Find(m_AND[iAndPtr]) == -1)
+      return false;
+  }
+
+  /* all ok, return true */
+  return true;
+}
+
+void CTextSearch::GetAndCutNextTerm(CStdString &strSearchTerm, CStdString &strNextTerm)
+{
+  CStdString strFindNext(" ");
+
+  if (strSearchTerm.Left(1).Equals("\""))
+  {
+    strSearchTerm.erase(0, 1);
+    strFindNext = "\"";
+  }
+
+  int iNextPos = strSearchTerm.Find(strFindNext);
+  if (iNextPos != -1)
+  {
+    strNextTerm = strSearchTerm.Left(iNextPos);
+    strSearchTerm.erase(0, iNextPos + 1);
+  }
+  else
+  {
+    strNextTerm = strSearchTerm;
+    strSearchTerm.clear();
+  }
+}
+
+void CTextSearch::ExtractSearchTerms(const CStdString &strSearchTerm, TextSearchDefault defaultSearchMode)
+{
+  CStdString strParsedSearchTerm(strSearchTerm);
+  strParsedSearchTerm = strParsedSearchTerm.Trim();
+
+  if (!m_bCaseSensitive)
+    strParsedSearchTerm = strParsedSearchTerm.ToLower();
+
+  bool bNextAND(defaultSearchMode == SEARCH_DEFAULT_AND);
+  bool bNextOR(defaultSearchMode == SEARCH_DEFAULT_OR);
+  bool bNextNOT(defaultSearchMode == SEARCH_DEFAULT_NOT);
+
+  while (strParsedSearchTerm.length() > 0)
+  {
+    strParsedSearchTerm = strParsedSearchTerm.TrimLeft();
+
+    if (strParsedSearchTerm.Left(1).Equals("!") || strParsedSearchTerm.Left(3).Equals("NOT"))
+    {
+      CStdString strDummy;
+      GetAndCutNextTerm(strParsedSearchTerm, strDummy);
+      bNextNOT = true;
+    }
+    else if (strParsedSearchTerm.Left(1).Equals("+") || strParsedSearchTerm.Left(3).Equals("AND"))
+    {
+      CStdString strDummy;
+      GetAndCutNextTerm(strParsedSearchTerm, strDummy);
+      bNextAND = true;
+    }
+    else if (strParsedSearchTerm.Left(1).Equals("|") || strParsedSearchTerm.Left(2).Equals("OR"))
+    {
+      CStdString strDummy;
+      GetAndCutNextTerm(strParsedSearchTerm, strDummy);
+      bNextOR = true;
+    }
+    else
+    {
+      CStdString strTerm;
+      GetAndCutNextTerm(strParsedSearchTerm, strTerm);
+      if (strTerm.length() > 0)
+      {
+        if (bNextAND)
+          m_AND.push_back(strTerm);
+        else if (bNextOR)
+          m_OR.push_back(strTerm);
+        else
+          m_NOT.push_back(strTerm);
+      }
+      else
+      {
+        break;
+      }
+
+      bNextAND = (defaultSearchMode == SEARCH_DEFAULT_AND);
+      bNextOR  = (defaultSearchMode == SEARCH_DEFAULT_OR);
+      bNextNOT = (defaultSearchMode == SEARCH_DEFAULT_NOT);
+    }
+
+    strParsedSearchTerm = strParsedSearchTerm.TrimLeft();
+  }
+}
diff --git a/xbmc/utils/URIUtils.cpp b/xbmc/utils/URIUtils.cpp
index 376d2d7..eeb2fc5 100644
--- a/xbmc/utils/URIUtils.cpp
+++ b/xbmc/utils/URIUtils.cpp
@@ -759,2 +759,5 @@ bool URIUtils::IsLiveTV(const CStdString& strFile)
 {
+  CStdString strFileWithoutSlash(strFile);
+  RemoveSlashAtEnd(strFileWithoutSlash);
+
   if(IsTuxBox(strFile)
@@ -764,3 +767,4 @@ bool URIUtils::IsLiveTV(const CStdString& strFile)
   || IsHTSP(strFile)
-  || strFile.Left(4).Equals("sap:"))
+  || strFile.Left(4).Equals("sap:")
+  ||(strFileWithoutSlash.Right(4).Equals(".pvr") && !strFileWithoutSlash.Left(16).Equals("pvr://recordings")))
     return true;
@@ -773,2 +777,11 @@ bool URIUtils::IsLiveTV(const CStdString& strFile)
 
+bool URIUtils::IsPVRRecording(const CStdString& strFile)
+{
+  CStdString strFileWithoutSlash(strFile);
+  RemoveSlashAtEnd(strFileWithoutSlash);
+
+  return strFileWithoutSlash.Right(4).Equals(".pvr") &&
+         strFile.Left(16).Equals("pvr://recordings");
+}
+
 bool URIUtils::IsMusicDb(const CStdString& strFile)
diff --git a/xbmc/utils/XMLUtils.cpp b/xbmc/utils/XMLUtils.cpp
index 1b5d585..615cc06 100644
--- a/xbmc/utils/XMLUtils.cpp
+++ b/xbmc/utils/XMLUtils.cpp
@@ -133,2 +133,10 @@ bool XMLUtils::GetString(const TiXmlNode* pRootNode, const char* strTag, CStdStr
 
+bool XMLUtils::HasChild(const TiXmlNode* pRootNode, const char* strTag)
+{
+  const TiXmlElement* pElement = pRootNode->FirstChildElement(strTag);
+  if (!pElement) return false;
+  const TiXmlNode* pNode = pElement->FirstChild();
+  return (pNode != NULL);
+}
+
 bool XMLUtils::GetAdditiveString(const TiXmlNode* pRootNode, const char* strTag,
diff --git a/xbmc/video/GUIViewStateVideo.cpp b/xbmc/video/GUIViewStateVideo.cpp
index d3cd0ae..a0eee3a 100644
--- a/xbmc/video/GUIViewStateVideo.cpp
+++ b/xbmc/video/GUIViewStateVideo.cpp
@@ -23,2 +23,4 @@
 #include "PlayListPlayer.h"
+#include "filesystem/PluginDirectory.h"
+#include "filesystem/PVRDirectory.h"
 #include "filesystem/VideoDatabaseDirectory.h"
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index ed827a0..7e2e020 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -54,2 +54,4 @@
 #include "XBDateTime.h"
+#include "pvr/PVRManager.h"
+#include "pvr/recordings/PVRRecordings.h"
 #include "URL.h"
@@ -63,2 +65,3 @@ using namespace VIDEO;
 using namespace ADDON;
+using namespace PVR;
 
@@ -4286,2 +4289,6 @@ void CVideoDatabase::SetPlayCount(const CFileItem &item, int count, const CDateT
 
+    // PVR: Set recording's play count on the backend (if supported)
+    if (item.HasPVRRecordingInfoTag() && g_PVRManager.IsStarted())
+      g_PVRRecordings->SetPlayCount(item, count);
+
     // We only need to announce changes to video items in the library
diff --git a/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp b/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
index 031be11..26f89fc 100644
--- a/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
+++ b/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
@@ -38,2 +38,3 @@
 #include "guilib/LocalizeStrings.h"
+#include "pvr/PVRManager.h"
 #include "cores/AudioEngine/Utils/AEUtil.h"
@@ -42,2 +43,3 @@ using namespace std;
 using namespace XFILE;
+using namespace PVR;
 
@@ -350,2 +352,5 @@ void CGUIDialogAudioSubtitleSettings::OnSettingChanged(SettingInfo &setting)
   }
+
+  if (g_PVRManager.IsPlayingRadio() || g_PVRManager.IsPlayingTV())
+    g_PVRManager.TriggerSaveChannelSettings();
 }
diff --git a/xbmc/video/dialogs/GUIDialogVideoOSD.cpp b/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
index 402fbb9..6c65423 100644
--- a/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
@@ -23,2 +23,3 @@
 #include "Application.h"
+#include "FileItem.h"
 #include "GUIUserMessages.h"
@@ -27,2 +28,7 @@
 
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
+
+using namespace PVR;
+
 CGUIDialogVideoOSD::CGUIDialogVideoOSD(void)
@@ -44,2 +50,6 @@ void CGUIDialogVideoOSD::FrameMove()
                            || g_windowManager.IsWindowActive(WINDOW_DIALOG_VIDEO_BOOKMARKS)
+                           || g_windowManager.IsWindowActive(WINDOW_DIALOG_PVR_OSD_CHANNELS)
+                           || g_windowManager.IsWindowActive(WINDOW_DIALOG_PVR_OSD_GUIDE)
+                           || g_windowManager.IsWindowActive(WINDOW_DIALOG_PVR_OSD_DIRECTOR)
+                           || g_windowManager.IsWindowActive(WINDOW_DIALOG_PVR_OSD_CUTTER)
                            || g_windowManager.IsWindowActive(WINDOW_DIALOG_OSD_TELETEXT))
@@ -101,2 +111,10 @@ bool CGUIDialogVideoOSD::OnMessage(CGUIMessage& message)
       if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
+      pDialog = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_OSD_CHANNELS);
+      if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
+      pDialog = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_OSD_GUIDE);
+      if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
+      pDialog = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_OSD_DIRECTOR);
+      if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
+      pDialog = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_OSD_CUTTER);
+      if (pDialog && pDialog->IsDialogRunning()) pDialog->Close(true);
       pDialog = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_OSD_TELETEXT);
diff --git a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
index 025186c..ca13609 100644
--- a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
@@ -34,4 +34,6 @@
 #include "addons/Skin.h"
+#include "pvr/PVRManager.h"
 
 using namespace std;
+using namespace PVR;
 
@@ -112,2 +114,3 @@ void CGUIDialogVideoSettings::CreateSettings()
     entries.push_back(make_pair(VS_INTERLACEMETHOD_DXVA_BEST                  , 16321));
+    entries.push_back(make_pair(VS_INTERLACEMETHOD_AUTO_ION                   , 16325));
 
@@ -242,2 +245,5 @@ void CGUIDialogVideoSettings::OnSettingChanged(SettingInfo &setting)
   }
+
+  if (g_PVRManager.IsPlayingRadio() || g_PVRManager.IsPlayingTV())
+    g_PVRManager.TriggerSaveChannelSettings();
 }
diff --git a/xbmc/video/windows/GUIWindowFullScreen.cpp b/xbmc/video/windows/GUIWindowFullScreen.cpp
index 1f0fc6c..7a1972f 100644
--- a/xbmc/video/windows/GUIWindowFullScreen.cpp
+++ b/xbmc/video/windows/GUIWindowFullScreen.cpp
@@ -25,2 +25,3 @@
 #include "Application.h"
+#include "ApplicationMessenger.h"
 #include "Util.h"
@@ -43,2 +44,3 @@
 #include "settings/Settings.h"
+#include "guilib/GUISelectButtonControl.h"
 #include "FileItem.h"
@@ -54,2 +56,4 @@
 #include "input/ButtonTranslator.h"
+#include "pvr/PVRManager.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
 #include "windowing/WindowingFactory.h"
@@ -62,2 +66,4 @@
 
+using namespace PVR;
+
 #define BLUE_BAR                          0
@@ -66,2 +72,3 @@
 #define LABEL_ROW3                       12
+#define CONTROL_GROUP_CHOOSER            503
 
@@ -127,2 +134,3 @@ CGUIWindowFullScreen::CGUIWindowFullScreen(void)
   m_subsLayout = NULL;
+  m_bGroupSelectShow = false;
   m_sliderAction = 0;
@@ -208,32 +216,48 @@ bool CGUIWindowFullScreen::OnAction(const CAction &action)
   case ACTION_STEP_BACK:
-    if (m_timeCodePosition > 0)
-      SeekToTimeCodeStamp(SEEK_RELATIVE, SEEK_BACKWARD);
+    if (!g_application.CurrentFileItem().HasPVRChannelInfoTag())
+    {
+      if (m_timeCodePosition > 0)
+        SeekToTimeCodeStamp(SEEK_RELATIVE, SEEK_BACKWARD);
+      else
+        g_application.m_pPlayer->Seek(false, false);
+    }
     else
-      g_application.m_pPlayer->Seek(false, false);
+      SeekTV(false, false);
     return true;
-    break;
 
   case ACTION_STEP_FORWARD:
-    if (m_timeCodePosition > 0)
-      SeekToTimeCodeStamp(SEEK_RELATIVE, SEEK_FORWARD);
+    if (!g_application.CurrentFileItem().HasPVRChannelInfoTag())
+    {
+      if (m_timeCodePosition > 0)
+        SeekToTimeCodeStamp(SEEK_RELATIVE, SEEK_FORWARD);
+      else
+        g_application.m_pPlayer->Seek(true, false);
+    }
     else
-      g_application.m_pPlayer->Seek(true, false);
+      SeekTV(true, false);
     return true;
-    break;
 
   case ACTION_BIG_STEP_BACK:
-    if (m_timeCodePosition > 0)
-      SeekToTimeCodeStamp(SEEK_RELATIVE, SEEK_BACKWARD);
+    if (!g_application.CurrentFileItem().HasPVRChannelInfoTag())
+    {
+      if (m_timeCodePosition > 0)
+        SeekToTimeCodeStamp(SEEK_RELATIVE, SEEK_BACKWARD);
+      else
+        g_application.m_pPlayer->Seek(false, true);
+    }
     else
-      g_application.m_pPlayer->Seek(false, true);
+      SeekTV(false, true);
     return true;
-    break;
 
   case ACTION_BIG_STEP_FORWARD:
-    if (m_timeCodePosition > 0)
-      SeekToTimeCodeStamp(SEEK_RELATIVE, SEEK_FORWARD);
+    if (!g_application.CurrentFileItem().HasPVRChannelInfoTag())
+    {
+      if (m_timeCodePosition > 0)
+        SeekToTimeCodeStamp(SEEK_RELATIVE, SEEK_FORWARD);
+      else
+        g_application.m_pPlayer->Seek(true, true);
+    }
     else
-      g_application.m_pPlayer->Seek(true, true);
+      SeekTV(true, true);
     return true;
-    break;
 
@@ -287,2 +311,3 @@ bool CGUIWindowFullScreen::OnAction(const CAction &action)
       {
+        CFileItem item(g_application.CurrentFileItem());
         pDialog->DoModal();
@@ -424,11 +449,32 @@ bool CGUIWindowFullScreen::OnAction(const CAction &action)
       {
-        int channelNr = -1;
+          CPVRChannelPtr channel;
+        int iChannelNumber = -1;
+        g_PVRManager.GetCurrentChannel(channel);
 
-        CStdString strChannel;
-        strChannel.Format("%i", action.GetID() - REMOTE_0);
-        if (CGUIDialogNumeric::ShowAndGetNumber(strChannel, g_localizeStrings.Get(19000)))
-          channelNr = atoi(strChannel.c_str());
+        if (action.GetID() == REMOTE_0)
+        {
+          iChannelNumber = g_PVRManager.GetPreviousChannel();
+          if (iChannelNumber > 0)
+            CLog::Log(LOGDEBUG, "switch to channel number %d", iChannelNumber);
+          else
+            CLog::Log(LOGDEBUG, "no previous channel number found");
+        }
+        else
+        {
+          int autoCloseTime = g_guiSettings.GetBool("pvrplayback.switchautoclose") ? 1500 : 0;
+          CStdString strChannel;
+          strChannel.Format("%i", action.GetID() - REMOTE_0);
+          if (CGUIDialogNumeric::ShowAndGetNumber(strChannel, g_localizeStrings.Get(19000), autoCloseTime) || autoCloseTime)
+            iChannelNumber = atoi(strChannel.c_str());
+        }
 
-        if (channelNr > 0)
-          OnAction(CAction(ACTION_CHANNEL_SWITCH, (float)channelNr));
+        if (iChannelNumber > 0 && iChannelNumber != channel->ChannelNumber())
+        {
+          CPVRChannelGroupPtr selectedGroup = g_PVRManager.GetPlayingGroup(channel->IsRadio());
+          CFileItemPtr channel = selectedGroup->GetByChannelNumber(iChannelNumber);
+          if (!channel || !channel->HasPVRChannelInfoTag())
+            return false;
+
+          OnAction(CAction(ACTION_CHANNEL_SWITCH, (float)iChannelNumber));
+        }
       }
@@ -467,2 +513,14 @@ bool CGUIWindowFullScreen::OnAction(const CAction &action)
     break;
+  case ACTION_SHOW_PLAYLIST:
+    {
+      CFileItem item(g_application.CurrentFileItem());
+      if (item.HasPVRChannelInfoTag())
+        g_windowManager.ActivateWindow(WINDOW_DIALOG_PVR_OSD_CHANNELS);
+      else if (item.HasVideoInfoTag())
+        g_windowManager.ActivateWindow(WINDOW_VIDEO_PLAYLIST);
+      else if (item.HasMusicInfoTag())
+        g_windowManager.ActivateWindow(WINDOW_MUSIC_PLAYLIST);
+    }
+    return true;
+    break;
   case ACTION_ZOOM_IN:
@@ -628,2 +686,3 @@ bool CGUIWindowFullScreen::OnAction(const CAction &action)
   }
+
   return CGUIWindow::OnAction(action);
@@ -662,3 +721,6 @@ void CGUIWindowFullScreen::OnWindowLoaded()
   }
+
   m_showCodec.Parse("player.showcodec", GetID());
+
+  FillInTVGroups();
 }
@@ -681,2 +743,3 @@ bool CGUIWindowFullScreen::OnMessage(CGUIMessage& message)
       m_bShowCurrentTime = false;
+      m_bGroupSelectShow = false;
       g_infoManager.SetDisplayAfterSeek(0); // Make sure display after seek is off.
@@ -728,2 +791,10 @@ bool CGUIWindowFullScreen::OnMessage(CGUIMessage& message)
       if (pDialog) pDialog->Close(true);
+      pDialog = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_OSD_CHANNELS);
+      if (pDialog) pDialog->Close(true);
+      pDialog = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_OSD_GUIDE);
+      if (pDialog) pDialog->Close(true);
+      pDialog = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_OSD_DIRECTOR);
+      if (pDialog) pDialog->Close(true);
+      pDialog = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_PVR_OSD_CUTTER);
+      if (pDialog) pDialog->Close(true);
 
@@ -751,2 +822,57 @@ bool CGUIWindowFullScreen::OnMessage(CGUIMessage& message)
     }
+  case GUI_MSG_CLICKED:
+    {
+      unsigned int iControl = message.GetSenderId();
+      if (iControl == CONTROL_GROUP_CHOOSER && g_PVRManager.IsStarted())
+      {
+        // Get the currently selected label of the Select button
+        CGUIMessage msg(GUI_MSG_ITEM_SELECTED, GetID(), iControl);
+        OnMessage(msg);
+        CStdString strLabel = msg.GetLabel();
+
+        CPVRChannelPtr playingChannel;
+        if (g_PVRManager.GetCurrentChannel(playingChannel))
+        {
+          CPVRChannelGroupPtr selectedGroup = g_PVRChannelGroups->Get(playingChannel->IsRadio())->GetByName(strLabel);
+          if (selectedGroup)
+          {
+            g_PVRManager.SetPlayingGroup(selectedGroup);
+            CLog::Log(LOGDEBUG, "%s - switched to group '%s'", __FUNCTION__, selectedGroup->GroupName().c_str());
+
+            if (!selectedGroup->IsGroupMember(*playingChannel))
+            {
+              CLog::Log(LOGDEBUG, "%s - channel '%s' is not a member of '%s', switching to channel 1 of the new group",
+                  __FUNCTION__, playingChannel->ChannelName().c_str(), selectedGroup->GroupName().c_str());
+              CFileItemPtr switchChannel = selectedGroup->GetByChannelNumber(1);
+
+              if (switchChannel && switchChannel->HasPVRChannelInfoTag())
+                OnAction(CAction(ACTION_CHANNEL_SWITCH, (float) switchChannel->GetPVRChannelInfoTag()->ChannelNumber()));
+              else
+              {
+                CLog::Log(LOGERROR, "%s - cannot find channel '1' in group %s", __FUNCTION__, selectedGroup->GroupName().c_str());
+                CApplicationMessenger::Get().MediaStop(false);
+              }
+            }
+          }
+          else
+          {
+            CLog::Log(LOGERROR, "%s - could not switch to group '%s'", __FUNCTION__, selectedGroup->GroupName().c_str());
+            CApplicationMessenger::Get().MediaStop(false);
+          }
+        }
+        else
+        {
+          CLog::Log(LOGERROR, "%s - cannot find the current channel", __FUNCTION__);
+          CApplicationMessenger::Get().MediaStop(false);
+        }
+
+        // hide the control and reset focus
+        m_bGroupSelectShow = false;
+        SET_CONTROL_HIDDEN(CONTROL_GROUP_CHOOSER);
+//      SET_CONTROL_FOCUS(0, 0);
+
+        return true;
+      }
+      break;
+    }
   case GUI_MSG_SETFOCUS:
@@ -942,2 +1068,3 @@ void CGUIWindowFullScreen::FrameMove()
     SET_CONTROL_VISIBLE(BLUE_BAR);
+    SET_CONTROL_HIDDEN(CONTROL_GROUP_CHOOSER);
   }
@@ -949,2 +1076,11 @@ void CGUIWindowFullScreen::FrameMove()
     SET_CONTROL_VISIBLE(BLUE_BAR);
+    SET_CONTROL_HIDDEN(CONTROL_GROUP_CHOOSER);
+  }
+  else if (m_bGroupSelectShow)
+  {
+    SET_CONTROL_HIDDEN(LABEL_ROW1);
+    SET_CONTROL_HIDDEN(LABEL_ROW2);
+    SET_CONTROL_HIDDEN(LABEL_ROW3);
+    SET_CONTROL_HIDDEN(BLUE_BAR);
+    SET_CONTROL_VISIBLE(CONTROL_GROUP_CHOOSER);
   }
@@ -956,2 +1092,3 @@ void CGUIWindowFullScreen::FrameMove()
     SET_CONTROL_HIDDEN(BLUE_BAR);
+    SET_CONTROL_HIDDEN(CONTROL_GROUP_CHOOSER);
   }
@@ -1086,2 +1223,10 @@ void CGUIWindowFullScreen::SeekToTimeCodeStamp(SEEK_TYPE type, SEEK_DIRECTION di
 
+void CGUIWindowFullScreen::SeekTV(bool bPlus, bool bLargeStep)
+{
+  if (bLargeStep)
+    OnAction(CAction(bPlus ? ACTION_NEXT_ITEM : ACTION_PREV_ITEM));
+  else if (!bLargeStep)
+    ChangetheTVGroup(bPlus);
+}
+
 double CGUIWindowFullScreen::GetTimeCodeStamp()
@@ -1151,2 +1296,43 @@ void CGUIWindowFullScreen::OnSliderChange(void *data, CGUISliderControl *slider)
 
+void CGUIWindowFullScreen::FillInTVGroups()
+{
+  if (!g_PVRManager.IsStarted())
+    return;
+
+  CGUIMessage msgReset(GUI_MSG_LABEL_RESET, GetID(), CONTROL_GROUP_CHOOSER);
+  g_windowManager.SendMessage(msgReset);
+
+  const CPVRChannelGroups *groups = g_PVRChannelGroups->Get(g_PVRManager.IsPlayingRadio());
+  if (groups)
+    groups->FillGroupsGUI(GetID(), CONTROL_GROUP_CHOOSER);
+}
+
+void CGUIWindowFullScreen::ChangetheTVGroup(bool next)
+{
+  if (!g_PVRManager.IsStarted())
+    return;
+
+  CGUISelectButtonControl* pButton = (CGUISelectButtonControl*)GetControl(CONTROL_GROUP_CHOOSER);
+  if (!pButton)
+    return;
+
+  if (!m_bGroupSelectShow)
+  {
+    SET_CONTROL_VISIBLE(CONTROL_GROUP_CHOOSER);
+    SET_CONTROL_FOCUS(CONTROL_GROUP_CHOOSER, 0);
+
+    // fire off an event that we've pressed this button...
+    OnAction(CAction(ACTION_SELECT_ITEM));
+
+    m_bGroupSelectShow = true;
+  }
+  else
+  {
+    if (next)
+      pButton->OnRight();
+    else
+      pButton->OnLeft();
+  }
+}
+
 void CGUIWindowFullScreen::ToggleOSD()
diff --git a/xbmc/video/windows/GUIWindowVideoBase.cpp b/xbmc/video/windows/GUIWindowVideoBase.cpp
index 00c1289..fea2089 100644
--- a/xbmc/video/windows/GUIWindowVideoBase.cpp
+++ b/xbmc/video/windows/GUIWindowVideoBase.cpp
@@ -63,2 +63,5 @@
 #include "utils/FileUtils.h"
+#include "interfaces/AnnouncementManager.h"
+#include "pvr/PVRManager.h"
+#include "pvr/recordings/PVRRecordings.h"
 #include "utils/URIUtils.h"
@@ -76,2 +79,3 @@ using namespace VIDEO;
 using namespace ADDON;
+using namespace PVR;
 
@@ -1464,2 +1468,61 @@ bool CGUIWindowVideoBase::OnPlayMedia(int iItem)
 
+  if (item.GetPath().Left(17) == "pvr://recordings/")
+  {
+    if (!g_PVRManager.IsStarted())
+      return false;
+
+    /* For recordings we check here for a available stream URL */
+    CFileItemPtr tag = g_PVRRecordings->GetByPath(item.GetPath());
+    if (tag && tag->HasPVRRecordingInfoTag() && !tag->GetPVRRecordingInfoTag()->m_strStreamURL.IsEmpty())
+    {
+      CStdString stream = tag->GetPVRRecordingInfoTag()->m_strStreamURL;
+
+      /* Isolate the folder from the filename */
+      size_t found = stream.find_last_of("/");
+      if (found == CStdString::npos)
+        found = stream.find_last_of("\\");
+
+      if (found != CStdString::npos)
+      {
+        /* Check here for asterix at the begin of the filename */
+        if (stream[found+1] == '*')
+        {
+          /* Create a "stack://" url with all files matching the extension */
+          CStdString ext = URIUtils::GetExtension(stream);
+          CStdString dir = stream.substr(0, found).c_str();
+
+          CFileItemList items;
+          CDirectory::GetDirectory(dir, items);
+          items.Sort(SORT_METHOD_FILE, SortOrderAscending);
+
+          vector<int> stack;
+          for (int i = 0; i < items.Size(); ++i)
+          {
+            if (URIUtils::GetExtension(items[i]->GetPath()) == ext)
+              stack.push_back(i);
+          }
+
+          if (stack.size() > 0)
+          {
+            /* If we have a stack change the path of the item to it */
+            CStackDirectory dir;
+            CStdString stackPath = dir.ConstructStackPath(items, stack);
+            item.SetPath(stackPath);
+          }
+        }
+        else
+        {
+          /* If no asterix is present play only the given stream URL */
+          item.SetPath(stream);
+        }
+      }
+      else
+      {
+        CLog::Log(LOGERROR, "CGUIWindowTV: Can't open recording, no valid filename!");
+        CGUIDialogOK::ShowAndGetInput(19033,0,19036,0);
+        return false;
+      }
+    }
+  }
+
   PlayMovie(&item);
diff --git a/xbmc/windows/GUIMediaWindow.cpp b/xbmc/windows/GUIMediaWindow.cpp
index 59d5927..0b1f055 100644
--- a/xbmc/windows/GUIMediaWindow.cpp
+++ b/xbmc/windows/GUIMediaWindow.cpp
@@ -837,3 +837,4 @@ bool CGUIMediaWindow::Update(const CStdString &strDirectory)
 
-  m_history.AddPath(m_vecItems->GetPath());
+  if (iWindow != WINDOW_PVR || (iWindow == WINDOW_PVR && m_vecItems->GetPath().Left(17) == "pvr://recordings/"))
+    m_history.AddPath(m_vecItems->GetPath());
 
diff --git a/xbmc/windows/GUIWindowLoginScreen.cpp b/xbmc/windows/GUIWindowLoginScreen.cpp
index 9752c88..a2b0477 100644
--- a/xbmc/windows/GUIWindowLoginScreen.cpp
+++ b/xbmc/windows/GUIWindowLoginScreen.cpp
@@ -271,2 +271,6 @@ void CGUIWindowLoginScreen::LoadProfile(unsigned int profile)
 
+  // stop PVR related services
+  g_application.StopPVRManager();
+  g_application.StopEPGManager();
+
   if (profile != 0 || !g_settings.IsMasterUser())
@@ -306,2 +310,6 @@ void CGUIWindowLoginScreen::LoadProfile(unsigned int profile)
 
+  // start PVR related services
+  g_application.StartEPGManager();
+  g_application.StartPVRManager();
+
   g_windowManager.ChangeActiveWindow(g_SkinInfo->GetFirstWindow());
diff --git a/xbmc/windows/GUIWindowSystemInfo.cpp b/xbmc/windows/GUIWindowSystemInfo.cpp
index 0e6e6f4..b248df0 100644
--- a/xbmc/windows/GUIWindowSystemInfo.cpp
+++ b/xbmc/windows/GUIWindowSystemInfo.cpp
@@ -37,5 +37,6 @@
 #define CONTROL_BT_HARDWARE 98
+#define CONTROL_BT_PVR      99
 
 #define CONTROL_START       CONTROL_BT_STORAGE
-#define CONTROL_END         CONTROL_BT_HARDWARE
+#define CONTROL_END         CONTROL_BT_PVR
 
@@ -153,2 +154,18 @@ void CGUIWindowSystemInfo::FrameMove()
   }
+  else if(m_section == CONTROL_BT_PVR)
+  {
+    SET_CONTROL_LABEL(40,g_localizeStrings.Get(19166));
+    int i = 2;
+
+    SetControlLabel(i++, "%s: %s", 19120, PVR_BACKEND_NUMBER);
+    i++; // empty line
+    SetControlLabel(i++, "%s: %s", 19012, PVR_BACKEND_NAME);
+    SetControlLabel(i++, "%s: %s", 19114, PVR_BACKEND_VERSION);
+    SetControlLabel(i++, "%s: %s", 19115, PVR_BACKEND_HOST);
+    SetControlLabel(i++, "%s: %s", 19116, PVR_BACKEND_DISKSPACE);
+    SetControlLabel(i++, "%s: %s", 19019, PVR_BACKEND_CHANNELS);
+    SetControlLabel(i++, "%s: %s", 19163, PVR_BACKEND_RECORDINGS);
+    SetControlLabel(i++, "%s: %s", 19025, PVR_BACKEND_TIMERS);
+  }
+
   CGUIWindow::FrameMove();