import sysimport osimport codecsimport reimport csvfrom logChunk import getExceptionKeywordfrom datetime import datetime, timedeltasys.path.append("../util")from dumpLogs import dumpLogsfrom logChunk import logChunkfrom logChunk import functionObjfrom PatchMethod import PatchMethodimport UtilSHA   = '[a-f0-9]{40}'#EMAIL = '<[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}>'#EMAIL = '<[A-Z0-9._%+-]+@([a-z0-9-])+>'EMAIL = '<[\w.%+-]+@([\w.+-])+>'DATE  = '[0-9]{4}-[0-9]{2}-[0-9]{2}'#071215 error_cases = 0 #Global Count of the incorrectly named spots#071215 normal_cases = 0 #Global Count of correctly named spotsdef toStr(text):  try:    text1 = str(text).encode('iso-8859-1')    temp_text = text1.replace("\'","\"")    temp_text = temp_text.strip()    return "\'" + str(temp_text) + "\'"  except:    print type(text)    return "\'NA\'"#text = str(text).encode('utf-8')class Patch:  def __init__(self, fileName, language):    self.file_name = fileName    self.language  = language    self.is_test    = False    self.methods  = []    self.bracket_diff= 0    self.isExceptionPatch=False  #Deprecated  def addMethod(self, methodName):    method = PatchMethod(methodName)    self.methods.append(method)  #LogChunk --> ---  #Add the Log chunk's recorded methods to the Patch  #ERROR: When there is a Mock_Function_For_Asserts, it  #is added for every function in the patch...  def addFunctions(self, nextLogChunk):    # mockFunc1 = PatchMethod("")    # mockFunc2 = PatchMethod("")    #    # temp = []    #    # for i in range(0, len(nextLogChunk.functions)):    #   if(nextLogChunk.functions[i].name == "Mock_Function_For_Asserts"):    #     temp.append(nextLogChunk.functions[i])    #     del nextLogChunk.functions[i]    #     break    #    # if(len(temp) == 2):    #   raise ValueError("Should not be more than 1 mock function")    # if(len(temp) == 1):    #   mockFunc1 = temp[0].convertToPatchMethod()    #    #   #Check existing PatchMethods for a mock function    #   for i in range(0, len(self.methods)):    #     nextFunc = self.methods[i]    #     #Note uses method instead of name    #     if(nextFunc.method == "Mock_Function_For_Asserts"):    #       mockFunc2 = nextFunc    #       del self.methods[i]    #       break    #    #   mockFunc1.total_add += mockFunc2.total_add    #   mockFunc1.total_del += mockFunc2.total_del    #   mockFunc1.assert_add += mockFunc2.assert_add    #   mockFunc1.assert_del += mockFunc2.assert_del    #   self.methods.append(mockFunc1)    #Add the asserts from the normal functions    self.methods += map(lambda(x): x.convertToPatchMethod(), nextLogChunk.functions)  def printPatch(self):    retStr  = "\n\t------ Patch -----\n"    retStr += "\tlanguage    = %s\n" % (self.language)    retStr += "\tfile        = %s\n" % (self.file_name)    retStr += "\tis_test     = %s\n" % (self.is_test)    retStr += "\tbracket_diff     = %s\n" % (self.bracket_diff)    for m in self.methods:      retStr += m.printPatch()    return retStr  def patchToCsv(self, sha, project, inf2,fPtrPatchSummary):    sha      = toStr(sha)    project  = toStr(project)    language = toStr(self.language)    fileName = toStr(self.file_name)    isTest   = toStr(self.is_test)    bracket_diff=toStr(self.bracket_diff)    isExceptionPatch=toStr(self.isExceptionPatch)    for m in self.methods:        patchStr = (",").join((project, sha, language, fileName, isTest, bracket_diff,isExceptionPatch, m.methodToCsv()))        inf2.write(patchStr+"\n")        fPtrPatchSummary.write(patchStr+"\n")    # for m in self.methods:    #   patchStr = (",").join((project, sha, language, fileName, isTest, m.dumpMethod()))    #   #print patchStr    #   dumpLog.dumpMethodChanges(patchStr)  def dumpPatch(self, sha, project, dumpLog):    sha      = toStr(sha)    project  = toStr(project)    language = toStr(self.language)    fileName = toStr(self.file_name)    isTest   = toStr(self.is_test)    bracket_diff=toStr(self.bracket_diff)    for m in self.methods:      patchStr = (",").join((project, sha, language, fileName, isTest,bracket_diff, m.dumpMethod()))      #print patchStr      dumpLog.dumpMethodChanges(patchStr)class Sha:  def __init__(self, project, sha):    self.project    = project    self.sha        = sha    self.language   = None    self.file_name  = None    self.function   = None    self.author     = None    self.date       = None    self.is_bug     = False    self.log        = None    self.patches    = []  def __str__(self):    return self.printSha()  def dumpSha(self, dumpLogDb):    project = toStr(self.project)    sha     = toStr(self.sha)    author  = toStr(self.author)    commit_date = toStr(self.date)    log     = toStr(self.log)    is_bug  = toStr(self.is_bug)    #shaStr = (",").join((project,sha,author,commit_date,log,is_bug))    shaStr = (",").join((project,sha,author,commit_date,is_bug))    #print shaStr    dumpLogDb.dumpSummary(shaStr)    self.dumpPatches(dumpLogDb)  def bracketMismatch(self):      total_match=0      total_mismatch=0      for x in self.patches:          if x.bracket_diff==0:              total_match+=1          else:              total_mismatch+=1      print "total_match Patch: ", total_match      print "total mismatch Patch: ",total_mismatch  def dumpSummary(self, summaryStr):    schema = self.db_config['schema']    table = schema + "." + self.db_config['table_change_summary']    sql_command = "INSERT INTO " + table + \                "(project, sha, author, commit_date, is_bug)" + \                "VALUES (" + summaryStr + ")"  def shaToCsv(self,inf1,inf2,fPtrChangeSummary,fPtrPatchSummary):    project = toStr(self.project).replace(","," ")    sha     = toStr(self.sha)    author  = toStr(self.author).replace(","," ")    commit_date = toStr(self.date)    log     = toStr(self.log)    is_bug  = toStr(self.is_bug)    #shaStr = (",").join((project,sha,author,commit_date,log,is_bug))    shaStr = (",").join((project,sha,author,commit_date,is_bug))    #print shaStr    inf1.write(shaStr+"\n")    fPtrChangeSummary.write(shaStr+"\n")    self.patchesToCsv(inf2,fPtrPatchSummary)    #print shaStr    #dumpSummary(shaStr)    #self.dumpPatches(dumpLogDb)  def printSha(self):    retStr  = "------ Sha Details -----\n"    retStr += "project     = %s\n" % (self.project)    retStr += "sha         = %s\n" % (self.sha)    retStr += "author      = %s\n" % (self.author)    retStr += "commit date = %s\n" % (self.date)    retStr += "log         = %s\n" % (self.log)    retStr += "is_bug      = %s\n" % (self.is_bug)    retStr += self.printPatches()    #print self.patches    print retStr.encode('ascii', 'ignore')  def dumpPatches(self,dumpLogDb):    for p in self.patches:      p.dumpPatch(self.sha, self.project, dumpLogDb)  def patchesToCsv(self,inf2,fPtrPatchSummary):    for p in self.patches:      p.patchToCsv(self.sha, self.project, inf2,fPtrPatchSummary)  def printPatches(self):    retStr = ""    for p in self.patches:      retStr += p.printPatch()    return retStr  def setLog(self, log):    self.log = log    if len(log) > 1000:      self.log = log[:1000]    err_str  = ' error | bug | fix | issue | mistake | blunder | incorrect|" \      + " fault | defect | flaw | glitch | gremlin '    if re.search(err_str, log, re.IGNORECASE):      self.is_bug = Trueclass ghLogDb:  def __init__(self, logFile):    self.log_file = logFile    self.project_name = None    self.curr_method = None    self.shas = []    def __str__(self):    print self.project_name    for s in shas:      print s  def isSha(self,line):    is_sha = re.search(SHA, line, re.IGNORECASE)    sha = None    if line.startswith("commit") and is_sha:      sha = is_sha.group(0)      if Util.DEBUG == 1:        print("COMMIT: " + sha)    return sha  def isAuthor(self,line,shaObj):    assert(shaObj != None)    #if(line.startswith("Author:")):    #  print("I'm an author.")    #  print(line)    is_auth = re.search(EMAIL, line, re.IGNORECASE)    if line.startswith("Author:") and is_auth:      author = is_auth.group(0)      #print "!!!!"      #print author      #print line.split(author)      shaObj.author =  line.split(author)[0].split("Author:")[1]      shaObj.author = shaObj.author.strip()      #print shaObj.author      return True    return False  def isDate(self,line,shaObj):    assert(shaObj != None)    is_date = re.search(DATE, line, re.IGNORECASE)    if line.startswith("Date:") and is_date:      date = is_date.group(0)      #print shaObj.sha, "---->" , date      shaObj.date = date      return True    return False  def createPatchWithNoPrevVersion(self, line):    #there was no previous version of a file    patchObj = None    if line.startswith("index "):      pass    elif line.startswith("+++ b/"):      #print line.split("+++ b/")      file_name = line.split("+++ b/")[1]      fileName, extension = os.path.splitext(file_name)      if extension == "":        language = ""      else:        language = extension.split(".")[1]      patchObj = Patch(file_name, language)      if "test" in fileName:        patchObj.is_test = True    return patchObj  def createPatch(self, line):    patchObj = None    if line.startswith("index "):      pass    elif line.startswith("--- a/"):      file_name = line.split("--- a/")[1]      fileName, extension = os.path.splitext(file_name)      if extension == "":        language = ""      else:        language = extension.split(".")[1]      patchObj = Patch(file_name, language)      if "test" in fileName:        patchObj.is_test = True    return patchObj  def processPatch(self, line, patchObj, curLogChunk):    if line.startswith("index "):      pass    elif line.startswith("--- a/"):      assert(patchObj == None)      file_name = line.split("--- a/")[1]      fileName, extension = os.path.splitext(file_name)      if extension == "":        language = ""      else:        language = extension.split(".")[1]      patchObj = Patch(file_name, language)      if "test" in fileName:        patchObj.is_test = True    elif line.startswith("+++ b/"):      pass    elif line.startswith("@@ "):      if Util.DEBUG == 1:         print("DING!" + line)        print("HEADER" + curLogChunk.header)      #Parse the previous chunk and store the results.      #if(curLogChunk.header == ""): #If there is an existing chunk to parse        #self.processLastChunk(patchObj, curLogChunk)      if Util.DEBUG == 1:        print("Resetting.")    #curLogChunk.reset()      temp_func   = line.split("@@ ")  #print temp_func      if len(temp_func) <= 2:          method_name = "NA"      else:        temp_func = temp_func[-1]        curLogChunk.addToText(temp_func.split(" ")[-1])        if '(' in temp_func:            temp_func   = temp_func.rsplit('(')[0].strip()      #print(temp_func)      #print(temp_func.split(" "))            method_name = temp_func.split(" ")[-1]      #print("NAME!" + method_name)        else:      #not a traditional method, contains other signature            method_name = temp_func      self.curr_method = method_name      #print "method name = " , method_name      #TODO: Replace this with our tracker to fix mislabeled cases.      #patchObj.addMethod(method_name)      curLogChunk.header = method_name # Track this with our chunk obj      #print("HEADER NOW!" + curLogChunk.header)    else:        curLogChunk.addToText(line) #Otherwise add the line to our separate parser      # if line.startswith("-"):      #   #print "------" , line      #   m = patchObj.methods[-1]      #   m.total_del += 1      #   if "assert" in line.lower():      #     l = line.split('-')[1]      #     l = l.strip()      #     if "assert.h" in l.lower():      #       pass      #     elif l.startswith("#include"):      #       pass      #     elif l.startswith('/*') or l.startswith('//') or l.startswith('* '): #comment      #       pass      #     elif l.endswith('*/') : #comment      #       pass      #     else:      #       m.assert_del += 1      # elif line.startswith("+"):      #   #print "++++++" , line      #   m = patchObj.methods[-1]      #   m.total_add += 1      #   if "assert" in line.lower():      #     l = line.split('+')[1]      #     l = l.strip()      #     if "assert.h" in l.lower():      #       pass      #     elif l.startswith("#include"):      #       pass      #     elif l.startswith('/*') or l.startswith('//') or l.startswith('* '): #comment      #       pass      #     elif l.endswith('*/') : #comment      #       pass      #     else:      #       m.assert_add += 1    return patchObj  #When we come to the end of a log chunk, we need to parse it and verify what it  #discovers against what git reports about the section of parsed text.  There are  #several possible cases and all are handled below.  Modification of the error_cases  #global marker should be limited to this method.  def processLastChunk(self, patchObj, curLogChunk):    #071215 global error_cases    #071215 global normal_cases    curLogChunk.parseText()    #print("-----------TEXT--------------")    #print(curLogChunk.text)    #print("-----------TEXT--------------")    #curLogChunk.printLogChunk()    # if(patchObj != None):    #         if (curLogChunk.header !=''):    #             for l in curLogChunk.text.split("\n"):    #                 if not l.startswith("-"):    #                     patchObj.bracket_diff+=(l.count("{") - l.count("}"))    #             #patchObj.bracket_diff= sum(1 for m in re.finditer("{", curLogChunk.text))- sum(1 for m in re.finditer("}", curLogChunk.text))    patchObj.bracket_diff=curLogChunk.bracketMisMatch    patchObj.isExceptionPatch=curLogChunk.isExceptionChunkFlag    patchObj.addFunctions(curLogChunk)    #curLogChunk.printLogChunk()  def processLog(self):    project1 = os.path.split(self.log_file)[0]    project1 = project1.rstrip(os.sep)    self.project_name = os.path.basename(project1)    print("---------- %s ------------\n" % (self.project_name))    if(Util.DATABASE == 1):      dl = dumpLogs()    if(Util.CSV==1):        if not os.path.isdir("../Results"):            os.mkdir("../Results")        inf1=open("../Results/"+str(self.project_name)+"ChangeSummary.csv",'w')        fPtrChangeSummary=open("../Results/"+"ChangeSummary.csv",'a')#        inf1=open(os.path.join(project1,str(self.project_name)+"ChangeSummary.csv"),'w')        inf1.write("project,sha,author,commit_date,is_bug\n")#        writer1=csv.writer(inf1)        inf2=open("../Results/"+str(self.project_name)+"PatchSummary.csv",'w')        fPtrPatchSummary=open("../Results/"+"PatchSummary.csv",'a')#        inf2=open(os.path.join(project1,str(self.project_name)+"PatchSummary.csv"),'w')        fPtrMisMatchSummary=open("../Results/"+"MisMatchSummary.csv",'a') #       writer2=csv.writer(inf2)        lst=[]        listToDict={}        getExceptionKeyword(lst)        for keyword in lst:            listToDict[str(keyword)+" Adds"]=0            listToDict[str(keyword)+" Dels"]=0        inf2.write("project, sha, language, file_name, is_test,bracket_diff,isExceptionPatch, method_name,total_add,total_del,uniqueExcepAdd,uniqueExcepDel,%s\n"%",".join(listToDict.keys()))    inf = codecs.open(self.log_file, "r", "iso-8859-1")    #lines = inf.readlines()    #inf.close()    shaObj   = None    patchObj = None    is_diff  = False    log_mssg = ""    is_no_prev_ver = False    is_no_next_ver = False    curLogChunk = logChunk("")    #071215 global error_cases    linenum = 0    #for i,l in enumerate(lines):    for l in inf:      #linenum += 1      #print(linenum)      #Assume to start that this isn't a content line - we'll get proven wrong before this is      #used if it is a content line.      #continue      #print i+1, line      sha  = self.isSha(l)      #line = l.strip()      line = l      #print(line)      if sha:        # if shaObj != None:        #   shaObj.dumpSha(dl)        shaObj = Sha(self.project_name, sha)        self.shas.append(shaObj)        is_diff = False        log_mssg = ""        continue      elif self.isAuthor(line,shaObj):        continue      elif self.isDate(line,shaObj):        continue      #0730 Commented because --x and ++y were being considered as Adds and Dels      # line = line.strip()      #0730 Try this and pass fullLine in processpatch function if there is some problem with number of +/-      fullLine=line      line=line.strip()      if line.startswith('diff --git '):        shaObj.setLog(log_mssg)        is_diff = True        is_no_prev_ver = False        is_no_next_ver = False        continue        '''        if patchObj != None:          shaObj.patches.append(patchObj)        '''      elif is_diff == False:        if not line.strip():          continue        log_mssg += line + "\t"      if is_diff:        if line.startswith("--- a/"):          #print "<a> : " , line          #Finish the changes to the old patch object          if(patchObj != None):            #If there is an existing chunk to parse, process it            if(curLogChunk.header != ""):              #patchObj.bracket_diff= sum(1 for m in re.finditer("{", curLogChunk.text))- sum(1 for m in re.finditer("}", curLogChunk.text))              self.processLastChunk(patchObj, curLogChunk)              # for line in curLogChunk.text.split("\n"):              #     if not line.startswith("-"):              #         patchObj.bracket_diff+=(line.count("{") - line.count("}"))                        #Reset the current chunk obj            if Util.DEBUG == 1:              print("Resetting.")            curLogChunk.reset()          patchObj = self.createPatch(line)          shaObj.patches.append(patchObj)          #print patchObj          #print shaObj.patches        elif (line == '--- /dev/null'): #earlier file was empty          #print "<b> : " , line          is_no_prev_ver = True        elif (line == '+++ /dev/null'): #next file version was empty          #print "<c> : " , line          is_no_next_ver = True          continue        elif (is_no_prev_ver == True) and line.startswith("+++ b/"):          #print "<d> : " , line          #Finish the changes to the old patch object          if(patchObj != None):            #if(len(curLogChunk.functions) != 0): #Functions in the chunk so the label is wrong.            #  patchObj.addFunctions(curLogChunk)            if(curLogChunk.header != ""): #If there is an existing chunk#              patchObj.bracket_diff= sum(1 for m in re.finditer("{", curLogChunk.text))- sum(1 for m in re.finditer("}", curLogChunk.text))              self.processLastChunk(patchObj, curLogChunk)              # for line in curLogChunk.text.split("\n"):              #     if not line.startswith("-"):              #         patchObj.bracket_diff+=(line.count("{") - line.count("}"))              if Util.DEBUG == 1:                print("Resetting.")              curLogChunk.reset()          patchObj = self.createPatchWithNoPrevVersion(line)          shaObj.patches.append(patchObj)          #print shaObj.patches        else: #Then we reached a content line.          #print "<e> : " , line          self.processPatch(fullLine, patchObj, curLogChunk)    '''    if shaObj != None:      shaObj.patches.append(patchObj)    '''    #Make sure to get the last patch in the file!    if(curLogChunk.header != ""): #If there is an existing chunk to parse        # patchObj.bracket_diff= sum(1 for m in re.finditer("{", curLogChunk.text))- sum(1 for m in re.finditer("}", curLogChunk.text))        self.processLastChunk(patchObj, curLogChunk)    for s in self.shas:      #s.printSha()      if s != None:        if(Util.DATABASE == 1):          s.dumpSha(dl)        else:          #s.bracketMismatch()          s.printSha()          if Util.CSV==1:            s.shaToCsv(inf1,inf2,fPtrChangeSummary,fPtrPatchSummary)    totalPatches=0    mismatchPatches=0    matchPatches=0    exceptionPatch=0    matchExceptionPatch=0    misMatchExceptionPatch=0    for s in self.shas:        for x in s.patches:            totalPatches+=1            if x.isExceptionPatch:                exceptionPatch+=1            if x.bracket_diff==0:                matchPatches+=1                if x.isExceptionPatch:                    matchExceptionPatch+=1            else:                mismatchPatches+=1                if x.isExceptionPatch:                    misMatchExceptionPatch+=1    print "Match patches: ",matchPatches    print "MisMatch patches: ", mismatchPatches    misMatchStr=(",").join((self.project_name,str(totalPatches),str(matchPatches),str(mismatchPatches),str(exceptionPatch),str(matchExceptionPatch),str(misMatchExceptionPatch)))    fPtrMisMatchSummary.write(misMatchStr+"\n")    if(Util.DATABASE == 1):      dl.close()        inf1.close()    inf2.close()    fPtrChangeSummary.close()    fPtrPatchSummary.close()    fPtrMisMatchSummary.close()    #071315 print len(self.shas)    #071215 print("Mismatch count:" + str(error_cases))    #071215 print("Normal count:" + str(normal_cases))#---------test-----------#def test():  if len(sys.argv) < 2:    print "!!! Pass a log file."    print "usage ./ghLogDb.py ccv_all_log.txt"    sys.exit()  log_file = sys.argv[1]  ghDb = ghLogDb(log_file)  ghDb.processLog()if __name__ == '__main__':  test()'''071315    if(curLogChunk.isHeaderMismatch()): #The Broken cases..      if Util.DEBUG == 1:        print("Mismatch Case!")      #In some cases, the header for function context is correct for the start of the      #diff.  In this case, if we have an assert in the section looking like      # @@ func name      #....      # }      #This would have been labelled as a Mock Function. This will fix that.      if(curLogChunk.hasMockFunction()):        curLogChunk.convertMockToReal()        if Util.DEBUG == 1:          print("Mock as real.")          curLogChunk.printLogChunk()      #071215 error_cases += 1      patchObj.addFunctions(curLogChunk)    elif(curLogChunk.header == "NA"):  #The context is correctly labeled as being outside a function      if Util.DEBUG == 1:        print("NA Case!")      if(curLogChunk.hasMockFunction()): #And asserts where changed outside this function        patchObj.addFunctions(curLogChunk)      else: #Or no asserts were changed outside this function        temp = PatchMethod("NA")        temp.total_add = curLogChunk.total_add        temp.total_del = curLogChunk.total_del        patchObj.methods.append(temp)    else: #The context in the '@@' was extracted correctly by git      if Util.DEBUG == 1:        print("Normal Case!")      #071215 normal_cases += 1      if(curLogChunk.hasMockFunction()): #And asserts were changed in this function        if Util.DEBUG == 1:          print("Mock as real.")          curLogChunk.printLogChunk()        curLogChunk.convertMockToReal()        patchObj.addFunctions(curLogChunk)      elif(len(curLogChunk.functions) == 1): #The function was labelled correctly, but whole function was altered      	if Util.DEBUG == 1:        	print("whole alter.")        patchObj.addFunctions(curLogChunk)      elif(len(curLogChunk.functions) == 0): #Or no asserts where changed in this function        temp = PatchMethod(curLogChunk.header)        if Util.DEBUG == 1:          print("No assert")        temp.total_add = curLogChunk.total_add        temp.total_del = curLogChunk.total_del        patchObj.methods.append(temp)      else: #Logically this shouldn't be possible.        assert(0)'''