projects/top_C++/phantomjs
Going to process projects/top_C++/phantomjs/all_log.txt 
---------- phantomjs ------------

===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(item->num_glyphs <= length);'), (3, 1, u'+    assert(length <= item->num_glyphs);')]
===========================================
===========================================
Total add: 1
Total del: 1
Header: HB_HeuristicSetGlyphAttributes
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(item->num_glyphs <= length);'), (3, 1, u'+    assert(length <= item->num_glyphs);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(item->num_glyphs <= length);'), (3, 1, u'+    assert(length <= item->num_glyphs);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(glyph_pos == item->num_glyphs);')]
===========================================
===========================================
Total add: 0
Total del: 1
Header: HB_HeuristicSetGlyphAttributes
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(glyph_pos == item->num_glyphs);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(glyph_pos == item->num_glyphs);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(length <= item->num_glyphs);'), (3, 1, u'+    assert(item->num_glyphs <= length);')]
===========================================
===========================================
Total add: 1
Total del: 1
Header: HB_HeuristicSetGlyphAttributes
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(length <= item->num_glyphs);'), (3, 1, u'+    assert(item->num_glyphs <= length);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(length <= item->num_glyphs);'), (3, 1, u'+    assert(item->num_glyphs <= length);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 1, u'+    assert(glyph_pos == item->num_glyphs);')]
===========================================
===========================================
Total add: 1
Total del: 0
Header: HB_HeuristicSetGlyphAttributes
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 1, u'+    assert(glyph_pos == item->num_glyphs);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 1, u'+    assert(glyph_pos == item->num_glyphs);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 2, u'-    ASSERT(!m_reachedTerminalState);')]
===========================================
===========================================
Total add: 4
Total del: 1
Header: ResourceLoader::didCancel
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 2, u'-    ASSERT(!m_reachedTerminalState);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 2, u'-    ASSERT(!m_reachedTerminalState);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(13, 1, u'+                    Q_ASSERT(connectionLists->inUse >= 0);')]
===========================================
===========================================
Total add: 15
Total del: 0
Header: QMetaObject::activate
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(13, 1, u'+                    Q_ASSERT(connectionLists->inUse >= 0);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(13, 1, u'+                    Q_ASSERT(connectionLists->inUse >= 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    Q_ASSERT(cachedItemsUnderMouse.first() == origin);')]
===========================================
===========================================
Total add: 0
Total del: 1
Header: QGraphicsScenePrivate::sendTouchBeginEvent
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    Q_ASSERT(cachedItemsUnderMouse.first() == origin);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    Q_ASSERT(cachedItemsUnderMouse.first() == origin);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 1, u'+    Q_ASSERT(shutdown == 0);')]
===========================================
===========================================
Total add: 2
Total del: 0
Header: connManager_cleanup
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 1, u'+    Q_ASSERT(shutdown == 0);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 1, u'+    Q_ASSERT(shutdown == 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(item->num_glyphs <= length);'), (3, 1, u'+    assert(length <= item->num_glyphs);')]
===========================================
===========================================
Total add: 1
Total del: 1
Header: HB_HeuristicSetGlyphAttributes
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(item->num_glyphs <= length);'), (3, 1, u'+    assert(length <= item->num_glyphs);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(item->num_glyphs <= length);'), (3, 1, u'+    assert(length <= item->num_glyphs);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(glyph_pos == item->num_glyphs);')]
===========================================
===========================================
Total add: 0
Total del: 1
Header: HB_HeuristicSetGlyphAttributes
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(glyph_pos == item->num_glyphs);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    assert(glyph_pos == item->num_glyphs);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 2, u'-    ASSERT(g_thread_supported());'), (71, 2, u'-    ASSERT(atomicallyInitializedStaticMutex);'), (101, 2, u'-    ASSERT(!identifierByGthreadHandle(thread));'), (123, 2, u'-    ASSERT(threadMap().contains(id));'), (146, 2, u'-    ASSERT(threadID);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(6, 1, u'+        Q_ASSERT(!d->resource);')]
===========================================
===========================================
Total add: 17
Total del: 0
Header: QTranslatorPrivate::do_load
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(6, 1, u'+        Q_ASSERT(!d->resource);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(6, 1, u'+        Q_ASSERT(!d->resource);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(!thread_p->finished);')]
===========================================
===========================================
Total add: 10
Total del: 2
Header: QCAdoptedThreadMonitor::RunL
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(!thread_p->finished);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(!thread_p->finished);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 1, u'+            Q_ASSERT(starter >= from);')]
===========================================
===========================================
Total add: 1
Total del: 0
Header: composeHelper
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 1, u'+            Q_ASSERT(starter >= from);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 1, u'+            Q_ASSERT(starter >= from);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(nativeParent);'), (4, 2, u'-        Q_ASSERT(nativeExtra);')]
===========================================
===========================================
Total add: 19
Total del: 9
Header: QWidgetPrivate::unregisterOleDnd
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(nativeParent);'), (4, 2, u'-        Q_ASSERT(nativeExtra);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(nativeParent);'), (4, 2, u'-        Q_ASSERT(nativeExtra);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(9, 1, u'+    Q_ASSERT(it > layoutData->items.constBegin());')]
===========================================
===========================================
Total add: 5
Total del: 5
Header: QTextEngine::setBoundary
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(9, 1, u'+    Q_ASSERT(it > layoutData->items.constBegin());')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(9, 1, u'+    Q_ASSERT(it > layoutData->items.constBegin());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 1, u'+        Q_ASSERT(dwlayout != 0);')]
===========================================
===========================================
Total add: 12
Total del: 0
Header: QDockWidgetPrivate::initDrag
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 1, u'+        Q_ASSERT(dwlayout != 0);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 1, u'+        Q_ASSERT(dwlayout != 0);')]
===========================================
Class:class QStackedLayoutHFW : public QStackedLayout { 
Class: class QStackedLayoutHFW : public QStackedLayout { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 1, u'+#include <wtf/Assertions.h>'), (197, 1, u'+    ASSERT(exec);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(eventType != QEvent::None);'), (3, 1, u'+        Q_ASSERT(mouseEventType != QEvent::None);')]
===========================================
===========================================
Total add: 12
Total del: 4
Header: WebPage::sendEvent
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(eventType != QEvent::None);'), (3, 1, u'+        Q_ASSERT(mouseEventType != QEvent::None);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(eventType != QEvent::None);'), (3, 1, u'+        Q_ASSERT(mouseEventType != QEvent::None);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(6, 1, u'+    _CrtSetReportMode(_CRT_ASSERT, 0);')]
===========================================
===========================================
Total add: 20
Total del: 1
Header: main
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(6, 1, u'+    _CrtSetReportMode(_CRT_ASSERT, 0);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(6, 1, u'+    _CrtSetReportMode(_CRT_ASSERT, 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(10, 1, u'+        Q_ASSERT(keyEventType != QEvent::None);')]
===========================================
===========================================
Total add: 22
Total del: 1
Header: WebPage::sendEvent
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(10, 1, u'+        Q_ASSERT(keyEventType != QEvent::None);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(10, 1, u'+        Q_ASSERT(keyEventType != QEvent::None);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+  assert(value_size == 4 || value_size == 8);'), (129, 1, u'+  assert(!iterator_->at_end && iterator_->type == N_SO);'), (202, 1, u'+    assert(iterator_->type == N_SO);'), (219, 1, u'+  assert(!iterator_->at_end && iterator_->type == N_FUN);'), (268, 1, u'+    assert(iterator_->type == N_SO || iterator_->type == N_FUN);'), (299, 1, u'+  assert(!iterator_->at_end &&')]
===========================================
Class: class SidCleanup { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(ncols == 0);')]
===========================================
===========================================
Total add: 0
Total del: 2
Header: read_dib_body
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(ncols == 0);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-        Q_ASSERT(ncols == 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(8, 1, u'+        Q_ASSERT(m_lastFocusedEditor);')]
===========================================
===========================================
Total add: 8
Total del: 0
Header: QCoeFepInputContext::setFocusWidget
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(8, 1, u'+        Q_ASSERT(m_lastFocusedEditor);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(8, 1, u'+        Q_ASSERT(m_lastFocusedEditor);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 2, u'-    Q_ASSERT((startedGestures & finishedGestures).isEmpty());'), (29, 2, u'-    Q_ASSERT((startedGestures & newMaybeGestures).isEmpty());'), (30, 2, u'-    Q_ASSERT((startedGestures & canceledGestures).isEmpty());'), (31, 2, u'-    Q_ASSERT((finishedGestures & newMaybeGestures).isEmpty());'), (32, 2, u'-    Q_ASSERT((finishedGestures & canceledGestures).isEmpty());'), (33, 2, u'-    Q_ASSERT((canceledGestures & newMaybeGestures).isEmpty());'), (64, 1, u'+        Q_ASSERT((startedGestures & finishedGestures).isEmpty());'), (65, 1, u'+        Q_ASSERT((startedGestures & newMaybeGestures).isEmpty());'), (66, 1, u'+        Q_ASSERT((startedGestures & canceledGestures).isEmpty());'), (67, 1, u'+        Q_ASSERT((finishedGestures & newMaybeGestures).isEmpty());'), (68, 1, u'+        Q_ASSERT((finishedGestures & canceledGestures).isEmpty());'), (69, 1, u'+        Q_ASSERT((canceledGestures & newMaybeGestures).isEmpty());'), (84, 1, u'+        Q_ASSERT((m_activeGestures & triggeredGestures).size() == triggeredGestures.size());'), (120, 2, u'-    Q_ASSERT((m_activeGestures & triggeredGestures).size() == triggeredGestures.size());')]
===========================================
===========================================
Total add: 91
Total del: 93
Header: QGestureManager::filterEventThroughContexts
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 2, u'-    Q_ASSERT((startedGestures & finishedGestures).isEmpty());'), (29, 2, u'-    Q_ASSERT((startedGestures & newMaybeGestures).isEmpty());'), (30, 2, u'-    Q_ASSERT((startedGestures & canceledGestures).isEmpty());'), (31, 2, u'-    Q_ASSERT((finishedGestures & newMaybeGestures).isEmpty());'), (32, 2, u'-    Q_ASSERT((finishedGestures & canceledGestures).isEmpty());'), (33, 2, u'-    Q_ASSERT((canceledGestures & newMaybeGestures).isEmpty());'), (64, 1, u'+        Q_ASSERT((startedGestures & finishedGestures).isEmpty());'), (65, 1, u'+        Q_ASSERT((startedGestures & newMaybeGestures).isEmpty());'), (66, 1, u'+        Q_ASSERT((startedGestures & canceledGestures).isEmpty());'), (67, 1, u'+        Q_ASSERT((finishedGestures & newMaybeGestures).isEmpty());'), (68, 1, u'+        Q_ASSERT((finishedGestures & canceledGestures).isEmpty());'), (69, 1, u'+        Q_ASSERT((canceledGestures & newMaybeGestures).isEmpty());'), (84, 1, u'+        Q_ASSERT((m_activeGestures & triggeredGestures).size() == triggeredGestures.size());'), (120, 2, u'-    Q_ASSERT((m_activeGestures & triggeredGestures).size() == triggeredGestures.size());')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 2, u'-    Q_ASSERT((startedGestures & finishedGestures).isEmpty());'), (29, 2, u'-    Q_ASSERT((startedGestures & newMaybeGestures).isEmpty());'), (30, 2, u'-    Q_ASSERT((startedGestures & canceledGestures).isEmpty());'), (31, 2, u'-    Q_ASSERT((finishedGestures & newMaybeGestures).isEmpty());'), (32, 2, u'-    Q_ASSERT((finishedGestures & canceledGestures).isEmpty());'), (33, 2, u'-    Q_ASSERT((canceledGestures & newMaybeGestures).isEmpty());'), (64, 1, u'+        Q_ASSERT((startedGestures & finishedGestures).isEmpty());'), (65, 1, u'+        Q_ASSERT((startedGestures & newMaybeGestures).isEmpty());'), (66, 1, u'+        Q_ASSERT((startedGestures & canceledGestures).isEmpty());'), (67, 1, u'+        Q_ASSERT((finishedGestures & newMaybeGestures).isEmpty());'), (68, 1, u'+        Q_ASSERT((finishedGestures & canceledGestures).isEmpty());'), (69, 1, u'+        Q_ASSERT((canceledGestures & newMaybeGestures).isEmpty());'), (84, 1, u'+        Q_ASSERT((m_activeGestures & triggeredGestures).size() == triggeredGestures.size());'), (120, 2, u'-    Q_ASSERT((m_activeGestures & triggeredGestures).size() == triggeredGestures.size());')]
===========================================
Class:class WebpageCallbacks : public QObject { 
Class: class ExceptionHandlerTest : public ::testing::Test { class ExceptionHandlerTest : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(66, 1, u'+    ASSERT_NE(sigaction(SIGCHLD, &sa, &old_action), -1);'), (100, 1, u'+  ASSERT_NE(pipe(fds), -1);'), (112, 1, u'+  ASSERT_NE(HANDLE_EINTR(waitpid(child, &status, 0)), -1);'), (113, 1, u'+  ASSERT_TRUE(WIFSIGNALED(status));'), (114, 1, u'+  ASSERT_EQ(WTERMSIG(status), SIGSEGV);'), (122, 1, u'+  ASSERT_EQ(r, 1);'), (123, 1, u'+  ASSERT_TRUE(pfd.revents & POLLIN);'), (126, 1, u'+  ASSERT_EQ(read(fds[0], &len, sizeof(len)), (ssize_t)sizeof(len));'), (127, 1, u'+  ASSERT_LT(len, (uint32_t)2048);'), (129, 1, u'+  ASSERT_EQ(read(fds[0], filename, len), len);'), (137, 1, u'+  ASSERT_EQ(stat(minidump_filename.c_str(), &st), 0);'), (138, 1, u'+  ASSERT_GT(st.st_size, 0u);'), (147, 1, u'+  ASSERT_NE(pipe(fds), -1);'), (186, 1, u'+  ASSERT_NE(HANDLE_EINTR(waitpid(child, &status, 0)), -1);'), (187, 1, u'+  ASSERT_TRUE(WIFSIGNALED(status));'), (188, 1, u'+  ASSERT_EQ(WTERMSIG(status), SIGILL);'), (196, 1, u'+  ASSERT_EQ(r, 1);'), (197, 1, u'+  ASSERT_TRUE(pfd.revents & POLLIN);'), (200, 1, u'+  ASSERT_EQ(read(fds[0], &len, sizeof(len)), (ssize_t)sizeof(len));'), (201, 1, u'+  ASSERT_LT(len, (uint32_t)2048);'), (203, 1, u'+  ASSERT_EQ(read(fds[0], filename, len), len);'), (211, 1, u'+  ASSERT_EQ(stat(minidump_filename.c_str(), &st), 0);'), (212, 1, u'+  ASSERT_GT(st.st_size, 0u);'), (219, 1, u'+  ASSERT_TRUE(minidump.Read());'), (223, 1, u'+  ASSERT_TRUE(exception);'), (224, 1, u'+  ASSERT_TRUE(memory_list);'), (225, 1, u'+  ASSERT_LT(0, memory_list->region_count());'), (228, 1, u'+  ASSERT_TRUE(context);'), (248, 1, u'+  ASSERT_TRUE(region);'), (252, 1, u'+  ASSERT_TRUE(bytes);'), (272, 1, u'+  ASSERT_NE(pipe(fds), -1);'), (311, 1, u'+  ASSERT_NE(HANDLE_EINTR(waitpid(child, &status, 0)), -1);'), (312, 1, u'+  ASSERT_TRUE(WIFSIGNALED(status));'), (313, 1, u'+  ASSERT_EQ(WTERMSIG(status), SIGILL);'), (321, 1, u'+  ASSERT_EQ(r, 1);'), (322, 1, u'+  ASSERT_TRUE(pfd.revents & POLLIN);'), (325, 1, u'+  ASSERT_EQ(read(fds[0], &len, sizeof(len)), (ssize_t)sizeof(len));'), (326, 1, u'+  ASSERT_LT(len, (uint32_t)2048);'), (328, 1, u'+  ASSERT_EQ(read(fds[0], filename, len), len);'), (336, 1, u'+  ASSERT_EQ(stat(minidump_filename.c_str(), &st), 0);'), (337, 1, u'+  ASSERT_GT(st.st_size, 0u);'), (344, 1, u'+  ASSERT_TRUE(minidump.Read());'), (348, 1, u'+  ASSERT_TRUE(exception);'), (349, 1, u'+  ASSERT_TRUE(memory_list);'), (350, 1, u'+  ASSERT_LT(0, memory_list->region_count());'), (353, 1, u'+  ASSERT_TRUE(context);'), (373, 1, u'+  ASSERT_TRUE(region);'), (377, 1, u'+  ASSERT_TRUE(bytes);'), (394, 1, u'+  ASSERT_NE(pipe(fds), -1);'), (436, 1, u'+  ASSERT_NE(HANDLE_EINTR(waitpid(child, &status, 0)), -1);'), (437, 1, u'+  ASSERT_TRUE(WIFSIGNALED(status));'), (438, 1, u'+  ASSERT_EQ(WTERMSIG(status), SIGILL);'), (446, 1, u'+  ASSERT_EQ(r, 1);'), (447, 1, u'+  ASSERT_TRUE(pfd.revents & POLLIN);'), (450, 1, u'+  ASSERT_EQ(read(fds[0], &len, sizeof(len)), (ssize_t)sizeof(len));'), (451, 1, u'+  ASSERT_LT(len, (uint32_t)2048);'), (453, 1, u'+  ASSERT_EQ(read(fds[0], filename, len), len);'), (461, 1, u'+  ASSERT_EQ(stat(minidump_filename.c_str(), &st), 0);'), (462, 1, u'+  ASSERT_GT(st.st_size, 0u);'), (469, 1, u'+  ASSERT_TRUE(minidump.Read());'), (473, 1, u'+  ASSERT_TRUE(exception);'), (474, 1, u'+  ASSERT_TRUE(memory_list);'), (475, 1, u'+  ASSERT_LT(0, memory_list->region_count());'), (478, 1, u'+  ASSERT_TRUE(context);'), (498, 1, u'+  ASSERT_TRUE(region);'), (503, 1, u'+  ASSERT_TRUE(bytes);'), (520, 1, u'+  ASSERT_NE(pipe(fds), -1);'), (537, 1, u'+  ASSERT_NE(HANDLE_EINTR(waitpid(child, &status, 0)), -1);'), (538, 1, u'+  ASSERT_TRUE(WIFSIGNALED(status));'), (539, 1, u'+  ASSERT_EQ(WTERMSIG(status), SIGSEGV);'), (547, 1, u'+  ASSERT_EQ(r, 1);'), (548, 1, u'+  ASSERT_TRUE(pfd.revents & POLLIN);'), (551, 1, u'+  ASSERT_EQ(read(fds[0], &len, sizeof(len)), (ssize_t)sizeof(len));'), (552, 1, u'+  ASSERT_LT(len, (uint32_t)2048);'), (554, 1, u'+  ASSERT_EQ(read(fds[0], filename, len), len);'), (562, 1, u'+  ASSERT_EQ(stat(minidump_filename.c_str(), &st), 0);'), (563, 1, u'+  ASSERT_GT(st.st_size, 0u);'), (570, 1, u'+  ASSERT_TRUE(minidump.Read());'), (574, 1, u'+  ASSERT_TRUE(exception);'), (575, 1, u'+  ASSERT_TRUE(memory_list);'), (576, 1, u'+  ASSERT_EQ((unsigned int)1, memory_list->region_count());'), (630, 1, u'+  ASSERT_TRUE(memory);'), (648, 1, u'+  ASSERT_TRUE(minidump.Read());'), (651, 1, u'+  ASSERT_TRUE(module_list);'), (654, 1, u'+  ASSERT_TRUE(module);'), (716, 1, u'+  ASSERT_NE(socketpair(AF_UNIX, SOCK_DGRAM, 0, fds), -1);'), (743, 1, u'+  ASSERT_EQ(n, kCrashContextSize);'), (744, 1, u'+  ASSERT_EQ(msg.msg_controllen, kControlMsgSize);'), (745, 1, u'+  ASSERT_EQ(msg.msg_flags, 0);'), (746, 1, u'+  ASSERT_EQ(close(fds[0]), 0);'), (757, 1, u'+      ASSERT_EQ(len, sizeof(int));'), (766, 1, u'+  ASSERT_NE(crashing_pid, -1);'), (767, 1, u'+  ASSERT_NE(signal_fd, -1);'), (771, 1, u'+  ASSERT_TRUE(WriteMinidump(templ.c_str(), crashing_pid, context,'), (775, 1, u'+  ASSERT_EQ(close(signal_fd), 0);'), (778, 1, u'+  ASSERT_NE(HANDLE_EINTR(waitpid(child, &status, 0)), -1);'), (779, 1, u'+  ASSERT_TRUE(WIFSIGNALED(status));'), (780, 1, u'+  ASSERT_EQ(WTERMSIG(status), SIGSEGV);'), (783, 1, u'+  ASSERT_EQ(stat(templ.c_str(), &st), 0);'), (784, 1, u'+  ASSERT_GT(st.st_size, 0u);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+  ASSERT_TRUE(dir != NULL);'), (59, 1, u'+  ASSERT_GE(fd, 0);'), (66, 1, u'+    ASSERT_TRUE(dent_set.find(name) != dent_set.end());'), (71, 1, u'+  ASSERT_TRUE(dent_set.find("status") != dent_set.end());'), (72, 1, u'+  ASSERT_TRUE(dent_set.find("stat") != dent_set.end());'), (73, 1, u'+  ASSERT_TRUE(dent_set.find("cmdline") != dent_set.end());'), (75, 1, u'+  ASSERT_EQ(dent_set.size(), seen);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 1, u'+  ASSERT_FALSE(reader.GetNextLine(&line, &len));'), (75, 1, u'+  ASSERT_EQ(2, r);'), (81, 1, u'+  ASSERT_TRUE(reader.GetNextLine(&line, &len));'), (82, 1, u'+  ASSERT_EQ((unsigned int)1, len);'), (83, 1, u"+  ASSERT_EQ('a', line[0]);"), (84, 1, u"+  ASSERT_EQ('\\0', line[1]);"), (87, 1, u'+  ASSERT_FALSE(reader.GetNextLine(&line, &len));'), (95, 1, u'+  ASSERT_EQ(1, r);'), (101, 1, u'+  ASSERT_TRUE(reader.GetNextLine(&line, &len));'), (102, 1, u'+  ASSERT_EQ((unsigned)1, len);'), (103, 1, u"+  ASSERT_EQ('a', line[0]);"), (104, 1, u"+  ASSERT_EQ('\\0', line[1]);"), (107, 1, u'+  ASSERT_FALSE(reader.GetNextLine(&line, &len));'), (115, 1, u'+  ASSERT_EQ(4, r);'), (121, 1, u'+  ASSERT_TRUE(reader.GetNextLine(&line, &len));'), (122, 1, u'+  ASSERT_EQ((unsigned)1, len);'), (123, 1, u"+  ASSERT_EQ('a', line[0]);"), (124, 1, u"+  ASSERT_EQ('\\0', line[1]);"), (127, 1, u'+  ASSERT_TRUE(reader.GetNextLine(&line, &len));'), (128, 1, u'+  ASSERT_EQ((unsigned)1, len);'), (129, 1, u"+  ASSERT_EQ('b', line[0]);"), (130, 1, u"+  ASSERT_EQ('\\0', line[1]);"), (133, 1, u'+  ASSERT_FALSE(reader.GetNextLine(&line, &len));'), (141, 1, u'+  ASSERT_EQ(3, r);'), (147, 1, u'+  ASSERT_TRUE(reader.GetNextLine(&line, &len));'), (148, 1, u'+  ASSERT_EQ((unsigned)1, len);'), (149, 1, u"+  ASSERT_EQ('a', line[0]);"), (150, 1, u"+  ASSERT_EQ('\\0', line[1]);"), (153, 1, u'+  ASSERT_TRUE(reader.GetNextLine(&line, &len));'), (154, 1, u'+  ASSERT_EQ((unsigned)1, len);'), (155, 1, u"+  ASSERT_EQ('b', line[0]);"), (156, 1, u"+  ASSERT_EQ('\\0', line[1]);"), (159, 1, u'+  ASSERT_FALSE(reader.GetNextLine(&line, &len));'), (169, 1, u'+  ASSERT_EQ(sizeof(l), r);'), (175, 1, u'+  ASSERT_TRUE(reader.GetNextLine(&line, &len));'), (176, 1, u'+  ASSERT_EQ(sizeof(l), len);'), (177, 1, u'+  ASSERT_TRUE(memcmp(l, line, sizeof(l)) == 0);'), (178, 1, u"+  ASSERT_EQ('\\0', line[len]);"), (188, 1, u'+  ASSERT_EQ(sizeof(l), r);'), (194, 1, u'+  ASSERT_FALSE(reader.GetNextLine(&line, &len));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 1, u'+  assert(core_path_);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 1, u'+  assert(!member || mapping_id < mappings_.size());'), (113, 1, u'+  assert(filename_len < NAME_MAX);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(156, 1, u'+  assert(info != NULL);')]
===========================================
Class:   class StackHelper { class StackHelper 
Class:class MinidumpWriter { class MinidumpWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 1, u'+  ASSERT_NE(-1, pipe(fds));'), (80, 1, u'+  ASSERT_TRUE(WriteMinidump(templ.c_str(), child, &context, sizeof(context)));'), (82, 1, u'+  ASSERT_EQ(stat(templ.c_str(), &st), 0);'), (83, 1, u'+  ASSERT_GT(st.st_size, 0u);'), (92, 1, u'+  ASSERT_NE(-1, pipe(fds));'), (125, 1, u'+  ASSERT_TRUE(memory);'), (156, 1, u'+  ASSERT_TRUE(WriteMinidump(templ.c_str(), child, &context, sizeof(context),'), (163, 1, u'+  ASSERT_TRUE(minidump.Read());'), (166, 1, u'+  ASSERT_TRUE(module_list);'), (169, 1, u'+  ASSERT_TRUE(module);'), (184, 1, u'+  ASSERT_NE(-1, pipe(fds));'), (212, 1, u'+  ASSERT_NE(-1, fd);'), (217, 1, u'+  ASSERT_EQ(kMemorySize, write(fd, buffer, kMemorySize));'), (228, 1, u'+  ASSERT_TRUE(memory);'), (260, 1, u'+  ASSERT_TRUE('), (268, 1, u'+  ASSERT_TRUE(minidump.Read());'), (271, 1, u'+  ASSERT_TRUE(module_list);'), (274, 1, u'+  ASSERT_TRUE(module);'), (310, 1, u'+  ASSERT_EQ(0, system(cmdline));'), (311, 1, u'+  ASSERT_EQ(0, chmod(binpath.c_str(), 0755));'), (314, 1, u'+  ASSERT_NE(-1, pipe(fds));'), (338, 1, u'+  ASSERT_EQ(1, r);'), (339, 1, u'+  ASSERT_TRUE(pfd.revents & POLLIN);'), (342, 1, u'+  ASSERT_EQ(sizeof(junk), nr);'), (355, 1, u'+  ASSERT_TRUE(WriteMinidump(templ.c_str(), child_pid, &context,'), (360, 1, u'+  ASSERT_EQ(stat(templ.c_str(), &st), 0);'), (361, 1, u'+  ASSERT_GT(st.st_size, 0u);'), (366, 1, u'+  ASSERT_TRUE(minidump.Read());'), (370, 1, u'+  ASSERT_TRUE(module_list);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(362, 1, u'+  assert(list.n_value);'), (565, 1, u'+    assert(mibLen < CTL_MAXNAME);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(623, 1, u'+    assert(((size_t)(gProtectedData.protected_buffer) & PAGE_MASK) == 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(426, 1, u'+      assert("Unknown CPU type!");'), (1179, 1, u'+    assert(header->magic == MH_MAGIC_64);'), (1184, 1, u'+    assert(header->magic == MH_MAGIC);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+  assert(valid_);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(66, 1, u'+  CPTAssert(kr == KERN_SUCCESS);'), (68, 1, u'+  CPTAssert(0 == memcmp(&buf[0], (const void*)addr, getpagesize()));'), (78, 1, u'+  CPTAssert(d->GetImageCount() > 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 1, u'+      CPTAssert(nmAddr == symbolList[0].n_value);')]
===========================================
Class:class CrashGenerationServerTest : public Test { class CrashGenerationServerTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 1, u'+  ASSERT_TRUE(server.Start());'), (107, 1, u'+  ASSERT_TRUE(server.Stop());'), (120, 1, u'+  ASSERT_TRUE(server.Start());'), (123, 1, u'+  ASSERT_NE(-1, pid);'), (131, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (170, 1, u'+  ASSERT_TRUE(server.Start());'), (173, 1, u'+  ASSERT_NE(-1, pid);'), (187, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (192, 1, u'+  ASSERT_FALSE(last_dump_name.empty());'), (197, 1, u'+  ASSERT_EQ(pid, child_pid);'), (218, 1, u'+  ASSERT_TRUE(server.Start());'), (221, 1, u'+  ASSERT_NE(-1, pid);'), (231, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (235, 1, u'+  ASSERT_FALSE(last_dump_name.empty());'), (242, 1, u'+  ASSERT_TRUE(minidump.Read());'), (245, 1, u'+  ASSERT_TRUE(system_info);'), (247, 1, u'+  ASSERT_TRUE(raw_info);'), (251, 1, u'+  ASSERT_TRUE(thread_list);'), (252, 1, u'+  ASSERT_EQ((unsigned int)1, thread_list->thread_count());'), (255, 1, u'+  ASSERT_TRUE(main_thread);'), (257, 1, u'+  ASSERT_TRUE(context);'), (261, 1, u'+  ASSERT_TRUE(module_list);'), (263, 1, u'+  ASSERT_TRUE(main_module);'), (279, 1, u'+  ASSERT_TRUE(server.Start());'), (290, 1, u'+  ASSERT_NE(-1, pid);'), (293, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (297, 1, u'+  ASSERT_FALSE(last_dump_name.empty());'), (319, 1, u'+  ASSERT_TRUE(minidump.Read());'), (322, 1, u'+  ASSERT_TRUE(system_info);'), (324, 1, u'+  ASSERT_TRUE(raw_info);'), (328, 1, u'+  ASSERT_TRUE(thread_list);'), (329, 1, u'+  ASSERT_EQ((unsigned int)1, thread_list->thread_count());'), (332, 1, u'+  ASSERT_TRUE(main_thread);'), (334, 1, u'+  ASSERT_TRUE(context);'), (338, 1, u'+  ASSERT_TRUE(module_list);'), (340, 1, u'+  ASSERT_TRUE(main_module);')]
===========================================
Class:class ExceptionHandlerTest : public Test { class ExceptionHandlerTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 1, u'+  ASSERT_EQ(0, pipe(fds));'), (119, 1, u'+  ASSERT_NE(-1, pid);'), (124, 1, u'+  ASSERT_NE(0, nbytes);'), (127, 1, u'+  ASSERT_EQ(0, stat(minidump_file, &st));'), (128, 1, u'+  ASSERT_LT(0, st.st_size);'), (132, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (162, 1, u'+  ASSERT_TRUE(eh.WriteMinidump());'), (165, 1, u'+  ASSERT_FALSE(lastDumpName.empty());'), (167, 1, u'+  ASSERT_EQ(0, stat(lastDumpName.c_str(), &st));'), (168, 1, u'+  ASSERT_LT(0, st.st_size);'), (172, 1, u'+  ASSERT_TRUE(minidump.Read());'), (181, 1, u'+  ASSERT_TRUE(eh.WriteMinidump(true));'), (184, 1, u'+  ASSERT_FALSE(lastDumpName.empty());'), (186, 1, u'+  ASSERT_EQ(0, stat(lastDumpName.c_str(), &st));'), (187, 1, u'+  ASSERT_LT(0, st.st_size);'), (191, 1, u'+  ASSERT_TRUE(minidump.Read());'), (194, 1, u'+  ASSERT_TRUE(exception);'), (196, 1, u'+  ASSERT_TRUE(raw_exception);'), (211, 1, u'+  ASSERT_EQ(0, pipe(fds));'), (234, 1, u'+  ASSERT_NE(-1, pid);'), (239, 1, u'+  ASSERT_EQ(KERN_SUCCESS,'), (243, 1, u'+  ASSERT_NE((mach_port_t)MACH_PORT_NULL, child_task);'), (244, 1, u'+  ASSERT_NE((mach_port_t)MACH_PORT_NULL, child_thread);'), (252, 1, u'+  ASSERT_EQ(true, result);'), (255, 1, u'+  ASSERT_FALSE(lastDumpName.empty());'), (257, 1, u'+  ASSERT_EQ(0, stat(lastDumpName.c_str(), &st));'), (258, 1, u'+  ASSERT_LT(0, st.st_size);'), (266, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (276, 1, u'+  ASSERT_EQ(0, pipe(fds));'), (314, 1, u'+  ASSERT_NE(-1, pid);'), (321, 1, u'+  ASSERT_NE(0, nbytes);'), (324, 1, u'+  ASSERT_EQ(0, stat(minidump_file, &st));'), (325, 1, u'+  ASSERT_LT(0, st.st_size);'), (329, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (338, 1, u'+  ASSERT_TRUE(minidump.Read());'), (342, 1, u'+  ASSERT_TRUE(exception);'), (343, 1, u'+  ASSERT_TRUE(memory_list);'), (344, 1, u'+  ASSERT_NE((unsigned int)0, memory_list->region_count());'), (347, 1, u'+  ASSERT_TRUE(context);'), (371, 1, u'+  ASSERT_TRUE(bytes);'), (388, 1, u'+  ASSERT_EQ(0, pipe(fds));'), (426, 1, u'+  ASSERT_NE(-1, pid);'), (433, 1, u'+  ASSERT_NE(0, nbytes);'), (436, 1, u'+  ASSERT_EQ(0, stat(minidump_file, &st));'), (437, 1, u'+  ASSERT_LT(0, st.st_size);'), (441, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (450, 1, u'+  ASSERT_TRUE(minidump.Read());'), (454, 1, u'+  ASSERT_TRUE(exception);'), (455, 1, u'+  ASSERT_TRUE(memory_list);'), (456, 1, u'+  ASSERT_NE((unsigned int)0, memory_list->region_count());'), (459, 1, u'+  ASSERT_TRUE(context);'), (483, 1, u'+  ASSERT_TRUE(bytes);'), (497, 1, u'+  ASSERT_EQ(0, pipe(fds));'), (538, 1, u'+  ASSERT_NE(-1, pid);'), (545, 1, u'+  ASSERT_NE(0, nbytes);'), (548, 1, u'+  ASSERT_EQ(0, stat(minidump_file, &st));'), (549, 1, u'+  ASSERT_LT(0, st.st_size);'), (553, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (562, 1, u'+  ASSERT_TRUE(minidump.Read());'), (566, 1, u'+  ASSERT_TRUE(exception);'), (567, 1, u'+  ASSERT_TRUE(memory_list);'), (568, 1, u'+  ASSERT_NE((unsigned int)0, memory_list->region_count());'), (571, 1, u'+  ASSERT_TRUE(context);'), (596, 1, u'+  ASSERT_TRUE(bytes);'), (610, 1, u'+  ASSERT_EQ(0, pipe(fds));'), (625, 1, u'+  ASSERT_NE(-1, pid);'), (632, 1, u'+  ASSERT_NE(0, nbytes);'), (635, 1, u'+  ASSERT_EQ(0, stat(minidump_file, &st));'), (636, 1, u'+  ASSERT_LT(0, st.st_size);'), (640, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (648, 1, u'+  ASSERT_TRUE(minidump.Read());'), (652, 1, u'+  ASSERT_TRUE(exception);'), (653, 1, u'+  ASSERT_TRUE(memory_list);'), (654, 1, u'+  ASSERT_EQ((unsigned int)1, memory_list->region_count());'), (667, 1, u'+  ASSERT_EQ(0, pipe(fds));'), (686, 1, u'+  ASSERT_NE(-1, pid);'), (693, 1, u'+  ASSERT_NE(0, nbytes);'), (696, 1, u'+  ASSERT_EQ(0, stat(minidump_file, &st));'), (697, 1, u'+  ASSERT_LT(0, st.st_size);'), (701, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (707, 1, u'+  ASSERT_TRUE(minidump.Read());'), (710, 1, u'+  ASSERT_TRUE(memory_list);'), (713, 1, u'+  ASSERT_EQ((unsigned int)3, memory_list->region_count());')]
===========================================
Class:class MinidumpGeneratorTest : public Test { class MinidumpGeneratorTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(98, 1, u'+  ASSERT_EQ(0, pthread_create(&junk_thread, NULL, Junk, &quit));'), (100, 1, u'+  ASSERT_TRUE(generator.Write(dump_filename.c_str()));'), (103, 1, u'+  ASSERT_EQ(0, stat(dump_filename.c_str(), &st));'), (104, 1, u'+  ASSERT_LT(0, st.st_size);'), (112, 1, u'+  ASSERT_TRUE(minidump.Read());'), (115, 1, u'+  ASSERT_TRUE(system_info);'), (117, 1, u'+  ASSERT_TRUE(raw_info);'), (121, 1, u'+  ASSERT_TRUE(thread_list);'), (122, 1, u'+  ASSERT_EQ((unsigned int)1, thread_list->thread_count());'), (125, 1, u'+  ASSERT_TRUE(main_thread);'), (127, 1, u'+  ASSERT_TRUE(context);'), (131, 1, u'+  ASSERT_TRUE(module_list);'), (133, 1, u'+  ASSERT_TRUE(main_module);'), (146, 1, u'+  ASSERT_EQ(0, pipe(fds));'), (170, 1, u'+  ASSERT_NE(-1, pid);'), (175, 1, u'+  ASSERT_EQ(KERN_SUCCESS,'), (178, 1, u'+  ASSERT_NE((mach_port_t)MACH_PORT_NULL, child_task);'), (184, 1, u'+  ASSERT_TRUE(generator.Write(dump_filename.c_str()));'), (188, 1, u'+  ASSERT_EQ(0, stat(dump_filename.c_str(), &st));'), (189, 1, u'+  ASSERT_LT(0, st.st_size);'), (197, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (203, 1, u'+  ASSERT_TRUE(minidump.Read());'), (206, 1, u'+  ASSERT_TRUE(system_info);'), (208, 1, u'+  ASSERT_TRUE(raw_info);'), (212, 1, u'+  ASSERT_TRUE(thread_list);'), (213, 1, u'+  ASSERT_EQ((unsigned int)1, thread_list->thread_count());'), (216, 1, u'+  ASSERT_TRUE(main_thread);'), (218, 1, u'+  ASSERT_TRUE(context);'), (222, 1, u'+  ASSERT_TRUE(module_list);'), (224, 1, u'+  ASSERT_TRUE(main_module);'), (250, 1, u'+  ASSERT_NE(-1, pid);'), (254, 1, u'+  ASSERT_EQ(KERN_SUCCESS,'), (257, 1, u'+  ASSERT_NE((mach_port_t)MACH_PORT_NULL, child_task);'), (263, 1, u'+  ASSERT_TRUE(generator.Write(dump_filename.c_str()));'), (267, 1, u'+  ASSERT_EQ(0, stat(dump_filename.c_str(), &st));'), (268, 1, u'+  ASSERT_LT(0, st.st_size);'), (274, 1, u'+  ASSERT_EQ(pid, waitpid(pid, &ret, 0));'), (293, 1, u'+  ASSERT_TRUE(minidump.Read());'), (296, 1, u'+  ASSERT_TRUE(system_info);'), (298, 1, u'+  ASSERT_TRUE(raw_info);'), (302, 1, u'+  ASSERT_TRUE(thread_list);'), (303, 1, u'+  ASSERT_EQ((unsigned int)1, thread_list->thread_count());'), (306, 1, u'+  ASSERT_TRUE(main_thread);'), (308, 1, u'+  ASSERT_TRUE(context);'), (312, 1, u'+  ASSERT_TRUE(module_list);'), (314, 1, u'+  ASSERT_TRUE(main_module);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 1, u'+  assert(file_ == -1);'), (150, 1, u'+  assert(str);'), (151, 1, u'+  assert(location);'), (194, 1, u'+  assert(src);'), (195, 1, u'+  assert(output);'), (210, 1, u'+  assert(size);'), (211, 1, u'+  assert(file_ != -1);'), (236, 1, u'+  assert(src);'), (237, 1, u'+  assert(size);'), (238, 1, u'+  assert(file_ != -1);'), (260, 1, u'+  assert(size_ == 0);'), (267, 1, u'+  assert(src);'), (268, 1, u'+  assert(size);'), (269, 1, u'+  assert(pos + size <= position_ + size_);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 1, u'+#define ASSERT_TRUE(cond) \\'), (53, 1, u'+#define ASSERT_EQ(e1, e2) ASSERT_TRUE((e1) == (e2))'), (54, 1, u'+#define ASSERT_NE(e1, e2) ASSERT_TRUE((e1) != (e2))'), (78, 1, u'+    ASSERT_TRUE(strings.Allocate());'), (81, 1, u'+    ASSERT_TRUE(writer.WriteString(first, 0, &strings.get()->first_string));'), (83, 1, u'+    ASSERT_TRUE(writer.WriteString(second, 0, &strings.get()->second_string));'), (88, 1, u'+    ASSERT_TRUE(array.AllocateArray(count));'), (94, 1, u'+      ASSERT_TRUE(array.CopyIndex(i, &local));'), (99, 1, u'+    ASSERT_TRUE(obj_array.AllocateObjectAndArray(count,'), (107, 1, u'+      ASSERT_TRUE(obj_array.CopyIndexAfterObject(i, &local, sizeof(local)));'), (150, 1, u'+  ASSERT_NE(fd, -1);'), (151, 1, u'+  ASSERT_TRUE(buffer);'), (152, 1, u'+  ASSERT_EQ(read(fd, buffer, expected_byte_count),'), (165, 1, u'+  ASSERT_EQ(memcmp(buffer, expected, expected_byte_count), 0);'), (171, 1, u'+  ASSERT_TRUE(WriteFile(path));'), (172, 1, u'+  ASSERT_TRUE(CompareFile(path));')]
===========================================
Class:class AutoLwpResumer { class AutoLwpResumer 
Class:class AutoCloser { class AutoCloser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+                       MDRawAssertionInfo* assert_info,'), (49, 1, u'+      assert_info_(assert_info),')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 1, u'+  memset(&assert_info_, 0, sizeof(assert_info_));'), (210, 1, u'+                      &assert_info_,'), (292, 1, u'+                                        MDRawAssertionInfo* assert_info) {'), (300, 1, u'+  if (assert_info) {'), (301, 1, u'+    memcpy(&assert_info_, assert_info, sizeof(assert_info_));'), (303, 1, u'+    memset(&assert_info_, 0, sizeof(assert_info_));'), (313, 1, u'+bool CrashGenerationClient::RequestDump(MDRawAssertionInfo* assert_info) {'), (314, 1, u'+  return RequestDump(NULL, assert_info);'), (318, 1, u'+  assert(crash_event_);'), (319, 1, u'+  assert(crash_generated_);'), (320, 1, u'+  assert(server_alive_);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(92, 1, u'+          msg.assert_info != NULL);'), (271, 1, u'+  assert(server_state_ == IPC_SERVER_STATE_ERROR);'), (301, 1, u'+  assert(server_state_ == IPC_SERVER_STATE_INITIAL);'), (314, 1, u'+  assert(!success);'), (338, 1, u'+  assert(server_state_ == IPC_SERVER_STATE_CONNECTING);'), (361, 1, u'+  assert(server_state_ == IPC_SERVER_STATE_CONNECTED);'), (389, 1, u'+  assert(server_state_ == IPC_SERVER_STATE_READING);'), (404, 1, u'+    assert(error_code != ERROR_IO_INCOMPLETE);'), (417, 1, u'+  assert(server_state_ == IPC_SERVER_STATE_READ_DONE);'), (437, 1, u'+                     msg_.assert_info,'), (468, 1, u'+  assert(server_state_ == IPC_SERVER_STATE_WRITING);'), (485, 1, u'+  assert(error_code != ERROR_IO_INCOMPLETE);'), (495, 1, u'+  assert(server_state_ == IPC_SERVER_STATE_WRITE_DONE);'), (517, 1, u'+  assert(server_state_ == IPC_SERVER_STATE_READING_ACK);'), (536, 1, u'+    assert(error_code != ERROR_IO_INCOMPLETE);'), (547, 1, u'+  assert(server_state_ == IPC_SERVER_STATE_DISCONNECTING);'), (735, 1, u'+      assert(false);'), (780, 1, u'+  assert(context);'), (789, 1, u'+  assert(context);'), (794, 1, u'+  assert(crash_server);'), (802, 1, u'+  assert(context);'), (806, 1, u'+  assert(crash_server);'), (818, 1, u'+  assert(context);'), (822, 1, u'+  assert(crash_server);'), (835, 1, u'+  assert(client_info);'), (867, 1, u'+  assert(client.pid() != 0);'), (868, 1, u'+  assert(client.process_handle());'), (887, 1, u'+                                        client.assert_info(),')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 1, u'+                                      MDRawAssertionInfo* assert_info,'), (74, 1, u'+                             assert_info, dump_type, is_client_pointers,'), (83, 1, u'+                                      MDRawAssertionInfo* assert_info,'), (175, 1, u'+  MDRawAssertionInfo* actual_assert_info = assert_info;'), (176, 1, u'+  MDRawAssertionInfo client_assert_info = {0};'), (178, 1, u'+  if (assert_info) {'), (184, 1, u'+                             assert_info,'), (185, 1, u'+                             &client_assert_info,'), (186, 1, u'+                             sizeof(client_assert_info),'), (194, 1, u'+      if (bytes_read != sizeof(client_assert_info)) {'), (201, 1, u'+      actual_assert_info  = &client_assert_info;'), (204, 1, u'+    user_stream_array[1].Type = MD_ASSERTION_INFO_STREAM;'), (205, 1, u'+    user_stream_array[1].BufferSize = sizeof(MDRawAssertionInfo);'), (206, 1, u'+    user_stream_array[1].Buffer = actual_assert_info;')]
===========================================
Class:class AutoExceptionHandler { class AutoExceptionHandler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(184, 1, u'+                     MDRawAssertionInfo* assertion,'), (485, 1, u'+  _CrtSetReportMode(_CRT_ASSERT, 0);')]
===========================================
Class:class CrashGenerationServerTest : public ::testing::Test { class CrashGenerationServerTest : public ::testing::Test 
Class:  class MockCrashGenerationServerCallbacks {   class MockCrashGenerationServerCallbacks 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+    memset(&assert_info_, 0, sizeof(assert_info_));'), (102, 1, u'+    ASSERT_TRUE(crash_generation_server_.Start());'), (115, 1, u'+      ASSERT_EQ(ERROR_PIPE_BUSY, GetLastError());'), (118, 1, u'+      ASSERT_TRUE(WaitNamedPipe(kPipeName, 500));'), (129, 1, u'+    ASSERT_NE(pipe, INVALID_HANDLE_VALUE);'), (132, 1, u'+    ASSERT_TRUE(SetNamedPipeHandleState(pipe, &mode, NULL, NULL));'), (141, 1, u'+    ASSERT_NO_FATAL_FAILURE(FaultyClient(fault));'), (142, 1, u'+    ASSERT_NO_FATAL_FAILURE(FaultyClient(fault));'), (143, 1, u'+    ASSERT_NO_FATAL_FAILURE(FaultyClient(fault));'), (147, 1, u'+    ASSERT_NO_FATAL_FAILURE(FaultyClient(NO_FAULT));'), (154, 1, u'+    ASSERT_NO_FATAL_FAILURE(FaultyClient(CLOSE_AFTER_CONNECT));'), (178, 1, u'+      &assert_info_,'), (186, 1, u'+    ASSERT_TRUE(WriteFile(pipe,'), (224, 1, u'+    ASSERT_TRUE(WriteFile(pipe,'), (261, 1, u'+  MDRawAssertionInfo assert_info_;'), (294, 1, u'+  ASSERT_NO_FATAL_FAILURE(FaultyClient(SEND_INVALID_ACK));'), (297, 1, u'+  ASSERT_NO_FATAL_FAILURE(FaultyClient(CLOSE_AFTER_CONNECT));'), (300, 1, u'+  ASSERT_NO_FATAL_FAILURE(FaultyClient(NO_FAULT));'), (303, 1, u'+  ASSERT_NO_FATAL_FAILURE(FaultyClient(CLOSE_AFTER_CONNECT));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 1, u'+    ASSERT_TRUE(dump_file_handle_ != NULL);'), (60, 1, u'+    ASSERT_TRUE(dump_file_mapping_ == NULL);'), (68, 1, u'+    ASSERT_TRUE(dump_file_mapping_ != NULL);'), (75, 1, u'+    ASSERT_TRUE(dump_file_view_ != NULL);')]
===========================================
Class:class ExceptionHandlerDeathTest : public ::testing::Test { class ExceptionHandlerDeathTest : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 1, u'+    assert(false);'), (101, 1, u'+                             MDRawAssertionInfo* assertion,'), (120, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (126, 1, u'+  ASSERT_DEATH((*i)++, kSuccessIndicator);'), (147, 1, u'+  ASSERT_TRUE(exc->IsOutOfProcess());'), (161, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (172, 1, u'+  ASSERT_DEATH(this->DoCrashAccessViolation(), "");'), (179, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (184, 1, u'+  _CrtSetReportMode(_CRT_ASSERT, 0);'), (188, 1, u'+  ASSERT_EXIT(printf(NULL), ::testing::ExitedWithCode(0), "");'), (213, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (218, 1, u'+  _CrtSetReportMode(_CRT_ASSERT, 0);'), (249, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (264, 1, u'+  ASSERT_TRUE(memory);'), (276, 1, u'+  ASSERT_DEATH(memory_function(), "");'), (283, 1, u'+  ASSERT_FALSE(minidump_filename_wide.empty());'), (285, 1, u'+  ASSERT_TRUE(WindowsStringUtils::safe_wcstombs(minidump_filename_wide,'), (294, 1, u'+    ASSERT_TRUE(minidump.Read());'), (298, 1, u'+    ASSERT_TRUE(exception);'), (299, 1, u'+    ASSERT_TRUE(memory_list);'), (300, 1, u'+    ASSERT_LT((unsigned)0, memory_list->region_count());'), (303, 1, u'+    ASSERT_TRUE(context);'), (320, 1, u'+    ASSERT_TRUE(region);'), (324, 1, u'+    ASSERT_TRUE(bytes);'), (341, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (361, 1, u'+  ASSERT_TRUE(all_memory);'), (363, 1, u'+  ASSERT_TRUE(VirtualAlloc(memory, kPageSize,'), (376, 1, u'+  ASSERT_DEATH(memory_function(), "");'), (383, 1, u'+  ASSERT_FALSE(minidump_filename_wide.empty());'), (385, 1, u'+  ASSERT_TRUE(WindowsStringUtils::safe_wcstombs(minidump_filename_wide,'), (394, 1, u'+    ASSERT_TRUE(minidump.Read());'), (398, 1, u'+    ASSERT_TRUE(exception);'), (399, 1, u'+    ASSERT_TRUE(memory_list);'), (400, 1, u'+    ASSERT_LT((unsigned)0, memory_list->region_count());'), (403, 1, u'+    ASSERT_TRUE(context);'), (420, 1, u'+    ASSERT_TRUE(region);'), (424, 1, u'+    ASSERT_TRUE(bytes);'), (438, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (457, 1, u'+  ASSERT_TRUE(memory);'), (458, 1, u'+  ASSERT_TRUE(VirtualAlloc(memory, kPageSize,'), (468, 1, u'+  ASSERT_DEATH(memory_function(), "");'), (475, 1, u'+  ASSERT_FALSE(minidump_filename_wide.empty());'), (477, 1, u'+  ASSERT_TRUE(WindowsStringUtils::safe_wcstombs(minidump_filename_wide,'), (486, 1, u'+    ASSERT_TRUE(minidump.Read());'), (490, 1, u'+    ASSERT_TRUE(exception);'), (491, 1, u'+    ASSERT_TRUE(memory_list);'), (492, 1, u'+    ASSERT_LT((unsigned)0, memory_list->region_count());'), (495, 1, u'+    ASSERT_TRUE(context);'), (512, 1, u'+    ASSERT_TRUE(region);'), (517, 1, u'+    ASSERT_TRUE(bytes);')]
===========================================
Class:class ExceptionHandlerTest : public ::testing::Test { class ExceptionHandlerTest : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 1, u'+                           MDRawAssertionInfo* assertion,'), (112, 1, u'+    assert(false);'), (152, 1, u'+                    MDRawAssertionInfo* assertion,'), (169, 1, u'+  _CrtSetReportMode(_CRT_ASSERT, 0);'), (174, 1, u'+  ASSERT_TRUE(exc->IsOutOfProcess());'), (201, 1, u'+  _CrtSetReportMode(_CRT_ASSERT, 0);'), (206, 1, u'+  ASSERT_TRUE(exc->IsOutOfProcess());'), (217, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (220, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (226, 1, u'+  ASSERT_TRUE(dump_file.empty() && full_dump_file.empty());'), (233, 1, u'+  ASSERT_TRUE(!dump_file.empty() && !full_dump_file.empty());'), (234, 1, u'+  ASSERT_TRUE(DoesPathExist(dump_file.c_str()));'), (288, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (291, 1, u'+  ASSERT_TRUE(DoesPathExist(temp_path_));'), (297, 1, u'+  ASSERT_TRUE(dump_file.empty() && full_dump_file.empty());'), (304, 1, u'+  ASSERT_TRUE(!dump_file.empty() && !full_dump_file.empty());'), (305, 1, u'+  ASSERT_TRUE(DoesPathExist(dump_file.c_str()));'), (364, 1, u'+  ASSERT_TRUE(handler.WriteMinidump());'), (365, 1, u'+  ASSERT_FALSE(dump_file.empty());'), (368, 1, u'+  ASSERT_TRUE(WindowsStringUtils::safe_wcstombs(dump_file,'), (373, 1, u'+  ASSERT_TRUE(minidump.Read());')]
===========================================
Class:class MinidumpTest: public testing::Test { class MinidumpTest: public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(69, 1, u'+    ASSERT_EQ(NULL, ::GetModuleHandle(L"urlmon.dll"));'), (74, 1, u'+    ASSERT_TRUE(urlmon != NULL);'), (75, 1, u'+    ASSERT_TRUE(::FreeLibrary(urlmon));'), (167, 1, u'+  ASSERT_TRUE(dbg_help != NULL);'), (170, 1, u'+  ASSERT_TRUE(::GetModuleFileName(dbg_help,'), (174, 1, u'+  ASSERT_TRUE(HasFileInfo(std::wstring(dbg_help_file)) != NULL);'), (212, 1, u'+  ASSERT_TRUE(WriteDump(kSmallDumpType));'), (243, 1, u'+  ASSERT_TRUE(WriteDump(kLargerDumpType));'), (275, 1, u'+  ASSERT_TRUE(WriteDump(kFullDumpType));'), (276, 1, u'+  ASSERT_TRUE(dump_file_ != L"");'), (277, 1, u'+  ASSERT_TRUE(full_dump_file_ != L"");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(163, 1, u'+  ASSERT_TRUE(cursor'), (183, 1, u'+  ASSERT_TRUE(cursor'), (217, 1, u'+  ASSERT_TRUE(cursor'), (244, 1, u'+  ASSERT_TRUE(cursor'), (267, 1, u'+  ASSERT_TRUE(cursor'), (287, 1, u'+  ASSERT_TRUE(cursor'), (321, 1, u'+  ASSERT_TRUE(cursor'), (348, 1, u'+  ASSERT_TRUE(cursor'), (370, 1, u'+  ASSERT_TRUE(cursor'), (390, 1, u'+  ASSERT_TRUE(cursor'), (423, 1, u'+  ASSERT_TRUE(cursor'), (450, 1, u'+  ASSERT_TRUE(cursor'), (472, 1, u'+  ASSERT_TRUE(cursor'), (492, 1, u'+  ASSERT_TRUE(cursor'), (525, 1, u'+  ASSERT_TRUE(cursor'), (552, 1, u'+  ASSERT_TRUE(cursor')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 1, u'+  assert(size == 4 || size == 8);'), (57, 1, u'+  assert(size == 4 || size == 8);'), (108, 1, u'+  assert(encoding != DW_EH_PE_omit);'), (115, 1, u'+    assert(have_section_base_);'), (211, 1, u'+      assert(have_section_base_);'), (216, 1, u'+      assert(have_text_base_);'), (221, 1, u'+      assert(have_data_base_);'), (226, 1, u'+      assert(have_function_base_);'), (240, 1, u'+    assert(AddressSize() == sizeof(uint64));')]
===========================================
Class:class Reader: public ReaderFixture, public Test 
Class:class ReaderDeathTest: public ReaderFixture, public Test 
Class:class Aligned: public AlignedFixture, public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+  assert(!entry_length_);'), (79, 1, u'+  assert(!entry_length_);'), (111, 1, u'+  assert(entry_length_);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(114, 1, u'+  assert(!die_handlers_.empty());'), (118, 1, u'+    assert(entry->offset_ == offset);'), (141, 1, u'+  assert(offset == current.offset_);'), (151, 1, u'+  assert(offset == current.offset_);'), (161, 1, u'+  assert(offset == current.offset_);'), (172, 1, u'+  assert(offset == current.offset_);'), (182, 1, u'+  assert(offset == current.offset_);'), (192, 1, u'+  assert(offset == current.offset_);')]
===========================================
Class: class MockDIEHandler: public DIEHandler { class MockDIEHandler: public DIEHandler 
Class: class MockRootDIEHandler: public RootDIEHandler { class MockRootDIEHandler: public RootDIEHandler 
Class:class CallFrameInfo::Rule { class CallFrameInfo::Rule 
Class:  class CallFrameInfo::UndefinedRule: public CallFrameInfo::Rule { class CallFrameInfo::UndefinedRule: public CallFrameInfo::Rule 
Class:  class CallFrameInfo::SameValueRule: public CallFrameInfo::Rule { class CallFrameInfo::SameValueRule: public CallFrameInfo::Rule 
Class:   class CallFrameInfo::OffsetRule: public CallFrameInfo::Rule { class CallFrameInfo::OffsetRule: public CallFrameInfo::Rule 
Class:    class CallFrameInfo::ValOffsetRule: public CallFrameInfo::Rule { class CallFrameInfo::ValOffsetRule: public CallFrameInfo::Rule 
Class:  class CallFrameInfo::RegisterRule: public CallFrameInfo::Rule { class CallFrameInfo::RegisterRule: public CallFrameInfo::Rule 
Class:  class CallFrameInfo::ExpressionRule: public CallFrameInfo::Rule { class CallFrameInfo::ExpressionRule: public CallFrameInfo::Rule 
Class:  class CallFrameInfo::ValExpressionRule: public CallFrameInfo::Rule { class CallFrameInfo::ValExpressionRule: public CallFrameInfo::Rule 
Class:  class CallFrameInfo::RuleMap { class CallFrameInfo::RuleMap 
Class:   class CallFrameInfo::State { class CallFrameInfo::State 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+  assert(iter != sections_.end());'), (101, 1, u'+    assert(abbrevptr < abbrev_start + abbrev_length);'), (106, 1, u'+    assert(abbrevptr < abbrev_start + abbrev_length);'), (110, 1, u'+    assert(abbrevptr < abbrev_start + abbrev_length);'), (116, 1, u'+      assert(abbrevptr < abbrev_start + abbrev_length);'), (127, 1, u'+    assert(abbrev.number == abbrevs_->size());'), (186, 1, u'+      assert(header_.version == 2 || header_.version == 3);'), (221, 1, u'+  assert(headerptr + 4 < buffer_ + buffer_length_);'), (227, 1, u'+  assert(headerptr + 2 < buffer_ + buffer_length_);'), (231, 1, u'+  assert(headerptr + reader_->OffsetSize() < buffer_ + buffer_length_);'), (235, 1, u'+  assert(headerptr + 1 < buffer_ + buffer_length_);'), (245, 1, u'+  assert(buffer_ + initial_length_size + header_.length <='), (256, 1, u'+  assert(iter != sections_.end());'), (393, 1, u'+      assert(header_.version == 2 || header_.version == 3);'), (435, 1, u'+      assert(string_buffer_ != NULL);'), (438, 1, u'+      assert(string_buffer_ + offset < string_buffer_ + string_buffer_length_);'), (539, 1, u'+  assert(buffer_ + initial_length_size + header_.total_length <='), (543, 1, u'+  assert(reader_->AddressSize() != 0);'), (1104, 1, u'+  assert(reg != Handler::kCFARegister);'), (1113, 1, u'+  assert(reg != Handler::kCFARegister);'), (1114, 1, u'+  assert(rule);'), (1138, 1, u'+    assert(0);'), (1163, 1, u'+      assert(0);'), (1182, 1, u'+  assert(new_it == new_rules.registers_.end());'), (1416, 1, u'+          assert(0);'), (1428, 1, u'+  assert(entry_->kind != kUnknown);'), (1432, 1, u'+  assert(cursor_ < entry_->end);'), (1458, 1, u'+        assert(0);'), (1822, 1, u'+      assert(offset_size == 8);'), (1842, 1, u'+  assert(cie->kind == kCIE);'), (2215, 1, u'+    assert (kind == CallFrameInfo::kTerminator);')]
===========================================
Class: class MockCallFrameErrorReporter: public CallFrameInfo::Reporter { class MockCallFrameErrorReporter: public CallFrameInfo::Reporter 
Class:class CFI: public CFIFixture, public Test 
Class:class CFIInsn: public CFIInsnFixture, public Test 
Class:class CFIRestore: public CFIInsnFixture, public Test 
Class:class EHFrame: public EHFrameFixture, public Test 
Class:class CFIReporter: public CFIReporterFixture, public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(212, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (237, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (261, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (287, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (626, 1, u'+      assert(section->AddressSize() == 8);'), (666, 1, u'+      assert(section->endianness() == kLittleEndian);'), (1987, 1, u'+      assert(section->endianness() == kLittleEndian);')]
===========================================
Class: class MockDwarf2Handler: public Dwarf2Handler { class MockDwarf2Handler: public Dwarf2Handler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 1, u'+    assert(info.GetContents(&info_contents));'), (135, 1, u'+    assert(abbrevs.GetContents(&abbrevs_contents));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 1, u'+  assert(dirs->size() == 0);'), (56, 1, u'+  assert(files->size() == 0);'), (66, 1, u'+  assert(dir_num == dirs_->size());'), (73, 1, u'+  assert(dir_num >= 0);'), (74, 1, u'+  assert(dir_num < dirs_->size());'), (167, 1, u'+    assert(iter != sections_.end());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 1, u'+  assert(!entry_);'), (126, 1, u'+  assert(entry_);'), (128, 1, u'+    assert(i == kCFARegister);'), (146, 1, u'+  assert(entry_);')]
===========================================
Class:class Entry: public DwarfCFIToModuleFixture, public Test 
Class:class Rule: public RuleFixture, public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(88, 1, u'+  ASSERT_TRUE(handler.Entry(0x3b8961b8, 0xa21069698096fc98ULL,'), (90, 1, u'+  ASSERT_TRUE(handler.End());'), (100, 1, u'+  ASSERT_TRUE(handler.Entry(0xeb60e0fc, 0x75b8806bb09eab78ULL,'), (102, 1, u'+  ASSERT_TRUE(handler.End());'), (118, 1, u'+    ASSERT_TRUE(handler.Entry(0x4445c05c, entry_address, entry_size,'), (136, 1, u'+  ASSERT_TRUE(handler.UndefinedRule(entry_address, 7));'), (137, 1, u'+  ASSERT_TRUE(handler.End());'), (145, 1, u'+  ASSERT_TRUE(handler.SameValueRule(entry_address, 6));'), (146, 1, u'+  ASSERT_TRUE(handler.End());'), (156, 1, u'+  ASSERT_TRUE(handler.OffsetRule(entry_address + 1, return_reg,'), (159, 1, u'+  ASSERT_TRUE(handler.End());'), (169, 1, u'+  ASSERT_TRUE(handler.OffsetRule(entry_address + 1,'), (171, 1, u'+  ASSERT_TRUE(handler.End());'), (183, 1, u'+  ASSERT_TRUE(handler.ValOffsetRule(entry_address + 0x5ab7,'), (186, 1, u'+  ASSERT_TRUE(handler.End());'), (197, 1, u'+  ASSERT_TRUE(handler.RegisterRule(entry_address, return_reg, 3));'), (198, 1, u'+  ASSERT_TRUE(handler.End());'), (209, 1, u'+  ASSERT_TRUE(handler.ExpressionRule(entry_address + 0xf326, 2,'), (211, 1, u'+  ASSERT_TRUE(handler.End());'), (220, 1, u'+  ASSERT_TRUE(handler.ValExpressionRule(entry_address + 0x6367, 0,'), (222, 1, u'+  ASSERT_TRUE(handler.End());'), (231, 1, u'+  ASSERT_TRUE(handler.RegisterRule(entry_address, 0, 1));'), (232, 1, u'+  ASSERT_TRUE(handler.End());'), (244, 1, u'+  ASSERT_TRUE(handler.RegisterRule(entry_address, return_reg, 1));'), (245, 1, u'+  ASSERT_TRUE(handler.End());'), (256, 1, u'+  ASSERT_TRUE(handler.RegisterRule(entry_address + 1, return_reg, 1));'), (257, 1, u'+  ASSERT_TRUE(handler.End());')]
===========================================
Class:class DwarfCUToModule::GenericDIEHandler: public dwarf2reader::DIEHandler { class DwarfCUToModule::GenericDIEHandler: public dwarf2reader::DIEHandler 
Class:  class DwarfCUToModule::FuncHandler: public GenericDIEHandler { class DwarfCUToModule::FuncHandler: public GenericDIEHandler 
Class:   class DwarfCUToModule::NamedScopeHandler: public GenericDIEHandler { class DwarfCUToModule::NamedScopeHandler: public GenericDIEHandler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(793, 1, u'+    assert(!func || current < func->address || within(*func, current));'), (794, 1, u'+    assert(!line || current < line->address || within(*line, current));'), (855, 1, u'+        assert (func || line);'), (888, 1, u'+    assert(next_transition > current);')]
===========================================
Class:   class MockLineToModuleFunctor: public DwarfCUToModule::LineToModuleFunctor { class MockLineToModuleFunctor: public DwarfCUToModule::LineToModuleFunctor 
Class: class MockWarningReporter: public DwarfCUToModule::WarningReporter { class MockWarningReporter: public DwarfCUToModule::WarningReporter 
Class:    class CUFixtureBase { class CUFixtureBase 
Class:class Specifications: public CUFixtureBase, public Test 
Class:class CUErrors: public CUFixtureBase, public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 1, u'+  ASSERT_EQ(5U, files.size());'), (98, 1, u'+  ASSERT_EQ(5U, lines.size());'), (138, 1, u'+  ASSERT_EQ(1U, files.size());'), (140, 1, u'+  ASSERT_EQ(1U, lines.size());'), (156, 1, u'+  ASSERT_EQ(1U, files.size());'), (158, 1, u'+  ASSERT_EQ(1U, lines.size());'), (171, 1, u'+  ASSERT_EQ(1U, lines.size());'), (184, 1, u'+  ASSERT_EQ(1U, lines.size());'), (197, 1, u'+  ASSERT_EQ(1U, lines.size());'), (213, 1, u'+  ASSERT_EQ(1U, lines.size());'), (243, 1, u'+  ASSERT_EQ(1U, lines.size());'), (256, 1, u'+  ASSERT_EQ(0U, lines.size());'), (269, 1, u'+  ASSERT_EQ(1U, lines.size());'), (287, 1, u'+  ASSERT_EQ(1U, lines.size());'), (300, 1, u'+  ASSERT_EQ(1U, lines.size());'), (318, 1, u'+  ASSERT_EQ(4U, lines.size());'), (340, 1, u'+  ASSERT_EQ(2U, lines.size());')]
===========================================
Class:class CPPLanguage: public Language { class CPPLanguage: public Language 
Class:  class JavaLanguage: public Language { class JavaLanguage: public Language 
Class:  class AssemblerLanguage: public Language { class AssemblerLanguage: public Language 
Class:class FDWrapper { class FDWrapper 
Class:      class MmapWrapper { class MmapWrapper 
Class:    class DumperLineToModule: public DwarfCUToModule::LineToModuleFunctor { class DumperLineToModule: public DwarfCUToModule::LineToModuleFunctor 
Class:        class LoadSymbolsInfo { class LoadSymbolsInfo 
Class: class DumpSymbols : public Test { class DumpSymbols : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(69, 1, u'+    ASSERT_TRUE(elf.GetContents(&contents));'), (70, 1, u'+    ASSERT_LT(0, contents.size());'), (120, 1, u'+  ASSERT_TRUE(WriteSymbolFileInternal(elfdata,'), (157, 1, u'+  ASSERT_TRUE(WriteSymbolFileInternal(elfdata,')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(72, 1, u'+  ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header) - 1));'), (73, 1, u'+  ASSERT_TRUE(mapped_core_file.Map(core_file));'), (82, 1, u'+  ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));'), (83, 1, u'+  ASSERT_TRUE(mapped_core_file.Map(core_file));'), (88, 1, u'+  ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));'), (89, 1, u'+  ASSERT_TRUE(mapped_core_file.Map(core_file));'), (94, 1, u'+  ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));'), (95, 1, u'+  ASSERT_TRUE(mapped_core_file.Map(core_file));'), (100, 1, u'+  ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));'), (101, 1, u'+  ASSERT_TRUE(mapped_core_file.Map(core_file));'), (106, 1, u'+  ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));'), (107, 1, u'+  ASSERT_TRUE(mapped_core_file.Map(core_file));'), (112, 1, u'+  ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));'), (113, 1, u'+  ASSERT_TRUE(mapped_core_file.Map(core_file));'), (118, 1, u'+  ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));'), (119, 1, u'+  ASSERT_TRUE(mapped_core_file.Map(core_file));'), (124, 1, u'+  ASSERT_TRUE(WriteFile(core_file, &header, sizeof(header)));'), (125, 1, u'+  ASSERT_TRUE(mapped_core_file.Map(core_file));'), (156, 1, u'+  ASSERT_TRUE(mapped_core_file.Map(crash_generator.GetCoreFilePath().c_str()));')]
===========================================
Class:class ELFSymbolIterator { class ELFSymbolIterator 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+    assert(value_size == 4 || value_size == 8);')]
===========================================
Class: class ELFSymbolsToModuleTestFixture { class ELFSymbolsToModuleTestFixture 
Class: class ELFSymbolsToModuleTest32 : public ELFSymbolsToModuleTestFixture,                                    public TestWithParam<Endianness>  {                                    public TestWithParam<Endianness>  
Class:        class ELFSymbolsToModuleTest64 : public ELFSymbolsToModuleTestFixture,                                  public TestWithParam<Endianness>  {                                  public TestWithParam<Endianness>  
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(89, 1, u'+  assert(elf_base);'), (90, 1, u'+  assert(section_start);'), (91, 1, u'+  assert(section_size);'), (93, 1, u'+  assert(my_strncmp(elf_base, ELFMAG, SELFMAG) == 0);'), (98, 1, u'+  assert(elf_header->e_ident[EI_CLASS] == ElfClass::kClass);'), (133, 1, u'+  assert(elf_mapped_base);'), (134, 1, u'+  assert(section_start);'), (135, 1, u'+  assert(section_size);')]
===========================================
Class: class FileIDTest : public testing::Test { class FileIDTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(66, 1, u'+  ASSERT_TRUE(SafeReadLink("/proc/self/exe", exe_name));'), (73, 1, u'+  ASSERT_EQ(system(cmdline), 0);'), (75, 1, u'+  ASSERT_EQ(system(cmdline), 0);'), (96, 1, u'+    ASSERT_TRUE(elf.GetContents(&contents));'), (97, 1, u'+    ASSERT_LT(0, contents.size());')]
===========================================
Class:class MockLibcurlWrapper : public LibcurlWrapper { class MockLibcurlWrapper : public LibcurlWrapper 
Class: class GoogleCrashdumpUploaderTest : public ::testing::Test { class GoogleCrashdumpUploaderTest : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(72, 1, u'+  ASSERT_FALSE(uploader->Upload());'), (79, 1, u'+  ASSERT_NE(fd, -1);'), (99, 1, u'+  ASSERT_TRUE(uploader->Upload());'), (119, 1, u'+  ASSERT_FALSE(uploader->Upload());'), (135, 1, u'+  ASSERT_FALSE(uploader.Upload());'), (150, 1, u'+  ASSERT_FALSE(uploader1.Upload());'), (164, 1, u'+  ASSERT_FALSE(uploader2.Upload());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 1, u'+  assert(buf_len > kGUIDStringLength);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+    ASSERT_EQ(strlen(test_data[i]), my_strlen(test_data[i]));'), (67, 1, u'+    ASSERT_EQ(my_strcmp(test_data[i*2], test_data[i*2 + 1]), libc_result);'), (74, 1, u'+  ASSERT_FALSE(my_strtoui(&result, ""));'), (75, 1, u'+  ASSERT_FALSE(my_strtoui(&result, "-1"));'), (76, 1, u'+  ASSERT_FALSE(my_strtoui(&result, "-"));'), (77, 1, u'+  ASSERT_FALSE(my_strtoui(&result, "a"));'), (78, 1, u'+  ASSERT_FALSE(my_strtoui(&result, "23472893472938472987987398472398"));'), (80, 1, u'+  ASSERT_TRUE(my_strtoui(&result, "0"));'), (81, 1, u'+  ASSERT_EQ(result, 0);'), (82, 1, u'+  ASSERT_TRUE(my_strtoui(&result, "1"));'), (83, 1, u'+  ASSERT_EQ(result, 1);'), (84, 1, u'+  ASSERT_TRUE(my_strtoui(&result, "12"));'), (85, 1, u'+  ASSERT_EQ(result, 12);'), (86, 1, u'+  ASSERT_TRUE(my_strtoui(&result, "123"));'), (87, 1, u'+  ASSERT_EQ(result, 123);'), (88, 1, u'+  ASSERT_TRUE(my_strtoui(&result, "0123"));'), (89, 1, u'+  ASSERT_EQ(result, 123);'), (93, 1, u'+  ASSERT_EQ(my_int_len(0), 1);'), (94, 1, u'+  ASSERT_EQ(my_int_len(2), 1);'), (95, 1, u'+  ASSERT_EQ(my_int_len(5), 1);'), (96, 1, u'+  ASSERT_EQ(my_int_len(9), 1);'), (97, 1, u'+  ASSERT_EQ(my_int_len(10), 2);'), (98, 1, u'+  ASSERT_EQ(my_int_len(99), 2);'), (99, 1, u'+  ASSERT_EQ(my_int_len(100), 3);'), (100, 1, u'+  ASSERT_EQ(my_int_len(101), 3);'), (101, 1, u'+  ASSERT_EQ(my_int_len(1000), 4);'), (108, 1, u'+  ASSERT_EQ(0, memcmp(buf, "0", 1));'), (111, 1, u'+  ASSERT_EQ(0, memcmp(buf, "1", 1));'), (114, 1, u'+  ASSERT_EQ(0, memcmp(buf, "10", 2));'), (117, 1, u'+  ASSERT_EQ(0, memcmp(buf, "63", 2));'), (120, 1, u'+  ASSERT_EQ(0, memcmp(buf, "101", 2));'), (124, 1, u'+  ASSERT_EQ(NULL, my_strchr("abc", \'d\'));'), (125, 1, u'+  ASSERT_EQ(NULL, my_strchr("", \'d\'));'), (126, 1, u'+  ASSERT_EQ(NULL, my_strchr("efghi", \'d\'));'), (128, 1, u'+  ASSERT_TRUE(my_strchr("a", \'a\'));'), (129, 1, u'+  ASSERT_TRUE(my_strchr("abc", \'a\'));'), (130, 1, u'+  ASSERT_TRUE(my_strchr("bcda", \'a\'));'), (131, 1, u'+  ASSERT_TRUE(my_strchr("sdfasdf", \'a\'));'), (139, 1, u'+  ASSERT_EQ(result, 0);'), (140, 1, u'+  ASSERT_EQ(*last, 0);'), (143, 1, u'+  ASSERT_EQ(result, 0);'), (144, 1, u'+  ASSERT_EQ(*last, 0);'), (147, 1, u'+  ASSERT_EQ(result, 0x123);'), (148, 1, u'+  ASSERT_EQ(*last, 0);'), (151, 1, u'+  ASSERT_EQ(result, 0x123a);'), (152, 1, u'+  ASSERT_EQ(*last, 0);'), (155, 1, u'+  ASSERT_EQ(result, 0x123a);'), (156, 1, u"+  ASSERT_EQ(*last, '-');")]
===========================================
Class:class MemoryMappedFileTest : public testing::Test { class MemoryMappedFileTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(88, 1, u'+  ASSERT_TRUE(WriteFile(test_file.c_str(), NULL, 0));'), (110, 1, u'+  ASSERT_TRUE(WriteFile(test_file.c_str(), data, data_size));'), (145, 1, u'+  ASSERT_TRUE(WriteFile(test_file1.c_str(), data1, data1_size));'), (146, 1, u'+  ASSERT_TRUE(WriteFile(test_file2.c_str(), data2, data2_size));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 1, u'+  assert(machine == EM_386 ||'), (28, 1, u'+  assert(file_class == ELFCLASS32 || file_class == ELFCLASS64);'), (50, 1, u'+  assert(Size() == EI_NIDENT);'), (152, 1, u'+  assert(addr_size_ == 4 || addr_size_ == 8);'), (157, 1, u'+  assert(addr_size_ == 4);'), (168, 1, u'+  assert(addr_size_ == 8);')]
===========================================
Class: class StringTableTest : public Test { class StringTableTest : public Test 
Class:class SymbolTableTest : public Test 
Class:class BasicElf : public Test 
Class:class Reader::SegmentFinder : public LoadCommandHandler { class Reader::SegmentFinder : public LoadCommandHandler 
Class:class Reader::SectionMapper: public SectionHandler { class Reader::SectionMapper: public SectionHandler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(58, 1, u'+#define ASSERT_ALWAYS_EVAL(x) (x)'), (60, 1, u'+#define ASSERT_ALWAYS_EVAL(x) assert(x)'), (224, 1, u'+  assert(!buffer_.start);')]
===========================================
Class:    class MockFatReaderReporter: public FatReader::Reporter { class MockFatReaderReporter: public FatReader::Reporter 
Class: class MockReaderReporter: public Reader::Reporter { class MockReaderReporter: public Reader::Reporter 
Class: class MockLoadCommandHandler: public Reader::LoadCommandHandler { class MockLoadCommandHandler: public Reader::LoadCommandHandler 
Class: class MockSectionHandler: public Reader::SectionHandler { class MockSectionHandler: public Reader::SectionHandler 
Class:class FatReaderTest: public FatReaderFixture, public Test 
Class:     class WithConfiguration { class WithConfiguration 
Class:    class SizedSection: public test_assembler::Section { class SizedSection: public test_assembler::Section 
Class:  class LoadedSection: public SizedSection { class LoadedSection: public SizedSection 
Class:  class SegmentLoadCommand: public SizedSection { class SegmentLoadCommand: public SizedSection 
Class:  class LoadCommands: public SizedSection { class LoadCommands: public SizedSection 
Class:   class MachOFile: public SizedSection { class MachOFile: public SizedSection 
Class:class ReaderTest: public ReaderFixture, public Test 
Class:class LoadCommand: public ReaderFixture, public Test 
Class:      class StringAssembler: public SizedSection { class StringAssembler: public SizedSection 
Class:   class SymbolAssembler: public SizedSection { class SymbolAssembler: public SizedSection 
Class:class Symtab: public ReaderFixture, public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 1, u'+    assert(arch);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+    ASSERT_FALSE(p == NULL);'), (57, 1, u'+  ASSERT_FALSE(p == NULL);'), (60, 1, u'+    ASSERT_FALSE(p == NULL);'), (72, 1, u'+  ASSERT_TRUE(v.empty());'), (73, 1, u'+  ASSERT_EQ(v.size(), 0u);'), (82, 1, u'+    ASSERT_EQ(i, v.back());'), (83, 1, u'+    ASSERT_EQ(&v.back(), &v[i]);'), (85, 1, u'+  ASSERT_FALSE(v.empty());'), (86, 1, u'+  ASSERT_EQ(v.size(), 256u);'), (88, 1, u'+    ASSERT_EQ(v[i], i);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 1, u'+  assert(!function->name.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(355, 1, u'+  ASSERT_EQ(3U, entries.size());'), (359, 1, u'+  ASSERT_EQ(0U, entries[0]->initial_rules.size());'), (360, 1, u'+  ASSERT_EQ(0U, entries[0]->rule_changes.size());'), (364, 1, u'+  ASSERT_EQ(3U, entries[1]->initial_rules.size());'), (370, 1, u'+  ASSERT_EQ(0U, entries[1]->rule_changes.size());')]
===========================================
Class:class FDWrapper { class FDWrapper 
Class:      class MmapWrapper { class MmapWrapper 
Class:class AutoElfEnder { class AutoElfEnder 
Class:class AutoElfEnder { class AutoElfEnder 
Class: class AutoCloser { class AutoCloser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 1, u'+  assert(buf_len > kGUIDStringLength);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 1, u'+  assert(value_size == 4 || value_size == 8);'), (128, 1, u'+  assert(!iterator_->at_end && iterator_->type == N_SO);'), (201, 1, u'+    assert(iterator_->type == N_SO);'), (218, 1, u'+  assert(!iterator_->at_end && iterator_->type == N_FUN);'), (267, 1, u'+    assert(iterator_->type == N_SO || iterator_->type == N_FUN);'), (298, 1, u'+  assert(!iterator_->at_end &&')]
===========================================
Class:class StringAssembler: public Section { class StringAssembler: public Section 
Class:   class StabsAssembler: public Section { class StabsAssembler: public Section 
Class: class MockStabsReaderHandler: public StabsHandler { class MockStabsReaderHandler: public StabsHandler 
Class:class Stabs: public StabsFixture, public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(107, 1, u'+    assert(in_cu_);'), (135, 1, u'+  ~StabsAssembler() { assert(!cu_header_); }'), (170, 1, u'+    assert(!cu_header_);'), (183, 1, u'+    assert(cu_header_);'), (325, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());'), (343, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());'), (367, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());'), (380, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());'), (405, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());'), (448, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());'), (474, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());'), (517, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());'), (556, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());'), (579, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());'), (605, 1, u'+  ASSERT_TRUE(ApplyHandlerToMockStabsData());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 1, u'+  assert(!in_compilation_unit_);'), (81, 1, u'+  assert(in_compilation_unit_);'), (93, 1, u'+  assert(!current_function_);'), (105, 1, u'+  assert(current_function_);'), (121, 1, u'+  assert(current_function_);'), (122, 1, u'+  assert(current_source_file_);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 1, u'+  ASSERT_TRUE(file != NULL);'), (63, 1, u'+  ASSERT_EQ((size_t) 1, functions.size());'), (69, 1, u'+  ASSERT_EQ((size_t) 1, function->lines.size());'), (93, 1, u'+  ASSERT_EQ((size_t) 3, externs.size());'), (125, 1, u'+  ASSERT_TRUE(file != NULL);'), (129, 1, u'+  ASSERT_EQ(1U, functions.size());'), (135, 1, u'+  ASSERT_EQ(0U, function->lines.size());'), (158, 1, u'+  ASSERT_TRUE(file1 != NULL);'), (160, 1, u'+  ASSERT_TRUE(file2 != NULL);'), (164, 1, u'+  ASSERT_EQ((size_t) 1, functions.size());'), (171, 1, u'+  ASSERT_EQ((size_t) 2, function->lines.size());'), (205, 1, u'+  ASSERT_TRUE(file != NULL);'), (209, 1, u'+  ASSERT_EQ(1U, functions.size());'), (221, 1, u'+  ASSERT_EQ(0U, function->lines.size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 1, u'+#define ALWAYS_EVALUATE_AND_ASSERT(x) x'), (89, 1, u'+#define ALWAYS_EVALUATE_AND_ASSERT(x) assert(x)'), (94, 1, u'+  ALWAYS_EVALUATE_AND_ASSERT(IsKnownOffsetFrom(label, &offset));'), (100, 1, u'+  ALWAYS_EVALUATE_AND_ASSERT(IsKnownConstant(&v));'), (133, 1, u'+  assert(reference_count_ == 0);'), (141, 1, u'+    assert(addend_ == addend);'), (161, 1, u'+    assert(binding != this);'), (207, 1, u'+  assert(size > 0);'), (214, 1, u'+    assert(endianness == kBigEndian);'), (237, 1, u'+  assert(endianness != kUnsetEndian);'), (326, 1, u'+  assert(((alignment - 1) & alignment) == 0);'), (329, 1, u'+  assert((contents_.size() & (alignment - 1)) == 0);'), (348, 1, u'+    assert(r.offset < contents_.size());'), (349, 1, u'+    assert(contents_.size() - r.offset >= r.size);')]
===========================================
Class:  class SectionFixture { class SectionFixture 
Class:class Append: public SectionFixture, public Test 
Class:class GetContents: public SectionFixture, public Test 
Class:class Miscellanea: public SectionFixture, public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(58, 1, u'+  ASSERT_DEATH(l.Value(), "IsKnownConstant\\\\(&v\\\\)");'), (215, 1, u'+  ASSERT_DEATH(l = l, "binding != this");'), (222, 1, u'+  ASSERT_DEATH(n = l, "binding != this");'), (230, 1, u'+  ASSERT_DEATH(o = l, "binding != this");'), (301, 1, u'+  ASSERT_DEATH(l - m, "IsKnownOffsetFrom\\\\(label, &offset\\\\)");'), (680, 1, u'+  ASSERT_DEATH(m = n, "addend_ == addend");'), (688, 1, u'+  ASSERT_DEATH(m = n, "addend_ == addend");'), (702, 1, u'+  ASSERT_EQ(0xca8bae92f0376d4fULL, l.Value());'), (719, 1, u'+  ASSERT_EQ(0x7a0b0c576672daafULL, l.Value());'), (753, 1, u'+#define ASSERT_BYTES(s, b)                                              \\'), (757, 1, u'+      ASSERT_EQ(sizeof(expected_bytes), s.size());                      \\'), (758, 1, u'+      ASSERT_TRUE(memcmp(s.data(), (const char *) expected_bytes,       \\'), (767, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (768, 1, u'+  ASSERT_EQ(sizeof(data), contents.size());'), (775, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (776, 1, u'+  ASSERT_EQ(2 * sizeof(data), contents.size());'), (777, 1, u'+  ASSERT_TRUE(0 == memcmp(contents.data(), (const char *) data, sizeof(data)));'), (778, 1, u'+  ASSERT_TRUE(0 == memcmp(contents.data() + sizeof(data),'), (787, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (788, 1, u'+  ASSERT_STREQ(contents.c_str(), "howdy there");'), (795, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (796, 1, u'+  ASSERT_EQ(string("howdy\\0\\0there\\0", 13), contents);'), (805, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (806, 1, u'+  ASSERT_EQ(string("howtherefred\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0", 24), contents);'), (811, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (812, 1, u'+  ASSERT_STREQ(contents.c_str(), "**********");'), (817, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (818, 1, u'+  ASSERT_BYTES(contents, I1(42));'), (823, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (824, 1, u'+  ASSERT_BYTES(contents, I2(0xa1, 0x15));'), (829, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (830, 1, u'+  ASSERT_BYTES(contents, I3(0x8d, 0xae, 0x59));'), (835, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (836, 1, u'+  ASSERT_BYTES(contents, I4(0x56, 0x3c, 0x60, 0x51));'), (841, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (842, 1, u'+  ASSERT_BYTES(contents, I5(0xb4, 0x03, 0x28, 0x5e, 0x38));'), (847, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (848, 1, u'+  ASSERT_BYTES(contents, I6(0x1f, 0xdd, 0x34, 0x95, 0xdb, 0xc7));'), (853, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (854, 1, u'+  ASSERT_BYTES(contents, I7(0xe6, 0x43, 0xb8, 0xf1, 0xc9, 0x45, 0x14));'), (859, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (860, 1, u'+  ASSERT_BYTES(contents, I8(0xe5, 0x01, 0x5c, 0xfe, 0x9d, 0x01, 0x48, 0xaf));'), (865, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (866, 1, u'+  ASSERT_BYTES(contents, I1(0xd0));'), (871, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (872, 1, u'+  ASSERT_BYTES(contents, I2(0x2e, 0x7e));'), (877, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (878, 1, u'+  ASSERT_BYTES(contents, I3(0x37, 0xda, 0xd6));'), (883, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (884, 1, u'+  ASSERT_BYTES(contents, I4(0x71, 0x59, 0x35, 0xc7));'), (889, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (890, 1, u'+  ASSERT_BYTES(contents, I5(0x42, 0xba, 0xeb, 0x02, 0xb7));'), (895, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (896, 1, u'+  ASSERT_BYTES(contents, I6(0xf1, 0xcd, 0xf1, 0x0e, 0x7b, 0x18));'), (901, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (902, 1, u'+  ASSERT_BYTES(contents, I7(0xf5, 0x0a, 0x72, 0x4f, 0x0b, 0x0d, 0x20));'), (907, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (908, 1, u'+  ASSERT_BYTES(contents, I8(0xa6, 0xb2, 0xcb, 0x5e, 0x98, 0xdc, 0x9c, 0x16));'), (915, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (916, 1, u'+  ASSERT_BYTES(contents, I1(42));'), (923, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (924, 1, u'+  ASSERT_BYTES(contents, I2(0xa1, 0x15));'), (931, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (932, 1, u'+  ASSERT_BYTES(contents, I3(0x8d, 0xae, 0x59));'), (939, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (940, 1, u'+  ASSERT_BYTES(contents, I4(0x56, 0x3c, 0x60, 0x51));'), (947, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (948, 1, u'+  ASSERT_BYTES(contents, I5(0xb4, 0x03, 0x28, 0x5e, 0x38));'), (955, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (956, 1, u'+  ASSERT_BYTES(contents, I6(0x1f, 0xdd, 0x34, 0x95, 0xdb, 0xc7));'), (963, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (964, 1, u'+  ASSERT_BYTES(contents, I7(0xe6, 0x43, 0xb8, 0xf1, 0xc9, 0x45, 0x14));'), (971, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (972, 1, u'+  ASSERT_BYTES(contents, I8(0xe5, 0x01, 0x5c, 0xfe, 0x9d, 0x01, 0x48, 0xaf));'), (979, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (980, 1, u'+  ASSERT_BYTES(contents, I1(0xd0));'), (987, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (988, 1, u'+  ASSERT_BYTES(contents, I2(0x2e, 0x7e));'), (995, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (996, 1, u'+  ASSERT_BYTES(contents, I3(0x37, 0xda, 0xd6));'), (1003, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1004, 1, u'+  ASSERT_BYTES(contents, I4(0x71, 0x59, 0x35, 0xc7));'), (1011, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1012, 1, u'+  ASSERT_BYTES(contents, I5(0x42, 0xba, 0xeb, 0x02, 0xb7));'), (1019, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1020, 1, u'+  ASSERT_BYTES(contents, I6(0xf1, 0xcd, 0xf1, 0x0e, 0x7b, 0x18));'), (1027, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1028, 1, u'+  ASSERT_BYTES(contents, I7(0xf5, 0x0a, 0x72, 0x4f, 0x0b, 0x0d, 0x20));'), (1035, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1036, 1, u'+  ASSERT_BYTES(contents, I8(0xa6, 0xb2, 0xcb, 0x5e, 0x98, 0xdc, 0x9c, 0x16));'), (1042, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1043, 1, u'+  ASSERT_BYTES(contents, I2(0x2a, 0xd3));'), (1051, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1052, 1, u'+  ASSERT_BYTES(contents, I2(0x2a, 0x4b));'), (1058, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1059, 1, u'+  ASSERT_BYTES(contents, I3(0x2a, 0x47, 0x2a));'), (1067, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1068, 1, u'+  ASSERT_BYTES(contents, I3(0x2a, 0x55, 0xe8));'), (1074, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1075, 1, u'+  ASSERT_BYTES(contents, I5(0x2a, 0xbd, 0x41, 0x2c, 0xbc));'), (1083, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1084, 1, u'+  ASSERT_BYTES(contents, I5(0x2a, 0x20, 0x8e, 0x37, 0xd5));'), (1090, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1091, 1, u'+  ASSERT_BYTES(contents,'), (1100, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1101, 1, u'+  ASSERT_BYTES(contents,'), (1108, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1109, 1, u'+  ASSERT_BYTES(contents, I2(0x2a, 0x26));'), (1117, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1118, 1, u'+  ASSERT_BYTES(contents, I2(0x2a, 0xa8));'), (1124, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1125, 1, u'+  ASSERT_BYTES(contents, I3(0x2a, 0x6d, 0xca));'), (1133, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1134, 1, u'+  ASSERT_BYTES(contents, I3(0x2a, 0x1f, 0xd2));'), (1140, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1141, 1, u'+  ASSERT_BYTES(contents, I5(0x2a, 0x81, 0x61, 0x8f, 0x55));'), (1149, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1150, 1, u'+  ASSERT_BYTES(contents, I5(0x2a, 0x82, 0x0f, 0x81, 0x4b));'), (1156, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1157, 1, u'+  ASSERT_BYTES(contents,'), (1166, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1167, 1, u'+  ASSERT_BYTES(contents,'), (1175, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1176, 1, u'+  ASSERT_BYTES(contents, I2(0x2a, 0xe6));'), (1185, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1186, 1, u'+  ASSERT_BYTES(contents, I2(0x2a, 0xee));'), (1193, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1194, 1, u'+  ASSERT_BYTES(contents, I3(0x2a, 0x83, 0xb1));'), (1203, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1204, 1, u'+  ASSERT_BYTES(contents, I3(0x2a, 0x5b, 0x55));'), (1211, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1212, 1, u'+  ASSERT_BYTES(contents, I5(0x2a, 0xd0, 0xb0, 0xe4, 0x31));'), (1221, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1222, 1, u'+  ASSERT_BYTES(contents, I5(0x2a, 0x31, 0x2f, 0xb3, 0x40));'), (1229, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1230, 1, u'+  ASSERT_BYTES(contents,'), (1240, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1241, 1, u'+  ASSERT_BYTES(contents,'), (1249, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1250, 1, u'+  ASSERT_BYTES(contents, I2(0x2a, 0x42));'), (1259, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1260, 1, u'+  ASSERT_BYTES(contents, I2(0x2a, 0x05));'), (1267, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1268, 1, u'+  ASSERT_BYTES(contents, I3(0x2a, 0xc5, 0xc5));'), (1277, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1278, 1, u'+  ASSERT_BYTES(contents, I3(0x2a, 0x20, 0xb6));'), (1285, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1286, 1, u'+  ASSERT_BYTES(contents, I5(0x2a, 0xfe, 0xd0, 0x87, 0x1a));'), (1295, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1296, 1, u'+  ASSERT_BYTES(contents, I5(0x2a, 0x6b, 0x2d, 0x01, 0xb8));'), (1303, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1304, 1, u'+  ASSERT_BYTES(contents,'), (1314, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1315, 1, u'+  ASSERT_BYTES(contents,'), (1361, 1, u'+  ASSERT_EQ(8 * 18U, section.Size());'), (1362, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1383, 1, u'+  ASSERT_TRUE(0 == memcmp(contents.data(), expected, sizeof(expected)));'), (1595, 1, u'+  ASSERT_FALSE(section.GetContents(&contents));'), (1609, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1610, 1, u'+  ASSERT_BYTES(contents, I1(42));'), (1611, 1, u'+  ASSERT_TRUE(section.GetContents(&contents)); // should not die'), (1624, 1, u'+  ASSERT_TRUE(section.GetContents(&contents)); // should not die'), (1643, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (1644, 1, u'+  ASSERT_EQ(string("*   **"), contents);')]
===========================================
Class:class HTTPUpload::AutoInternetHandle { class HTTPUpload::AutoInternetHandle 
Class:class AutoImage { class AutoImage 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 1, u'+  assert(wcs);'), (59, 1, u'+  assert(wcs_length > 0);'), (92, 1, u'+  assert(mbs);'), (102, 1, u'+  assert(mbs_length > 0);')]
===========================================
Class:class CountedObject { class CountedObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 1, u'+  assert(that);')]
===========================================
Class:class TestCodeModule : public CodeModule { class TestCodeModule : public CodeModule 
Class:  class MockMemoryRegion: public MemoryRegion { class MockMemoryRegion: public MemoryRegion 
Class: class TestBasicSourceLineResolver : public ::testing::Test { class TestBasicSourceLineResolver : public ::testing::Test 
Class:class BinaryStreamBasicTest : public ::testing::Test { class BinaryStreamBasicTest : public ::testing::Test 
Class: class BinaryStreamU8Test : public ::testing::Test { class BinaryStreamU8Test : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 1, u'+  ASSERT_FALSE(stream.eof());'), (53, 1, u'+  ASSERT_TRUE(stream.eof());'), (58, 1, u'+  ASSERT_FALSE(stream.eof());'), (66, 1, u'+  ASSERT_FALSE(stream.eof());'), (68, 1, u'+  ASSERT_TRUE(stream.eof());'), (73, 1, u'+  ASSERT_FALSE(stream.eof());'), (81, 1, u'+  ASSERT_FALSE(stream.eof());'), (83, 1, u'+  ASSERT_TRUE(stream.eof());'), (88, 1, u'+  ASSERT_FALSE(stream.eof());'), (96, 1, u'+  ASSERT_FALSE(stream.eof());'), (98, 1, u'+  ASSERT_TRUE(stream.eof());'), (103, 1, u'+  ASSERT_FALSE(stream.eof());'), (111, 1, u'+  ASSERT_FALSE(stream.eof());'), (113, 1, u'+  ASSERT_TRUE(stream.eof());'), (126, 1, u'+  ASSERT_FALSE(stream.eof());'), (144, 1, u'+  ASSERT_FALSE(stream.eof());'), (149, 1, u'+  ASSERT_FALSE(stream.eof());'), (153, 1, u'+  ASSERT_TRUE(stream.eof());'), (157, 1, u'+  ASSERT_FALSE(stream.eof());'), (174, 1, u'+  ASSERT_FALSE(stream.eof());'), (179, 1, u'+  ASSERT_FALSE(stream.eof());'), (187, 1, u'+  ASSERT_FALSE(stream.eof());'), (204, 1, u'+  ASSERT_FALSE(stream.eof());'), (209, 1, u'+  ASSERT_FALSE(stream.eof());'), (217, 1, u'+  ASSERT_FALSE(stream.eof());'), (235, 1, u'+  ASSERT_FALSE(stream.eof());'), (240, 1, u'+  ASSERT_FALSE(stream.eof());'), (248, 1, u'+  ASSERT_FALSE(stream.eof());'), (353, 1, u'+  ASSERT_FALSE(stream.eof());'), (355, 1, u'+  ASSERT_TRUE(stream.eof());'), (361, 1, u'+  ASSERT_FALSE(stream.eof());'), (363, 1, u'+  ASSERT_TRUE(stream.eof());'), (369, 1, u'+  ASSERT_FALSE(stream.eof());'), (371, 1, u'+  ASSERT_TRUE(stream.eof());'), (377, 1, u'+  ASSERT_FALSE(stream.eof());'), (379, 1, u'+  ASSERT_TRUE(stream.eof());'), (389, 1, u'+  ASSERT_FALSE(stream.eof());'), (401, 1, u'+  ASSERT_FALSE(stream.eof());'), (420, 1, u'+  ASSERT_FALSE(stream.eof());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(152, 1, u'+      assert(token_len > 0); // strtok_r guarantees this, I think.')]
===========================================
Class: class MockMemoryRegion: public MemoryRegion { class MockMemoryRegion: public MemoryRegion 
Class:class Simple: public CFIFixture, public Test 
Class:class Scope: public CFIFixture, public Test 
Class: class MockCFIRuleParserHandler: public CFIRuleParser::Handler { class MockCFIRuleParserHandler: public CFIRuleParser::Handler 
Class:  class CFIParserFixture { class CFIParserFixture 
Class:class Parser: public CFIParserFixture, public Test 
Class: class ParseHandlerFixture: public CFIFixture { class ParseHandlerFixture: public CFIFixture 
Class:class ParseHandler: public ParseHandlerFixture, public Test 
Class:class SimpleWalker: public SimpleCFIWalkerFixture, public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+#define ASSERT_TRUE(condition) \\'), (47, 1, u'+#define ASSERT_FALSE(condition) ASSERT_TRUE(!(condition))'), (61, 1, u'+  ASSERT_TRUE (crm.StoreRange(10, 10,  1));'), (62, 1, u'+  ASSERT_FALSE(crm.StoreRange(10, 10,  2));  // exactly equal to 1'), (63, 1, u'+  ASSERT_FALSE(crm.StoreRange(11, 10,  3));  // begins inside 1 and extends up'), (64, 1, u'+  ASSERT_FALSE(crm.StoreRange( 9, 10,  4));  // begins below 1 and ends inside'), (65, 1, u'+  ASSERT_TRUE (crm.StoreRange(11,  9,  5));  // contained by existing'), (66, 1, u'+  ASSERT_TRUE (crm.StoreRange(12,  7,  6));'), (67, 1, u'+  ASSERT_TRUE (crm.StoreRange( 9, 12,  7));  // contains existing'), (68, 1, u'+  ASSERT_TRUE (crm.StoreRange( 9, 13,  8));'), (69, 1, u'+  ASSERT_TRUE (crm.StoreRange( 8, 14,  9));'), (70, 1, u'+  ASSERT_TRUE (crm.StoreRange(30,  3, 10));'), (71, 1, u'+  ASSERT_TRUE (crm.StoreRange(33,  3, 11));'), (72, 1, u'+  ASSERT_TRUE (crm.StoreRange(30,  6, 12));  // storable but totally masked'), (73, 1, u'+  ASSERT_TRUE (crm.StoreRange(40,  8, 13));  // will be totally masked'), (74, 1, u'+  ASSERT_TRUE (crm.StoreRange(40,  4, 14));'), (75, 1, u'+  ASSERT_TRUE (crm.StoreRange(44,  4, 15));'), (76, 1, u'+  ASSERT_FALSE(crm.StoreRange(32, 10, 16));  // begins in #10, ends in #14'), (77, 1, u'+  ASSERT_FALSE(crm.StoreRange(50,  0, 17));  // zero length'), (78, 1, u'+  ASSERT_TRUE (crm.StoreRange(50, 10, 18));'), (79, 1, u'+  ASSERT_TRUE (crm.StoreRange(50,  1, 19));'), (80, 1, u'+  ASSERT_TRUE (crm.StoreRange(59,  1, 20));'), (81, 1, u'+  ASSERT_TRUE (crm.StoreRange(60,  1, 21));'), (82, 1, u'+  ASSERT_TRUE (crm.StoreRange(69,  1, 22));'), (83, 1, u'+  ASSERT_TRUE (crm.StoreRange(60, 10, 23));'), (84, 1, u'+  ASSERT_TRUE (crm.StoreRange(68,  1, 24));'), (85, 1, u'+  ASSERT_TRUE (crm.StoreRange(61,  1, 25));'), (86, 1, u'+  ASSERT_TRUE (crm.StoreRange(61,  8, 26));'), (87, 1, u'+  ASSERT_FALSE(crm.StoreRange(59,  9, 27));'), (88, 1, u'+  ASSERT_FALSE(crm.StoreRange(59, 10, 28));'), (89, 1, u'+  ASSERT_FALSE(crm.StoreRange(59, 11, 29));'), (90, 1, u'+  ASSERT_TRUE (crm.StoreRange(70, 10, 30));'), (91, 1, u'+  ASSERT_TRUE (crm.StoreRange(74,  2, 31));'), (92, 1, u'+  ASSERT_TRUE (crm.StoreRange(77,  2, 32));'), (93, 1, u'+  ASSERT_FALSE(crm.StoreRange(72,  6, 33));'), (94, 1, u'+  ASSERT_TRUE (crm.StoreRange(80,  3, 34));'), (95, 1, u'+  ASSERT_TRUE (crm.StoreRange(81,  1, 35));'), (96, 1, u'+  ASSERT_TRUE (crm.StoreRange(82,  1, 36));'), (97, 1, u'+  ASSERT_TRUE (crm.StoreRange(83,  3, 37));'), (98, 1, u'+  ASSERT_TRUE (crm.StoreRange(84,  1, 38));'), (99, 1, u'+  ASSERT_TRUE (crm.StoreRange(83,  1, 39));'), (100, 1, u'+  ASSERT_TRUE (crm.StoreRange(86,  5, 40));'), (101, 1, u'+  ASSERT_TRUE (crm.StoreRange(88,  1, 41));'), (102, 1, u'+  ASSERT_TRUE (crm.StoreRange(90,  1, 42));'), (103, 1, u'+  ASSERT_TRUE (crm.StoreRange(86,  1, 43));'), (104, 1, u'+  ASSERT_TRUE (crm.StoreRange(87,  1, 44));'), (105, 1, u'+  ASSERT_TRUE (crm.StoreRange(89,  1, 45));'), (106, 1, u'+  ASSERT_TRUE (crm.StoreRange(87,  4, 46));'), (107, 1, u'+  ASSERT_TRUE (crm.StoreRange(87,  3, 47));'), (108, 1, u'+  ASSERT_FALSE(crm.StoreRange(86,  2, 48));')]
===========================================
Class:class MockMinidump : public Minidump { class MockMinidump : public Minidump 
Class:class TestSymbolSupplier : public SymbolSupplier { class TestSymbolSupplier : public SymbolSupplier 
Class:class TestCodeModule : public CodeModule { class TestCodeModule : public CodeModule 
Class:  class MockMemoryRegion: public MemoryRegion { class MockMemoryRegion: public MemoryRegion 
Class: class TestFastSourceLineResolver : public ::testing::Test { class TestFastSourceLineResolver : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 1, u'+  assert(error_string);')]
===========================================
Class: class TestStdMapSerializer : public ::testing::Test { class TestStdMapSerializer : public ::testing::Test 
Class: class TestAddressMapSerializer : public ::testing::Test { class TestAddressMapSerializer : public ::testing::Test 
Class:  class TestRangeMapSerializer : public ::testing::Test { class TestRangeMapSerializer : public ::testing::Test 
Class:  class TestContainedRangeMapSerializer : public ::testing::Test { class TestContainedRangeMapSerializer : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(263, 1, u'+  ASSERT_TRUE(range_map_.StoreRange(2, 4, 1));'), (264, 1, u'+  ASSERT_TRUE(range_map_.StoreRange(6, 4, 2));'), (265, 1, u'+  ASSERT_TRUE(range_map_.StoreRange(10, 11, 3));'), (367, 1, u'+  ASSERT_TRUE(crm_map_.StoreRange(2, 7, -1));'), (369, 1, u'+  ASSERT_TRUE(crm_map_.StoreRange(10, 11, -1));'), (371, 1, u'+  ASSERT_TRUE(crm_map_.StoreRange(3, 2, -1));'), (373, 1, u'+  ASSERT_TRUE(crm_map_.StoreRange(6, 2, -1));'), (375, 1, u'+  ASSERT_TRUE(crm_map_.StoreRange(16, 5, -1));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(1191, 1, u'+  assert(value);'), (1375, 1, u'+  assert(thread_id);'), (1800, 1, u'+      assert(cv_record_70->cv_signature == MD_CVINFOPDB70_SIGNATURE);'), (1808, 1, u'+      assert(cv_record_20->cv_header.signature == MD_CVINFOPDB20_SIGNATURE);'), (1881, 1, u'+      assert(cv_record_70->cv_signature == MD_CVINFOPDB70_SIGNATURE);'), (1905, 1, u'+      assert(cv_record_20->cv_header.signature == MD_CVINFOPDB20_SIGNATURE);'), (2239, 1, u'+      assert(cv_record_70->cv_signature == MD_CVINFOPDB70_SIGNATURE);'), (2262, 1, u'+      assert(cv_record_20->cv_header.signature == MD_CVINFOPDB20_SIGNATURE);'), (2822, 1, u'+  assert(thread_id);'), (2908, 1, u'+MinidumpAssertion::MinidumpAssertion(Minidump* minidump)'), (2910, 1, u'+      assertion_(),'), (2917, 1, u'+MinidumpAssertion::~MinidumpAssertion() {'), (2921, 1, u'+bool MinidumpAssertion::Read(u_int32_t expected_size) {'), (2925, 1, u'+  if (expected_size != sizeof(assertion_)) {'), (2927, 1, u'+                    " != " << sizeof(assertion_);'), (2931, 1, u'+  if (!minidump_->ReadBytes(&assertion_, sizeof(assertion_))) {'), (2942, 1, u'+  u_int32_t word_length = UTF16codeunits(assertion_.expression,'), (2943, 1, u'+                                         sizeof(assertion_.expression));'), (2947, 1, u'+    memcpy(&expression_utf16[0], &assertion_.expression[0], byte_length);'), (2956, 1, u'+  word_length = UTF16codeunits(assertion_.function,'), (2957, 1, u'+                               sizeof(assertion_.function));'), (2961, 1, u'+    memcpy(&function_utf16[0], &assertion_.function[0], byte_length);'), (2969, 1, u'+  word_length = UTF16codeunits(assertion_.file,'), (2970, 1, u'+                               sizeof(assertion_.file));'), (2974, 1, u'+    memcpy(&file_utf16[0], &assertion_.file[0], byte_length);'), (2982, 1, u'+    Swap(&assertion_.line);'), (2983, 1, u'+    Swap(&assertion_.type);'), (2990, 1, u'+void MinidumpAssertion::Print() {'), (3004, 1, u'+         assertion_.line);'), (3006, 1, u'+         assertion_.type);'), (3391, 1, u'+  assert(thread_id);'), (3413, 1, u'+  assert(thread_id);'), (3935, 1, u'+MinidumpAssertion* Minidump::GetAssertion() {'), (3936, 1, u'+  MinidumpAssertion* assertion;'), (3937, 1, u'+  return GetStream(&assertion);'), (4130, 1, u'+  assert(stream_length);'), (4175, 1, u'+  assert(stream);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 1, u'+using google_breakpad::MinidumpAssertion;'), (136, 1, u'+  MinidumpAssertion *assertion = minidump.GetAssertion();'), (137, 1, u'+  if (!assertion) {'), (140, 1, u'+    assertion->Print();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(63, 1, u'+  assert(dump);'), (64, 1, u'+  assert(process_state);'), (100, 1, u'+  process_state->assertion_ = GetAssertion(dump);'), (292, 1, u'+  assert(dump);'), (293, 1, u'+  assert(info);'), (359, 1, u'+  assert(dump);'), (360, 1, u'+  assert(info);'), (1082, 1, u'+string MinidumpProcessor::GetAssertion(Minidump *dump) {'), (1083, 1, u'+  MinidumpAssertion *assertion = dump->GetAssertion();'), (1084, 1, u'+  if (!assertion)'), (1087, 1, u'+  const MDRawAssertionInfo *raw_assertion = assertion->assertion();'), (1088, 1, u'+  if (!raw_assertion)'), (1091, 1, u'+  string assertion_string;'), (1092, 1, u'+  switch (raw_assertion->type) {'), (1093, 1, u'+  case MD_ASSERTION_INFO_TYPE_INVALID_PARAMETER:'), (1094, 1, u'+    assertion_string = "Invalid parameter passed to library function";'), (1096, 1, u'+  case MD_ASSERTION_INFO_TYPE_PURE_VIRTUAL_CALL:'), (1097, 1, u'+    assertion_string = "Pure virtual function called";'), (1100, 1, u'+    char assertion_type[32];'), (1101, 1, u'+    sprintf(assertion_type, "0x%08x", raw_assertion->type);'), (1102, 1, u'+    assertion_string = "Unknown assertion type ";'), (1103, 1, u'+    assertion_string += assertion_type;'), (1108, 1, u'+  string expression = assertion->expression();'), (1110, 1, u'+    assertion_string.append(" " + expression);'), (1113, 1, u'+  string function = assertion->function();'), (1115, 1, u'+    assertion_string.append(" in function " + function);'), (1118, 1, u'+  string file = assertion->file();'), (1120, 1, u'+    assertion_string.append(", in file " + file);'), (1123, 1, u'+  if (raw_assertion->line != 0) {'), (1124, 1, u'+    char assertion_line[32];'), (1125, 1, u'+    sprintf(assertion_line, "%u", raw_assertion->line);'), (1126, 1, u'+    assertion_string.append(" at line ");'), (1127, 1, u'+    assertion_string.append(assertion_line);'), (1130, 1, u'+  return assertion_string;')]
===========================================
Class:class MockMinidump : public Minidump { class MockMinidump : public Minidump 
Class:class TestSymbolSupplier : public SymbolSupplier { class TestSymbolSupplier : public SymbolSupplier 
Class:   class MockSymbolSupplier : public SymbolSupplier { class MockSymbolSupplier : public SymbolSupplier 
Class: class MinidumpProcessorTest : public ::testing::Test { class MinidumpProcessorTest : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(276, 1, u'+      assert(!frame->module->code_file().empty());'), (407, 1, u'+  string assertion = process_state.assertion();'), (408, 1, u'+  if (!assertion.empty()) {'), (409, 1, u'+    printf("Assertion: %s\\n", assertion.c_str());'), (466, 1, u'+    string assertion = process_state.assertion();'), (467, 1, u'+    if (!assertion.empty()) {'), (468, 1, u'+      printf("%s%c%c", StripSeparator(assertion).c_str(),')]
===========================================
Class:class MinidumpTest : public ::testing::Test { class MinidumpTest : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 1, u'+  ASSERT_EQ(minidump.path(), minidump_file_);'), (88, 1, u'+  ASSERT_TRUE(minidump.Read());'), (90, 1, u'+  ASSERT_NE(header, (MDRawHeader*)NULL);'), (91, 1, u'+  ASSERT_EQ(header->signature, u_int32_t(MD_HEADER_SIGNATURE));'), (98, 1, u'+  ASSERT_TRUE(file_stream.good());'), (101, 1, u'+  ASSERT_TRUE(file_stream.good());'), (104, 1, u'+  ASSERT_TRUE(file_stream.good());'), (106, 1, u'+  ASSERT_TRUE(file_stream.good());'), (109, 1, u'+  ASSERT_TRUE(stream.good());'), (113, 1, u'+  ASSERT_EQ(minidump.path(), "");'), (114, 1, u'+  ASSERT_TRUE(minidump.Read());'), (116, 1, u'+  ASSERT_NE(header, (MDRawHeader*)NULL);'), (117, 1, u'+  ASSERT_EQ(header->signature, u_int32_t(MD_HEADER_SIGNATURE));'), (125, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (128, 1, u'+  ASSERT_TRUE(minidump.Read());'), (129, 1, u'+  ASSERT_EQ(0U, minidump.GetDirectoryEntryCount());'), (136, 1, u'+  ASSERT_TRUE(big_minidump.GetContents(&contents));'), (139, 1, u'+  ASSERT_TRUE(minidump.Read());'), (140, 1, u'+  ASSERT_EQ(0U, minidump.GetDirectoryEntryCount());'), (151, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (154, 1, u'+  ASSERT_TRUE(minidump.Read());'), (155, 1, u'+  ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());'), (158, 1, u'+  ASSERT_TRUE(dir != NULL);'), (162, 1, u'+  ASSERT_TRUE(minidump.SeekToStreamType(0xfbb7fa2bU, &stream_length));'), (163, 1, u'+  ASSERT_EQ(15U, stream_length);'), (165, 1, u'+  ASSERT_TRUE(minidump.ReadBytes(stream_contents, sizeof(stream_contents)));'), (173, 1, u'+  EXPECT_FALSE(minidump.GetAssertion());'), (187, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (190, 1, u'+  ASSERT_TRUE(minidump.Read());'), (191, 1, u'+  ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());'), (194, 1, u'+  ASSERT_TRUE(dir != NULL);'), (198, 1, u'+  ASSERT_TRUE(memory_list != NULL);'), (199, 1, u'+  ASSERT_EQ(1U, memory_list->region_count());'), (202, 1, u'+  ASSERT_EQ(0x309d68010bd21b2cULL, region1->GetBase());'), (203, 1, u'+  ASSERT_EQ(15U, region1->GetSize());'), (205, 1, u'+  ASSERT_TRUE(memcmp("memory contents", region1_bytes, 15) == 0);'), (239, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (243, 1, u'+  ASSERT_TRUE(minidump.Read());'), (244, 1, u'+  ASSERT_EQ(2U, minidump.GetDirectoryEntryCount());'), (247, 1, u'+  ASSERT_TRUE(md_memory_list != NULL);'), (248, 1, u'+  ASSERT_EQ(1U, md_memory_list->region_count());'), (251, 1, u'+  ASSERT_EQ(0x2326a0faU, md_region->GetBase());'), (252, 1, u'+  ASSERT_EQ(16U, md_region->GetSize());'), (254, 1, u'+  ASSERT_TRUE(memcmp("stack for thread", region_bytes, 16) == 0);'), (257, 1, u'+  ASSERT_TRUE(thread_list != NULL);'), (258, 1, u'+  ASSERT_EQ(1U, thread_list->thread_count());'), (261, 1, u'+  ASSERT_TRUE(md_thread != NULL);'), (263, 1, u'+  ASSERT_TRUE(md_thread->GetThreadID(&thread_id));'), (264, 1, u'+  ASSERT_EQ(0xa898f11bU, thread_id);'), (266, 1, u'+  ASSERT_TRUE(md_stack != NULL);'), (267, 1, u'+  ASSERT_EQ(0x2326a0faU, md_stack->GetBase());'), (268, 1, u'+  ASSERT_EQ(16U, md_stack->GetSize());'), (270, 1, u'+  ASSERT_TRUE(memcmp("stack for thread", md_stack_bytes, 16) == 0);'), (273, 1, u'+  ASSERT_TRUE(md_context != NULL);'), (274, 1, u'+  ASSERT_EQ((u_int32_t) MD_CONTEXT_X86, md_context->GetContextCPU());'), (276, 1, u'+  ASSERT_TRUE(md_raw_context != NULL);'), (277, 1, u'+  ASSERT_EQ((u_int32_t) (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL),'), (325, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (328, 1, u'+  ASSERT_TRUE(minidump.Read());'), (329, 1, u'+  ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());'), (332, 1, u'+  ASSERT_TRUE(dir != NULL);'), (336, 1, u'+  ASSERT_TRUE(md_module_list != NULL);'), (337, 1, u'+  ASSERT_EQ(1U, md_module_list->module_count());'), (340, 1, u'+  ASSERT_TRUE(md_module != NULL);'), (341, 1, u'+  ASSERT_EQ(0xa90206ca83eb2852ULL, md_module->base_address());'), (342, 1, u'+  ASSERT_EQ(0xada542bd, md_module->size());'), (343, 1, u'+  ASSERT_EQ("single module", md_module->code_file());'), (346, 1, u'+  ASSERT_TRUE(md_raw_module != NULL);'), (347, 1, u'+  ASSERT_EQ(0xb1054d2aU, md_raw_module->time_date_stamp);'), (348, 1, u'+  ASSERT_EQ(0x34571371U, md_raw_module->checksum);'), (349, 1, u'+  ASSERT_TRUE(memcmp(&md_raw_module->version_info, &fixed_file_info,'), (363, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (366, 1, u'+  ASSERT_TRUE(minidump.Read());'), (367, 1, u'+  ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());'), (370, 1, u'+  ASSERT_TRUE(dir != NULL);'), (374, 1, u'+  ASSERT_TRUE(md_system_info != NULL);'), (375, 1, u'+  ASSERT_EQ("windows", md_system_info->GetOS());'), (376, 1, u'+  ASSERT_EQ("x86", md_system_info->GetCPU());'), (377, 1, u'+  ASSERT_EQ("Petulant Pierogi", *md_system_info->GetCSDVersion());'), (378, 1, u'+  ASSERT_EQ("GenuineIntel", *md_system_info->GetCPUVendor());'), (475, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (478, 1, u'+  ASSERT_TRUE(minidump.Read());'), (479, 1, u'+  ASSERT_EQ(4U, minidump.GetDirectoryEntryCount());'), (483, 1, u'+  ASSERT_TRUE(thread_list != NULL);'), (484, 1, u'+  ASSERT_EQ(5U, thread_list->thread_count());'), (486, 1, u'+  ASSERT_TRUE(thread_list->GetThreadAtIndex(0)->GetThreadID(&thread_id));'), (487, 1, u'+  ASSERT_EQ(0xbbef4432U, thread_id);'), (488, 1, u'+  ASSERT_EQ(0x70b9ebfcU,'), (490, 1, u'+  ASSERT_EQ(0xaf0709e4U,'), (494, 1, u'+  ASSERT_TRUE(thread_list->GetThreadAtIndex(1)->GetThreadID(&thread_id));'), (495, 1, u'+  ASSERT_EQ(0x657c3f58U, thread_id);'), (496, 1, u'+  ASSERT_EQ(0xf988cc45U,'), (498, 1, u'+  ASSERT_EQ(0xe4f56f81U,'), (502, 1, u'+  ASSERT_TRUE(thread_list->GetThreadAtIndex(2)->GetThreadID(&thread_id));'), (503, 1, u'+  ASSERT_EQ(0xdf4b8a71U, thread_id);'), (504, 1, u'+  ASSERT_EQ(0xc8a92e7cU,'), (506, 1, u'+  ASSERT_EQ(0xb336a438U,'), (510, 1, u'+  ASSERT_TRUE(thread_list->GetThreadAtIndex(3)->GetThreadID(&thread_id));'), (511, 1, u'+  ASSERT_EQ(0x86e6c341U, thread_id);'), (512, 1, u'+  ASSERT_EQ(0x36d08e08U,'), (514, 1, u'+  ASSERT_EQ(0xdf99a60cU,'), (518, 1, u'+  ASSERT_TRUE(thread_list->GetThreadAtIndex(4)->GetThreadID(&thread_id));'), (519, 1, u'+  ASSERT_EQ(0x261a28d4U, thread_id);'), (520, 1, u'+  ASSERT_EQ(0x1e0ab4faU,'), (522, 1, u'+  ASSERT_EQ(0xaa646267U,'), (528, 1, u'+  ASSERT_TRUE(md_module_list != NULL);'), (529, 1, u'+  ASSERT_EQ(3U, md_module_list->module_count());'), (566, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (569, 1, u'+  ASSERT_TRUE(minidump.Read());'), (570, 1, u'+  ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());'), (573, 1, u'+  ASSERT_TRUE(dir != NULL);'), (577, 1, u'+  ASSERT_TRUE(info_list != NULL);'), (578, 1, u'+  ASSERT_EQ(1U, info_list->info_count());'), (581, 1, u'+  ASSERT_EQ(kBaseAddress, info1->GetBase());'), (582, 1, u'+  ASSERT_EQ(kRegionSize, info1->GetSize());'), (583, 1, u'+  ASSERT_TRUE(info1->IsExecutable());'), (584, 1, u'+  ASSERT_TRUE(info1->IsWritable());'), (589, 1, u'+  ASSERT_EQ(kBaseAddress, info2->GetBase());'), (590, 1, u'+  ASSERT_EQ(kRegionSize, info2->GetSize());'), (623, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (627, 1, u'+  ASSERT_TRUE(minidump.Read());'), (628, 1, u'+  ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());'), (631, 1, u'+  ASSERT_TRUE(md_exception != NULL);'), (634, 1, u'+  ASSERT_TRUE(md_exception->GetThreadID(&thread_id));'), (635, 1, u'+  ASSERT_EQ(0x1234abcd, thread_id);'), (638, 1, u'+  ASSERT_TRUE(raw_exception != NULL);'), (645, 1, u'+  ASSERT_TRUE(md_context != NULL);'), (646, 1, u'+  ASSERT_EQ((u_int32_t) MD_CONTEXT_X86, md_context->GetContextCPU());'), (648, 1, u'+  ASSERT_TRUE(md_raw_context != NULL);'), (649, 1, u'+  ASSERT_EQ((u_int32_t) (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL),'), (697, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (701, 1, u'+  ASSERT_TRUE(minidump.Read());'), (702, 1, u'+  ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());'), (705, 1, u'+  ASSERT_TRUE(md_exception != NULL);'), (708, 1, u'+  ASSERT_TRUE(md_exception->GetThreadID(&thread_id));'), (709, 1, u'+  ASSERT_EQ(0x1234abcd, thread_id);'), (712, 1, u'+  ASSERT_TRUE(raw_exception != NULL);'), (719, 1, u'+  ASSERT_TRUE(md_context != NULL);'), (720, 1, u'+  ASSERT_EQ((u_int32_t) MD_CONTEXT_X86, md_context->GetContextCPU());'), (722, 1, u'+  ASSERT_TRUE(md_raw_context != NULL);'), (723, 1, u'+  ASSERT_EQ((u_int32_t) (MD_CONTEXT_X86_INTEGER | MD_CONTEXT_X86_CONTROL),'), (775, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (779, 1, u'+  ASSERT_TRUE(minidump.Read());'), (780, 1, u'+  ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());'), (783, 1, u'+  ASSERT_TRUE(md_exception != NULL);'), (786, 1, u'+  ASSERT_TRUE(md_exception->GetThreadID(&thread_id));'), (787, 1, u'+  ASSERT_EQ(0x1234abcd, thread_id);'), (790, 1, u'+  ASSERT_TRUE(raw_exception != NULL);'), (797, 1, u'+  ASSERT_TRUE(md_context != NULL);'), (798, 1, u'+  ASSERT_EQ((u_int32_t) MD_CONTEXT_ARM, md_context->GetContextCPU());'), (800, 1, u'+  ASSERT_TRUE(md_raw_context != NULL);'), (801, 1, u'+  ASSERT_EQ((u_int32_t) MD_CONTEXT_ARM_INTEGER,'), (859, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (863, 1, u'+  ASSERT_TRUE(minidump.Read());'), (864, 1, u'+  ASSERT_EQ(1U, minidump.GetDirectoryEntryCount());'), (867, 1, u'+  ASSERT_TRUE(md_exception != NULL);'), (870, 1, u'+  ASSERT_TRUE(md_exception->GetThreadID(&thread_id));'), (871, 1, u'+  ASSERT_EQ(0x1234abcd, thread_id);'), (874, 1, u'+  ASSERT_TRUE(raw_exception != NULL);'), (881, 1, u'+  ASSERT_TRUE(md_context != NULL);'), (882, 1, u'+  ASSERT_EQ((u_int32_t) MD_CONTEXT_ARM, md_context->GetContextCPU());'), (884, 1, u'+  ASSERT_TRUE(md_raw_context != NULL);'), (885, 1, u'+  ASSERT_EQ((u_int32_t) MD_CONTEXT_ARM_INTEGER,')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+#define ASSERT_TRUE(condition) \\'), (51, 1, u'+#define ASSERT_FALSE(condition) ASSERT_TRUE(!(condition))'), (62, 1, u'+  ASSERT_TRUE(basic_module->LoadMapFromMemory(buffer.get()));'), (69, 1, u'+  ASSERT_TRUE(serialized_data.get());'), (73, 1, u'+  ASSERT_TRUE(fast_module->LoadMapFromMemory(serialized_data.get()));'), (77, 1, u'+  ASSERT_TRUE(CompareModule(basic_module.get(), fast_module.get()));'), (86, 1, u'+  ASSERT_TRUE(basic_module->name_ == fast_module->name_);'), (94, 1, u'+      ASSERT_TRUE(iter1->first == iter2.GetKey());'), (96, 1, u'+      ASSERT_TRUE(iter1->second == tmp);'), (100, 1, u'+    ASSERT_TRUE(iter1 == basic_module->files_.end());'), (101, 1, u'+    ASSERT_TRUE(iter2 == fast_module->files_.end());'), (112, 1, u'+      ASSERT_TRUE(iter1->first == iter2.GetKey());'), (113, 1, u'+      ASSERT_TRUE(iter1->second.base() == iter2.GetValuePtr()->base());'), (114, 1, u'+      ASSERT_TRUE(CompareFunction('), (119, 1, u'+    ASSERT_TRUE(iter1 == basic_module->functions_.map_.end());'), (120, 1, u'+    ASSERT_TRUE(iter2 == fast_module->functions_.map_.end());'), (131, 1, u'+      ASSERT_TRUE(iter1->first == iter2.GetKey());'), (132, 1, u'+      ASSERT_TRUE(ComparePubSymbol('), (137, 1, u'+    ASSERT_TRUE(iter1 == basic_module->public_symbols_.map_.end());'), (138, 1, u'+    ASSERT_TRUE(iter2 == fast_module->public_symbols_.map_.end());'), (143, 1, u'+    ASSERT_TRUE(CompareCRM(&(basic_module->windows_frame_info_[i]),'), (155, 1, u'+      ASSERT_TRUE(iter1->first == iter2.GetKey());'), (156, 1, u'+      ASSERT_TRUE(iter1->second.base() == iter2.GetValuePtr()->base());'), (158, 1, u'+      ASSERT_TRUE(iter1->second.entry() == tmp);'), (162, 1, u'+    ASSERT_TRUE(iter1 == basic_module->cfi_initial_rules_.map_.end());'), (163, 1, u'+    ASSERT_TRUE(iter2 == fast_module->cfi_initial_rules_.map_.end());'), (174, 1, u'+      ASSERT_TRUE(iter1->first == iter2.GetKey());'), (176, 1, u'+      ASSERT_TRUE(iter1->second == tmp);'), (180, 1, u'+    ASSERT_TRUE(iter1 == basic_module->cfi_delta_rules_.end());'), (181, 1, u'+    ASSERT_TRUE(iter2 == fast_module->cfi_delta_rules_.end());'), (191, 1, u'+  ASSERT_TRUE(basic_func->name == fast_func->name);'), (192, 1, u'+  ASSERT_TRUE(basic_func->address == fast_func->address);'), (193, 1, u'+  ASSERT_TRUE(basic_func->size == fast_func->size);'), (202, 1, u'+    ASSERT_TRUE(iter1->first == iter2.GetKey());'), (203, 1, u'+    ASSERT_TRUE(iter1->second.base() == iter2.GetValuePtr()->base());'), (204, 1, u'+    ASSERT_TRUE(CompareLine(iter1->second.entry().get(),'), (209, 1, u'+  ASSERT_TRUE(iter1 == basic_func->lines.map_.end());'), (210, 1, u'+  ASSERT_TRUE(iter2 == fast_func->lines.map_.end());'), (221, 1, u'+  ASSERT_TRUE(basic_line->address == fast_line->address);'), (222, 1, u'+  ASSERT_TRUE(basic_line->size == fast_line->size);'), (223, 1, u'+  ASSERT_TRUE(basic_line->source_file_id == fast_line->source_file_id);'), (224, 1, u'+  ASSERT_TRUE(basic_line->line == fast_line->line);'), (234, 1, u'+  ASSERT_TRUE(basic_ps->name == fast_ps->name);'), (235, 1, u'+  ASSERT_TRUE(basic_ps->address == fast_ps->address);'), (236, 1, u'+  ASSERT_TRUE(basic_ps->parameter_size == fast_ps->parameter_size);'), (243, 1, u'+  ASSERT_TRUE(wfi1.valid == wfi2.valid);'), (244, 1, u'+  ASSERT_TRUE(wfi1.prolog_size == wfi2.prolog_size);'), (245, 1, u'+  ASSERT_TRUE(wfi1.epilog_size == wfi2.epilog_size);'), (246, 1, u'+  ASSERT_TRUE(wfi1.parameter_size == wfi2.parameter_size);'), (247, 1, u'+  ASSERT_TRUE(wfi1.saved_register_size == wfi2.saved_register_size);'), (248, 1, u'+  ASSERT_TRUE(wfi1.local_size == wfi2.local_size);'), (249, 1, u'+  ASSERT_TRUE(wfi1.max_stack_size == wfi2.max_stack_size);'), (250, 1, u'+  ASSERT_TRUE(wfi1.allocates_base_pointer == wfi2.allocates_base_pointer);'), (251, 1, u'+  ASSERT_TRUE(wfi1.program_string == wfi2.program_string);'), (259, 1, u'+  ASSERT_TRUE(basic_crm->base_ == fast_crm->base_);'), (263, 1, u'+    ASSERT_TRUE(!basic_crm->entry_.get() && !fast_crm->entry_ptr_);'), (267, 1, u'+    ASSERT_TRUE(CompareWFI(*(basic_crm->entry_.get()), newwfi));'), (272, 1, u'+    ASSERT_TRUE((!basic_crm->map_ || basic_crm->map_->empty())'), (281, 1, u'+      ASSERT_TRUE(iter1->first == iter2.GetKey());'), (285, 1, u'+      ASSERT_TRUE(CompareCRM(iter1->second, child));'), (290, 1, u'+    ASSERT_TRUE(iter1 == basic_crm->map_->end());'), (291, 1, u'+    ASSERT_TRUE(iter2 == fast_crm->map_.end());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(35, 1, u'+#define ASSERT_TRUE(condition) \\'), (41, 1, u'+#define ASSERT_EQ(e1, e2) ASSERT_TRUE((e1) == (e2))'), (48, 1, u'+  ASSERT_EQ(PathnameStripper::File("/dir/file"), "file");'), (49, 1, u'+  ASSERT_EQ(PathnameStripper::File("\\\\dir\\\\file"), "file");'), (50, 1, u'+  ASSERT_EQ(PathnameStripper::File("/dir\\\\file"), "file");'), (51, 1, u'+  ASSERT_EQ(PathnameStripper::File("\\\\dir/file"), "file");'), (52, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir/file"), "file");'), (53, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir\\\\file"), "file");'), (54, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir/\\\\file"), "file");'), (55, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir\\\\/file"), "file");'), (56, 1, u'+  ASSERT_EQ(PathnameStripper::File("file"), "file");'), (57, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir/"), "");'), (58, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir\\\\"), "");'), (59, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir/dir/"), "");'), (60, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir\\\\dir\\\\"), "");'), (61, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir1/dir2/file"), "file");'), (62, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir1\\\\dir2\\\\file"), "file");'), (63, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir1/dir2\\\\file"), "file");'), (64, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir1\\\\dir2/file"), "file");'), (65, 1, u'+  ASSERT_EQ(PathnameStripper::File(""), "");'), (66, 1, u'+  ASSERT_EQ(PathnameStripper::File("1"), "1");'), (67, 1, u'+  ASSERT_EQ(PathnameStripper::File("1/2"), "2");'), (68, 1, u'+  ASSERT_EQ(PathnameStripper::File("1\\\\2"), "2");'), (69, 1, u'+  ASSERT_EQ(PathnameStripper::File("/1/2"), "2");'), (70, 1, u'+  ASSERT_EQ(PathnameStripper::File("\\\\1\\\\2"), "2");'), (71, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir//file"), "file");'), (72, 1, u'+  ASSERT_EQ(PathnameStripper::File("dir\\\\\\\\file"), "file");'), (73, 1, u'+  ASSERT_EQ(PathnameStripper::File("/dir//file"), "file");'), (74, 1, u'+  ASSERT_EQ(PathnameStripper::File("\\\\dir\\\\\\\\file"), "file");'), (75, 1, u'+  ASSERT_EQ(PathnameStripper::File("c:\\\\dir\\\\file"), "file");'), (76, 1, u'+  ASSERT_EQ(PathnameStripper::File("c:\\\\dir\\\\file.ext"), "file.ext");')]
===========================================
Class:class FakeMemoryRegion : public MemoryRegion { class FakeMemoryRegion : public MemoryRegion 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 1, u'+  assertion_.clear();')]
===========================================
Class:class CountedObject { class CountedObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(64, 1, u'+  assert(symbol_file);'), (83, 1, u'+  assert(symbol_data);'), (102, 1, u'+  assert(symbol_data);'), (143, 1, u'+  assert(symbol_file);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+  assert(stack);')]
===========================================
Class: class StackwalkerAMD64Fixture { class StackwalkerAMD64Fixture 
Class:class GetContextFrame: public StackwalkerAMD64Fixture, public Test 
Class:class SanityCheck: public StackwalkerAMD64Fixture, public Test 
Class:class GetCallerFrame: public StackwalkerAMD64Fixture, public Test 
Class:class CFI: public CFIFixture, public Test 
Class: class StackwalkerARMFixture { class StackwalkerARMFixture 
Class:class SanityCheck: public StackwalkerARMFixture, public Test 
Class:class GetContextFrame: public StackwalkerARMFixture, public Test 
Class:class GetCallerFrame: public StackwalkerARMFixture, public Test 
Class:class CFI: public CFIFixture, public Test 
Class: class StackwalkerARMFixtureIOS : public StackwalkerARMFixture { class StackwalkerARMFixtureIOS : public StackwalkerARMFixture 
Class:class GetFramesByFramePointer: public StackwalkerARMFixtureIOS, public Test 
Class: class StackwalkerX86Fixture { class StackwalkerX86Fixture 
Class:class SanityCheck: public StackwalkerX86Fixture, public Test 
Class:class GetContextFrame: public StackwalkerX86Fixture, public Test 
Class:class GetCallerFrame: public StackwalkerX86Fixture, public Test 
Class:class CFI: public CFIFixture, public Test 
Class: class TestStaticAddressMap : public ::testing::Test { class TestStaticAddressMap : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(105, 1, u'+    ASSERT_EQ(found, found_test);'), (108, 1, u'+      ASSERT_EQ(address, address_test);'), (110, 1, u'+      ASSERT_EQ(entry, entry_test);')]
===========================================
Class:class TestStaticCRMMap : public ::testing::Test { class TestStaticCRMMap : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(179, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(10, 10,  1));'), (180, 1, u'+  ASSERT_FALSE(crm_map_.StoreRange(10, 10,  2));  // exactly equal to 1'), (181, 1, u'+  ASSERT_FALSE(crm_map_.StoreRange(11, 10,  3));  // begins inside 1 and extends up'), (182, 1, u'+  ASSERT_FALSE(crm_map_.StoreRange( 9, 10,  4));  // begins below 1 and ends inside'), (183, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(11,  9,  5));  // contained by existing'), (184, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(12,  7,  6));'), (185, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange( 9, 12,  7));  // contains existing'), (186, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange( 9, 13,  8));'), (187, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange( 8, 14,  9));'), (188, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(30,  3, 10));'), (189, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(33,  3, 11));'), (190, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(30,  6, 12));  // storable but totally masked'), (191, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(40,  8, 13));  // will be totally masked'), (192, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(40,  4, 14));'), (193, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(44,  4, 15));'), (194, 1, u'+  ASSERT_FALSE(crm_map_.StoreRange(32, 10, 16));  // begins in #10, ends in #14'), (195, 1, u'+  ASSERT_FALSE(crm_map_.StoreRange(50,  0, 17));  // zero length'), (196, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(50, 10, 18));'), (197, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(50,  1, 19));'), (198, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(59,  1, 20));'), (199, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(60,  1, 21));'), (200, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(69,  1, 22));'), (201, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(60, 10, 23));'), (202, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(68,  1, 24));'), (203, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(61,  1, 25));'), (204, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(61,  8, 26));'), (205, 1, u'+  ASSERT_FALSE(crm_map_.StoreRange(59,  9, 27));'), (206, 1, u'+  ASSERT_FALSE(crm_map_.StoreRange(59, 10, 28));'), (207, 1, u'+  ASSERT_FALSE(crm_map_.StoreRange(59, 11, 29));'), (208, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(70, 10, 30));'), (209, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(74,  2, 31));'), (210, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(77,  2, 32));'), (211, 1, u'+  ASSERT_FALSE(crm_map_.StoreRange(72,  6, 33));'), (212, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(80,  3, 34));'), (213, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(81,  1, 35));'), (214, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(82,  1, 36));'), (215, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(83,  3, 37));'), (216, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(84,  1, 38));'), (217, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(83,  1, 39));'), (218, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(86,  5, 40));'), (219, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(88,  1, 41));'), (220, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(90,  1, 42));'), (221, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(86,  1, 43));'), (222, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(87,  1, 44));'), (223, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(89,  1, 45));'), (224, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(87,  4, 46));'), (225, 1, u'+  ASSERT_TRUE (crm_map_.StoreRange(87,  3, 47));'), (226, 1, u'+  ASSERT_FALSE(crm_map_.StoreRange(86,  2, 48));'), (246, 1, u'+  ASSERT_EQ(kCorrectSizeForEmptyMap, size);'), (249, 1, u'+  ASSERT_FALSE(test_map->RetrieveRange(-1, entry_test));'), (250, 1, u'+  ASSERT_FALSE(test_map->RetrieveRange(0, entry_test));'), (251, 1, u'+  ASSERT_FALSE(test_map->RetrieveRange(10, entry_test));'), (266, 1, u'+  ASSERT_EQ(kCorrectSizeForSingleElementMap, size);'), (269, 1, u'+  ASSERT_FALSE(test_map->RetrieveRange(-1, entry_test));'), (270, 1, u'+  ASSERT_FALSE(test_map->RetrieveRange(0, entry_test));'), (271, 1, u'+  ASSERT_TRUE(test_map->RetrieveRange(10, entry_test));'), (272, 1, u'+  ASSERT_EQ(*entry_test, entry);'), (273, 1, u'+  ASSERT_TRUE(test_map->RetrieveRange(13, entry_test));'), (274, 1, u'+  ASSERT_EQ(*entry_test, entry);')]
===========================================
Class:  class TestInvalidMap : public ::testing::Test { class TestInvalidMap : public ::testing::Test 
Class:  class TestValidMap : public ::testing::Test { class TestValidMap : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 1, u'+  ASSERT_FALSE(test_map.ValidateInMemoryStructure());'), (112, 1, u'+  ASSERT_FALSE(test_map.ValidateInMemoryStructure());'), (117, 1, u'+  ASSERT_FALSE(test_map.ValidateInMemoryStructure());'), (135, 1, u'+  ASSERT_FALSE(test_map.ValidateInMemoryStructure());'), (195, 1, u'+      ASSERT_EQ(iter_test.GetKey(), iter_std->first);'), (196, 1, u'+      ASSERT_EQ(*(iter_test.GetValuePtr()), iter_std->second);'), (198, 1, u'+    ASSERT_TRUE(iter_test == test_map[test_case].end()'), (208, 1, u'+      ASSERT_EQ(iter_test.GetKey(), iter_std->first);'), (209, 1, u'+      ASSERT_EQ(*(iter_test.GetValuePtr()), iter_std->second);'), (213, 1, u'+      ASSERT_TRUE(iter_test == test_map[test_case].end());'), (217, 1, u'+      ASSERT_TRUE(iter_test != test_map[test_case].end());'), (218, 1, u'+      ASSERT_TRUE(iter_test == test_map[test_case].last());'), (219, 1, u'+      ASSERT_EQ(iter_test.GetKey(), iter_std->first);'), (220, 1, u'+      ASSERT_EQ(*(iter_test.GetValuePtr()), iter_std->second);'), (225, 1, u'+      ASSERT_TRUE(iter_test == test_map[test_case].begin());'), (232, 1, u'+    ASSERT_EQ(found1, found2);'), (235, 1, u'+      ASSERT_EQ(iter_test.GetKey(), iter_std->first);'), (236, 1, u'+      ASSERT_EQ(*(iter_test.GetValuePtr()), iter_std->second);'), (317, 1, u'+  ASSERT_EQ(correct_size[test_case], size[test_case]);'), (320, 1, u'+  ASSERT_TRUE(test_map[test_case].ValidateInMemoryStructure());'), (321, 1, u'+  ASSERT_EQ(std_map[test_case].empty(), test_map[test_case].empty());'), (322, 1, u'+  ASSERT_EQ(std_map[test_case].size(), test_map[test_case].size());'), (334, 1, u'+  ASSERT_EQ(correct_size[test_case], size[test_case]);'), (337, 1, u'+  ASSERT_TRUE(test_map[test_case].ValidateInMemoryStructure());'), (338, 1, u'+  ASSERT_EQ(std_map[test_case].empty(), test_map[test_case].empty());'), (339, 1, u'+  ASSERT_EQ(std_map[test_case].size(), test_map[test_case].size());'), (351, 1, u'+  ASSERT_EQ(correct_size[test_case], size[test_case]);'), (354, 1, u'+  ASSERT_TRUE(test_map[test_case].ValidateInMemoryStructure());'), (355, 1, u'+  ASSERT_EQ(std_map[test_case].empty(), test_map[test_case].empty());'), (356, 1, u'+  ASSERT_EQ(std_map[test_case].size(), test_map[test_case].size());'), (368, 1, u'+  ASSERT_EQ(correct_size[test_case], size[test_case]);'), (371, 1, u'+  ASSERT_TRUE(test_map[test_case].ValidateInMemoryStructure());'), (372, 1, u'+  ASSERT_EQ(std_map[test_case].empty(), test_map[test_case].empty());'), (373, 1, u'+  ASSERT_EQ(std_map[test_case].size(), test_map[test_case].size());')]
===========================================
Class:class TestStaticRangeMap : public ::testing::Test { class TestStaticRangeMap : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(319, 1, u'+    ASSERT_TRUE(range_map->RetrieveRangeAtIndex(object_index,'), (326, 1, u'+    ASSERT_TRUE(entry) << "FAILED: RetrieveRangeAtIndex set " << set'), (345, 1, u'+  ASSERT_FALSE(range_map->RetrieveRangeAtIndex(')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(129, 1, u'+  assert(context.context_flags & MD_CONTEXT_X86);'), (131, 1, u'+  assert(dump.endianness() == kLittleEndian);'), (170, 1, u'+  assert(Size() == sizeof(MDRawContextX86));'), (176, 1, u'+  assert((context.context_flags & MD_CONTEXT_ARM) ||'), (179, 1, u'+  assert(dump.endianness() == kLittleEndian);'), (189, 1, u'+  assert(Size() == sizeof(MDRawContextARM));'), (203, 1, u'+  assert(Size() == sizeof(MDRawThread));'), (273, 1, u'+  assert(Size() == sizeof(MDRawExceptionStream));'), (295, 1, u'+  assert(Size() == sizeof(MDRawHeader));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(65, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (77, 1, u'+  ASSERT_TRUE(section1.GetContents(&contents));'), (91, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (109, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (123, 1, u'+  ASSERT_EQ(0x89979731eb060ed4ULL + 1729, l.Value());'), (128, 1, u'+  assert(x86_raw_context.context_flags & MD_CONTEXT_X86);'), (131, 1, u'+  ASSERT_TRUE(context.GetContents(&contents));'), (139, 1, u'+  assert(arm_raw_context.context_flags & MD_CONTEXT_ARM);'), (142, 1, u'+  ASSERT_TRUE(context.GetContents(&contents));'), (152, 1, u'+  ASSERT_DEATH(Context context(dump, raw);,'), (160, 1, u'+  ASSERT_DEATH(Context context(dump, raw);,'), (177, 1, u'+  ASSERT_TRUE(thread.GetContents(&contents));'), (205, 1, u'+  ASSERT_TRUE(exception.GetContents(&contents));'), (241, 1, u'+  ASSERT_TRUE(s.GetContents(&contents));'), (257, 1, u'+  ASSERT_TRUE(section.GetContents(&contents));'), (267, 1, u'+  ASSERT_TRUE(list.GetContents(&contents));'), (284, 1, u'+  ASSERT_TRUE(list.GetContents(&contents));'), (293, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (294, 1, u'+  ASSERT_EQ(string("\\x4d\\x44\\x4d\\x50"   // signature'), (309, 1, u'+  ASSERT_TRUE(dump.GetContents(&contents));'), (310, 1, u'+  ASSERT_EQ(string("\\x50\\x4d\\x44\\x4d"   // signature'), (329, 1, u'+  ASSERT_TRUE(dump.GetContents(&dump_contents));'), (334, 1, u'+  ASSERT_TRUE(referencing_section.GetContents(&contents));'), (335, 1, u'+  ASSERT_EQ(string("\\x10\\0\\0\\0\\x20\\0\\0\\0", 8), contents);')]
===========================================
Class:class LogFileObject : public base::Logger { class LogFileObject : public base::Logger 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(430, 1, u'+  assert(severity >= 0 && severity < NUM_SEVERITIES);'), (479, 1, u'+  assert(min_severity >= 0 && min_severity < NUM_SEVERITIES);'), (497, 1, u'+  assert(min_severity >= 0 && min_severity < NUM_SEVERITIES);'), (605, 1, u'+  assert(severity >=0 && severity < NUM_SEVERITIES);'), (633, 1, u'+  assert(severity >= 0);'), (634, 1, u'+  assert(severity < NUM_SEVERITIES);'), (1148, 1, u'+  log_mutex.AssertHeld();')]
===========================================
Class: class TestLogSinkImpl : public LogSink { class TestLogSinkImpl : public LogSink 
Class:    class TestLogSinkWriter : public Thread { class TestLogSinkWriter : public Thread 
Class:    class TestWaitingLogSink : public LogSink { class TestWaitingLogSink : public LogSink 
Class:class MinimalFormatter { class MinimalFormatter 
Class:class LineReader { class LineReader 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(65, 1, u'+static int AssertFail() {'), (70, 1, u'+#define SAFE_ASSERT(expr) ((expr) ? 0 : AssertFail())'), (87, 1, u'+      SAFE_ASSERT(len < sizeof(demangled));'), (125, 1, u'+  SAFE_ASSERT(fd >= 0);'), (126, 1, u'+  SAFE_ASSERT(count >= 0 && count <= std::numeric_limits<ssize_t>::max());'), (140, 1, u'+  SAFE_ASSERT(num_bytes <= count);'), (194, 1, u'+    SAFE_ASSERT(len % sizeof(buf[0]) == 0);'), (196, 1, u'+    SAFE_ASSERT(num_headers_in_buf <= sizeof(buf) / sizeof(buf[0]));'), (284, 1, u'+    SAFE_ASSERT(len % sizeof(buf[0]) == 0);'), (286, 1, u'+    SAFE_ASSERT(num_symbols_in_buf <= sizeof(buf)/sizeof(buf[0]));'), (403, 1, u'+      SAFE_ASSERT(bol_ <= eod_);  // "bol_" can point to "eod_".'), (480, 1, u'+  SAFE_ASSERT(p <= end);'), (659, 1, u'+  SAFE_ASSERT(out_size >= 0);'), (675, 1, u'+  assert(0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(46, 1, u'+  ASSERT_DEATH(InitGoogleLogging("foobar"), "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(129, 1, u'+  vmodule_lock.AssertHeld();')]
===========================================
Class:class CommandLineInterface::ErrorPrinter : public MultiFileErrorCollector, class CommandLineInterface::ErrorPrinter : public MultiFileErrorCollector,
Class:class CommandLineInterface::GeneratorContextImpl : public GeneratorContext { class CommandLineInterface::GeneratorContextImpl : public GeneratorContext 
Class:class CommandLineInterface::MemoryOutputStream class CommandLineInterface::MemoryOutputStream
Class:class CommandLineInterfaceTest : public testing::Test { class CommandLineInterfaceTest : public testing::Test 
Class:  class NullCodeGenerator;
Class:class CommandLineInterfaceTest::NullCodeGenerator : public CodeGenerator { class CommandLineInterfaceTest::NullCodeGenerator : public CodeGenerator 
Class:class EncodeDecodeTest : public testing::Test { class EncodeDecodeTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(780, 1, u'+  ASSERT_EQ(1, descriptor_set.file_size());'), (803, 1, u'+  ASSERT_EQ(2, descriptor_set.file_size());'), (1362, 1, u'+    ASSERT_TRUE(File::ReadFileToString(filename, &expected_output));'), (1371, 1, u'+    ASSERT_TRUE(File::ReadFileToString(filename, &expected_output));')]
===========================================
Class:class MockErrorCollector : public MultiFileErrorCollector { class MockErrorCollector : public MultiFileErrorCollector 
Class:class FieldGroup { class FieldGroup 
Class:class TestGenerator : public CodeGenerator { class TestGenerator : public CodeGenerator 
Class:class MockErrorCollector : public MultiFileErrorCollector { class MockErrorCollector : public MultiFileErrorCollector 
Class:class SourceTreeDescriptorDatabase::SingleFileErrorCollector class SourceTreeDescriptorDatabase::SingleFileErrorCollector
Class:class MockErrorCollector : public MultiFileErrorCollector { class MockErrorCollector : public MultiFileErrorCollector 
Class:class TestGenerator : public CodeGenerator { class TestGenerator : public CodeGenerator 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(79, 1, u'+  ASSERT_TRUE(File::ReadFileToString('), (97, 1, u'+  ASSERT_EQ(lines.size(), 3 + insertion_list.size() * 2);')]
===========================================
Class:class MockErrorCollector : public io::ErrorCollector { class MockErrorCollector : public io::ErrorCollector 
Class:class GeneratorResponseContext : public GeneratorContext { class GeneratorResponseContext : public GeneratorContext 
Class:class TestGenerator : public CodeGenerator { class TestGenerator : public CodeGenerator 
Class:class DescriptorPool::Tables { class DescriptorPool::Tables 
Class:class FileDescriptorTables { class FileDescriptorTables 
Class: class DescriptorBuilder { class DescriptorBuilder 
Class:      class OptionInterpreter {   class OptionInterpreter 
Class: class DescriptorBuilder::OptionInterpreter::AggregateOptionFinder     : public TextFormat::Finder {     : public TextFormat::Finder 
Class:class AggregateErrorCollector : public io::ErrorCollector { class AggregateErrorCollector : public io::ErrorCollector 
Class:class DescriptorDatabaseTestCase { class DescriptorDatabaseTestCase 
Class:class FileDescriptorTest : public testing::Test { class FileDescriptorTest : public testing::Test 
Class:class DescriptorTest : public testing::Test { class DescriptorTest : public testing::Test 
Class:class StylizedFieldNamesTest : public testing::Test { class StylizedFieldNamesTest : public testing::Test 
Class:    class EnumDescriptorTest : public testing::Test { class EnumDescriptorTest : public testing::Test 
Class:    class ServiceDescriptorTest : public testing::Test { class ServiceDescriptorTest : public testing::Test 
Class:    class NestedDescriptorTest : public testing::Test { class NestedDescriptorTest : public testing::Test 
Class:    class ExtensionDescriptorTest : public testing::Test { class ExtensionDescriptorTest : public testing::Test 
Class:   class MiscTest : public testing::Test { class MiscTest : public testing::Test 
Class:   class AllowUnknownDependenciesTest : public testing::Test { class AllowUnknownDependenciesTest : public testing::Test 
Class:        class MockErrorCollector : public DescriptorPool::ErrorCollector { class MockErrorCollector : public DescriptorPool::ErrorCollector 
Class: class ValidationErrorTest : public testing::Test { class ValidationErrorTest : public testing::Test 
Class: class DatabaseBackedPoolTest : public testing::Test { class DatabaseBackedPoolTest : public testing::Test 
Class:         class ErrorDescriptorDatabase : public DescriptorDatabase {   class ErrorDescriptorDatabase : public DescriptorDatabase 
Class:         class CallCountingDatabase : public DescriptorDatabase {   class CallCountingDatabase : public DescriptorDatabase 
Class:            class FalsePositiveDatabase : public DescriptorDatabase {   class FalsePositiveDatabase : public DescriptorDatabase 
Class:class DynamicMessage : public Message { class DynamicMessage : public Message 
Class:class DynamicMessageTest : public testing::Test { class DynamicMessageTest : public testing::Test 
Class:class DescriptorPoolExtensionFinder : public ExtensionFinder { class DescriptorPoolExtensionFinder : public ExtensionFinder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(220, 1, u'+    ASSERT_FALSE(output_stream.HadError());'), (264, 1, u'+    ASSERT_FALSE(output_stream.HadError());'), (331, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_string_extension));'), (528, 1, u'+  ASSERT_TRUE(file != NULL);'), (569, 1, u'+    ASSERT_TRUE(message.ParseFromCodedStream(&input));'), (570, 1, u'+    ASSERT_TRUE(input.ConsumedEntireMessage());'), (605, 1, u'+    ASSERT_TRUE(WireFormat::ParseAndMergePartial(&input, &message2));'), (606, 1, u'+    ASSERT_TRUE(input.ConsumedEntireMessage());'), (614, 1, u'+    ASSERT_TRUE(message_extension != NULL);'), (619, 1, u'+    ASSERT_TRUE(typed_sub_message != NULL);'), (628, 1, u'+    ASSERT_TRUE(dynamic_message_extension != NULL);')]
===========================================
Class:  class FIXTURE##_##NAME##_DD : public FIXTURE {                           \   class FIXTURE##_##NAME##_DD : public FIXTURE 
Class:  class FIXTURE##_##NAME##_DD : public FIXTURE {                           \   class FIXTURE##_##NAME##_DD : public FIXTURE 
Class:class CodedStreamTest : public testing::Test { class CodedStreamTest : public testing::Test 
Class:  class In : public ZeroCopyInputStream {   class In : public ZeroCopyInputStream 
Class: class ReallyBigInputStream : public ZeroCopyInputStream { class ReallyBigInputStream : public ZeroCopyInputStream 
Class:  class NAME {                                 \   class NAME 
Class:  class FIXTURE##_##NAME##_DD : public FIXTURE {                           \   class FIXTURE##_##NAME##_DD : public FIXTURE 
Class:  class FIXTURE##_##NAME##_DD : public FIXTURE {                           \   class FIXTURE##_##NAME##_DD : public FIXTURE 
Class:class TestInputStream : public ZeroCopyInputStream { class TestInputStream : public ZeroCopyInputStream 
Class:class IoTest : public testing::Test { class IoTest : public testing::Test 
Class:class MsvcDebugDisabler { class MsvcDebugDisabler 
Class:class GeneratedMessageFactory : public MessageFactory { class GeneratedMessageFactory : public MessageFactory 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(190, 1, u'+  ASSERT_EQ(1, errors.size());'), (238, 1, u'+  ASSERT_EQ(3, errors.size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(146, 1, u'+  ASSERT_EQ(2, message1.unknown_fields().field_count());'), (147, 1, u'+  ASSERT_EQ(UnknownField::TYPE_VARINT,'), (150, 1, u'+  ASSERT_EQ(UnknownField::TYPE_VARINT,')]
===========================================
Class:class RepeatedFieldIteratorTest : public testing::Test { class RepeatedFieldIteratorTest : public testing::Test 
Class:class RepeatedPtrFieldIteratorTest : public testing::Test { class RepeatedPtrFieldIteratorTest : public testing::Test 
Class:class RepeatedPtrFieldPtrsIteratorTest : public testing::Test { class RepeatedPtrFieldPtrsIteratorTest : public testing::Test 
Class:        class RepeatedFieldInsertionIteratorsTest : public testing::Test { class RepeatedFieldInsertionIteratorsTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(226, 1, u'+  ASSERT_EQ(5, destination.size());'), (247, 1, u'+  ASSERT_EQ(2, destination.size());'), (260, 1, u'+  ASSERT_EQ(2, destination.size());'), (277, 1, u'+  ASSERT_EQ(2, destination.size());'), (578, 1, u'+  ASSERT_EQ(5, destination.size());'), (599, 1, u'+  ASSERT_EQ(2, destination.size());'), (613, 1, u'+  ASSERT_EQ(2, destination.size());'), (630, 1, u'+  ASSERT_EQ(2, destination.size());'), (1027, 1, u'+  ASSERT_EQ(words.size(), protobuffer.repeated_string_size());'), (1038, 1, u'+  ASSERT_EQ(protobuffer.repeated_nested_message_size(), 4);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(279, 1, u'+void Mutex::AssertHeld() {'), (315, 1, u'+void Mutex::AssertHeld() {')]
===========================================
Class:class ClosureTest : public testing::Test { class ClosureTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(128, 1, u'+  ASSERT_EQ(2, captured_messages_.size());'), (154, 1, u'+  ASSERT_EQ(2, captured_messages_.size());')]
===========================================
Class:class OnceInitTest : public testing::Test { class OnceInitTest : public testing::Test 
Class:  class TestThread {   class TestThread 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(248, 1, u"+  assert('0' == 0x30 && 'A' == 0x41 && 'a' == 0x61);"), (249, 1, u'+  assert(isxdigit(c));'), (1020, 1, u'+  GOOGLE_COMPILE_ASSERT(DBL_DIG < 20, DBL_DIG_is_too_big);'), (1075, 1, u'+  GOOGLE_COMPILE_ASSERT(FLT_DIG < 10, FLT_DIG_is_too_big);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+  ASSERT_TRUE(old_locale_cstr != NULL);'), (52, 1, u'+  ASSERT_TRUE(setlocale(LC_NUMERIC, "C") != NULL);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(306, 1, u'+  ASSERT_EQ(2, message.repeated_int32_size   ());'), (307, 1, u'+  ASSERT_EQ(2, message.repeated_int64_size   ());'), (308, 1, u'+  ASSERT_EQ(2, message.repeated_uint32_size  ());'), (309, 1, u'+  ASSERT_EQ(2, message.repeated_uint64_size  ());'), (310, 1, u'+  ASSERT_EQ(2, message.repeated_sint32_size  ());'), (311, 1, u'+  ASSERT_EQ(2, message.repeated_sint64_size  ());'), (312, 1, u'+  ASSERT_EQ(2, message.repeated_fixed32_size ());'), (313, 1, u'+  ASSERT_EQ(2, message.repeated_fixed64_size ());'), (314, 1, u'+  ASSERT_EQ(2, message.repeated_sfixed32_size());'), (315, 1, u'+  ASSERT_EQ(2, message.repeated_sfixed64_size());'), (316, 1, u'+  ASSERT_EQ(2, message.repeated_float_size   ());'), (317, 1, u'+  ASSERT_EQ(2, message.repeated_double_size  ());'), (318, 1, u'+  ASSERT_EQ(2, message.repeated_bool_size    ());'), (319, 1, u'+  ASSERT_EQ(2, message.repeated_string_size  ());'), (320, 1, u'+  ASSERT_EQ(2, message.repeated_bytes_size   ());'), (322, 1, u'+  ASSERT_EQ(2, message.repeatedgroup_size           ());'), (323, 1, u'+  ASSERT_EQ(2, message.repeated_nested_message_size ());'), (324, 1, u'+  ASSERT_EQ(2, message.repeated_foreign_message_size());'), (325, 1, u'+  ASSERT_EQ(2, message.repeated_import_message_size ());'), (326, 1, u'+  ASSERT_EQ(2, message.repeated_nested_enum_size    ());'), (327, 1, u'+  ASSERT_EQ(2, message.repeated_foreign_enum_size   ());'), (328, 1, u'+  ASSERT_EQ(2, message.repeated_import_enum_size    ());'), (331, 1, u'+  ASSERT_EQ(2, message.repeated_string_piece_size());'), (332, 1, u'+  ASSERT_EQ(2, message.repeated_cord_size());'), (578, 1, u'+  ASSERT_EQ(2, message.repeated_int32_size   ());'), (579, 1, u'+  ASSERT_EQ(2, message.repeated_int64_size   ());'), (580, 1, u'+  ASSERT_EQ(2, message.repeated_uint32_size  ());'), (581, 1, u'+  ASSERT_EQ(2, message.repeated_uint64_size  ());'), (582, 1, u'+  ASSERT_EQ(2, message.repeated_sint32_size  ());'), (583, 1, u'+  ASSERT_EQ(2, message.repeated_sint64_size  ());'), (584, 1, u'+  ASSERT_EQ(2, message.repeated_fixed32_size ());'), (585, 1, u'+  ASSERT_EQ(2, message.repeated_fixed64_size ());'), (586, 1, u'+  ASSERT_EQ(2, message.repeated_sfixed32_size());'), (587, 1, u'+  ASSERT_EQ(2, message.repeated_sfixed64_size());'), (588, 1, u'+  ASSERT_EQ(2, message.repeated_float_size   ());'), (589, 1, u'+  ASSERT_EQ(2, message.repeated_double_size  ());'), (590, 1, u'+  ASSERT_EQ(2, message.repeated_bool_size    ());'), (591, 1, u'+  ASSERT_EQ(2, message.repeated_string_size  ());'), (592, 1, u'+  ASSERT_EQ(2, message.repeated_bytes_size   ());'), (594, 1, u'+  ASSERT_EQ(2, message.repeatedgroup_size           ());'), (595, 1, u'+  ASSERT_EQ(2, message.repeated_nested_message_size ());'), (596, 1, u'+  ASSERT_EQ(2, message.repeated_foreign_message_size());'), (597, 1, u'+  ASSERT_EQ(2, message.repeated_import_message_size ());'), (598, 1, u'+  ASSERT_EQ(2, message.repeated_nested_enum_size    ());'), (599, 1, u'+  ASSERT_EQ(2, message.repeated_foreign_enum_size   ());'), (600, 1, u'+  ASSERT_EQ(2, message.repeated_import_enum_size    ());'), (603, 1, u'+  ASSERT_EQ(2, message.repeated_string_piece_size());'), (604, 1, u'+  ASSERT_EQ(2, message.repeated_cord_size());'), (751, 1, u'+  ASSERT_EQ(2, message.packed_int32_size   ());'), (752, 1, u'+  ASSERT_EQ(2, message.packed_int64_size   ());'), (753, 1, u'+  ASSERT_EQ(2, message.packed_uint32_size  ());'), (754, 1, u'+  ASSERT_EQ(2, message.packed_uint64_size  ());'), (755, 1, u'+  ASSERT_EQ(2, message.packed_sint32_size  ());'), (756, 1, u'+  ASSERT_EQ(2, message.packed_sint64_size  ());'), (757, 1, u'+  ASSERT_EQ(2, message.packed_fixed32_size ());'), (758, 1, u'+  ASSERT_EQ(2, message.packed_fixed64_size ());'), (759, 1, u'+  ASSERT_EQ(2, message.packed_sfixed32_size());'), (760, 1, u'+  ASSERT_EQ(2, message.packed_sfixed64_size());'), (761, 1, u'+  ASSERT_EQ(2, message.packed_float_size   ());'), (762, 1, u'+  ASSERT_EQ(2, message.packed_double_size  ());'), (763, 1, u'+  ASSERT_EQ(2, message.packed_bool_size    ());'), (764, 1, u'+  ASSERT_EQ(2, message.packed_enum_size    ());'), (801, 1, u'+  ASSERT_EQ(2, message.unpacked_int32_size   ());'), (802, 1, u'+  ASSERT_EQ(2, message.unpacked_int64_size   ());'), (803, 1, u'+  ASSERT_EQ(2, message.unpacked_uint32_size  ());'), (804, 1, u'+  ASSERT_EQ(2, message.unpacked_uint64_size  ());'), (805, 1, u'+  ASSERT_EQ(2, message.unpacked_sint32_size  ());'), (806, 1, u'+  ASSERT_EQ(2, message.unpacked_sint64_size  ());'), (807, 1, u'+  ASSERT_EQ(2, message.unpacked_fixed32_size ());'), (808, 1, u'+  ASSERT_EQ(2, message.unpacked_fixed64_size ());'), (809, 1, u'+  ASSERT_EQ(2, message.unpacked_sfixed32_size());'), (810, 1, u'+  ASSERT_EQ(2, message.unpacked_sfixed64_size());'), (811, 1, u'+  ASSERT_EQ(2, message.unpacked_float_size   ());'), (812, 1, u'+  ASSERT_EQ(2, message.unpacked_double_size  ());'), (813, 1, u'+  ASSERT_EQ(2, message.unpacked_bool_size    ());'), (814, 1, u'+  ASSERT_EQ(2, message.unpacked_enum_size    ());'), (873, 1, u'+  ASSERT_EQ(2, message.packed_int32_size   ());'), (874, 1, u'+  ASSERT_EQ(2, message.packed_int64_size   ());'), (875, 1, u'+  ASSERT_EQ(2, message.packed_uint32_size  ());'), (876, 1, u'+  ASSERT_EQ(2, message.packed_uint64_size  ());'), (877, 1, u'+  ASSERT_EQ(2, message.packed_sint32_size  ());'), (878, 1, u'+  ASSERT_EQ(2, message.packed_sint64_size  ());'), (879, 1, u'+  ASSERT_EQ(2, message.packed_fixed32_size ());'), (880, 1, u'+  ASSERT_EQ(2, message.packed_fixed64_size ());'), (881, 1, u'+  ASSERT_EQ(2, message.packed_sfixed32_size());'), (882, 1, u'+  ASSERT_EQ(2, message.packed_sfixed64_size());'), (883, 1, u'+  ASSERT_EQ(2, message.packed_float_size   ());'), (884, 1, u'+  ASSERT_EQ(2, message.packed_double_size  ());'), (885, 1, u'+  ASSERT_EQ(2, message.packed_bool_size    ());'), (886, 1, u'+  ASSERT_EQ(2, message.packed_enum_size    ());'), (1152, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_int32_extension   ));'), (1153, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_int64_extension   ));'), (1154, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_uint32_extension  ));'), (1155, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_uint64_extension  ));'), (1156, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sint32_extension  ));'), (1157, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sint64_extension  ));'), (1158, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_fixed32_extension ));'), (1159, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_fixed64_extension ));'), (1160, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sfixed32_extension));'), (1161, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sfixed64_extension));'), (1162, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_float_extension   ));'), (1163, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_double_extension  ));'), (1164, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_bool_extension    ));'), (1165, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_string_extension  ));'), (1166, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_bytes_extension   ));'), (1168, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeatedgroup_extension           ));'), (1169, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_nested_message_extension ));'), (1170, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_foreign_message_extension));'), (1171, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_import_message_extension ));'), (1172, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_nested_enum_extension    ));'), (1173, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_foreign_enum_extension   ));'), (1174, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_import_enum_extension    ));'), (1176, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_string_piece_extension));'), (1177, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_cord_extension));'), (1289, 1, u'+  ASSERT_TRUE(message.SerializeToString(&serialized));'), (1442, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_int32_extension   ));'), (1443, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_int64_extension   ));'), (1444, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_uint32_extension  ));'), (1445, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_uint64_extension  ));'), (1446, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sint32_extension  ));'), (1447, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sint64_extension  ));'), (1448, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_fixed32_extension ));'), (1449, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_fixed64_extension ));'), (1450, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sfixed32_extension));'), (1451, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sfixed64_extension));'), (1452, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_float_extension   ));'), (1453, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_double_extension  ));'), (1454, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_bool_extension    ));'), (1455, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_string_extension  ));'), (1456, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_bytes_extension   ));'), (1458, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeatedgroup_extension           ));'), (1459, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_nested_message_extension ));'), (1460, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_foreign_message_extension));'), (1461, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_import_message_extension ));'), (1462, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_nested_enum_extension    ));'), (1463, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_foreign_enum_extension   ));'), (1464, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_import_enum_extension    ));'), (1466, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_string_piece_extension));'), (1467, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_cord_extension));'), (1585, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_int32_extension   ));'), (1586, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_int64_extension   ));'), (1587, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_uint32_extension  ));'), (1588, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_uint64_extension  ));'), (1589, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sint32_extension  ));'), (1590, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sint64_extension  ));'), (1591, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_fixed32_extension ));'), (1592, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_fixed64_extension ));'), (1593, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sfixed32_extension));'), (1594, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sfixed64_extension));'), (1595, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_float_extension   ));'), (1596, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_double_extension  ));'), (1597, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_bool_extension    ));'), (1598, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_enum_extension    ));'), (1656, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_int32_extension   ));'), (1657, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_int64_extension   ));'), (1658, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_uint32_extension  ));'), (1659, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_uint64_extension  ));'), (1660, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sint32_extension  ));'), (1661, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sint64_extension  ));'), (1662, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_fixed32_extension ));'), (1663, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_fixed64_extension ));'), (1664, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sfixed32_extension));'), (1665, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sfixed64_extension));'), (1666, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_float_extension   ));'), (1667, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_double_extension  ));'), (1668, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_bool_extension    ));'), (1669, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_enum_extension    ));'), (1733, 1, u'+  ASSERT_EQ(1, message.repeated_int32_size   ());'), (1734, 1, u'+  ASSERT_EQ(1, message.repeated_int64_size   ());'), (1735, 1, u'+  ASSERT_EQ(1, message.repeated_uint32_size  ());'), (1736, 1, u'+  ASSERT_EQ(1, message.repeated_uint64_size  ());'), (1737, 1, u'+  ASSERT_EQ(1, message.repeated_sint32_size  ());'), (1738, 1, u'+  ASSERT_EQ(1, message.repeated_sint64_size  ());'), (1739, 1, u'+  ASSERT_EQ(1, message.repeated_fixed32_size ());'), (1740, 1, u'+  ASSERT_EQ(1, message.repeated_fixed64_size ());'), (1741, 1, u'+  ASSERT_EQ(1, message.repeated_sfixed32_size());'), (1742, 1, u'+  ASSERT_EQ(1, message.repeated_sfixed64_size());'), (1743, 1, u'+  ASSERT_EQ(1, message.repeated_float_size   ());'), (1744, 1, u'+  ASSERT_EQ(1, message.repeated_double_size  ());'), (1745, 1, u'+  ASSERT_EQ(1, message.repeated_bool_size    ());'), (1746, 1, u'+  ASSERT_EQ(1, message.repeated_string_size  ());'), (1747, 1, u'+  ASSERT_EQ(1, message.repeated_bytes_size   ());'), (1749, 1, u'+  ASSERT_EQ(1, message.repeatedgroup_size           ());'), (1750, 1, u'+  ASSERT_EQ(1, message.repeated_nested_message_size ());'), (1751, 1, u'+  ASSERT_EQ(1, message.repeated_foreign_message_size());'), (1752, 1, u'+  ASSERT_EQ(1, message.repeated_import_message_size ());'), (1753, 1, u'+  ASSERT_EQ(1, message.repeated_nested_enum_size    ());'), (1754, 1, u'+  ASSERT_EQ(1, message.repeated_foreign_enum_size   ());'), (1755, 1, u'+  ASSERT_EQ(1, message.repeated_import_enum_size    ());'), (1758, 1, u'+  ASSERT_EQ(1, message.repeated_string_piece_size());'), (1759, 1, u'+  ASSERT_EQ(1, message.repeated_cord_size());'), (1793, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_int32_extension   ));'), (1794, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_int64_extension   ));'), (1795, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_uint32_extension  ));'), (1796, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_uint64_extension  ));'), (1797, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_sint32_extension  ));'), (1798, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_sint64_extension  ));'), (1799, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_fixed32_extension ));'), (1800, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_fixed64_extension ));'), (1801, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_sfixed32_extension));'), (1802, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_sfixed64_extension));'), (1803, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_float_extension   ));'), (1804, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_double_extension  ));'), (1805, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_bool_extension    ));'), (1806, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_string_extension  ));'), (1807, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_bytes_extension   ));'), (1809, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeatedgroup_extension           ));'), (1810, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_nested_message_extension ));'), (1811, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_foreign_message_extension));'), (1812, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_import_message_extension ));'), (1813, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_nested_enum_extension    ));'), (1814, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_foreign_enum_extension   ));'), (1815, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_import_enum_extension    ));'), (1817, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_string_piece_extension));'), (1818, 1, u'+  ASSERT_EQ(1, message.ExtensionSize(unittest::repeated_cord_extension));'), (1852, 1, u'+  ASSERT_EQ(2, message.repeated_int32_size   ());'), (1853, 1, u'+  ASSERT_EQ(2, message.repeated_int64_size   ());'), (1854, 1, u'+  ASSERT_EQ(2, message.repeated_uint32_size  ());'), (1855, 1, u'+  ASSERT_EQ(2, message.repeated_uint64_size  ());'), (1856, 1, u'+  ASSERT_EQ(2, message.repeated_sint32_size  ());'), (1857, 1, u'+  ASSERT_EQ(2, message.repeated_sint64_size  ());'), (1858, 1, u'+  ASSERT_EQ(2, message.repeated_fixed32_size ());'), (1859, 1, u'+  ASSERT_EQ(2, message.repeated_fixed64_size ());'), (1860, 1, u'+  ASSERT_EQ(2, message.repeated_sfixed32_size());'), (1861, 1, u'+  ASSERT_EQ(2, message.repeated_sfixed64_size());'), (1862, 1, u'+  ASSERT_EQ(2, message.repeated_float_size   ());'), (1863, 1, u'+  ASSERT_EQ(2, message.repeated_double_size  ());'), (1864, 1, u'+  ASSERT_EQ(2, message.repeated_bool_size    ());'), (1865, 1, u'+  ASSERT_EQ(2, message.repeated_string_size  ());'), (1866, 1, u'+  ASSERT_EQ(2, message.repeated_bytes_size   ());'), (1868, 1, u'+  ASSERT_EQ(2, message.repeatedgroup_size           ());'), (1869, 1, u'+  ASSERT_EQ(2, message.repeated_nested_message_size ());'), (1870, 1, u'+  ASSERT_EQ(2, message.repeated_foreign_message_size());'), (1871, 1, u'+  ASSERT_EQ(2, message.repeated_import_message_size ());'), (1872, 1, u'+  ASSERT_EQ(2, message.repeated_nested_enum_size    ());'), (1873, 1, u'+  ASSERT_EQ(2, message.repeated_foreign_enum_size   ());'), (1874, 1, u'+  ASSERT_EQ(2, message.repeated_import_enum_size    ());'), (1877, 1, u'+  ASSERT_EQ(2, message.repeated_string_piece_size());'), (1878, 1, u'+  ASSERT_EQ(2, message.repeated_cord_size());'), (1936, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_int32_extension   ));'), (1937, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_int64_extension   ));'), (1938, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_uint32_extension  ));'), (1939, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_uint64_extension  ));'), (1940, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sint32_extension  ));'), (1941, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sint64_extension  ));'), (1942, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_fixed32_extension ));'), (1943, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_fixed64_extension ));'), (1944, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sfixed32_extension));'), (1945, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sfixed64_extension));'), (1946, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_float_extension   ));'), (1947, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_double_extension  ));'), (1948, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_bool_extension    ));'), (1949, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_string_extension  ));'), (1950, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_bytes_extension   ));'), (1952, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeatedgroup_extension           ));'), (1953, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_nested_message_extension ));'), (1954, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_foreign_message_extension));'), (1955, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_import_message_extension ));'), (1956, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_nested_enum_extension    ));'), (1957, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_foreign_enum_extension   ));'), (1958, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_import_enum_extension    ));'), (1960, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_string_piece_extension));'), (1961, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_cord_extension));'), (2360, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_int32"   )));'), (2361, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_int64"   )));'), (2362, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_uint32"  )));'), (2363, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_uint64"  )));'), (2364, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_sint32"  )));'), (2365, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_sint64"  )));'), (2366, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_fixed32" )));'), (2367, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_fixed64" )));'), (2368, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_sfixed32")));'), (2369, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_sfixed64")));'), (2370, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_float"   )));'), (2371, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_double"  )));'), (2372, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_bool"    )));'), (2373, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_string"  )));'), (2374, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_bytes"   )));'), (2376, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeatedgroup"           )));'), (2377, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_nested_message" )));'), (2378, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_foreign_message")));'), (2379, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_import_message" )));'), (2380, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_nested_enum"    )));'), (2381, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_foreign_enum"   )));'), (2382, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_import_enum"    )));'), (2384, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_string_piece")));'), (2385, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("repeated_cord")));'), (2535, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_int32"   )));'), (2536, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_int64"   )));'), (2537, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_uint32"  )));'), (2538, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_uint64"  )));'), (2539, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_sint32"  )));'), (2540, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_sint64"  )));'), (2541, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_fixed32" )));'), (2542, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_fixed64" )));'), (2543, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_sfixed32")));'), (2544, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_sfixed64")));'), (2545, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_float"   )));'), (2546, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_double"  )));'), (2547, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_bool"    )));'), (2548, 1, u'+  ASSERT_EQ(2, reflection->FieldSize(message, F("packed_enum"    )));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 1, u'+#define ASSERT_TRUE GOOGLE_CHECK'), (43, 1, u'+#define ASSERT_EQ GOOGLE_CHECK_EQ'), (247, 1, u'+  ASSERT_EQ(2, message.repeated_int32_size   ());'), (248, 1, u'+  ASSERT_EQ(2, message.repeated_int64_size   ());'), (249, 1, u'+  ASSERT_EQ(2, message.repeated_uint32_size  ());'), (250, 1, u'+  ASSERT_EQ(2, message.repeated_uint64_size  ());'), (251, 1, u'+  ASSERT_EQ(2, message.repeated_sint32_size  ());'), (252, 1, u'+  ASSERT_EQ(2, message.repeated_sint64_size  ());'), (253, 1, u'+  ASSERT_EQ(2, message.repeated_fixed32_size ());'), (254, 1, u'+  ASSERT_EQ(2, message.repeated_fixed64_size ());'), (255, 1, u'+  ASSERT_EQ(2, message.repeated_sfixed32_size());'), (256, 1, u'+  ASSERT_EQ(2, message.repeated_sfixed64_size());'), (257, 1, u'+  ASSERT_EQ(2, message.repeated_float_size   ());'), (258, 1, u'+  ASSERT_EQ(2, message.repeated_double_size  ());'), (259, 1, u'+  ASSERT_EQ(2, message.repeated_bool_size    ());'), (260, 1, u'+  ASSERT_EQ(2, message.repeated_string_size  ());'), (261, 1, u'+  ASSERT_EQ(2, message.repeated_bytes_size   ());'), (263, 1, u'+  ASSERT_EQ(2, message.repeatedgroup_size           ());'), (264, 1, u'+  ASSERT_EQ(2, message.repeated_nested_message_size ());'), (265, 1, u'+  ASSERT_EQ(2, message.repeated_foreign_message_size());'), (266, 1, u'+  ASSERT_EQ(2, message.repeated_import_message_size ());'), (267, 1, u'+  ASSERT_EQ(2, message.repeated_nested_enum_size    ());'), (268, 1, u'+  ASSERT_EQ(2, message.repeated_foreign_enum_size   ());'), (269, 1, u'+  ASSERT_EQ(2, message.repeated_import_enum_size    ());'), (511, 1, u'+  ASSERT_EQ(2, message.repeated_int32_size   ());'), (512, 1, u'+  ASSERT_EQ(2, message.repeated_int64_size   ());'), (513, 1, u'+  ASSERT_EQ(2, message.repeated_uint32_size  ());'), (514, 1, u'+  ASSERT_EQ(2, message.repeated_uint64_size  ());'), (515, 1, u'+  ASSERT_EQ(2, message.repeated_sint32_size  ());'), (516, 1, u'+  ASSERT_EQ(2, message.repeated_sint64_size  ());'), (517, 1, u'+  ASSERT_EQ(2, message.repeated_fixed32_size ());'), (518, 1, u'+  ASSERT_EQ(2, message.repeated_fixed64_size ());'), (519, 1, u'+  ASSERT_EQ(2, message.repeated_sfixed32_size());'), (520, 1, u'+  ASSERT_EQ(2, message.repeated_sfixed64_size());'), (521, 1, u'+  ASSERT_EQ(2, message.repeated_float_size   ());'), (522, 1, u'+  ASSERT_EQ(2, message.repeated_double_size  ());'), (523, 1, u'+  ASSERT_EQ(2, message.repeated_bool_size    ());'), (524, 1, u'+  ASSERT_EQ(2, message.repeated_string_size  ());'), (525, 1, u'+  ASSERT_EQ(2, message.repeated_bytes_size   ());'), (527, 1, u'+  ASSERT_EQ(2, message.repeatedgroup_size           ());'), (528, 1, u'+  ASSERT_EQ(2, message.repeated_nested_message_size ());'), (529, 1, u'+  ASSERT_EQ(2, message.repeated_foreign_message_size());'), (530, 1, u'+  ASSERT_EQ(2, message.repeated_import_message_size ());'), (531, 1, u'+  ASSERT_EQ(2, message.repeated_nested_enum_size    ());'), (532, 1, u'+  ASSERT_EQ(2, message.repeated_foreign_enum_size   ());'), (533, 1, u'+  ASSERT_EQ(2, message.repeated_import_enum_size    ());'), (647, 1, u'+  ASSERT_EQ(2, message.packed_int32_size   ());'), (648, 1, u'+  ASSERT_EQ(2, message.packed_int64_size   ());'), (649, 1, u'+  ASSERT_EQ(2, message.packed_uint32_size  ());'), (650, 1, u'+  ASSERT_EQ(2, message.packed_uint64_size  ());'), (651, 1, u'+  ASSERT_EQ(2, message.packed_sint32_size  ());'), (652, 1, u'+  ASSERT_EQ(2, message.packed_sint64_size  ());'), (653, 1, u'+  ASSERT_EQ(2, message.packed_fixed32_size ());'), (654, 1, u'+  ASSERT_EQ(2, message.packed_fixed64_size ());'), (655, 1, u'+  ASSERT_EQ(2, message.packed_sfixed32_size());'), (656, 1, u'+  ASSERT_EQ(2, message.packed_sfixed64_size());'), (657, 1, u'+  ASSERT_EQ(2, message.packed_float_size   ());'), (658, 1, u'+  ASSERT_EQ(2, message.packed_double_size  ());'), (659, 1, u'+  ASSERT_EQ(2, message.packed_bool_size    ());'), (660, 1, u'+  ASSERT_EQ(2, message.packed_enum_size    ());'), (719, 1, u'+  ASSERT_EQ(2, message.packed_int32_size   ());'), (720, 1, u'+  ASSERT_EQ(2, message.packed_int64_size   ());'), (721, 1, u'+  ASSERT_EQ(2, message.packed_uint32_size  ());'), (722, 1, u'+  ASSERT_EQ(2, message.packed_uint64_size  ());'), (723, 1, u'+  ASSERT_EQ(2, message.packed_sint32_size  ());'), (724, 1, u'+  ASSERT_EQ(2, message.packed_sint64_size  ());'), (725, 1, u'+  ASSERT_EQ(2, message.packed_fixed32_size ());'), (726, 1, u'+  ASSERT_EQ(2, message.packed_fixed64_size ());'), (727, 1, u'+  ASSERT_EQ(2, message.packed_sfixed32_size());'), (728, 1, u'+  ASSERT_EQ(2, message.packed_sfixed64_size());'), (729, 1, u'+  ASSERT_EQ(2, message.packed_float_size   ());'), (730, 1, u'+  ASSERT_EQ(2, message.packed_double_size  ());'), (731, 1, u'+  ASSERT_EQ(2, message.packed_bool_size    ());'), (732, 1, u'+  ASSERT_EQ(2, message.packed_enum_size    ());'), (973, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_int32_extension_lite   ));'), (974, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_int64_extension_lite   ));'), (975, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_uint32_extension_lite  ));'), (976, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_uint64_extension_lite  ));'), (977, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sint32_extension_lite  ));'), (978, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sint64_extension_lite  ));'), (979, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_fixed32_extension_lite ));'), (980, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_fixed64_extension_lite ));'), (981, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sfixed32_extension_lite));'), (982, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sfixed64_extension_lite));'), (983, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_float_extension_lite   ));'), (984, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_double_extension_lite  ));'), (985, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_bool_extension_lite    ));'), (986, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_string_extension_lite  ));'), (987, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_bytes_extension_lite   ));'), (989, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeatedgroup_extension_lite           ));'), (990, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_nested_message_extension_lite ));'), (991, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_foreign_message_extension_lite));'), (992, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_import_message_extension_lite ));'), (993, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_nested_enum_extension_lite    ));'), (994, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_foreign_enum_extension_lite   ));'), (995, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_import_enum_extension_lite    ));'), (1100, 1, u'+  ASSERT_TRUE(message.SerializeToString(&serialized));'), (1243, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_int32_extension_lite   ));'), (1244, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_int64_extension_lite   ));'), (1245, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_uint32_extension_lite  ));'), (1246, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_uint64_extension_lite  ));'), (1247, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sint32_extension_lite  ));'), (1248, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sint64_extension_lite  ));'), (1249, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_fixed32_extension_lite ));'), (1250, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_fixed64_extension_lite ));'), (1251, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sfixed32_extension_lite));'), (1252, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_sfixed64_extension_lite));'), (1253, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_float_extension_lite   ));'), (1254, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_double_extension_lite  ));'), (1255, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_bool_extension_lite    ));'), (1256, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_string_extension_lite  ));'), (1257, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_bytes_extension_lite   ));'), (1259, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeatedgroup_extension_lite           ));'), (1260, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_nested_message_extension_lite ));'), (1261, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_foreign_message_extension_lite));'), (1262, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_import_message_extension_lite ));'), (1263, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_nested_enum_extension_lite    ));'), (1264, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_foreign_enum_extension_lite   ));'), (1265, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::repeated_import_enum_extension_lite    ));'), (1382, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_int32_extension_lite   ));'), (1383, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_int64_extension_lite   ));'), (1384, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_uint32_extension_lite  ));'), (1385, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_uint64_extension_lite  ));'), (1386, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sint32_extension_lite  ));'), (1387, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sint64_extension_lite  ));'), (1388, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_fixed32_extension_lite ));'), (1389, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_fixed64_extension_lite ));'), (1390, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sfixed32_extension_lite));'), (1391, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sfixed64_extension_lite));'), (1392, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_float_extension_lite   ));'), (1393, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_double_extension_lite  ));'), (1394, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_bool_extension_lite    ));'), (1395, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_enum_extension_lite    ));'), (1453, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_int32_extension_lite   ));'), (1454, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_int64_extension_lite   ));'), (1455, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_uint32_extension_lite  ));'), (1456, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_uint64_extension_lite  ));'), (1457, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sint32_extension_lite  ));'), (1458, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sint64_extension_lite  ));'), (1459, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_fixed32_extension_lite ));'), (1460, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_fixed64_extension_lite ));'), (1461, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sfixed32_extension_lite));'), (1462, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_sfixed64_extension_lite));'), (1463, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_float_extension_lite   ));'), (1464, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_double_extension_lite  ));'), (1465, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_bool_extension_lite    ));'), (1466, 1, u'+  ASSERT_EQ(2, message.ExtensionSize(unittest::packed_enum_extension_lite    ));')]
===========================================
Class:class TempDirDeleter { class TempDirDeleter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 1, u'+      assert(err == inlen);')]
===========================================
Class:class TextFormat::Parser::ParserImpl { class TextFormat::Parser::ParserImpl 
Class:  class ParserErrorCollector : public io::ErrorCollector {   class ParserErrorCollector : public io::ErrorCollector 
Class:class TextFormatTest : public testing::Test { class TextFormatTest : public testing::Test 
Class:class UnknownFieldSetTest : public testing::Test { class UnknownFieldSetTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(64, 1, u'+    ASSERT_TRUE(empty_message_.ParseFromString(all_fields_data_));'), (120, 1, u'+      ASSERT_LT(pos, unknown_fields_->field_count());'), (124, 1, u'+        ASSERT_LT(pos, unknown_fields_->field_count());'), (134, 1, u'+  ASSERT_TRUE(field != NULL);'), (136, 1, u'+  ASSERT_EQ(UnknownField::TYPE_VARINT, field->type());'), (142, 1, u'+  ASSERT_TRUE(field != NULL);'), (144, 1, u'+  ASSERT_EQ(UnknownField::TYPE_FIXED32, field->type());'), (150, 1, u'+  ASSERT_TRUE(field != NULL);'), (152, 1, u'+  ASSERT_EQ(UnknownField::TYPE_FIXED64, field->type());'), (158, 1, u'+  ASSERT_TRUE(field != NULL);'), (160, 1, u'+  ASSERT_EQ(UnknownField::TYPE_LENGTH_DELIMITED, field->type());'), (166, 1, u'+  ASSERT_TRUE(field != NULL);'), (168, 1, u'+  ASSERT_EQ(UnknownField::TYPE_GROUP, field->type());'), (169, 1, u'+  ASSERT_EQ(1, field->group().field_count());'), (174, 1, u'+  ASSERT_TRUE(nested_field_descriptor != NULL);'), (177, 1, u'+  ASSERT_EQ(UnknownField::TYPE_VARINT, nested_field.type());'), (199, 1, u'+    ASSERT_FALSE(output_stream.HadError());'), (224, 1, u'+  ASSERT_TRUE(WireFormat::ParseAndMergePartial(&input, &message));'), (240, 1, u'+    ASSERT_FALSE(output.HadError());'), (258, 1, u'+  ASSERT_TRUE(other_message.ParseFromString(GetBizarroData()));'), (312, 1, u'+  ASSERT_TRUE(source.SerializeToString(&data));'), (315, 1, u'+  ASSERT_TRUE(destination.ParseFromString(all_fields_data_ + data));'), (318, 1, u'+  ASSERT_EQ(1, destination.unknown_fields().field_count());'), (319, 1, u'+  ASSERT_EQ(UnknownField::TYPE_VARINT,'), (331, 1, u'+  ASSERT_TRUE(all_types_message.ParseFromString(bizarro_data));'), (332, 1, u'+  ASSERT_TRUE(empty_message.ParseFromString(bizarro_data));'), (347, 1, u'+  ASSERT_TRUE(WireFormat::ParseAndMergePartial(&input, &all_types_message));'), (348, 1, u'+  ASSERT_TRUE(empty_message.ParseFromString(bizarro_data));'), (358, 1, u'+  ASSERT_TRUE(message.ParseFromString(all_fields_data_));'), (370, 1, u'+  ASSERT_TRUE(WireFormat::ParseAndMergePartial(&input, &message));'), (382, 1, u'+  ASSERT_TRUE(all_extensions_message.ParseFromString(bizarro_data));'), (383, 1, u'+  ASSERT_TRUE(empty_message.ParseFromString(bizarro_data));'), (399, 1, u'+  ASSERT_TRUE(singular_field != NULL);'), (400, 1, u'+  ASSERT_TRUE(repeated_field != NULL);'), (418, 1, u'+    ASSERT_TRUE(message.ParseFromString(data));'), (420, 1, u'+    ASSERT_EQ(2, message.repeated_nested_enum_size());'), (425, 1, u'+    ASSERT_EQ(3, unknown_fields.field_count());'), (428, 1, u'+    ASSERT_EQ(UnknownField::TYPE_VARINT, unknown_fields.field(0).type());'), (432, 1, u'+    ASSERT_EQ(UnknownField::TYPE_VARINT, unknown_fields.field(1).type());'), (436, 1, u'+    ASSERT_EQ(UnknownField::TYPE_VARINT, unknown_fields.field(2).type());'), (445, 1, u'+    ASSERT_TRUE(message.ParseFromString(data));'), (448, 1, u'+    ASSERT_EQ(2, message.ExtensionSize(repeated_nested_enum_extension));'), (455, 1, u'+    ASSERT_EQ(3, unknown_fields.field_count());'), (458, 1, u'+    ASSERT_EQ(UnknownField::TYPE_VARINT, unknown_fields.field(0).type());'), (462, 1, u'+    ASSERT_EQ(UnknownField::TYPE_VARINT, unknown_fields.field(1).type());'), (466, 1, u'+    ASSERT_EQ(UnknownField::TYPE_VARINT, unknown_fields.field(2).type());')]
===========================================
Class:class WireFormatInvalidInputTest : public testing::Test { class WireFormatInvalidInputTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(233, 1, u'+    ASSERT_FALSE(output.HadError());'), (241, 1, u'+    ASSERT_FALSE(output.HadError());'), (263, 1, u'+    ASSERT_FALSE(output.HadError());'), (271, 1, u'+    ASSERT_FALSE(output.HadError());'), (293, 1, u'+    ASSERT_FALSE(output.HadError());'), (301, 1, u'+    ASSERT_FALSE(output.HadError());'), (351, 1, u'+  ASSERT_TRUE(message_set.SerializeToString(&data));'), (355, 1, u'+  ASSERT_TRUE(raw.ParseFromString(data));'), (359, 1, u'+  ASSERT_EQ(3, raw.item_size());'), (395, 1, u'+  ASSERT_EQ(size, WireFormat::ByteSize(message_set));'), (415, 1, u'+    ASSERT_FALSE(output_stream.HadError());'), (423, 1, u'+    ASSERT_FALSE(output_stream.HadError());'), (459, 1, u'+  ASSERT_TRUE(raw.SerializeToString(&data));'), (463, 1, u'+  ASSERT_TRUE(message_set.ParseFromString(data));'), (470, 1, u'+  ASSERT_EQ(1, message_set.unknown_fields().field_count());'), (471, 1, u'+  ASSERT_EQ(UnknownField::TYPE_LENGTH_DELIMITED,'), (479, 1, u'+  ASSERT_TRUE(WireFormat::ParseAndMergePartial(&input, &dynamic_message_set));'), (620, 1, u'+  ASSERT_TRUE(field != NULL);'), (621, 1, u'+  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));'), (623, 1, u'+  ASSERT_TRUE(field != NULL);'), (624, 1, u'+  ASSERT_EQ(1, WireFormat::TagSize(field->number(), field->type()));'), (626, 1, u'+  ASSERT_TRUE(field != NULL);'), (627, 1, u'+  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));'), (629, 1, u'+  ASSERT_TRUE(field != NULL);'), (630, 1, u'+  ASSERT_EQ(2, WireFormat::TagSize(field->number(), field->type()));'), (632, 1, u'+  ASSERT_TRUE(field != NULL);'), (633, 1, u'+  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));'), (635, 1, u'+  ASSERT_TRUE(field != NULL);'), (636, 1, u'+  ASSERT_EQ(3, WireFormat::TagSize(field->number(), field->type()));'), (813, 1, u'+  ASSERT_EQ(1, errors.size());'), (820, 1, u'+  ASSERT_EQ(0, errors.size());'), (836, 1, u'+  ASSERT_EQ(1, errors.size());'), (843, 1, u'+  ASSERT_EQ(0, errors.size());'), (856, 1, u'+  ASSERT_EQ(0, errors.size());'), (870, 1, u'+  ASSERT_EQ(0, errors.size());'), (884, 1, u'+  ASSERT_EQ(0, errors.size());'), (898, 1, u'+  ASSERT_EQ(0, errors.size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 1, u'+  assert(results);'), (83, 1, u'+  assert(module_parts);'), (92, 1, u'+        assert(!"The file is invalid!");')]
===========================================
Class:class DumpSection: public mach_o::Reader::SectionHandler { class DumpSection: public mach_o::Reader::SectionHandler 
Class: class DumpCommand: public mach_o::Reader::LoadCommandHandler { class DumpCommand: public mach_o::Reader::LoadCommandHandler 
Class:class C { class C 
Class:class AutoSymSrv { class AutoSymSrv 
Class:    class AutoDeleter { class AutoDeleter 
Class:class C { class C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(16, 2, u'-    ASSERT(enabled || !debugger());'), (17, 2, u'-    ASSERT(enabled || !supportsProfiling());')]
===========================================
===========================================
Total add: 0
Total del: 17
Header: JSDOMWindowBase::supportsRichSourceInfo
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(16, 2, u'-    ASSERT(enabled || !debugger());'), (17, 2, u'-    ASSERT(enabled || !supportsProfiling());')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(16, 2, u'-    ASSERT(enabled || !debugger());'), (17, 2, u'-    ASSERT(enabled || !supportsProfiling());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  assert(conn->content_len >= conn->consumed_content);'), (3, 1, u'+  assert((conn->content_len == -1 && conn->consumed_content == 0) ||')]
===========================================
===========================================
Total add: 2
Total del: 1
Header: mg_read
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  assert(conn->content_len >= conn->consumed_content);'), (3, 1, u'+  assert((conn->content_len == -1 && conn->consumed_content == 0) ||')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  assert(conn->content_len >= conn->consumed_content);'), (3, 1, u'+  assert((conn->content_len == -1 && conn->consumed_content == 0) ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(10, 2, u'-  assert (conn);'), (11, 2, u'-  assert (conn->is_async);')]
===========================================
===========================================
Total add: 2
Total del: 13
Header: discard_current_request_from_buffer
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(10, 2, u'-  assert (conn);'), (11, 2, u'-  assert (conn->is_async);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(10, 2, u'-  assert (conn);'), (11, 2, u'-  assert (conn->is_async);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(11, 2, u'-      assert(conn != NULL);'), (19, 1, u'+  assert(conn != NULL);')]
===========================================
===========================================
Total add: 6
Total del: 11
Header: consume_socket
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(11, 2, u'-      assert(conn != NULL);'), (19, 1, u'+  assert(conn != NULL);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(11, 2, u'-      assert(conn != NULL);'), (19, 1, u'+  assert(conn != NULL);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 2, u'-    Q_ASSERT(QThread::currentThread() == thread());')]
===========================================
===========================================
Total add: 94
Total del: 84
Header: WebServer::close
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 2, u'-    Q_ASSERT(QThread::currentThread() == thread());')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 2, u'-    Q_ASSERT(QThread::currentThread() == thread());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(5, 2, u'-    Q_ASSERT(m_tcpConnection);')]
===========================================
===========================================
Total add: 3
Total del: 7
Header: InspectorServerRequestHandlerQt::tcpConnectionDisconnected
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(5, 2, u'-    Q_ASSERT(m_tcpConnection);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(5, 2, u'-    Q_ASSERT(m_tcpConnection);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 2, u'-        Q_ASSERT(!m_data[0]);')]
===========================================
===========================================
Total add: 34
Total del: 20
Header: InspectorServerRequestHandlerQt::webSocketReadyRead
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 2, u'-        Q_ASSERT(!m_data[0]);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 2, u'-        Q_ASSERT(!m_data[0]);')]
===========================================
Class: class ProjectBuilderSources { 
Class:class SourceFiles { class SourceFiles 
Class: class SubdirsMetaMakefileGenerator : public MetaMakefileGenerator { 
Class: class QMakeCacheClearItem { class QMakeCacheClearItem 
Class:    class = Get_New_Class( gdef, glyphID, index );
Class:  class = bits & 0x000F;
Class:  class       = ma->MarkRecord[mark_index].Class;
Class:  class       = ma->MarkRecord[mark_index].Class;
Class:  class        = ma1->MarkRecord[mark1_index].Class;
Class: class tst_CharAttributes : public QObject { 
Class:     class tst_QScriptEngine : public QObject { 
Class: class Shaper { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(304, 1, u'+  assert( 0==argc );'), (305, 1, u'+  assert( zShellStatic );'), (912, 1, u'+    assert( (zCsr-zIn)==len );'), (1122, 1, u'+            assert(sizeof(int) <= sizeof(char *));'), (2184, 1, u'+      { "assert",                SQLITE_TESTCTRL_ASSERT                 },'), (2256, 1, u'+        case SQLITE_TESTCTRL_ASSERT:'), (2312, 1, u'+    assert( nArg<=ArraySize(azArg) );')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(514, 1, u'+# define ALWAYS(X)      ((X)?1:(assert(0),0))'), (515, 1, u'+# define NEVER(X)       ((X)?(assert(0),1):0)'), (6124, 1, u'+#define SQLITE_TESTCTRL_ASSERT                  12'), (8515, 1, u'+SQLITE_PRIVATE   int sqlite3VdbeAssertMayAbort(Vdbe *, int);'), (12150, 1, u'+#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT'), (12947, 1, u'+  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );'), (12957, 1, u'+  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );'), (12969, 1, u'+  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );'), (13024, 1, u'+      assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)>=0 );'), (13025, 1, u'+      assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)<3 );'), (14401, 1, u'+  assert( rc==SQLITE_OK || pFile->pMethods==0 );'), (14485, 1, u'+  assert( pFile );'), (14539, 1, u'+  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) );'), (14576, 1, u'+  assert(vfsList);'), (14783, 1, u'+  assert( nByte>0 );'), (14806, 1, u'+  assert( pPrior!=0 );'), (14835, 1, u'+  assert( pPrior!=0 && nByte>0 );'), (14836, 1, u'+  assert( nByte==ROUND8(nByte) ); /* EV: R-46199-30249 */'), (15037, 1, u'+    assert( mem.nCurrent[i]>=0 );'), (15055, 1, u'+  assert( p->iForeGuard==(int)FOREGUARD );'), (15059, 1, u'+  assert( pInt[nReserve/sizeof(int)]==(int)REARGUARD );'), (15064, 1, u'+  while( nReserve-- > p->iSize ) assert( pU8[nReserve]==0x65 );'), (15085, 1, u'+  assert( (sizeof(struct MemBlockHdr)&7) == 0 );'), (15146, 1, u'+  assert( mem.disallow==0 );'), (15171, 1, u'+      assert(pBt[0]);'), (15200, 1, u'+  assert( sqlite3GlobalConfig.bMemstat || sqlite3GlobalConfig.bCoreMutex==0'), (15207, 1, u'+    assert( pHdr->pPrev->pNext==pHdr );'), (15210, 1, u'+    assert( mem.pFirst==pHdr );'), (15214, 1, u'+    assert( pHdr->pNext->pPrev==pHdr );'), (15217, 1, u'+    assert( mem.pLast==pHdr );'), (15241, 1, u'+  assert( mem.disallow==0 );'), (15242, 1, u'+  assert( (nByte & 7)==0 );     /* EV: R-46199-30249 */'), (15280, 1, u'+    assert( pHdr->iForeGuard==FOREGUARD );'), (15299, 1, u'+    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */'), (15321, 1, u'+    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */'), (15575, 1, u'+  assert( sqlite3_mutex_held(mem3.mutex) );'), (15594, 1, u'+  assert( sqlite3_mutex_held(mem3.mutex) );'), (15595, 1, u'+  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );'), (15596, 1, u'+  assert( i>=1 );'), (15598, 1, u'+  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );'), (15599, 1, u'+  assert( size>=2 );'), (15613, 1, u'+  assert( sqlite3_mutex_held(mem3.mutex) );'), (15628, 1, u'+  assert( sqlite3_mutex_held(mem3.mutex) );'), (15629, 1, u'+  assert( i>=1 );'), (15630, 1, u'+  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );'), (15632, 1, u'+  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );'), (15633, 1, u'+  assert( size>=2 );'), (15663, 1, u'+    assert( sqlite3_mutex_held(mem3.mutex) );'), (15679, 1, u'+  assert( sqlite3_mutex_held(mem3.mutex) );'), (15680, 1, u'+  assert( i>=1 );'), (15681, 1, u'+  assert( mem3.aPool[i-1].u.hdr.size4x/4==nBlock );'), (15682, 1, u'+  assert( mem3.aPool[i+nBlock-1].u.hdr.prevSize==nBlock );'), (15696, 1, u'+  assert( sqlite3_mutex_held(mem3.mutex) );'), (15697, 1, u'+  assert( mem3.szMaster>=nBlock );'), (15709, 1, u'+    assert( newi > mem3.iMaster+1 );'), (15743, 1, u'+  assert( sqlite3_mutex_held(mem3.mutex) );'), (15747, 1, u'+    assert( (size&1)==0 );'), (15750, 1, u'+      assert( i > mem3.aPool[i-1].u.hdr.prevSize );'), (15784, 1, u'+  assert( sqlite3_mutex_held(mem3.mutex) );'), (15785, 1, u'+  assert( sizeof(Mem3Block)==8 );'), (15791, 1, u'+  assert( nBlock>=2 );'), (15865, 1, u'+  assert( sqlite3_mutex_held(mem3.mutex) );'), (15866, 1, u'+  assert( p>mem3.aPool && p<&mem3.aPool[mem3.nPool] );'), (15868, 1, u'+  assert( (mem3.aPool[i-1].u.hdr.size4x&1)==1 );'), (15870, 1, u'+  assert( i+size<=mem3.nPool+1 );'), (15906, 1, u'+  assert( (pBlock[-1].u.hdr.size4x&1)!=0 );'), (15926, 1, u'+  assert( nBytes>0 );          /* malloc.c filters out 0 byte requests */'), (15937, 1, u'+  assert( pPrior );'), (15984, 1, u'+  assert( sizeof(Mem3Block)==8 );'), (16035, 1, u'+      assert( 0 );'), (16040, 1, u'+      assert( 0 );'), (16045, 1, u'+      assert( 0 );'), (16263, 1, u'+  assert( i>=0 && i<mem5.nBlock );'), (16264, 1, u'+  assert( iLogsize>=0 && iLogsize<=LOGMAX );'), (16265, 1, u'+  assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize );'), (16285, 1, u'+  assert( sqlite3_mutex_held(mem5.mutex) );'), (16286, 1, u'+  assert( i>=0 && i<mem5.nBlock );'), (16287, 1, u'+  assert( iLogsize>=0 && iLogsize<=LOGMAX );'), (16288, 1, u'+  assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize );'), (16293, 1, u'+    assert( x<mem5.nBlock );'), (16320, 1, u'+    assert( i>=0 && i<mem5.nBlock );'), (16334, 1, u'+  assert( iLogsize>=0 && iLogsize<=LOGMAX );'), (16336, 1, u'+  assert( iFirst>=0 );'), (16362, 1, u'+  assert( nByte>0 );'), (16427, 1, u'+  assert( iBlock>=0 && iBlock<mem5.nBlock );'), (16428, 1, u'+  assert( ((u8 *)pOld-mem5.zPool)%mem5.szAtom==0 );'), (16429, 1, u'+  assert( (mem5.aCtrl[iBlock] & CTRL_FREE)==0 );'), (16433, 1, u'+  assert( iBlock+size-1<(u32)mem5.nBlock );'), (16437, 1, u'+  assert( mem5.currentCount>0 );'), (16438, 1, u'+  assert( mem5.currentOut>=(size*mem5.szAtom) );'), (16441, 1, u'+  assert( mem5.currentOut>0 || mem5.currentCount==0 );'), (16442, 1, u'+  assert( mem5.currentCount>0 || mem5.currentOut==0 );'), (16452, 1, u'+    assert( iBuddy>=0 );'), (16490, 1, u'+  assert( pPrior!=0 );'), (16511, 1, u'+  assert( pPrior!=0 );'), (16512, 1, u'+  assert( (nBytes&(nBytes-1))==0 );  /* EV: R-46199-30249 */'), (16513, 1, u'+  assert( nBytes>=0 );'), (16584, 1, u'+  assert( (sizeof(Mem5Link)&(sizeof(Mem5Link)-1))==0 );'), (16588, 1, u'+  assert( zByte!=0 );  /* sqlite3_config() does not allow otherwise */'), (16613, 1, u'+    assert((iOffset+nAlloc)>mem5.nBlock);'), (16790, 1, u'+  assert( GLOBAL(int, mutexIsInit) );'), (16975, 1, u'+      assert( id-2 >= 0 );'), (16976, 1, u'+      assert( id-2 < (int)(sizeof(aStatic)/sizeof(aStatic[0])) );'), (16990, 1, u'+  assert( p->cnt==0 );'), (16991, 1, u'+  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );'), (17008, 1, u'+  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );'), (17013, 1, u'+  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );'), (17026, 1, u'+  assert( debugMutexHeld(pX) );'), (17028, 1, u'+  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );'), (17206, 1, u'+      assert( iType-2 >= 0 );'), (17207, 1, u'+      assert( iType-2 < sizeof(staticMutexes)/sizeof(staticMutexes[0]) );'), (17227, 1, u'+  assert( ulCount==0 );'), (17228, 1, u'+  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );'), (17282, 1, u'+  assert( p->id==SQLITE_MUTEX_RECURSIVE || os2MutexNotheld(p) );'), (17290, 1, u'+  assert( p->id==SQLITE_MUTEX_RECURSIVE || os2MutexNotheld(p) );'), (17307, 1, u'+  assert( os2MutexHeld(p) );'), (17508, 1, u'+      assert( iType-2 >= 0 );'), (17509, 1, u'+      assert( iType-2 < ArraySize(staticMutexes) );'), (17527, 1, u'+  assert( p->nRef==0 );'), (17528, 1, u'+  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );'), (17545, 1, u'+  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );'), (17564, 1, u'+      assert( p->nRef==0 );'), (17574, 1, u'+  assert( p->nRef>0 || p->owner==0 );'), (17588, 1, u'+  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );'), (17607, 1, u'+      assert( p->nRef==0 );'), (17644, 1, u'+  assert( pthreadMutexHeld(p) );'), (17649, 1, u'+  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );'), (17891, 1, u'+      assert( winMutex_isInit==1 );'), (17892, 1, u'+      assert( iType-2 >= 0 );'), (17893, 1, u'+      assert( iType-2 < ArraySize(winMutex_staticMutexes) );'), (17911, 1, u'+  assert( p );'), (17912, 1, u'+  assert( p->nRef==0 && p->owner==0 );'), (17913, 1, u'+  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );'), (17932, 1, u'+  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );'), (17936, 1, u'+  assert( p->nRef>0 || p->owner==0 );'), (17949, 1, u'+  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );'), (17987, 1, u'+  assert( p->nRef>0 );'), (17988, 1, u'+  assert( p->owner==tid );'), (17991, 1, u'+  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );'), (18286, 1, u'+  assert( sqlite3_mutex_held(mem0.mutex) );'), (18336, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(p) );  /* IMP: R-04675-44850 */'), (18373, 1, u'+  assert( n>0 );'), (18395, 1, u'+  assert( sqlite3_mutex_notheld(mem0.mutex) );'), (18403, 1, u'+  assert( scratchAllocOut<=1 );'), (18417, 1, u'+    assert( scratchAllocOut>=1 && scratchAllocOut<=2 );'), (18429, 1, u'+      assert( mem0.nScratchFree <= (u32)sqlite3GlobalConfig.nScratch );'), (18434, 1, u'+      assert( sqlite3MemdebugHasType(p, MEMTYPE_SCRATCH) );'), (18435, 1, u'+      assert( sqlite3MemdebugNoType(p, ~MEMTYPE_SCRATCH) );'), (18468, 1, u'+  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );'), (18469, 1, u'+  assert( sqlite3MemdebugNoType(p, MEMTYPE_DB) );'), (18473, 1, u'+  assert( db==0 || sqlite3_mutex_held(db->mutex) );'), (18477, 1, u'+    assert( sqlite3MemdebugHasType(p, MEMTYPE_DB) );'), (18478, 1, u'+    assert( sqlite3MemdebugHasType(p, MEMTYPE_LOOKASIDE|MEMTYPE_HEAP) );'), (18479, 1, u'+    assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );'), (18489, 1, u'+  assert( sqlite3MemdebugNoType(p, MEMTYPE_DB) );'), (18490, 1, u'+  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );'), (18507, 1, u'+  assert( db==0 || sqlite3_mutex_held(db->mutex) );'), (18521, 1, u'+  assert( sqlite3MemdebugHasType(p, MEMTYPE_DB) );'), (18522, 1, u'+  assert( sqlite3MemdebugHasType(p, MEMTYPE_LOOKASIDE|MEMTYPE_HEAP) );'), (18523, 1, u'+  assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );'), (18560, 1, u'+    assert( sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP) );'), (18561, 1, u'+    assert( sqlite3MemdebugNoType(pOld, ~MEMTYPE_HEAP) );'), (18575, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(pNew) ); /* IMP: R-04675-44850 */'), (18634, 1, u'+  assert( db==0 || sqlite3_mutex_held(db->mutex) );'), (18635, 1, u'+  assert( db==0 || db->pnBytesFreed==0 );'), (18678, 1, u'+  assert( db!=0 );'), (18679, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (18694, 1, u'+      assert( sqlite3MemdebugHasType(p, MEMTYPE_DB) );'), (18695, 1, u'+      assert( sqlite3MemdebugHasType(p, MEMTYPE_LOOKASIDE|MEMTYPE_HEAP) );'), (18736, 1, u'+  assert( (n&0x7fffffff)==n );'), (18748, 1, u'+  assert( (n&0x7fffffff)==n );'), (18792, 1, u'+  assert( !db || sqlite3_mutex_held(db->mutex) );'), (19362, 1, u'+          assert( precision>0 );'), (19372, 1, u'+          assert( bufpt>buf );'), (19504, 1, u'+        assert( k>=0 && k<pSrc->nSrc );'), (19514, 1, u'+        assert( xtype==etINVALID );'), (19550, 1, u'+  assert( z!=0 || N==0 );'), (19660, 1, u'+  assert( db!=0 );'), (20189, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (20190, 1, u'+  assert( pMem->flags&MEM_Str );'), (20191, 1, u'+  assert( pMem->enc!=desiredEnc );'), (20192, 1, u'+  assert( pMem->enc!=0 );'), (20193, 1, u'+  assert( pMem->n>=0 );'), (20212, 1, u'+      assert( rc==SQLITE_NOMEM );'), (20268, 1, u'+      assert( desiredEnc==SQLITE_UTF16BE );'), (20279, 1, u'+    assert( desiredEnc==SQLITE_UTF8 );'), (20296, 1, u'+  assert( (pMem->n+(desiredEnc==SQLITE_UTF8?1:2))<=len );'), (20329, 1, u'+  assert( pMem->n>=0 );'), (20372, 1, u'+  assert( z<=zTerm );'), (20427, 1, u'+  assert( (m.flags & MEM_Term)!=0 || db->mallocFailed );'), (20428, 1, u'+  assert( (m.flags & MEM_Str)!=0 || db->mallocFailed );'), (20429, 1, u'+  assert( (m.flags & MEM_Dyn)!=0 || db->mallocFailed );'), (20430, 1, u'+  assert( m.z || db->mallocFailed );'), (20451, 1, u'+    assert( db->mallocFailed );'), (20454, 1, u'+  assert( m.z==m.zMalloc );'), (20501, 1, u'+    assert( n>0 && n<=4 );'), (20508, 1, u'+    assert( c==t );'), (20509, 1, u'+    assert( (z-zBuf)==n );'), (20516, 1, u'+    assert( n>0 && n<=4 );'), (20520, 1, u'+    assert( c==i );'), (20521, 1, u'+    assert( (z-zBuf)==n );'), (20528, 1, u'+    assert( n>0 && n<=4 );'), (20532, 1, u'+    assert( c==i );'), (20533, 1, u'+    assert( (z-zBuf)==n );'), (21037, 1, u'+    assert( u<=LARGEST_INT64 );'), (21044, 1, u'+      assert( u<=LARGEST_INT64 );'), (21052, 1, u'+      assert( u-1==LARGEST_INT64 );'), (21053, 1, u'+      assert( (*pNum)==SMALLEST_INT64 );'), (21159, 1, u'+  assert( n<=9 );'), (21230, 1, u'+  assert( SLOT_2_0 == ((0x7f<<14) | (0x7f)) );'), (21231, 1, u'+  assert( SLOT_4_2_0 == ((0xfU<<28) | (0x7f<<14) | (0x7f)) );'), (21436, 1, u'+    assert( n>3 && n<=9 );'), (21488, 1, u'+    assert( n>5 && n<=9 );'), (21530, 1, u"+  assert( (h>='0' && h<='9') ||  (h>='a' && h<='f') ||  (h>='A' && h<='F') );"), (21665, 1, u'+  assert( iA1*iB0==0 || iA0*iB1==0 );'), (21737, 1, u'+  assert( pNew!=0 );'), (21751, 1, u'+  assert( pH!=0 );'), (21770, 1, u'+  assert( nKey>=0 );'), (21901, 1, u'+    assert( pEntry->count>=0 );'), (21906, 1, u'+    assert( pH->first==0 );'), (21907, 1, u'+    assert( pH->count==0 );'), (21920, 1, u'+  assert( pH!=0 );'), (21921, 1, u'+  assert( pKey!=0 );'), (21922, 1, u'+  assert( nKey>=0 );'), (21951, 1, u'+  assert( pH!=0 );'), (21952, 1, u'+  assert( pKey!=0 );'), (21953, 1, u'+  assert( nKey>=0 );'), (21967, 1, u'+      assert(nKey==elem->nKey);'), (21980, 1, u'+      assert( pH->htsize>0 );'), (22453, 1, u'+  assert( id!=0 );'), (22485, 1, u'+  assert( id!=0 );'), (22517, 1, u'+  assert( id!=0 );'), (22524, 1, u'+  assert( amt>0 );'), (22542, 1, u'+  assert( id!=0 );'), (22598, 1, u'+  assert( id!=0 );'), (22681, 1, u'+  assert( pFile!=0 );'), (22695, 1, u'+  assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK );'), (22696, 1, u'+  assert( locktype!=PENDING_LOCK );'), (22697, 1, u'+  assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK );'), (22723, 1, u'+    assert( pFile->locktype==NO_LOCK );'), (22734, 1, u'+    assert( pFile->locktype==SHARED_LOCK );'), (22758, 1, u'+    assert( pFile->locktype>=SHARED_LOCK );'), (22811, 1, u'+  assert( pFile!=0 );'), (22863, 1, u'+  assert( pFile!=0 );'), (22864, 1, u'+  assert( locktype<=SHARED_LOCK );'), (23195, 1, u'+  assert( sqlite3_mutex_held(pNode->mutex) || pNode->nRef==0 );'), (23444, 1, u'+    assert( szRegion==pNode->szRegion );'), (23530, 1, u'+    assert(*ppLink);'), (23573, 1, u'+  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );'), (23574, 1, u'+  assert( n>=1 );'), (23575, 1, u'+  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)'), (23579, 1, u'+  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );'), (23582, 1, u'+  assert( n>1 || mask==(1<<ofst) );'), (23593, 1, u'+      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );'), (23654, 1, u'+        assert( (p->sharedMask & mask)==0 );'), (23845, 1, u'+  assert( id!=0 );'), (23854, 1, u'+  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));'), (23855, 1, u'+  assert(isCreate==0 || isReadWrite);'), (23856, 1, u'+  assert(isExclusive==0 || isCreate);'), (23857, 1, u'+  assert(isDelete==0 || isCreate);'), (23861, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );'), (23862, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );'), (23863, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );'), (23864, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );'), (23867, 1, u'+  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DB'), (23880, 1, u'+    assert(isDelete && !isOpenJournal);'), (24016, 1, u'+      assert( !"Invalid flags argument" );'), (24235, 1, u"+  assert(zBuf[0]=='\\0');"), (25058, 1, u'+    assert( 0 );'), (25060, 1, u'+  assert( p->l_whence==SEEK_SET );'), (25077, 1, u'+      assert( 0 );'), (25268, 1, u"+  assert( zAbsoluteName[0]=='/' );"), (25307, 1, u'+  assert( pId->nRef>0 );'), (25312, 1, u'+    assert( *pp==pId );'), (25520, 1, u'+  assert( errcode!=SQLITE_OK );'), (25573, 1, u'+  assert( unixMutexHeld() );'), (25577, 1, u'+      assert( pInode->pShmNode==0 );'), (25580, 1, u'+        assert( pInode->pPrev->pNext==pInode );'), (25583, 1, u'+        assert( inodeList==pInode );'), (25587, 1, u'+        assert( pInode->pNext->pPrev==pInode );'), (25615, 1, u'+  assert( unixMutexHeld() );'), (25699, 1, u'+  assert( pFile );'), (25759, 1, u'+  assert( unixMutexHeld() );'), (25760, 1, u'+  assert( pInode!=0 );'), (25766, 1, u'+      assert( pInode->nLock==0 );'), (25853, 1, u'+  assert( pFile );'), (25873, 1, u'+  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );'), (25874, 1, u'+  assert( eFileLock!=PENDING_LOCK );'), (25875, 1, u'+  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );'), (25898, 1, u'+    assert( eFileLock==SHARED_LOCK );'), (25899, 1, u'+    assert( pFile->eFileLock==0 );'), (25900, 1, u'+    assert( pInode->nShared>0 );'), (25934, 1, u'+    assert( pInode->nShared==0 );'), (25935, 1, u'+    assert( pInode->eFileLock==0 );'), (25936, 1, u'+    assert( rc==SQLITE_OK );'), (25975, 1, u'+    assert( 0!=pFile->eFileLock );'), (25978, 1, u'+    assert( eFileLock==RESERVED_LOCK || eFileLock==EXCLUSIVE_LOCK );'), (26062, 1, u'+  assert( pFile );'), (26067, 1, u'+  assert( eFileLock<=SHARED_LOCK );'), (26074, 1, u'+  assert( pInode->nShared!=0 );'), (26076, 1, u'+    assert( pInode->eFileLock==pFile->eFileLock );'), (26091, 1, u'+    assert( pFile->inNormalWrite==0'), (26111, 1, u'+      assert( handleNFSUnlock==0 );'), (26177, 1, u'+    lock.l_len = 2L;  assert( PENDING_BYTE+1==RESERVED_BYTE );'), (26214, 1, u'+    assert( pInode->nLock>=0 );'), (26285, 1, u'+  assert( pFile->pInode->nLock>0 || pFile->pInode->bProcessLock==0 );'), (26389, 1, u'+  assert( pFile );'), (26489, 1, u'+  assert( pFile );'), (26492, 1, u'+  assert( eFileLock<=SHARED_LOCK );'), (26508, 1, u'+  assert( eFileLock==NO_LOCK );'), (26584, 1, u'+  assert( pFile );'), (26663, 1, u'+  assert( pFile );'), (26706, 1, u'+  assert( pFile );'), (26709, 1, u'+  assert( eFileLock<=SHARED_LOCK );'), (26774, 1, u'+  assert( pFile );'), (26873, 1, u'+  assert( pFile );'), (26874, 1, u'+  assert( pSem );'), (26877, 1, u'+  assert( eFileLock<=SHARED_LOCK );'), (26910, 1, u'+    assert( pFile );'), (27018, 1, u'+  assert( pFile );'), (27086, 1, u'+  assert( pFile );'), (27106, 1, u'+  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );'), (27107, 1, u'+  assert( eFileLock!=PENDING_LOCK );'), (27108, 1, u'+  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );'), (27131, 1, u'+    assert( eFileLock==SHARED_LOCK );'), (27132, 1, u'+    assert( pFile->eFileLock==0 );'), (27133, 1, u'+    assert( pInode->nShared>0 );'), (27162, 1, u'+    assert( pInode->nShared==0 );'), (27163, 1, u'+    assert( pInode->eFileLock==0 );'), (27202, 1, u'+    assert( 0!=pFile->eFileLock );'), (27272, 1, u'+  assert( pFile );'), (27277, 1, u'+  assert( eFileLock<=SHARED_LOCK );'), (27283, 1, u'+  assert( pInode->nShared!=0 );'), (27285, 1, u'+    assert( pInode->eFileLock==pFile->eFileLock );'), (27299, 1, u'+    assert( pFile->inNormalWrite==0'), (27350, 1, u'+      assert( pInode->nLock>=0 );'), (27490, 1, u'+  assert( id );'), (27495, 1, u'+  assert( pFile->pUnused==0'), (27571, 1, u'+  assert( id );'), (27572, 1, u'+  assert( amt>0 );'), (27577, 1, u'+  assert( pFile->pUnused==0'), (27772, 1, u'+  assert((flags&0x0F)==SQLITE_SYNC_NORMAL'), (27781, 1, u'+  assert( pFile );'), (27821, 1, u'+  assert( pFile );'), (27861, 1, u'+  assert( id );'), (28107, 1, u'+  assert( sqlite3_mutex_held(pShmNode->mutex) || pShmNode->nRef==0 );'), (28110, 1, u'+  assert( n==1 || lockType!=F_RDLCK );'), (28113, 1, u'+  assert( n>=1 && n<SQLITE_SHM_NLOCK );'), (28142, 1, u'+      assert( lockType==F_WRLCK );'), (28153, 1, u'+      assert( lockType==F_WRLCK );'), (28174, 1, u'+  assert( unixMutexHeld() );'), (28177, 1, u'+    assert( p->pInode==pFd->pInode );'), (28243, 1, u'+  assert( pDbFd->pShm==0 );'), (28396, 1, u'+  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );'), (28397, 1, u'+  assert( pShmNode->pInode==pDbFd->pInode );'), (28398, 1, u'+  assert( pShmNode->h>=0 || pDbFd->pInode->bProcessLock==1 );'), (28399, 1, u'+  assert( pShmNode->h<0 || pDbFd->pInode->bProcessLock==0 );'), (28499, 1, u'+  assert( pShmNode==pDbFd->pInode->pShmNode );'), (28500, 1, u'+  assert( pShmNode->pInode==pDbFd->pInode );'), (28501, 1, u'+  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );'), (28502, 1, u'+  assert( n>=1 );'), (28503, 1, u'+  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)'), (28507, 1, u'+  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );'), (28508, 1, u'+  assert( pShmNode->h>=0 || pDbFd->pInode->bProcessLock==1 );'), (28509, 1, u'+  assert( pShmNode->h<0 || pDbFd->pInode->bProcessLock==0 );'), (28512, 1, u'+  assert( n>1 || mask==(1<<ofst) );'), (28520, 1, u'+      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );'), (28581, 1, u'+        assert( (p->sharedMask & mask)==0 );'), (28627, 1, u'+  assert( pShmNode==pDbFd->pInode->pShmNode );'), (28628, 1, u'+  assert( pShmNode->pInode==pDbFd->pInode );'), (28644, 1, u'+  assert( pShmNode->nRef>0 );'), (28971, 1, u'+  assert( pNew->pInode==NULL );'), (28983, 1, u"+  assert( zFilename==0 || zFilename[0]=='/'"), (28986, 1, u"+  assert( zFilename==0 || zFilename[0]=='/' );"), (29443, 1, u'+  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));'), (29444, 1, u'+  assert(isCreate==0 || isReadWrite);'), (29445, 1, u'+  assert(isExclusive==0 || isCreate);'), (29446, 1, u'+  assert(isDelete==0 || isCreate);'), (29450, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );'), (29451, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );'), (29452, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );'), (29453, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );'), (29456, 1, u'+  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DB'), (29478, 1, u'+    assert(isDelete && !isOpenDirectory);'), (29500, 1, u'+      assert( !p->pUnused );'), (29501, 1, u'+      assert( eType==SQLITE_OPEN_WAL || eType==SQLITE_OPEN_MAIN_JOURNAL );'), (29520, 1, u'+  assert( fd>=0 );'), (29550, 1, u'+      assert( eType!=SQLITE_OPEN_MAIN_DB );'), (29703, 1, u'+      assert(!"Invalid flags argument");'), (29739, 1, u'+  assert( pVfs->mxPathname==MAX_PATHNAME );'), (29824, 1, u'+  assert((size_t)nBuf>=(sizeof(time_t)+sizeof(int)));'), (29849, 1, u'+      assert( sizeof(t)+sizeof(pid)<=(size_t)nBuf );'), (30186, 1, u'+  assert(lockPath!=NULL);'), (30318, 1, u'+  assert(PROXY_HOSTIDLEN == sizeof(uuid_t));'), (30446, 1, u'+      assert( nTries>1 );'), (30472, 1, u'+      assert( nTries==3 );'), (30772, 1, u'+  assert( (int)strlen(conchPath) == len+7 );'), (30822, 1, u'+    assert( (int)strlen((char*)pFile->lockingContext)<=MAXPATHLEN );'), (30833, 1, u'+    assert( strlen((char*)pFile->lockingContext)<=MAXPATHLEN );'), (30984, 1, u'+      assert( 0 );  /* The call assures that only valid opcodes are sent */'), (31229, 1, u'+  assert( ArraySize(aSyscall)==16 );'), (31851, 1, u'+  assert( errcode!=SQLITE_OK );'), (32115, 1, u'+      assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE);'), (32123, 1, u'+      assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE || nNumberOfBytesToUnlockLow == 1);'), (32239, 1, u'+  assert( id!=0 );'), (32240, 1, u'+  assert( pFile->pShm==0 );'), (32281, 1, u'+  assert( id!=0 );'), (32314, 1, u'+  assert( amt>0 );'), (32315, 1, u'+  assert( pFile );'), (32354, 1, u'+  assert( pFile );'), (32400, 1, u'+  assert( pFile );'), (32402, 1, u'+  assert((flags&0x0F)==SQLITE_SYNC_NORMAL'), (32448, 1, u'+  assert( id!=0 );'), (32554, 1, u'+  assert( id!=0 );'), (32568, 1, u'+  assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK );'), (32569, 1, u'+  assert( locktype!=PENDING_LOCK );'), (32570, 1, u'+  assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK );'), (32598, 1, u'+    assert( pFile->locktype==NO_LOCK );'), (32610, 1, u'+    assert( pFile->locktype==SHARED_LOCK );'), (32629, 1, u'+    assert( pFile->locktype>=SHARED_LOCK );'), (32675, 1, u'+  assert( id!=0 );'), (32706, 1, u'+  assert( pFile!=0 );'), (32707, 1, u'+  assert( locktype<=SHARED_LOCK );'), (32774, 1, u'+  assert( id!=0 );'), (32919, 1, u'+  assert( sqlite3_mutex_held(pFile->mutex) || pFile->nRef==0 );'), (32965, 1, u'+  assert( winShmMutexHeld() );'), (33014, 1, u'+  assert( pDbFd->pShm==0 );    /* Not previously opened */'), (33148, 1, u'+  assert( pShmNode->nRef>0 );'), (33174, 1, u'+  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );'), (33175, 1, u'+  assert( n>=1 );'), (33176, 1, u'+  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)'), (33180, 1, u'+  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );'), (33183, 1, u'+  assert( n>1 || mask==(1<<ofst) );'), (33191, 1, u'+      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );'), (33252, 1, u'+        assert( (p->sharedMask & mask)==0 );'), (33318, 1, u'+  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );'), (33601, 1, u'+  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));'), (33602, 1, u'+  assert(isCreate==0 || isReadWrite);'), (33603, 1, u'+  assert(isExclusive==0 || isCreate);'), (33604, 1, u'+  assert(isDelete==0 || isCreate);'), (33608, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );'), (33609, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );'), (33610, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );'), (33611, 1, u'+  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );'), (33614, 1, u'+  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DB'), (33620, 1, u'+  assert( id!=0 );'), (33629, 1, u'+    assert(isDelete && !isOpenJournal);'), (33888, 1, u'+      assert(!"Invalid flags argument");'), (34296, 1, u'+  assert(winSysInfo.dwAllocationGranularity > 0);'), (34424, 1, u'+  assert( sizeof(*p)==BITVEC_SZ );'), (34476, 1, u'+  assert( i>0 );'), (34477, 1, u'+  assert( i<=p->iSize );'), (34546, 1, u'+  assert( i>0 );'), (34757, 1, u'+#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT'), (34758, 1, u'+# define expensive_assert(X)  assert(X)'), (34760, 1, u'+# define expensive_assert(X)'), (34765, 1, u'+#if !defined(NDEBUG) && defined(SQLITE_ENABLE_EXPENSIVE_ASSERT)'), (34776, 1, u'+    assert( p->nRef || (p->flags&PGHDR_NEED_SYNC) );'), (34788, 1, u'+  assert( pPage->pDirtyNext || pPage==p->pDirtyTail );'), (34789, 1, u'+  assert( pPage->pDirtyPrev || pPage==p->pDirty );'), (34803, 1, u'+    assert( pPage==p->pDirtyTail );'), (34809, 1, u'+    assert( pPage==p->pDirty );'), (34815, 1, u'+  expensive_assert( pcacheCheckSynced(p) );'), (34825, 1, u'+  assert( pPage->pDirtyNext==0 && pPage->pDirtyPrev==0 && p->pDirty!=pPage );'), (34829, 1, u'+    assert( pPage->pDirtyNext->pDirtyPrev==0 );'), (34839, 1, u'+  expensive_assert( pcacheCheckSynced(p) );'), (34910, 1, u'+  assert( pCache->nRef==0 && pCache->pDirty==0 );'), (34931, 1, u'+  assert( pCache!=0 );'), (34932, 1, u'+  assert( createFlag==1 || createFlag==0 );'), (34933, 1, u'+  assert( pgno>0 );'), (34963, 1, u'+    expensive_assert( pcacheCheckSynced(pCache) );'), (34999, 1, u'+    assert( pPage->pCache==pCache );'), (35000, 1, u'+    assert( pPage->pgno==pgno );'), (35001, 1, u'+    assert( pPage->pData==(void *)&pPage[1] );'), (35002, 1, u'+    assert( pPage->pExtra==(void *)&((char *)&pPage[1])[pCache->szPage] );'), (35021, 1, u'+  assert( p->nRef>0 );'), (35040, 1, u'+  assert(p->nRef>0);'), (35051, 1, u'+  assert( p->nRef==1 );'), (35069, 1, u'+  assert( p->nRef>0 );'), (35116, 1, u'+  assert( p->nRef>0 );'), (35117, 1, u'+  assert( newPgno>0 );'), (35145, 1, u'+      assert( p->pgno>0 );'), (35147, 1, u'+        assert( p->flags&PGHDR_DIRTY );'), (35524, 1, u'+  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );'), (35533, 1, u'+      assert( pcache1.nFreeSlot>=0 );'), (35568, 1, u'+    assert( pcache1.nFreeSlot<=pcache1.nSlot );'), (35572, 1, u'+    assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );'), (35591, 1, u'+    assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );'), (35690, 1, u'+  assert( sqlite3_mutex_held(p->pGroup->mutex) );'), (35738, 1, u'+  assert( sqlite3_mutex_held(pGroup->mutex) );'), (35770, 1, u'+  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );'), (35783, 1, u'+  assert( sqlite3_mutex_held(pGroup->mutex) );'), (35786, 1, u'+    assert( p->pCache->pGroup==pGroup );'), (35806, 1, u'+  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );'), (35822, 1, u'+  assert( pCache->nPage==nPage );'), (35833, 1, u'+  assert( pcache1.isInit==0 );'), (35851, 1, u'+  assert( pcache1.isInit!=0 );'), (35998, 1, u'+  assert( pCache->bPurgeable || createFlag!=1 );'), (35999, 1, u'+  assert( pCache->bPurgeable || pCache->nMin==0 );'), (36000, 1, u'+  assert( pCache->bPurgeable==0 || pCache->nMin==10 );'), (36001, 1, u'+  assert( pCache->nMin==0 || pCache->bPurgeable );'), (36030, 1, u'+  assert( nPinned>=0 );'), (36031, 1, u'+  assert( pGroup->mxPinned == pGroup->nMaxPage + 10 - pGroup->nMinPage );'), (36032, 1, u'+  assert( pCache->n90pct == pCache->nMax*9/10 );'), (36106, 1, u'+  assert( pPage->pCache==pCache );'), (36112, 1, u'+  assert( pPage->pLruPrev==0 && pPage->pLruNext==0 );'), (36113, 1, u'+  assert( pGroup->pLruHead!=pPage && pGroup->pLruTail!=pPage );'), (36147, 1, u'+  assert( pPage->iKey==iOld );'), (36148, 1, u'+  assert( pPage->pCache==pCache );'), (36195, 1, u'+  assert( pCache->bPurgeable || (pCache->nMax==0 && pCache->nMin==0) );'), (36241, 1, u'+  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );'), (36242, 1, u'+  assert( sqlite3_mutex_notheld(pcache1.mutex) );'), (36409, 1, u'+  assert( N >= ROUND8(sizeof(*p)) );'), (36451, 1, u'+  assert( p!=0 );'), (36474, 1, u'+    assert( p->pEntry==0 ); /* Fires if INSERT after SMALLEST */'), (36495, 1, u'+    assert( pA->pRight==0 || pA->v<=pA->pRight->v );'), (36496, 1, u'+    assert( pB->pRight==0 || pB->v<=pB->pRight->v );'), (36510, 1, u'+    assert( pA->pRight==0 || pA->v<=pA->pRight->v );'), (36513, 1, u'+    assert( pB==0 || pB->pRight==0 || pB->v<=pB->pRight->v );'), (36527, 1, u'+  assert( p->isSorted==0 );'), (36559, 1, u'+  assert( pIn!=0 );'), (36572, 1, u'+  assert( (*ppLast)->pRight==0 );'), (36624, 1, u'+  assert( pList!=0 );'), (37633, 1, u'+static int assert_pager_state(Pager *p){'), (37637, 1, u'+  assert( p->eState==PAGER_OPEN'), (37650, 1, u'+  assert( p->tempFile==0 || p->eLock==EXCLUSIVE_LOCK );'), (37651, 1, u'+  assert( p->tempFile==0 || pPager->changeCountDone );'), (37656, 1, u'+  assert( p->journalMode==PAGER_JOURNALMODE_OFF || p->useJournal );'), (37657, 1, u'+  assert( p->journalMode!=PAGER_JOURNALMODE_OFF || !isOpen(p->jfd) );'), (37668, 1, u'+    assert( p->noSync );'), (37669, 1, u'+    assert( p->journalMode==PAGER_JOURNALMODE_OFF'), (37672, 1, u'+    assert( p->eState!=PAGER_ERROR && p->eState!=PAGER_OPEN );'), (37673, 1, u'+    assert( pagerUseWal(p)==0 );'), (37679, 1, u'+  assert( pPager->changeCountDone==0 || pPager->eLock>=RESERVED_LOCK );'), (37680, 1, u'+  assert( p->eLock!=PENDING_LOCK );'), (37684, 1, u'+      assert( !MEMDB );'), (37685, 1, u'+      assert( pPager->errCode==SQLITE_OK );'), (37686, 1, u'+      assert( sqlite3PcacheRefCount(pPager->pPCache)==0 || pPager->tempFile );'), (37690, 1, u'+      assert( pPager->errCode==SQLITE_OK );'), (37691, 1, u'+      assert( p->eLock!=UNKNOWN_LOCK );'), (37692, 1, u'+      assert( p->eLock>=SHARED_LOCK || p->noReadlock );'), (37696, 1, u'+      assert( p->eLock!=UNKNOWN_LOCK );'), (37697, 1, u'+      assert( pPager->errCode==SQLITE_OK );'), (37699, 1, u'+        assert( p->eLock>=RESERVED_LOCK );'), (37701, 1, u'+      assert( pPager->dbSize==pPager->dbOrigSize );'), (37702, 1, u'+      assert( pPager->dbOrigSize==pPager->dbFileSize );'), (37703, 1, u'+      assert( pPager->dbOrigSize==pPager->dbHintSize );'), (37704, 1, u'+      assert( pPager->setMaster==0 );'), (37708, 1, u'+      assert( p->eLock!=UNKNOWN_LOCK );'), (37709, 1, u'+      assert( pPager->errCode==SQLITE_OK );'), (37716, 1, u'+        assert( p->eLock>=RESERVED_LOCK );'), (37717, 1, u'+        assert( isOpen(p->jfd)'), (37722, 1, u'+      assert( pPager->dbOrigSize==pPager->dbFileSize );'), (37723, 1, u'+      assert( pPager->dbOrigSize==pPager->dbHintSize );'), (37727, 1, u'+      assert( p->eLock==EXCLUSIVE_LOCK );'), (37728, 1, u'+      assert( pPager->errCode==SQLITE_OK );'), (37729, 1, u'+      assert( !pagerUseWal(pPager) );'), (37730, 1, u'+      assert( p->eLock>=EXCLUSIVE_LOCK );'), (37731, 1, u'+      assert( isOpen(p->jfd)'), (37735, 1, u'+      assert( pPager->dbOrigSize<=pPager->dbHintSize );'), (37739, 1, u'+      assert( p->eLock==EXCLUSIVE_LOCK );'), (37740, 1, u'+      assert( pPager->errCode==SQLITE_OK );'), (37741, 1, u'+      assert( !pagerUseWal(pPager) );'), (37742, 1, u'+      assert( isOpen(p->jfd)'), (37753, 1, u'+      assert( pPager->errCode!=SQLITE_OK );'), (37754, 1, u'+      assert( sqlite3PcacheRefCount(pPager->pPCache)>0 );'), (37886, 1, u'+  assert( !pPager->exclusiveMode || pPager->eLock==eLock );'), (37887, 1, u'+  assert( eLock==NO_LOCK || eLock==SHARED_LOCK );'), (37888, 1, u'+  assert( eLock!=NO_LOCK || pagerUseWal(pPager)==0 );'), (37890, 1, u'+    assert( pPager->eLock>=eLock );'), (37913, 1, u'+  assert( eLock==SHARED_LOCK || eLock==RESERVED_LOCK || eLock==EXCLUSIVE_LOCK );'), (37943, 1, u'+  assert( !MEMDB );'), (37949, 1, u'+    assert( isOpen(pPager->fd) );'), (37954, 1, u'+    assert(SQLITE_IOCAP_ATOMIC512==(512>>8));'), (37955, 1, u'+    assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));'), (37997, 1, u'+  assert( pPager->eState!=PAGER_ERROR );'), (37998, 1, u'+  assert( (pPg->flags&PGHDR_DIRTY) || pPg->pageHash==pager_pagehash(pPg) );'), (38092, 1, u'+  assert( offset%JOURNAL_HDR_SZ(pPager)==0 );'), (38093, 1, u'+  assert( offset>=c );'), (38094, 1, u'+  assert( (offset-c)<JOURNAL_HDR_SZ(pPager) );'), (38121, 1, u'+  assert( isOpen(pPager->jfd) );'), (38175, 1, u'+  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */'), (38213, 1, u'+  assert( isOpen(pPager->fd) || pPager->noSync );'), (38262, 1, u'+    assert( pPager->journalHdr <= pPager->journalOff );'), (38297, 1, u'+  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */'), (38418, 1, u'+  assert( pPager->setMaster==0 );'), (38419, 1, u'+  assert( !pagerUseWal(pPager) );'), (38428, 1, u'+  assert( isOpen(pPager->jfd) );'), (38429, 1, u'+  assert( pPager->journalHdr <= pPager->journalOff );'), (38532, 1, u'+      assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );'), (38557, 1, u'+  assert( pPager->eState==PAGER_READER'), (38567, 1, u'+    assert( !isOpen(pPager->jfd) );'), (38579, 1, u'+    assert( (PAGER_JOURNALMODE_MEMORY   & 5)!=1 );'), (38580, 1, u'+    assert( (PAGER_JOURNALMODE_OFF      & 5)!=1 );'), (38581, 1, u'+    assert( (PAGER_JOURNALMODE_WAL      & 5)!=1 );'), (38582, 1, u'+    assert( (PAGER_JOURNALMODE_DELETE   & 5)!=1 );'), (38583, 1, u'+    assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );'), (38584, 1, u'+    assert( (PAGER_JOURNALMODE_PERSIST  & 5)==1 );'), (38605, 1, u'+    assert( pPager->errCode || pPager->eState!=PAGER_ERROR );'), (38616, 1, u'+    assert( !MEMDB );'), (38649, 1, u'+  assert( rc==SQLITE_OK || !MEMDB );'), (38650, 1, u'+  assert('), (38732, 1, u'+  assert( assert_pager_state(pPager) );'), (38733, 1, u'+  assert( pPager->eState!=PAGER_ERROR );'), (38739, 1, u'+  assert( isOpen(pPager->jfd) || pPager->pInJournal==0 );'), (38741, 1, u'+    assert( !pagerUseWal(pPager) );'), (38745, 1, u'+      assert( pPager->journalMode==PAGER_JOURNALMODE_MEMORY );'), (38765, 1, u'+      assert( pPager->journalMode==PAGER_JOURNALMODE_DELETE'), (38799, 1, u'+    assert( rc2==SQLITE_OK );'), (38832, 1, u'+    assert( assert_pager_state(pPager) );'), (38838, 1, u'+      assert( pPager->eState==PAGER_READER );'), (38941, 1, u'+  assert( (isMainJrnl&~1)==0 );      /* isMainJrnl is 0 or 1 */'), (38942, 1, u'+  assert( (isSavepnt&~1)==0 );       /* isSavepnt is 0 or 1 */'), (38943, 1, u'+  assert( isMainJrnl || pDone );     /* pDone always used on sub-journals */'), (38944, 1, u'+  assert( isSavepnt || pDone==0 );   /* pDone never used on non-savepoint */'), (38947, 1, u'+  assert( aData );         /* Temp storage must have already been allocated */'), (38948, 1, u'+  assert( pagerUseWal(pPager)==0 || (!isMainJrnl && isSavepnt) );'), (38956, 1, u'+  assert( pPager->eState>=PAGER_WRITER_CACHEMOD'), (38959, 1, u'+  assert( pPager->eState>=PAGER_WRITER_CACHEMOD || isMainJrnl );'), (38977, 1, u'+    assert( !isSavepnt );'), (39045, 1, u'+  assert( pPg || !MEMDB );'), (39046, 1, u'+  assert( pPager->eState!=PAGER_OPEN || pPg==0 );'), (39062, 1, u'+    assert( !pagerUseWal(pPager) );'), (39089, 1, u'+    assert( isSavepnt );'), (39090, 1, u'+    assert( pPager->doNotSpill==0 );'), (39093, 1, u'+    assert( pPager->doNotSpill==1 );'), (39130, 1, u'+      assert( !pagerUseWal(pPager) );'), (39274, 1, u'+    assert( !isOpen(pJournal) );'), (39303, 1, u'+  assert( pPager->eState!=PAGER_ERROR );'), (39304, 1, u'+  assert( pPager->eState!=PAGER_READER );'), (39311, 1, u'+    assert( pPager->eLock==EXCLUSIVE_LOCK );'), (39349, 1, u'+  assert( isOpen(pPager->fd) || pPager->tempFile );'), (39362, 1, u'+    assert( MAX_SECTOR_SIZE>=512 );'), (39438, 1, u'+  assert( isOpen(pPager->jfd) );'), (39491, 1, u'+      assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) );'), (39559, 1, u'+  assert( 0 );'), (39567, 1, u'+  assert('), (39632, 1, u'+  assert( pPager->eState>=PAGER_READER && !MEMDB );'), (39633, 1, u'+  assert( isOpen(pPager->fd) );'), (39636, 1, u'+    assert( pPager->tempFile );'), (39797, 1, u'+  assert( pPager->pWal );'), (39801, 1, u'+    assert( p->pgno < p->pDirty->pgno );'), (39815, 1, u'+    assert( pList );'), (39851, 1, u'+  assert( pagerUseWal(pPager) );'), (39852, 1, u'+  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );'), (39888, 1, u'+  assert( pPager->eState==PAGER_OPEN );'), (39889, 1, u'+  assert( pPager->eLock>=SHARED_LOCK || pPager->noReadlock );'), (39900, 1, u'+    assert( isOpen(pPager->fd) || pPager->tempFile );'), (39946, 1, u'+  assert( pPager->eState==PAGER_OPEN );'), (39947, 1, u'+  assert( pPager->eLock>=SHARED_LOCK || pPager->noReadlock );'), (40018, 1, u'+  assert( pPager->eState!=PAGER_ERROR );'), (40019, 1, u'+  assert( pPager->eState>=PAGER_WRITER_LOCKED );'), (40045, 1, u'+  assert( pagerUseWal(pPager)==0 || szJ==0 );'), (40060, 1, u'+    assert( rc!=SQLITE_DONE );'), (40075, 1, u'+    assert( rc!=SQLITE_DONE );'), (40090, 1, u'+    assert( rc!=SQLITE_DONE );'), (40092, 1, u'+  assert( rc!=SQLITE_OK || pPager->journalOff>=szJ );'), (40106, 1, u'+      assert( offset==ii*(4+pPager->pageSize) );'), (40109, 1, u'+    assert( rc!=SQLITE_DONE );'), (40177, 1, u'+  assert( level>=1 && level<=3 );'), (40234, 1, u'+  assert( rc!=SQLITE_OK || isOpen(pFile) );'), (40312, 1, u'+  assert( pageSize==0 || (pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE) );'), (40341, 1, u'+    assert( nReserve>=0 && nReserve<1000 );'), (40371, 1, u'+  assert( pPager->eState!=PAGER_OPEN );      /* Called only by OP_MaxPgcnt */'), (40372, 1, u'+  assert( pPager->mxPgno>=pPager->dbSize );  /* OP_MaxPgcnt enforces this */'), (40417, 1, u'+  assert( isOpen(pPager->fd) || pPager->tempFile );'), (40423, 1, u'+  assert( !pagerUseWal(pPager) );'), (40443, 1, u'+  assert( pPager->eState>=PAGER_READER );'), (40444, 1, u'+  assert( pPager->eState!=PAGER_WRITER_FINISHED );'), (40471, 1, u'+  assert( (pPager->eLock>=locktype)'), (40505, 1, u'+static void assertTruncateConstraintCb(PgHdr *pPg){'), (40506, 1, u'+  assert( pPg->flags&PGHDR_DIRTY );'), (40507, 1, u'+  assert( !subjRequiresPage(pPg) || pPg->pgno<=pPg->pPager->dbSize );'), (40509, 1, u'+static void assertTruncateConstraint(Pager *pPager){'), (40510, 1, u'+  sqlite3PcacheIterateDirty(pPager->pPCache, assertTruncateConstraintCb);'), (40513, 1, u'+# define assertTruncateConstraint(pPager)'), (40523, 1, u'+  assert( pPager->dbSize>=nPage );'), (40524, 1, u'+  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );'), (40526, 1, u'+  assertTruncateConstraint(pPager);'), (40613, 1, u'+  assert( !pPager->aSavepoint && !pPager->pInJournal );'), (40614, 1, u'+  assert( !isOpen(pPager->jfd) && !isOpen(pPager->sjfd) );'), (40674, 1, u'+  assert( pPager->eState==PAGER_WRITER_CACHEMOD'), (40677, 1, u'+  assert( assert_pager_state(pPager) );'), (40678, 1, u'+  assert( !pagerUseWal(pPager) );'), (40684, 1, u'+    assert( !pPager->tempFile );'), (40687, 1, u'+      assert( isOpen(pPager->jfd) );'), (40778, 1, u'+  assert( assert_pager_state(pPager) );'), (40818, 1, u'+  assert( !pagerUseWal(pPager) );'), (40819, 1, u'+  assert( pPager->eState==PAGER_WRITER_DBMOD );'), (40820, 1, u'+  assert( pPager->eLock==EXCLUSIVE_LOCK );'), (40827, 1, u'+    assert( pPager->tempFile && rc==SQLITE_OK );'), (40834, 1, u'+  assert( rc!=SQLITE_OK || isOpen(pPager->fd) );'), (40856, 1, u'+      assert( (pList->flags&PGHDR_NEED_SYNC)==0 );'), (40933, 1, u'+    assert( pPager->useJournal );'), (40934, 1, u'+    assert( isOpen(pPager->jfd) || pagerUseWal(pPager) );'), (40935, 1, u'+    assert( isOpen(pPager->sjfd) || pPager->nSubRec==0 );'), (40936, 1, u'+    assert( pagerUseWal(pPager)'), (40959, 1, u'+    assert( pPager->nSavepoint>0 );'), (40988, 1, u'+  assert( pPg->pPager==pPager );'), (40989, 1, u'+  assert( pPg->flags&PGHDR_DIRTY );'), (41065, 1, u'+      assert( (pPg->flags&PGHDR_NEED_SYNC)==0 );'), (41217, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize)) );'), (41228, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(pPager->jfd) );'), (41232, 1, u'+    assert( nPathname>0 );'), (41255, 1, u'+    assert( !memDb );'), (41268, 1, u'+      assert(SQLITE_DEFAULT_PAGE_SIZE<=SQLITE_MAX_DEFAULT_PAGE_SIZE);'), (41280, 1, u'+        assert(SQLITE_IOCAP_ATOMIC512==(512>>8));'), (41281, 1, u'+        assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));'), (41282, 1, u'+        assert(SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536);'), (41310, 1, u'+    assert( pPager->memDb==0 );'), (41319, 1, u'+    assert( !pPager->pTmpSpace );'), (41326, 1, u'+  assert( nExtra<1000 );'), (41345, 1, u'+  assert( pPager->state == (tempFile ? PAGER_EXCLUSIVE : PAGER_UNLOCK) );'), (41349, 1, u'+  assert( tempFile==PAGER_LOCKINGMODE_NORMAL'), (41351, 1, u'+  assert( PAGER_LOCKINGMODE_EXCLUSIVE==1 );'), (41356, 1, u'+  assert( useJournal || pPager->tempFile );'), (41366, 1, u'+  assert( isOpen(pPager->fd) || tempFile );'), (41421, 1, u'+  assert( pPager->useJournal );'), (41422, 1, u'+  assert( isOpen(pPager->fd) );'), (41423, 1, u'+  assert( pPager->eState==PAGER_OPEN );'), (41425, 1, u'+  assert( jrnlOpen==0 || ( sqlite3OsDeviceCharacteristics(pPager->jfd) &'), (41540, 1, u'+  assert( sqlite3PcacheRefCount(pPager->pPCache)==0 );'), (41541, 1, u'+  assert( assert_pager_state(pPager) );'), (41542, 1, u'+  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );'), (41548, 1, u'+    assert( !MEMDB );'), (41549, 1, u'+    assert( pPager->noReadlock==0 || pPager->readOnly );'), (41554, 1, u'+        assert( pPager->eLock==NO_LOCK || pPager->eLock==UNKNOWN_LOCK );'), (41610, 1, u'+          assert( !pPager->tempFile );'), (41612, 1, u'+          assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );'), (41629, 1, u'+        assert( rc==SQLITE_OK );'), (41660, 1, u'+      assert( pPager->eState==PAGER_OPEN );'), (41661, 1, u'+      assert( (pPager->eLock==SHARED_LOCK)'), (41711, 1, u'+    assert( pPager->pWal==0 || rc==SQLITE_OK );'), (41716, 1, u'+    assert( rc==SQLITE_OK );'), (41726, 1, u'+    assert( !MEMDB );'), (41728, 1, u'+    assert( pPager->eState==PAGER_OPEN );'), (41808, 1, u'+  assert( pPager->eState>=PAGER_READER );'), (41809, 1, u'+  assert( assert_pager_state(pPager) );'), (41830, 1, u'+  assert( (*ppPage)->pgno==pgno );'), (41831, 1, u'+  assert( (*ppPage)->pPager==pPager || (*ppPage)->pPager==0 );'), (41836, 1, u'+    assert( pgno<=PAGER_MAX_PGNO && pgno!=PAGER_MJ_PGNO(pPager) );'), (41879, 1, u'+      assert( pPg->pPager==pPager );'), (41891, 1, u'+  assert( rc!=SQLITE_OK );'), (41914, 1, u'+  assert( pPager!=0 );'), (41915, 1, u'+  assert( pgno!=0 );'), (41916, 1, u'+  assert( pPager->pPCache!=0 );'), (41917, 1, u'+  assert( pPager->eState>=PAGER_READER && pPager->eState!=PAGER_ERROR );'), (41964, 1, u'+  assert( pPager->eState==PAGER_WRITER_LOCKED );'), (41965, 1, u'+  assert( assert_pager_state(pPager) );'), (41966, 1, u'+  assert( pPager->pInJournal==0 );'), (41998, 1, u'+      assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );'), (42019, 1, u'+    assert( pPager->eState==PAGER_WRITER_LOCKED );'), (42047, 1, u'+  assert( pPager->eState>=PAGER_READER && pPager->eState<PAGER_ERROR );'), (42051, 1, u'+    assert( pPager->pInJournal==0 );'), (42100, 1, u'+    assert( rc==SQLITE_OK || pPager->eState==PAGER_READER );'), (42101, 1, u'+    assert( rc!=SQLITE_OK || pPager->eState==PAGER_WRITER_LOCKED );'), (42102, 1, u'+    assert( assert_pager_state(pPager) );'), (42125, 1, u'+  assert( pPager->eState==PAGER_WRITER_LOCKED'), (42129, 1, u'+  assert( assert_pager_state(pPager) );'), (42154, 1, u'+  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );'), (42155, 1, u'+  assert( assert_pager_state(pPager) );'), (42162, 1, u'+    assert( !pagerUseWal(pPager) );'), (42170, 1, u'+      assert( pagerUseWal(pPager)==0 );'), (42179, 1, u'+        assert( pPg->pgno!=PAGER_MJ_PGNO(pPager) );'), (42181, 1, u'+        assert( pPager->journalHdr<=pPager->journalOff );'), (42210, 1, u'+        assert( pPager->pInJournal!=0 );'), (42213, 1, u'+        assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );'), (42216, 1, u'+          assert( rc==SQLITE_NOMEM );'), (42268, 1, u'+  assert( pPager->eState>=PAGER_WRITER_LOCKED );'), (42269, 1, u'+  assert( pPager->eState!=PAGER_ERROR );'), (42270, 1, u'+  assert( assert_pager_state(pPager) );'), (42283, 1, u'+    assert( !MEMDB );'), (42284, 1, u'+    assert( pPager->doNotSyncSpill==0 );'), (42301, 1, u'+    assert(nPage>0);'), (42302, 1, u'+    assert(pg1<=pPg->pgno);'), (42303, 1, u'+    assert((pg1+nPage)>pPg->pgno);'), (42334, 1, u'+      assert( !MEMDB );'), (42344, 1, u'+    assert( pPager->doNotSyncSpill==1 );'), (42412, 1, u'+  assert( pPager->eState==PAGER_WRITER_CACHEMOD'), (42415, 1, u'+  assert( assert_pager_state(pPager) );'), (42429, 1, u'+  assert( isDirectMode==0 );'), (42438, 1, u'+    assert( !pPager->tempFile && isOpen(pPager->fd) );'), (42442, 1, u'+    assert( pPgHdr==0 || rc==SQLITE_OK );'), (42460, 1, u'+        assert( pPager->dbFileSize>0 );'), (42489, 1, u'+    assert( !MEMDB );'), (42492, 1, u'+    assert( !MEMDB );'), (42511, 1, u'+  assert( pPager->eState==PAGER_WRITER_CACHEMOD'), (42515, 1, u'+  assert( assert_pager_state(pPager) );'), (42555, 1, u'+  assert( pPager->eState==PAGER_WRITER_LOCKED'), (42560, 1, u'+  assert( assert_pager_state(pPager) );'), (42588, 1, u'+      assert( rc==SQLITE_OK );'), (42624, 1, u'+      assert( isOpen(pPager->jfd)'), (42706, 1, u'+        assert( rc!=SQLITE_IOERR_BLOCKED );'), (42716, 1, u'+        assert( pPager->eState==PAGER_WRITER_DBMOD );'), (42760, 1, u'+  assert( pPager->eState==PAGER_WRITER_LOCKED'), (42764, 1, u'+  assert( assert_pager_state(pPager) );'), (42781, 1, u'+    assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) || !pPager->journalOff );'), (42825, 1, u'+  assert( assert_pager_state(pPager) );'), (42850, 1, u'+  assert( pPager->eState==PAGER_READER || rc!=SQLITE_OK );'), (42851, 1, u'+  assert( rc==SQLITE_OK || rc==SQLITE_FULL || (rc&0xFF)==SQLITE_IOERR );'), (42935, 1, u'+  assert( pPager->eState>=PAGER_WRITER_LOCKED );'), (42936, 1, u'+  assert( assert_pager_state(pPager) );'), (42973, 1, u'+    assert( pPager->nSavepoint==nSavepoint );'), (42974, 1, u'+    assertTruncateConstraint(pPager);'), (43013, 1, u'+  assert( op==SAVEPOINT_RELEASE || op==SAVEPOINT_ROLLBACK );'), (43014, 1, u'+  assert( iSavepoint>=0 || op==SAVEPOINT_ROLLBACK );'), (43037, 1, u'+          assert( rc==SQLITE_OK );'), (43050, 1, u'+      assert(rc!=SQLITE_DONE);'), (43150, 1, u'+  assert( pPg->nRef>0 );'), (43151, 1, u'+  assert( pPager->eState==PAGER_WRITER_CACHEMOD'), (43154, 1, u'+  assert( assert_pager_state(pPager) );'), (43202, 1, u'+    assert( pageInJournal(pPg) || pPg->pgno>pPager->dbOrigSize );'), (43203, 1, u'+    assert( pPg->flags&PGHDR_DIRTY );'), (43213, 1, u'+  assert( !pPgOld || pPgOld->nRef==1 );'), (43234, 1, u'+    assert( pPgOld );'), (43258, 1, u'+        assert( pPager->pTmpSpace!=0 );'), (43276, 1, u'+  assert( pPg->nRef>0 || pPg->pPager->memDb );'), (43299, 1, u'+  assert( eMode==PAGER_LOCKINGMODE_QUERY'), (43302, 1, u'+  assert( PAGER_LOCKINGMODE_QUERY<0 );'), (43303, 1, u'+  assert( PAGER_LOCKINGMODE_NORMAL>=0 && PAGER_LOCKINGMODE_EXCLUSIVE>=0 );'), (43304, 1, u'+  assert( pPager->exclusiveMode || 0==sqlite3WalHeapMemory(pPager->pWal) );'), (43342, 1, u'+  assert(      eMode==PAGER_JOURNALMODE_DELETE'), (43353, 1, u'+  assert( pPager->tempFile==0 || eMode!=PAGER_JOURNALMODE_WAL );'), (43359, 1, u'+    assert( eOld==PAGER_JOURNALMODE_MEMORY || eOld==PAGER_JOURNALMODE_OFF );'), (43368, 1, u'+    assert( pPager->eState!=PAGER_ERROR );'), (43375, 1, u'+    assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );'), (43376, 1, u'+    assert( (PAGER_JOURNALMODE_PERSIST & 5)==1 );'), (43377, 1, u'+    assert( (PAGER_JOURNALMODE_DELETE & 5)==0 );'), (43378, 1, u'+    assert( (PAGER_JOURNALMODE_MEMORY & 5)==4 );'), (43379, 1, u'+    assert( (PAGER_JOURNALMODE_OFF & 5)==0 );'), (43380, 1, u'+    assert( (PAGER_JOURNALMODE_WAL & 5)==5 );'), (43382, 1, u'+    assert( isOpen(pPager->fd) || pPager->exclusiveMode );'), (43399, 1, u'+        assert( state==PAGER_OPEN || state==PAGER_READER );'), (43404, 1, u'+          assert( rc==SQLITE_OK );'), (43415, 1, u'+        assert( state==pPager->eState );'), (43437, 1, u'+  assert( assert_pager_state(pPager) );'), (43507, 1, u'+  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );'), (43527, 1, u'+  assert( pPager->pWal==0 && pPager->tempFile==0 );'), (43528, 1, u'+  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK || pPager->noReadlock);'), (43574, 1, u'+  assert( assert_pager_state(pPager) );'), (43575, 1, u'+  assert( pPager->eState==PAGER_OPEN   || pbOpen );'), (43576, 1, u'+  assert( pPager->eState==PAGER_READER || !pbOpen );'), (43577, 1, u'+  assert( pbOpen==0 || *pbOpen==0 );'), (43578, 1, u'+  assert( pbOpen!=0 || (!pPager->tempFile && !pPager->pWal) );'), (43610, 1, u'+  assert( pPager->journalMode==PAGER_JOURNALMODE_WAL );'), (44209, 1, u'+  assert( iPage==0 || *ppPage || rc!=SQLITE_OK );'), (44217, 1, u'+  assert( pWal->nWiData>0 && pWal->apWiData[0] );'), (44225, 1, u'+  assert( pWal->nWiData>0 && pWal->apWiData[0] );'), (44268, 1, u'+  assert( nByte>=8 );'), (44269, 1, u'+  assert( (nByte&0x00000007)==0 );'), (44303, 1, u'+  assert( pWal->writeLock );'), (44334, 1, u'+  assert( WAL_FRAME_HDRSIZE==24 );'), (44362, 1, u'+  assert( WAL_FRAME_HDRSIZE==24 );'), (44471, 1, u'+  assert( iPage>0 );'), (44472, 1, u'+  assert( (HASHTABLE_NSLOT & (HASHTABLE_NSLOT-1))==0 );'), (44504, 1, u'+  assert( rc==SQLITE_OK || iHash>0 );'), (44533, 1, u'+  assert( (iHash==0 || iFrame>HASHTABLE_NPAGE_ONE)'), (44573, 1, u'+  assert( pWal->writeLock );'), (44584, 1, u'+  assert( pWal->nWiData>walFramePage(pWal->hdr.mxFrame) );'), (44585, 1, u'+  assert( pWal->apWiData[walFramePage(pWal->hdr.mxFrame)] );'), (44592, 1, u'+  assert( iLimit>0 );'), (44605, 1, u'+#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT'), (44616, 1, u'+      assert( aHash[iKey]==i );'), (44644, 1, u'+    assert( idx <= HASHTABLE_NSLOT/2 + 1 );'), (44662, 1, u'+      assert( !aPgno[idx] );'), (44673, 1, u'+#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT'), (44681, 1, u'+      assert( nEntry==idx );'), (44695, 1, u'+        assert( aHash[iKey]==i );'), (44729, 1, u'+  assert( pWal->ckptLock==1 || pWal->ckptLock==0 );'), (44730, 1, u'+  assert( WAL_ALL_BUT_WRITE==WAL_WRITE_LOCK+1 );'), (44731, 1, u'+  assert( WAL_CKPT_LOCK==WAL_ALL_BUT_WRITE );'), (44732, 1, u'+  assert( pWal->writeLock );'), (44918, 1, u'+  assert( zWalName && zWalName[0] );'), (44919, 1, u'+  assert( pDbFd );'), (44926, 1, u'+  assert( WIN_SHM_BASE==WALINDEX_LOCK_OFFSET );'), (44929, 1, u'+  assert( UNIX_SHM_BASE==WALINDEX_LOCK_OFFSET );'), (44993, 1, u'+  assert( iMin<0xffffffff );'), (45050, 1, u'+  assert( nLeft>0 && nRight>0 );'), (45067, 1, u'+    assert( iLeft>=nLeft || aContent[aLeft[iLeft]]>dbpage );'), (45068, 1, u'+    assert( iRight>=nRight || aContent[aRight[iRight]]>dbpage );'), (45112, 1, u'+  assert( nList<=HASHTABLE_NPAGE && nList>0 );'), (45113, 1, u'+  assert( HASHTABLE_NPAGE==(1<<(ArraySize(aSub)-1)) );'), (45120, 1, u'+      assert( p->aList && p->nList<=(1<<iSub) );'), (45121, 1, u'+      assert( p->aList==&aList[iList&~((2<<iSub)-1)] );'), (45131, 1, u'+      assert( p->nList<=(1<<iSub) );'), (45132, 1, u'+      assert( p->aList==&aList[nList&~((2<<iSub)-1)] );'), (45136, 1, u'+  assert( aMerge==aList );'), (45143, 1, u'+      assert( aContent[aList[i]] > aContent[aList[i-1]] );'), (45180, 1, u'+  assert( pWal->ckptLock && pWal->hdr.mxFrame>0 );'), (45333, 1, u'+  assert( pIter );'), (45347, 1, u'+      assert( y<=pWal->hdr.mxFrame );'), (45386, 1, u'+      assert( walFramePgno(pWal, iFrame)==iDbpage );'), (45429, 1, u'+    assert( pWal->writeLock );'), (45433, 1, u'+      assert( mxSafeFrame==pWal->hdr.mxFrame );'), (45515, 1, u'+  assert( pWal->nWiData>0 && pWal->apWiData[0] );'), (45575, 1, u'+  assert( pChanged );'), (45580, 1, u'+  assert( page0 || pWal->writeLock==0 );'), (45592, 1, u'+  assert( badHdr==0 || pWal->writeLock==0 );'), (45691, 1, u'+  assert( pWal->readLock<0 );     /* Not currently locked */'), (45794, 1, u'+      assert( thisMark!=READMARK_NOT_USED );'), (45817, 1, u'+      assert( rc==SQLITE_BUSY || (pWal->readOnly & WAL_SHM_RDONLY)!=0 );'), (45852, 1, u'+      assert( mxReadMark<=pWal->hdr.mxFrame );'), (45919, 1, u'+  assert( pWal->readLock>=0 || pWal->lockError );'), (45973, 1, u'+        assert( iFrame>iRead );'), (45982, 1, u'+#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT'), (45995, 1, u'+    assert( iRead==iRead2 );'), (46049, 1, u'+  assert( pWal->readLock>=0 );'), (46127, 1, u'+      assert( walFramePgno(pWal, iFrame)!=1 );'), (46132, 1, u'+  assert( rc==SQLITE_OK );'), (46143, 1, u'+  assert( pWal->writeLock );'), (46159, 1, u'+  assert( pWal->writeLock );'), (46160, 1, u'+  assert( aWalData[3]!=pWal->nCkpt || aWalData[0]<=pWal->hdr.mxFrame );'), (46199, 1, u'+    assert( pInfo->nBackfill==pWal->hdr.mxFrame );'), (46242, 1, u'+        assert( pInfo->aReadMark[0]==0 );'), (46255, 1, u'+    assert( (rc&0xff)!=SQLITE_BUSY ); /* BUSY not possible when useWal==1 */'), (46282, 1, u'+  assert( pList );'), (46283, 1, u'+  assert( pWal->writeLock );'), (46329, 1, u'+  assert( (int)pWal->szPage==szPage );'), (46366, 1, u'+    assert( isCommit );'), (46367, 1, u'+    assert( iSegment>0 );'), (46457, 1, u'+  assert( pWal->ckptLock==0 );'), (46458, 1, u'+  assert( pWal->writeLock==0 );'), (46568, 1, u'+  assert( pWal->writeLock==0 );'), (46569, 1, u'+  assert( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE || op==-1 );'), (46577, 1, u'+  assert( pWal->readLock>=0 || pWal->lockError );'), (46578, 1, u'+  assert( pWal->readLock>=0 || (op<=0 && pWal->exclusiveMode==0) );'), (46592, 1, u'+    assert( pWal->exclusiveMode==0 );'), (46593, 1, u'+    assert( pWal->readLock>=0 );'), (47236, 1, u'+  assert( p->pBt->inTransaction!=TRANS_NONE || p->pBt->nTransaction==0 ); \\'), (47237, 1, u'+  assert( p->pBt->inTransaction>=p->inTrans );'), (47289, 1, u'+  assert( p->locked==0 );'), (47290, 1, u'+  assert( sqlite3_mutex_notheld(p->pBt->mutex) );'), (47291, 1, u'+  assert( sqlite3_mutex_held(p->db->mutex) );'), (47304, 1, u'+  assert( p->locked==1 );'), (47305, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (47306, 1, u'+  assert( sqlite3_mutex_held(p->db->mutex) );'), (47307, 1, u'+  assert( p->db==pBt->db );'), (47336, 1, u'+  assert( p->pNext==0 || p->pNext->pBt>p->pBt );'), (47337, 1, u'+  assert( p->pPrev==0 || p->pPrev->pBt<p->pBt );'), (47338, 1, u'+  assert( p->pNext==0 || p->pNext->db==p->db );'), (47339, 1, u'+  assert( p->pPrev==0 || p->pPrev->db==p->db );'), (47340, 1, u'+  assert( p->sharable || (p->pNext==0 && p->pPrev==0) );'), (47343, 1, u'+  assert( !p->locked || p->wantToLock>0 );'), (47344, 1, u'+  assert( p->sharable || p->wantToLock==0 );'), (47347, 1, u'+  assert( sqlite3_mutex_held(p->db->mutex) );'), (47351, 1, u'+  assert( (p->locked==0 && p->sharable) || p->pBt->db==p->db );'), (47373, 1, u'+    assert( pLater->sharable );'), (47374, 1, u'+    assert( pLater->pNext==0 || pLater->pNext->pBt>pLater->pBt );'), (47375, 1, u'+    assert( !pLater->locked || pLater->wantToLock>0 );'), (47393, 1, u'+    assert( p->wantToLock>0 );'), (47409, 1, u'+  assert( p->sharable==0 || p->locked==0 || p->wantToLock>0 );'), (47410, 1, u'+  assert( p->sharable==0 || p->locked==0 || p->db==p->pBt->db );'), (47411, 1, u'+  assert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->pBt->mutex) );'), (47412, 1, u'+  assert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->db->mutex) );'), (47451, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (47460, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (47513, 1, u'+  assert( db!=0 );'), (47515, 1, u'+  assert( iDb>=0 && iDb<db->nDb );'), (47519, 1, u'+  assert( p!=0 );'), (47776, 1, u'+  assert( sqlite3BtreeHoldsMutex(p) );'), (47777, 1, u'+  assert( eLock==READ_LOCK || eLock==WRITE_LOCK );'), (47778, 1, u'+  assert( p->db!=0 );'), (47779, 1, u'+  assert( !(p->db->flags&SQLITE_ReadUncommitted)||eLock==WRITE_LOCK||iTab==1 );'), (47785, 1, u'+  assert( eLock==READ_LOCK || (p==pBt->pWriter && p->inTrans==TRANS_WRITE) );'), (47786, 1, u'+  assert( eLock==READ_LOCK || pBt->inTransaction==TRANS_WRITE );'), (47811, 1, u'+    assert( pIter->eLock==READ_LOCK || pIter->eLock==WRITE_LOCK );'), (47812, 1, u'+    assert( eLock==READ_LOCK || pIter->pBtree==p || pIter->eLock==READ_LOCK);'), (47816, 1, u'+        assert( p==pBt->pWriter );'), (47849, 1, u'+  assert( sqlite3BtreeHoldsMutex(p) );'), (47850, 1, u'+  assert( eLock==READ_LOCK || eLock==WRITE_LOCK );'), (47851, 1, u'+  assert( p->db!=0 );'), (47857, 1, u'+  assert( 0==(p->db->flags&SQLITE_ReadUncommitted) || eLock==WRITE_LOCK );'), (47861, 1, u'+  assert( p->sharable );'), (47862, 1, u'+  assert( SQLITE_OK==querySharedCacheTableLock(p, iTable, eLock) );'), (47890, 1, u'+  assert( WRITE_LOCK>READ_LOCK );'), (47912, 1, u'+  assert( sqlite3BtreeHoldsMutex(p) );'), (47913, 1, u'+  assert( p->sharable || 0==*ppIter );'), (47914, 1, u'+  assert( p->inTrans>0 );'), (47918, 1, u'+    assert( pBt->isExclusive==0 || pBt->pWriter==pLock->pBtree );'), (47919, 1, u'+    assert( pLock->pBtree->inTrans>=pLock->eLock );'), (47922, 1, u'+      assert( pLock->iTable!=1 || pLock==&p->lock );'), (47931, 1, u'+  assert( pBt->isPending==0 || pBt->pWriter );'), (47961, 1, u'+      assert( pLock->eLock==READ_LOCK || pLock->pBtree==p );'), (47988, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (47999, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (48025, 1, u'+  assert( sqlite3BtreeHoldsMutex(pBtree) );'), (48078, 1, u'+    assert( pgno<=pBt->nPage );'), (48121, 1, u'+  assert( CURSOR_VALID==pCur->eState );'), (48122, 1, u'+  assert( 0==pCur->pKey );'), (48123, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (48126, 1, u'+  assert( rc==SQLITE_OK );  /* KeySize() cannot fail */'), (48147, 1, u'+  assert( !pCur->apPage[0]->intKey || !pCur->pKey );'), (48170, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (48171, 1, u'+  assert( pExcept==0 || pExcept->pBt==pBt );'), (48188, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (48211, 1, u'+    assert( nKey==(i64)(int)nKey );'), (48234, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (48235, 1, u'+  assert( pCur->eState>=CURSOR_REQUIRESEEK );'), (48244, 1, u'+    assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_INVALID );'), (48291, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (48321, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (48323, 1, u'+  assert( 0==PTRMAP_ISPAGE(pBt, PENDING_BYTE_PAGE(pBt)) );'), (48325, 1, u'+  assert( pBt->autoVacuum );'), (48341, 1, u'+  assert( offset <= (int)pBt->usableSize-5 );'), (48371, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (48385, 1, u'+  assert( offset <= (int)pBt->usableSize-5 );'), (48386, 1, u'+  assert( pEType!=0 );'), (48419, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (48452, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (48455, 1, u'+  assert( pPage->leaf==0 || pPage->leaf==1 );'), (48457, 1, u'+  assert( n==4-4*pPage->leaf );'), (48575, 1, u'+  assert( nSize==debuginfo.nSize );'), (48596, 1, u'+  assert( pCell!=0 );'), (48598, 1, u'+  assert( (info.nData+(pPage->intKey?0:info.nKey))==info.nPayload );'), (48628, 1, u'+  assert( sqlite3PagerIswriteable(pPage->pDbPage) );'), (48629, 1, u'+  assert( pPage->pBt!=0 );'), (48630, 1, u'+  assert( pPage->pBt->usableSize <= SQLITE_MAX_PAGE_SIZE );'), (48631, 1, u'+  assert( pPage->nOverflow==0 );'), (48632, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (48638, 1, u'+  assert( nCell==get2byte(&data[hdr+3]) );'), (48659, 1, u'+    assert( pc>=iCellFirst && pc<=iCellLast );'), (48671, 1, u'+    assert( cbrk+size<=usableSize && cbrk>=iCellFirst );'), (48677, 1, u'+  assert( cbrk>=iCellFirst );'), (48683, 1, u'+  assert( sqlite3PagerIswriteable(pPage->pDbPage) );'), (48712, 1, u'+  assert( sqlite3PagerIswriteable(pPage->pDbPage) );'), (48713, 1, u'+  assert( pPage->pBt );'), (48714, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (48715, 1, u'+  assert( nByte>=0 );  /* Minimum cell size is 4 */'), (48716, 1, u'+  assert( pPage->nFree>=nByte );'), (48717, 1, u'+  assert( pPage->nOverflow==0 );'), (48719, 1, u'+  assert( nByte < usableSize-8 );'), (48722, 1, u'+  assert( pPage->cellOffset == hdr + 12 - 4*pPage->leaf );'), (48777, 1, u'+    assert( gap+nByte<=top );'), (48789, 1, u'+  assert( top+nByte <= (int)pPage->pBt->usableSize );'), (48807, 1, u'+  assert( pPage->pBt!=0 );'), (48808, 1, u'+  assert( sqlite3PagerIswriteable(pPage->pDbPage) );'), (48809, 1, u'+  assert( start>=pPage->hdrOffset+6+pPage->childPtrSize );'), (48810, 1, u'+  assert( (start + size) <= (int)pPage->pBt->usableSize );'), (48811, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (48812, 1, u'+  assert( size>=0 );   /* Minimum cell size is 4 */'), (48832, 1, u'+  assert( start<=iLast );'), (48842, 1, u'+  assert( pbegin>addr || pbegin==0 );'), (48852, 1, u'+    assert( pbegin>addr );'), (48853, 1, u'+    assert( pbegin <= (int)pPage->pBt->usableSize-4 );'), (48879, 1, u'+  assert( sqlite3PagerIswriteable(pPage->pDbPage) );'), (48898, 1, u'+  assert( pPage->hdrOffset==(pPage->pgno==1 ? 100 : 0) );'), (48899, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (48900, 1, u'+  pPage->leaf = (u8)(flagByte>>3);  assert( PTF_LEAF == 1<<3 );'), (48931, 1, u'+  assert( pPage->pBt!=0 );'), (48932, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (48933, 1, u'+  assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) );'), (48934, 1, u'+  assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) );'), (48935, 1, u'+  assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) );'), (48954, 1, u'+    assert( pBt->pageSize>=512 && pBt->pageSize<=65536 );'), (49045, 1, u'+  assert( sqlite3PagerPagenumber(pPage->pDbPage)==pPage->pgno );'), (49046, 1, u'+  assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage );'), (49047, 1, u'+  assert( sqlite3PagerGetData(pPage->pDbPage) == data );'), (49048, 1, u'+  assert( sqlite3PagerIswriteable(pPage->pDbPage) );'), (49049, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (49063, 1, u'+  assert( pBt->pageSize>=512 && pBt->pageSize<=65536 );'), (49104, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (49118, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (49134, 1, u'+  assert( sqlite3BtreeHoldsMutex(p) );'), (49135, 1, u'+  assert( ((p->pBt->nPage)&0x8000000)==0 );'), (49153, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (49168, 1, u'+  assert( pgno!=0 || rc==SQLITE_CORRUPT );'), (49178, 1, u'+    assert( pPage->aData );'), (49179, 1, u'+    assert( pPage->pBt );'), (49180, 1, u'+    assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage );'), (49181, 1, u'+    assert( sqlite3PagerGetData(pPage->pDbPage)==pPage->aData );'), (49182, 1, u'+    assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (49198, 1, u'+  assert( sqlite3PagerPageRefcount(pData)>0 );'), (49200, 1, u'+    assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (49219, 1, u'+  assert( pBt->db );'), (49220, 1, u'+  assert( sqlite3_mutex_held(pBt->db->mutex) );'), (49276, 1, u'+  assert( db!=0 );'), (49277, 1, u'+  assert( pVfs!=0 );'), (49278, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (49279, 1, u'+  assert( (flags&0xff)==flags );   /* flags fit in 8 bits */'), (49282, 1, u'+  assert( (flags & BTREE_UNORDERED)==0 || (flags & BTREE_SINGLE)!=0 );'), (49285, 1, u'+  assert( (flags & BTREE_SINGLE)==0 || isTempDb );'), (49328, 1, u'+        assert( pBt->nRef>0 );'), (49368, 1, u'+    assert( sizeof(i64)==8 || sizeof(i64)==4 );'), (49369, 1, u'+    assert( sizeof(u64)==8 || sizeof(u64)==4 );'), (49370, 1, u'+    assert( sizeof(u32)==4 );'), (49371, 1, u'+    assert( sizeof(u16)==2 );'), (49372, 1, u'+    assert( sizeof(Pgno)==4 );'), (49426, 1, u'+    assert( (pBt->pageSize & 7)==0 );  /* 8-byte alignment of pageSize */'), (49502, 1, u'+    assert( sqlite3_mutex_held(mutexOpen) );'), (49520, 1, u'+  assert( sqlite3_mutex_notheld(pBt->mutex) );'), (49574, 1, u'+  assert( sqlite3_mutex_held(p->db->mutex) );'), (49596, 1, u'+  assert( p->wantToLock==0 && p->locked==0 );'), (49603, 1, u'+    assert( !pBt->pCursor );'), (49614, 1, u'+  assert( p->wantToLock==0 );'), (49615, 1, u'+  assert( p->locked==0 );'), (49641, 1, u'+  assert( sqlite3_mutex_held(p->db->mutex) );'), (49664, 1, u'+  assert( sqlite3_mutex_held(p->db->mutex) );'), (49665, 1, u'+  assert( level>=1 && level<=3 );'), (49680, 1, u'+  assert( sqlite3_mutex_held(p->db->mutex) );'), (49682, 1, u'+  assert( pBt && pBt->pPager );'), (49711, 1, u'+  assert( nReserve>=-1 && nReserve<=255 );'), (49720, 1, u'+  assert( nReserve>=0 && nReserve<=255 );'), (49723, 1, u'+    assert( (pageSize & 7)==0 );'), (49724, 1, u'+    assert( !pBt->pPage1 && !pBt->pCursor );'), (49850, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (49851, 1, u'+  assert( pBt->pPage1==0 );'), (49925, 1, u'+    assert( (pageSize & 7)==0 );'), (49974, 1, u'+  assert( pBt->maxLeaf + 23 <= MX_CELL_SIZE(pBt) );'), (49994, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (49995, 1, u'+  assert( pBt->pCursor==0 || pBt->inTransaction>TRANS_NONE );'), (49997, 1, u'+    assert( pBt->pPage1->aData );'), (49998, 1, u'+    assert( sqlite3PagerRefcount(pBt->pPager)==1 );'), (49999, 1, u'+    assert( pBt->pPage1->aData );'), (50015, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (50020, 1, u'+  assert( pP1!=0 );'), (50025, 1, u'+  assert( sizeof(zMagicHeader)==16 );'), (50030, 1, u'+  assert( pBt->usableSize<=pBt->pageSize && pBt->usableSize+255>=pBt->pageSize);'), (50039, 1, u'+  assert( pBt->autoVacuum==1 || pBt->autoVacuum==0 );'), (50040, 1, u'+  assert( pBt->incrVacuum==1 || pBt->incrVacuum==0 );'), (50168, 1, u'+\tassert( p->lock.pBtree==p && p->lock.iTable==1 );'), (50182, 1, u'+      assert( !pBt->pWriter );'), (50232, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (50275, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (50276, 1, u'+  assert( sqlite3PagerIswriteable(pPage->pDbPage) );'), (50346, 1, u'+  assert( eType==PTRMAP_OVERFLOW2 || eType==PTRMAP_OVERFLOW1 ||'), (50348, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (50349, 1, u'+  assert( pDbPage->pBt==pBt );'), (50431, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (50432, 1, u'+  assert( iLastPg>nFin );'), (50464, 1, u'+        assert( iFreePg==iLastPg );'), (50492, 1, u'+      assert( iFreePg<iLastPg );'), (50541, 1, u'+  assert( pBt->inTransaction==TRANS_WRITE && p->inTrans==TRANS_WRITE );'), (50570, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (50572, 1, u'+  assert(pBt->autoVacuum);'), (50618, 1, u'+  assert( nRef==sqlite3PagerRefcount(pPager) );'), (50678, 1, u'+  assert( sqlite3BtreeHoldsMutex(p) );'), (50747, 1, u'+    assert( pBt->inTransaction==TRANS_WRITE );'), (50748, 1, u'+    assert( pBt->nTransaction>0 );'), (50863, 1, u'+    assert( TRANS_WRITE==pBt->inTransaction );'), (50880, 1, u'+    assert( countWriteCursors(pBt)==0 );'), (50911, 1, u'+  assert( p->inTrans==TRANS_WRITE );'), (50912, 1, u'+  assert( pBt->readOnly==0 );'), (50913, 1, u'+  assert( iStatement>0 );'), (50914, 1, u'+  assert( iStatement>p->db->nSavepoint );'), (50915, 1, u'+  assert( pBt->inTransaction==TRANS_WRITE );'), (50942, 1, u'+    assert( op==SAVEPOINT_RELEASE || op==SAVEPOINT_ROLLBACK );'), (50943, 1, u'+    assert( iSavepoint>=0 || (iSavepoint==-1 && op==SAVEPOINT_ROLLBACK) );'), (50954, 1, u'+      assert( pBt->nPage>0 );'), (51002, 1, u'+  assert( sqlite3BtreeHoldsMutex(p) );'), (51003, 1, u'+  assert( wrFlag==0 || wrFlag==1 );'), (51009, 1, u'+  assert( hasSharedCacheTableLock(p, iTable, pKeyInfo!=0, wrFlag+1) );'), (51010, 1, u'+  assert( wrFlag==0 || !hasReadConflicts(p, iTable) );'), (51013, 1, u'+  assert( p->inTrans>TRANS_NONE );'), (51014, 1, u'+  assert( wrFlag==0 || p->inTrans==TRANS_WRITE );'), (51015, 1, u'+  assert( pBt->pPage1 && pBt->pPage1->aData );'), (51096, 1, u'+  assert( pCur->cachedRowid==iRowid );'), (51155, 1, u'+  static void assertCellInfo(BtCursor *pCur){'), (51160, 1, u'+    assert( memcmp(&info, &pCur->info, sizeof(info))==0 );'), (51163, 1, u'+  #define assertCellInfo(x)'), (51173, 1, u'+      assertCellInfo(pCur);'), (51184, 1, u'+    assertCellInfo(pCur);                                                      \\'), (51212, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51213, 1, u'+  assert( pCur->eState==CURSOR_INVALID || pCur->eState==CURSOR_VALID );'), (51236, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51237, 1, u'+  assert( pCur->eState==CURSOR_VALID );'), (51272, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (51273, 1, u'+  assert(pPgnoNext);'), (51301, 1, u'+  assert( next==0 || rc==SQLITE_DONE );'), (51304, 1, u'+    assert( rc==SQLITE_OK || pPage==0 );'), (51393, 1, u'+  assert( pPage );'), (51394, 1, u'+  assert( pCur->eState==CURSOR_VALID );'), (51395, 1, u'+  assert( pCur->aiIdx[pCur->iPage]<pPage->nCell );'), (51396, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51463, 1, u'+        assert(!pCur->aOverflow[iIdx] || pCur->aOverflow[iIdx]==nextPage);'), (51524, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51525, 1, u'+  assert( pCur->eState==CURSOR_VALID );'), (51526, 1, u'+  assert( pCur->iPage>=0 && pCur->apPage[pCur->iPage] );'), (51527, 1, u'+  assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell );'), (51549, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51552, 1, u'+    assert( pCur->eState==CURSOR_VALID );'), (51553, 1, u'+    assert( pCur->iPage>=0 && pCur->apPage[pCur->iPage] );'), (51554, 1, u'+    assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell );'), (51589, 1, u'+  assert( pCur!=0 && pCur->iPage>=0 && pCur->apPage[pCur->iPage]);'), (51590, 1, u'+  assert( pCur->eState==CURSOR_VALID );'), (51591, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51593, 1, u'+  assert( pCur->aiIdx[pCur->iPage]<pPage->nCell );'), (51610, 1, u'+    assert( nLocal<=nKey );'), (51633, 1, u'+  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );'), (51634, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51642, 1, u'+  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );'), (51643, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51666, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51667, 1, u'+  assert( pCur->eState==CURSOR_VALID );'), (51668, 1, u'+  assert( pCur->iPage<BTCURSOR_MAX_DEPTH );'), (51694, 1, u'+static void assertParentIndex(MemPage *pParent, int iIdx, Pgno iChild){'), (51695, 1, u'+  assert( iIdx<=pParent->nCell );'), (51697, 1, u'+    assert( get4byte(&pParent->aData[pParent->hdrOffset+8])==iChild );'), (51699, 1, u'+    assert( get4byte(findCell(pParent, iIdx))==iChild );'), (51703, 1, u'+#  define assertParentIndex(x,y,z)'), (51715, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51716, 1, u'+  assert( pCur->eState==CURSOR_VALID );'), (51717, 1, u'+  assert( pCur->iPage>0 );'), (51718, 1, u'+  assert( pCur->apPage[pCur->iPage] );'), (51719, 1, u'+  assertParentIndex('), (51757, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51758, 1, u'+  assert( CURSOR_INVALID < CURSOR_REQUIRESEEK );'), (51759, 1, u'+  assert( CURSOR_VALID   < CURSOR_REQUIRESEEK );'), (51760, 1, u'+  assert( CURSOR_FAULT   > CURSOR_REQUIRESEEK );'), (51763, 1, u'+      assert( pCur->skipNext!=SQLITE_OK );'), (51787, 1, u'+    assert( pCur->apPage[0]->intKey==1 || pCur->apPage[0]->intKey==0 );'), (51800, 1, u'+  assert( pRoot->pgno==pCur->pgnoRoot );'), (51801, 1, u'+  assert( pRoot->isInit && (pCur->pKeyInfo==0)==pRoot->intKey );'), (51832, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51833, 1, u'+  assert( pCur->eState==CURSOR_VALID );'), (51835, 1, u'+    assert( pCur->aiIdx[pCur->iPage]<pPage->nCell );'), (51857, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51858, 1, u'+  assert( pCur->eState==CURSOR_VALID );'), (51879, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51880, 1, u'+  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );'), (51884, 1, u'+      assert( pCur->apPage[pCur->iPage]->nCell==0 );'), (51887, 1, u'+      assert( pCur->apPage[pCur->iPage]->nCell>0 );'), (51902, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51903, 1, u'+  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );'), (51912, 1, u'+      assert( pCur->aiIdx[ii]==pCur->apPage[ii]->nCell );'), (51914, 1, u'+    assert( pCur->aiIdx[pCur->iPage]==pCur->apPage[pCur->iPage]->nCell-1 );'), (51915, 1, u'+    assert( pCur->apPage[pCur->iPage]->leaf );'), (51923, 1, u'+      assert( pCur->apPage[pCur->iPage]->nCell==0 );'), (51926, 1, u'+      assert( pCur->eState==CURSOR_VALID );'), (51972, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (51973, 1, u'+  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );'), (51974, 1, u'+  assert( pRes );'), (51975, 1, u'+  assert( (pIdxKey==0)==(pCur->pKeyInfo==0) );'), (51996, 1, u'+  assert( pCur->apPage[pCur->iPage] );'), (51997, 1, u'+  assert( pCur->apPage[pCur->iPage]->isInit );'), (51998, 1, u'+  assert( pCur->apPage[pCur->iPage]->nCell>0 || pCur->eState==CURSOR_INVALID );'), (52001, 1, u'+    assert( pCur->apPage[pCur->iPage]->nCell==0 );'), (52004, 1, u'+  assert( pCur->apPage[0]->intKey || pIdxKey );'), (52017, 1, u'+    assert( pPage->nCell>0 );'), (52018, 1, u'+    assert( pPage->intKey==(pIdxKey==0) );'), (52029, 1, u'+      assert( idx==pCur->aiIdx[pCur->iPage] );'), (52044, 1, u'+          assert( nCellKey>intKey );'), (52114, 1, u'+    assert( lwr==upr+1 );'), (52115, 1, u'+    assert( pPage->isInit );'), (52124, 1, u'+      assert( pCur->aiIdx[pCur->iPage]<pCur->apPage[pCur->iPage]->nCell );'), (52166, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (52171, 1, u'+  assert( pRes!=0 );'), (52185, 1, u'+  assert( pPage->isInit );'), (52186, 1, u'+  assert( idx<=pPage->nCell );'), (52234, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (52252, 1, u'+  assert( pPage->isInit );'), (52320, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (52340, 1, u'+      assert( nearby>0 );'), (52341, 1, u'+      assert( pBt->autoVacuum );'), (52385, 1, u'+        assert( pPrevTrunk==0 );'), (52404, 1, u'+        assert( *pPgno==iTrunk );'), (52447, 1, u'+            assert( sqlite3PagerIswriteable(pPage1->pDbPage) );'), (52530, 1, u'+      assert( pBt->nPage!=PENDING_BYTE_PAGE(pBt) );'), (52544, 1, u'+    assert( *pPgno!=PENDING_BYTE_PAGE(pBt) );'), (52554, 1, u'+  assert( *pPgno!=PENDING_BYTE_PAGE(pBt) );'), (52568, 1, u'+  assert( rc!=SQLITE_OK || sqlite3PagerIswriteable((*ppPage)->pDbPage) );'), (52592, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (52593, 1, u'+  assert( iPage>1 );'), (52594, 1, u'+  assert( !pMemPage || pMemPage->pgno==iPage );'), (52646, 1, u'+    assert( pBt->usableSize>32 );'), (52723, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (52729, 1, u'+  assert( pBt->usableSize > 4 );'), (52732, 1, u'+  assert( ovflPgno==0 || nOvfl>0 );'), (52807, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (52811, 1, u'+  assert( pCell<pPage->aData || pCell>=&pPage->aData[pBt->pageSize]'), (52826, 1, u'+  assert( info.nHeader==nHeader );'), (52827, 1, u'+  assert( info.nKey==nKey );'), (52828, 1, u'+  assert( info.nData==(u32)(nData+nZero) );'), (52888, 1, u'+      assert( pToRelease==0 || sqlite3PagerIswriteable(pToRelease->pDbPage) );'), (52892, 1, u'+      assert( pPrior<pPage->aData || pPrior>=&pPage->aData[pBt->pageSize]'), (52908, 1, u'+    assert( pToRelease==0 || sqlite3PagerIswriteable(pToRelease->pDbPage) );'), (52912, 1, u'+    assert( pPayload<pPage->aData || pPayload>=&pPage->aData[pBt->pageSize]'), (52917, 1, u'+      assert( pSrc );'), (52954, 1, u'+  assert( idx>=0 && idx<pPage->nCell );'), (52955, 1, u'+  assert( sz==cellSize(pPage, idx) );'), (52956, 1, u'+  assert( sqlite3PagerIswriteable(pPage->pDbPage) );'), (52957, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (52974, 1, u'+  assert( (SQLITE_PTR_TO_INT(ptr)&1)==0 );  /* ptr is always 2-byte aligned */'), (53023, 1, u'+  assert( i>=0 && i<=pPage->nCell+pPage->nOverflow );'), (53024, 1, u'+  assert( pPage->nCell<=MX_CELL(pPage->pBt) && MX_CELL(pPage->pBt)<=10921 );'), (53025, 1, u'+  assert( pPage->nOverflow<=ArraySize(pPage->aOvfl) );'), (53026, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (53032, 1, u'+  assert( sz==cellSizePtr(pPage, pCell) || (sz==8 && iChild>0) );'), (53042, 1, u'+    assert( j<(int)(sizeof(pPage->aOvfl)/sizeof(pPage->aOvfl[0])) );'), (53051, 1, u'+    assert( sqlite3PagerIswriteable(pPage->pDbPage) );'), (53060, 1, u'+    assert( idx >= end+2 );'), (53061, 1, u'+    assert( idx+sz <= (int)pPage->pBt->usableSize );'), (53070, 1, u'+    assert( (SQLITE_PTR_TO_INT(ptr)&1)==0 );  /* ptr is always 2-byte aligned */'), (53105, 1, u'+  assert( pPage->nOverflow==0 );'), (53106, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (53107, 1, u'+  assert( nCell>=0 && nCell<=(int)MX_CELL(pPage->pBt)'), (53109, 1, u'+  assert( sqlite3PagerIswriteable(pPage->pDbPage) );'), (53112, 1, u'+  assert( pPage->nCell==0 );'), (53113, 1, u'+  assert( get2byteNotZero(&data[hdr+5])==nUsable );'), (53176, 1, u'+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );'), (53177, 1, u'+  assert( sqlite3PagerIswriteable(pParent->pDbPage) );'), (53178, 1, u'+  assert( pPage->nOverflow==1 );'), (53196, 1, u'+    assert( sqlite3PagerIswriteable(pNew->pDbPage) );'), (53197, 1, u'+    assert( pPage->aData[0]==(PTF_INTKEY|PTF_LEAFDATA|PTF_LEAF) );'), (53264, 1, u'+    assert( pPage->isInit );'), (53275, 1, u'+        assert( n==pPage->pgno && e==PTRMAP_OVERFLOW1 );'), (53280, 1, u'+        assert( n==pPage->pgno && e==PTRMAP_BTREE );'), (53286, 1, u'+      assert( n==pPage->pgno && e==PTRMAP_BTREE );'), (53321, 1, u'+    assert( pFrom->isInit );'), (53322, 1, u'+    assert( pFrom->nFree>=iToHdr );'), (53323, 1, u'+    assert( get2byte(&aFrom[iFromHdr+5]) <= (int)pBt->usableSize );'), (53426, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (53427, 1, u'+  assert( sqlite3PagerIswriteable(pParent->pDbPage) );'), (53438, 1, u'+  assert( pParent->nOverflow==0 || pParent->nOverflow==1 );'), (53439, 1, u'+  assert( pParent->nOverflow==0 || pParent->aOvfl[0].idx==iParentIdx );'), (53543, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(aSpace1) );'), (53578, 1, u'+        assert( nCell<nMaxCells );'), (53588, 1, u'+        assert( nCell<nMaxCells );'), (53597, 1, u'+      assert( nCell<nMaxCells );'), (53601, 1, u'+      assert( sz<=pBt->maxLocal+23 );'), (53602, 1, u'+      assert( iSpace1 <= (int)pBt->pageSize );'), (53605, 1, u'+      assert( leafCorrection==0 || leafCorrection==4 );'), (53608, 1, u'+        assert( leafCorrection==0 );'), (53609, 1, u'+        assert( pOld->hdrOffset==0 );'), (53614, 1, u'+        assert( leafCorrection==4 );'), (53642, 1, u'+    assert( i<nMaxCells );'), (53675, 1, u'+    assert( d<nMaxCells );'), (53676, 1, u'+    assert( r<nMaxCells );'), (53692, 1, u'+  assert( cntNew[0]>0 || (pParent->pgno==1 && pParent->nCell==0) );'), (53717, 1, u'+      assert( i>0 );'), (53780, 1, u'+  assert( sqlite3PagerIswriteable(pParent->pDbPage) );'), (53791, 1, u'+    assert( j<nMaxCells );'), (53794, 1, u'+    assert( pNew->nCell>0 || (nNew==1 && cntNew[0]==0) );'), (53795, 1, u'+    assert( pNew->nOverflow==0 );'), (53802, 1, u'+    assert( i<nNew-1 || j==nCell );'), (53808, 1, u'+      assert( j<nMaxCells );'), (53840, 1, u'+          assert(leafCorrection==4);'), (53845, 1, u'+      assert( sz<=pBt->maxLocal+23 );'), (53846, 1, u'+      assert( iOvflSpace <= (int)pBt->pageSize );'), (53849, 1, u'+      assert( sqlite3PagerIswriteable(pParent->pDbPage) );'), (53855, 1, u'+  assert( j==nCell );'), (53856, 1, u'+  assert( nOld>0 );'), (53857, 1, u'+  assert( nNew>0 );'), (53878, 1, u'+    assert( nNew==1 );'), (53879, 1, u'+    assert( apNew[0]->nFree =='), (53938, 1, u'+      assert(nOverflow>0 || iOverflow<i );'), (53939, 1, u'+      assert(nOverflow<2 || pOld->aOvfl[0].idx==pOld->aOvfl[1].idx-1);'), (53940, 1, u'+      assert(nOverflow<3 || pOld->aOvfl[1].idx==pOld->aOvfl[2].idx-1);'), (53955, 1, u'+      assert( j<nOld );'), (53956, 1, u'+      assert( k<nNew );'), (53989, 1, u'+  assert( pParent->isInit );'), (54034, 1, u'+  assert( pRoot->nOverflow>0 );'), (54035, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (54054, 1, u'+  assert( sqlite3PagerIswriteable(pChild->pDbPage) );'), (54055, 1, u'+  assert( sqlite3PagerIswriteable(pRoot->pDbPage) );'), (54056, 1, u'+  assert( pChild->nCell==pRoot->nCell );'), (54102, 1, u'+        assert( (balance_deeper_called++)==0 );'), (54108, 1, u'+          assert( pCur->apPage[1]->nOverflow );'), (54141, 1, u'+          assert( (balance_quick_called++)==0 );'), (54236, 1, u'+    assert( pCur->skipNext!=SQLITE_OK );'), (54240, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (54241, 1, u'+  assert( pCur->wrFlag && pBt->inTransaction==TRANS_WRITE && !pBt->readOnly );'), (54242, 1, u'+  assert( hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo!=0, 2) );'), (54249, 1, u'+  assert( (pKey==0)==(pCur->pKeyInfo==0) );'), (54275, 1, u'+  assert( pCur->eState==CURSOR_VALID || (pCur->eState==CURSOR_INVALID && loc) );'), (54278, 1, u'+  assert( pPage->intKey || nKey>=0 );'), (54279, 1, u'+  assert( pPage->leaf || !pPage->intKey );'), (54284, 1, u'+  assert( pPage->isInit );'), (54290, 1, u'+  assert( szNew==cellSizePtr(pPage, newCell) );'), (54291, 1, u'+  assert( szNew <= MX_CELL_SIZE(pBt) );'), (54295, 1, u'+    assert( idx<pPage->nCell );'), (54309, 1, u'+    assert( pPage->leaf );'), (54312, 1, u'+    assert( pPage->leaf );'), (54315, 1, u'+  assert( rc!=SQLITE_OK || pPage->nCell>0 || pPage->nOverflow>0 );'), (54349, 1, u'+  assert( pCur->apPage[pCur->iPage]->nOverflow==0 );'), (54368, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (54369, 1, u'+  assert( pBt->inTransaction==TRANS_WRITE );'), (54370, 1, u'+  assert( !pBt->readOnly );'), (54371, 1, u'+  assert( pCur->wrFlag );'), (54372, 1, u'+  assert( hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo!=0, 2) );'), (54373, 1, u'+  assert( !hasReadConflicts(p, pCur->pgnoRoot) );'), (54431, 1, u'+    assert( MX_CELL_SIZE(pBt) >= nCell );'), (54489, 1, u'+  assert( sqlite3BtreeHoldsMutex(p) );'), (54490, 1, u'+  assert( pBt->inTransaction==TRANS_WRITE );'), (54491, 1, u'+  assert( !pBt->readOnly );'), (54524, 1, u'+    assert( pgnoRoot>=3 );'), (54560, 1, u'+      assert( eType!=PTRMAP_ROOTPAGE );'), (54561, 1, u'+      assert( eType!=PTRMAP_FREEPAGE );'), (54593, 1, u'+    assert( sqlite3PagerIswriteable(pBt->pPage1->pDbPage) );'), (54605, 1, u'+  assert( sqlite3PagerIswriteable(pRoot->pDbPage) );'), (54613, 1, u'+  assert( (pBt->openFlags & BTREE_SINGLE)==0 || pgnoRoot==2 );'), (54640, 1, u'+  assert( sqlite3_mutex_held(pBt->mutex) );'), (54660, 1, u'+    assert( pPage->intKey );'), (54691, 1, u'+  assert( p->inTrans==TRANS_WRITE );'), (54731, 1, u'+  assert( sqlite3BtreeHoldsMutex(p) );'), (54732, 1, u'+  assert( p->inTrans==TRANS_WRITE );'), (54811, 1, u'+      assert( maxRootPgno!=PENDING_BYTE_PAGE(pBt) );'), (54855, 1, u'+  assert( p->inTrans>TRANS_NONE );'), (54856, 1, u'+  assert( SQLITE_OK==querySharedCacheTableLock(p, MASTER_ROOT, READ_LOCK) );'), (54857, 1, u'+  assert( pBt->pPage1 );'), (54858, 1, u'+  assert( idx>=0 && idx<=15 );'), (54879, 1, u'+  assert( idx>=1 && idx<=15 );'), (54881, 1, u'+  assert( p->inTrans==TRANS_WRITE );'), (54882, 1, u'+  assert( pBt->pPage1!=0 );'), (54889, 1, u'+      assert( pBt->autoVacuum || iMeta==0 );'), (54890, 1, u'+      assert( iMeta==0 || iMeta==1 );'), (55187, 1, u'+    assert( rc==SQLITE_CORRUPT );  /* The only possible error from InitPage */'), (55220, 1, u'+    assert( sz==info.nPayload );'), (55308, 1, u'+    assert( contentOffset<=usableSize );  /* Enforced by btreeInitPage() */'), (55330, 1, u'+      assert( i<=usableSize-4 );     /* Enforced by btreeInitPage() */'), (55332, 1, u'+      assert( i+size<=usableSize );  /* Enforced by btreeInitPage() */'), (55335, 1, u'+      assert( j==0 || j>i+size );  /* Enforced by btreeInitPage() */'), (55336, 1, u'+      assert( j<=usableSize-4 );   /* Enforced by btreeInitPage() */'), (55388, 1, u'+  assert( p->inTrans>TRANS_NONE && pBt->inTransaction>TRANS_NONE );'), (55487, 1, u'+  assert( p->pBt->pPager!=0 );'), (55500, 1, u'+  assert( p->pBt->pPager!=0 );'), (55508, 1, u'+  assert( p==0 || sqlite3_mutex_held(p->db->mutex) );'), (55541, 1, u'+  assert( p );'), (55542, 1, u'+  assert( sqlite3_mutex_held(p->db->mutex) );'), (55547, 1, u'+  assert( p );'), (55548, 1, u'+  assert( sqlite3_mutex_held(p->db->mutex) );'), (55590, 1, u'+  assert( sqlite3_mutex_held(p->db->mutex) );'), (55593, 1, u'+  assert( rc==SQLITE_OK || rc==SQLITE_LOCKED_SHAREDCACHE );'), (55607, 1, u'+  assert( p->inTrans!=TRANS_NONE );'), (55610, 1, u'+    assert( READ_LOCK+1==WRITE_LOCK );'), (55611, 1, u'+    assert( isWriteLock==0 || isWriteLock==1 );'), (55637, 1, u'+  assert( cursorHoldsMutex(pCsr) );'), (55638, 1, u'+  assert( sqlite3_mutex_held(pCsr->pBtree->db->mutex) );'), (55639, 1, u'+  assert( pCsr->isIncrblobHandle );'), (55645, 1, u'+  assert( pCsr->eState!=CURSOR_REQUIRESEEK );'), (55660, 1, u'+  assert( !pCsr->pBt->readOnly && pCsr->pBt->inTransaction==TRANS_WRITE );'), (55661, 1, u'+  assert( hasSharedCacheTableLock(pCsr->pBtree, pCsr->pgnoRoot, 0, 2) );'), (55662, 1, u'+  assert( !hasReadConflicts(pCsr->pBtree, pCsr->pgnoRoot) );'), (55663, 1, u'+  assert( pCsr->apPage[pCsr->iPage]->intKey );'), (55679, 1, u'+  assert( cursorHoldsMutex(pCur) );'), (55680, 1, u'+  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );'), (55695, 1, u'+  assert( pBtree->inTrans==TRANS_NONE );'), (55696, 1, u'+  assert( iVersion==1 || iVersion==2 );'), (55951, 1, u'+  assert( p->bDestLocked );'), (55952, 1, u'+  assert( !isFatalError(p->rc) );'), (55953, 1, u'+  assert( iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) );'), (55954, 1, u'+  assert( zSrcData );'), (56037, 1, u'+  assert( sqlite3BtreeHoldsMutex(p->pSrc) );'), (56106, 1, u'+    assert( nSrcPage>=0 );'), (56155, 1, u'+      assert( pgszSrc==sqlite3BtreeGetPageSize(p->pSrc) );'), (56156, 1, u'+      assert( pgszDest==sqlite3BtreeGetPageSize(p->pDest) );'), (56183, 1, u'+        assert( pFile );'), (56184, 1, u'+        assert( (i64)nDestTruncate*(i64)pgszDest >= iSize || ('), (56242, 1, u'+      assert( rc2==SQLITE_OK );'), (56340, 1, u'+    assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );'), (56347, 1, u'+      assert( p->pDestDb );'), (56351, 1, u'+      assert( rc!=SQLITE_BUSY && rc!=SQLITE_LOCKED );'), (56373, 1, u'+    assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );'), (56412, 1, u'+  assert( b.rc!=SQLITE_OK );'), (56465, 1, u'+  assert( (pMem->flags&MEM_RowSet)==0 );'), (56466, 1, u'+  assert( desiredEnc==SQLITE_UTF8 || desiredEnc==SQLITE_UTF16LE'), (56471, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56480, 1, u'+  assert(rc==SQLITE_OK    || rc==SQLITE_NOMEM);'), (56481, 1, u'+  assert(rc==SQLITE_OK    || pMem->enc!=desiredEnc);'), (56482, 1, u'+  assert(rc==SQLITE_NOMEM || pMem->enc==desiredEnc);'), (56501, 1, u'+  assert( 1 >='), (56507, 1, u'+  assert( (pMem->flags&MEM_RowSet)==0 );'), (56547, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56548, 1, u'+  assert( (pMem->flags&MEM_RowSet)==0 );'), (56574, 1, u'+    assert( pMem->flags&MEM_Blob );'), (56575, 1, u'+    assert( (pMem->flags&MEM_RowSet)==0 );'), (56576, 1, u'+    assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56600, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56631, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56632, 1, u'+  assert( !(fg&MEM_Zero) );'), (56633, 1, u'+  assert( !(fg&(MEM_Str|MEM_Blob)) );'), (56634, 1, u'+  assert( fg&(MEM_Int|MEM_Real) );'), (56635, 1, u'+  assert( (pMem->flags&MEM_RowSet)==0 );'), (56636, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(pMem) );'), (56652, 1, u'+    assert( fg & MEM_Real );'), (56674, 1, u'+    assert( (pMem->flags & MEM_Null)!=0 || pFunc==pMem->u.pDef );'), (56675, 1, u'+    assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56682, 1, u'+    assert( 0==(pMem->flags&MEM_Dyn) && !pMem->xDel );'), (56696, 1, u'+  assert( p->db==0 || sqlite3_mutex_held(p->db->mutex) );'), (56704, 1, u'+      assert( (p->flags & MEM_Agg)==0 );'), (56707, 1, u'+      assert( (p->flags&MEM_RowSet)==0 );'), (56785, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56786, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(pMem) );'), (56794, 1, u'+    assert( pMem->z || pMem->n==0 );'), (56810, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56811, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(pMem) );'), (56832, 1, u'+  assert( pMem->flags & MEM_Real );'), (56833, 1, u'+  assert( (pMem->flags & MEM_RowSet)==0 );'), (56834, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56835, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(pMem) );'), (56861, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56862, 1, u'+  assert( (pMem->flags & MEM_RowSet)==0 );'), (56863, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(pMem) );'), (56875, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56876, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(pMem) );'), (56893, 1, u'+    assert( (pMem->flags & (MEM_Blob|MEM_Str))!=0 );'), (56894, 1, u'+    assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (56903, 1, u'+  assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))!=0 );'), (56980, 1, u'+  assert( db!=0 );'), (56981, 1, u'+  assert( (pMem->flags & MEM_RowSet)==0 );'), (56987, 1, u'+    assert( pMem->zMalloc );'), (56990, 1, u'+    assert( pMem->u.pRowSet!=0 );'), (57000, 1, u'+  assert( p->db!=0 );'), (57045, 1, u'+  assert( (pFrom->flags & MEM_RowSet)==0 );'), (57051, 1, u'+    assert( srcType==MEM_Ephem || srcType==MEM_Static );'), (57063, 1, u'+  assert( (pFrom->flags & MEM_RowSet)==0 );'), (57085, 1, u'+  assert( pFrom->db==0 || sqlite3_mutex_held(pFrom->db->mutex) );'), (57086, 1, u'+  assert( pTo->db==0 || sqlite3_mutex_held(pTo->db->mutex) );'), (57087, 1, u'+  assert( pFrom->db==0 || pTo->db==0 || pFrom->db==pTo->db );'), (57122, 1, u'+  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );'), (57123, 1, u'+  assert( (pMem->flags & MEM_RowSet)==0 );'), (57138, 1, u'+    assert( enc!=0 );'), (57209, 1, u'+  assert( (combined_flags & MEM_RowSet)==0 );'), (57245, 1, u'+      assert( f1&MEM_Int );'), (57246, 1, u'+      assert( f2&MEM_Int );'), (57264, 1, u'+    assert( pMem1->enc==pMem2->enc );'), (57265, 1, u'+    assert( pMem1->enc==SQLITE_UTF8 ||'), (57272, 1, u'+    assert( !pColl || pColl->xCmp );'), (57334, 1, u'+  assert( sqlite3BtreeCursorIsValid(pCur) );'), (57338, 1, u'+  assert( (pMem->flags & MEM_RowSet)==0 );'), (57344, 1, u'+  assert( zData!=0 );'), (57383, 1, u'+  assert( pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) );'), (57384, 1, u'+  assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );'), (57385, 1, u'+  assert( (pVal->flags & MEM_RowSet)==0 );'), (57390, 1, u'+  assert( (MEM_Blob>>3) == MEM_Str );'), (57396, 1, u'+      assert( (pVal->flags & (MEM_Ephem|MEM_Static))!=0 );'), (57403, 1, u'+    assert( (pVal->flags&MEM_Blob)==0 );'), (57405, 1, u'+    assert( 0==(1&SQLITE_PTR_TO_INT(pVal->z)) );'), (57407, 1, u'+  assert(pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) || pVal->db==0'), (57520, 1, u"+    assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );"), (57521, 1, u"+    assert( pExpr->u.zToken[1]=='\\'' );"), (57526, 1, u"+    assert( zVal[nVal]=='\\'' );"), (57637, 1, u'+  assert( isPrepareV2==1 || isPrepareV2==0 );'), (57642, 1, u'+  assert( p->zSql==0 );'), (57726, 1, u'+  assert( p->magic==VDBE_MAGIC_INIT );'), (57727, 1, u'+  assert( op>0 && op<0xff );'), (57827, 1, u'+  assert( p->magic==VDBE_MAGIC_INIT );'), (57847, 1, u'+  assert( p->magic==VDBE_MAGIC_INIT );'), (57848, 1, u'+  assert( j>=0 && j<p->nLabel );'), (57902, 1, u'+    assert( p->iAddr<nOp );'), (57951, 1, u'+SQLITE_PRIVATE int sqlite3VdbeAssertMayAbort(Vdbe *v, int mayAbort){'), (58014, 1, u'+      assert( p->nOp - i >= 3 );'), (58015, 1, u'+      assert( pOp[-1].opcode==OP_Integer );'), (58022, 1, u'+      assert( -1-pOp->p2<p->nLabel );'), (58036, 1, u'+  assert( p->magic==VDBE_MAGIC_INIT );'), (58053, 1, u'+  assert( aOp && !p->db->mallocFailed );'), (58056, 1, u'+  assert( p->btreeMask==0 );'), (58070, 1, u'+  assert( p->magic==VDBE_MAGIC_INIT );'), (58111, 1, u'+  assert( p!=0 );'), (58112, 1, u'+  assert( addr>=0 );'), (58123, 1, u'+  assert( p!=0 );'), (58124, 1, u'+  assert( addr>=0 );'), (58134, 1, u'+  assert( p!=0 );'), (58135, 1, u'+  assert( addr>=0 );'), (58146, 1, u'+  assert( p!=0 );'), (58148, 1, u'+    assert( p->nOp>0 );'), (58158, 1, u'+  assert( addr>=0 );'), (58180, 1, u'+    assert( db );'), (58296, 1, u'+  assert( p!=0 );'), (58298, 1, u'+  assert( p->magic==VDBE_MAGIC_INIT );'), (58305, 1, u'+  assert( p->nOp>0 );'), (58306, 1, u'+  assert( addr<p->nOp );'), (58349, 1, u'+    assert( ((VTable *)zP4)->db==p->db );'), (58370, 1, u'+  assert( p->nOp>0 || p->aOp==0 );'), (58371, 1, u'+  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );'), (58384, 1, u'+  assert( p->nOp>0 || p->aOp==0 );'), (58385, 1, u'+  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );'), (58421, 1, u'+  assert( p->magic==VDBE_MAGIC_INIT );'), (58428, 1, u'+  assert( (addr>=0 && addr<p->nOp) || p->db->mallocFailed );'), (58444, 1, u'+  assert( nTemp>=20 );'), (58473, 1, u'+      assert( i<nTemp );'), (58500, 1, u'+      assert( (pMem->flags & MEM_Null)==0 );'), (58508, 1, u'+        assert( pMem->flags & MEM_Blob );'), (58536, 1, u'+  assert( zP4!=0 );'), (58549, 1, u'+  assert( i>=0 && i<p->db->nDb && i<(int)sizeof(yDbMask)*8 );'), (58550, 1, u'+  assert( i<(int)sizeof(p->btreeMask)*8 );'), (58656, 1, u'+      assert( (&p[1])==pEnd || p[0].db==p[1].db );'), (58726, 1, u'+  assert( p->explain );'), (58727, 1, u'+  assert( p->magic==VDBE_MAGIC_RUN );'), (58728, 1, u'+  assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY || p->rc==SQLITE_NOMEM );'), (58756, 1, u'+    assert( p->nMem>9 );'), (58804, 1, u'+      assert( pMem->z!=0 );'), (58846, 1, u'+      assert( p->db->mallocFailed );'), (58854, 1, u'+      assert( pMem->z!=0 );'), (58863, 1, u'+        assert( p->db->mallocFailed );'), (58971, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(*ppFrom) );'), (58991, 1, u'+  assert( p!=0 );'), (58992, 1, u'+  assert( p->magic==VDBE_MAGIC_INIT );'), (58996, 1, u'+  assert( p->nOp>0 );'), (59003, 1, u'+    assert( p->aMem[i].db==p->db );'), (59055, 1, u'+  assert( p!=0 );'), (59056, 1, u'+  assert( p->nOp>0 );'), (59057, 1, u'+  assert( pParse!=0 );'), (59058, 1, u'+  assert( p->magic==VDBE_MAGIC_INIT );'), (59060, 1, u'+  assert( db->mallocFailed==0 );'), (59090, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(zCsr) );'), (59238, 1, u'+  for(i=0; i<p->nCursor; i++) assert( p->apCsr==0 || p->apCsr[i]==0 );'), (59239, 1, u'+  for(i=1; i<=p->nMem; i++) assert( p->aMem==0 || p->aMem[i].flags==MEM_Null );'), (59290, 1, u'+  assert( idx<p->nResColumn );'), (59291, 1, u'+  assert( var<COLNAME_N );'), (59293, 1, u'+    assert( !zName || xDel!=SQLITE_DYNAMIC );'), (59296, 1, u'+  assert( p->aColName!=0 );'), (59299, 1, u'+  assert( rc!=0 || !zName || (pColName->flags&MEM_Term)!=0 );'), (59442, 1, u'+        assert( zFile[0]!=0 );'), (59487, 1, u'+    assert( rc!=SQLITE_BUSY );'), (59551, 1, u'+  assert( cnt==db->activeVdbeCnt );'), (59552, 1, u'+  assert( nWrite==db->writeVdbeCnt );'), (59607, 1, u'+    assert( eOp==SAVEPOINT_ROLLBACK || eOp==SAVEPOINT_RELEASE);'), (59608, 1, u'+    assert( db->nStatement>0 );'), (59609, 1, u'+    assert( p->iStatement==(db->nStatement+db->nSavepoint) );'), (59724, 1, u'+    assert( p->rc!=SQLITE_IOERR_BLOCKED );  /* This error no longer exists */'), (59861, 1, u'+    assert( db->activeVdbeCnt>=db->writeVdbeCnt );'), (59877, 1, u'+  assert( db->activeVdbeCnt>0 || db->autoCommit==0 || db->nStatement==0 );'), (59981, 1, u'+    assert( (rc & p->db->errMask)==rc );'), (60015, 1, u'+  assert( p->db==0 || p->db==db );'), (60043, 1, u'+    assert( db->pVdbe==p );'), (60073, 1, u'+    assert( p->isTable );'), (60173, 1, u'+  assert( pMem->db->mallocFailed || flags&(MEM_Str|MEM_Blob) );'), (60178, 1, u'+  assert( n>=0 );'), (60274, 1, u'+      assert( sizeof(v)==sizeof(pMem->r) );'), (60281, 1, u'+    assert( len<=(u32)nBuf );'), (60291, 1, u'+    assert( pMem->n + ((pMem->flags & MEM_Zero)?pMem->u.nZero:0)'), (60293, 1, u'+    assert( pMem->n<=nBuf );'), (60298, 1, u'+      assert( nBuf>=0 );'), (60369, 1, u'+      assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 );'), (60379, 1, u'+        assert( sizeof(x)==8 && sizeof(pMem->r)==8 );'), (60459, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(pMem) );'), (60475, 1, u'+  assert( u<=pKeyInfo->nField + 1 );'), (60488, 1, u'+  assert( p!=0 );'), (60489, 1, u'+  assert( p->flags & UNPACKED_NEED_DESTROY );'), (60581, 1, u'+      assert( mem1.zMalloc==0 );  /* See comment below */'), (60594, 1, u'+        assert( idx1==szHdr1 && rc );'), (60595, 1, u'+        assert( mem1.flags & MEM_Int );'), (60609, 1, u'+  assert( mem1.zMalloc==0 );'), (60619, 1, u'+  assert( rc==0 );'), (60654, 1, u'+  assert( sqlite3BtreeCursorIsValid(pCur) );'), (60656, 1, u'+  assert( rc==SQLITE_OK );     /* pCur is always valid so KeySize cannot fail */'), (60657, 1, u'+  assert( (nCellKey & SQLITE_MAX_U32)==(u64)nCellKey );'), (60729, 1, u'+  assert( sqlite3BtreeCursorIsValid(pCur) );'), (60731, 1, u'+  assert( rc==SQLITE_OK );    /* pCur is always valid so KeySize cannot fail */'), (60743, 1, u'+  assert( pUnpacked->flags & UNPACKED_IGNORE_ROWID );'), (60754, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (60800, 1, u'+  assert( iVar>0 );'), (60822, 1, u'+  assert( iVar>0 );'), (60935, 1, u'+    assert( (rc & (v->db->errMask))==rc );'), (61038, 1, u'+  assert( n>=0 );'), (61039, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61043, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61047, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61053, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61059, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61063, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61067, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61076, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61086, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61095, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61104, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61109, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61113, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61126, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61134, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61174, 1, u'+  assert(p);'), (61224, 1, u'+    assert( db->writeVdbeCnt>0 || db->autoCommit==0 || db->nDeferredCons==0 );'), (61258, 1, u'+    assert( p->rc==SQLITE_OK );'), (61277, 1, u'+  assert( rc==SQLITE_ROW  || rc==SQLITE_DONE   || rc==SQLITE_ERROR'), (61280, 1, u'+  assert( p->rc!=SQLITE_ROW && p->rc!=SQLITE_DONE );'), (61351, 1, u'+  assert( p && p->pFunc );'), (61366, 1, u'+  assert( p && p->pFunc );'), (61399, 1, u'+  assert( p && p->pFunc && p->pFunc->xStep );'), (61400, 1, u'+  assert( sqlite3_mutex_held(p->s.db->mutex) );'), (61427, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61450, 1, u'+  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );'), (61490, 1, u'+  assert( p && p->pMem && p->pFunc && p->pFunc->xStep );'), (61691, 1, u'+  assert( db!=0 );'), (61696, 1, u'+    assert( db->mallocFailed==0 );'), (62052, 1, u'+  assert( pTo->db==pFrom->db );'), (62053, 1, u'+  assert( pTo->nVar==pFrom->nVar );'), (62171, 1, u'+    assert( n>0 && tokenType!=TK_ILLEGAL );'), (62229, 1, u'+      assert( n>0 );'), (62232, 1, u'+      assert( zRawSql[0] || nToken==0 );'), (62236, 1, u'+          assert( sqlite3Isdigit(zRawSql[1]) );'), (62242, 1, u"+        assert( zRawSql[0]==':' || zRawSql[0]=='$' || zRawSql[0]=='@' );"), (62247, 1, u'+        assert( idx>0 );'), (62251, 1, u'+      assert( idx>0 && idx<=p->nVar );'), (62278, 1, u'+        assert( pVar->flags & MEM_Blob );'), (62513, 1, u'+  assert( iCur<p->nCursor );'), (62591, 1, u'+    assert( affinity==SQLITE_AFF_INTEGER || affinity==SQLITE_AFF_REAL'), (62643, 1, u'+      assert( (f & (MEM_Static|MEM_Ephem))==0 );'), (62646, 1, u'+      assert( (f & (MEM_Dyn|MEM_Ephem))==0 );'), (62649, 1, u'+      assert( (f & (MEM_Static|MEM_Dyn))==0 );'), (62680, 1, u'+      assert( (f & (MEM_Static|MEM_Ephem))==0 );'), (62683, 1, u'+      assert( (f & (MEM_Dyn|MEM_Ephem))==0 );'), (62686, 1, u'+      assert( (f & (MEM_Static|MEM_Dyn))==0 );'), (62876, 1, u'+  assert( n==(db->nSavepoint + db->isTransactionSavepoint) );'), (63362, 1, u'+  assert( p->magic==VDBE_MAGIC_RUN );  /* sqlite3_step() verifies this */'), (63369, 1, u'+  assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY );'), (63371, 1, u'+  assert( p->explain==0 );'), (63392, 1, u'+    assert( pc>=0 && pc<p->nOp );'), (63451, 1, u'+    assert( pOp->opflags==sqlite3OpcodeProperty[pOp->opcode] );'), (63453, 1, u'+      assert( pOp->p2>0 );'), (63454, 1, u'+      assert( pOp->p2<=p->nMem );'), (63464, 1, u'+      assert( pOp->p1>0 );'), (63465, 1, u'+      assert( pOp->p1<=p->nMem );'), (63466, 1, u'+      assert( memIsValid(&aMem[pOp->p1]) );'), (63470, 1, u'+      assert( pOp->p2>0 );'), (63471, 1, u'+      assert( pOp->p2<=p->nMem );'), (63472, 1, u'+      assert( memIsValid(&aMem[pOp->p2]) );'), (63476, 1, u'+      assert( pOp->p3>0 );'), (63477, 1, u'+      assert( pOp->p3<=p->nMem );'), (63478, 1, u'+      assert( memIsValid(&aMem[pOp->p3]) );'), (63482, 1, u'+      assert( pOp->p2>0 );'), (63483, 1, u'+      assert( pOp->p2<=p->nMem );'), (63487, 1, u'+      assert( pOp->p3>0 );'), (63488, 1, u'+      assert( pOp->p3<=p->nMem );'), (63550, 1, u'+  assert( (pIn1->flags & MEM_Dyn)==0 );'), (63565, 1, u'+  assert( pIn1->flags & MEM_Int );'), (63579, 1, u'+  assert( (pIn1->flags & MEM_Dyn)==0 );'), (63645, 1, u'+    assert( p->rc!=SQLITE_OK );'), (63654, 1, u'+  assert( rc==SQLITE_BUSY || rc==SQLITE_OK || rc==SQLITE_ERROR );'), (63658, 1, u'+    assert( rc==SQLITE_OK || p->rc==SQLITE_CONSTRAINT );'), (63659, 1, u'+    assert( rc==SQLITE_OK || db->nDeferredCons>0 );'), (63680, 1, u'+  assert( pOp->p4.pI64!=0 );'), (63693, 1, u'+  assert( !sqlite3IsNaN(*pOp->p4.pReal) );'), (63705, 1, u'+  assert( pOp->p4.z!=0 );'), (63714, 1, u'+    assert( pOut->zMalloc==pOut->z );'), (63715, 1, u'+    assert( pOut->flags & MEM_Dyn );'), (63738, 1, u'+  assert( pOp->p4.z!=0 );'), (63763, 1, u'+  assert( pOp->p1 <= SQLITE_MAX_LENGTH );'), (63782, 1, u'+  assert( pOp->p1>0 && pOp->p1<=p->nVar );'), (63783, 1, u'+  assert( pOp->p4.z==0 || pOp->p4.z==p->azVar[pOp->p1-1] );'), (63811, 1, u'+  assert( u.ac.n>0 && u.ac.p1>0 && u.ac.p2>0 );'), (63812, 1, u'+  assert( u.ac.p1+u.ac.n<=u.ac.p2 || u.ac.p2+u.ac.n<=u.ac.p1 );'), (63817, 1, u'+    assert( pOut<=&aMem[p->nMem] );'), (63818, 1, u'+    assert( pIn1<=&aMem[p->nMem] );'), (63819, 1, u'+    assert( memIsValid(pIn1) );'), (63842, 1, u'+  assert( pOut!=pIn1 );'), (63864, 1, u'+  assert( pOut!=pIn1 );'), (63886, 1, u'+  assert( p->nResColumn==pOp->p2 );'), (63887, 1, u'+  assert( pOp->p1>0 );'), (63888, 1, u'+  assert( pOp->p1+pOp->p2<=p->nMem+1 );'), (63894, 1, u'+    assert( db->flags&SQLITE_CountRows );'), (63895, 1, u'+    assert( p->usesStmtJournal );'), (63914, 1, u'+  assert( p->iStatement==0 || db->flags&SQLITE_CountRows );'), (63929, 1, u'+    assert( memIsValid(&u.ad.pMem[u.ad.i]) );'), (63931, 1, u'+    assert( (u.ad.pMem[u.ad.i].flags & MEM_Ephem)==0'), (63966, 1, u'+  assert( pIn1!=pOut );'), (64126, 1, u'+  assert( pOp->p4type==P4_COLLSEQ );'), (64157, 1, u'+  assert( u.ag.apVal || u.ag.n==0 );'), (64158, 1, u'+  assert( pOp->p3>0 && pOp->p3<=p->nMem );'), (64162, 1, u'+  assert( u.ag.n==0 || (pOp->p2>0 && pOp->p2+u.ag.n<=p->nMem+1) );'), (64163, 1, u'+  assert( pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+u.ag.n );'), (64166, 1, u'+    assert( memIsValid(u.ag.pArg) );'), (64173, 1, u'+  assert( pOp->p4type==P4_FUNCDEF || pOp->p4type==P4_VDBEFUNC );'), (64196, 1, u'+    assert( pOp>aOp );'), (64197, 1, u'+    assert( pOp[-1].p4type==P4_COLLSEQ );'), (64198, 1, u'+    assert( pOp[-1].opcode==OP_CollSeq );'), (64302, 1, u'+    assert( u.ah.op==OP_ShiftRight || u.ah.op==OP_ShiftLeft );'), (64306, 1, u'+      assert( OP_ShiftRight==OP_ShiftLeft+1 );'), (64401, 1, u'+  assert( MEM_Str==(MEM_Blob>>3) );'), (64405, 1, u'+  assert( pIn1->flags & MEM_Str || db->mallocFailed );'), (64425, 1, u'+    assert( pIn1->flags & MEM_Str || db->mallocFailed );'), (64584, 1, u'+      assert( pOp->opcode==OP_Eq || pOp->opcode==OP_Ne );'), (64609, 1, u'+    assert( pOp->p4type==P4_COLLSEQ || pOp->p4.pColl==0 );'), (64649, 1, u'+  assert( pOp->p4type==P4_INTARRAY );'), (64650, 1, u'+  assert( pOp->p4.ai );'), (64683, 1, u'+  assert( u.aj.n>0 );'), (64684, 1, u'+  assert( u.aj.pKeyInfo!=0 );'), (64691, 1, u'+    assert( u.aj.p1>0 && u.aj.p1+mx<=p->nMem+1 );'), (64692, 1, u'+    assert( u.aj.p2>0 && u.aj.p2+mx<=p->nMem+1 );'), (64694, 1, u'+    assert( u.aj.p1>0 && u.aj.p1+u.aj.n<=p->nMem+1 );'), (64695, 1, u'+    assert( u.aj.p2>0 && u.aj.p2+u.aj.n<=p->nMem+1 );'), (64700, 1, u'+    assert( memIsValid(&aMem[u.aj.p1+u.aj.idx]) );'), (64701, 1, u'+    assert( memIsValid(&aMem[u.aj.p2+u.aj.idx]) );'), (64704, 1, u'+    assert( u.aj.i<u.aj.pKeyInfo->nField );'), (64930, 1, u'+  assert( u.am.p1<p->nCursor );'), (64931, 1, u'+  assert( pOp->p3>0 && pOp->p3<=p->nMem );'), (64950, 1, u'+  assert( u.am.pC!=0 );'), (64952, 1, u'+  assert( u.am.pC->pVtabCursor==0 );'), (64965, 1, u'+      assert( sqlite3BtreeCursorIsValid(u.am.pCrsr) );'), (64967, 1, u'+      assert( rc==SQLITE_OK );   /* True because of CursorMoveto() call above */'), (64971, 1, u'+      assert( (u.am.payloadSize64 & SQLITE_MAX_U32)==(u64)u.am.payloadSize64 );'), (64974, 1, u'+      assert( sqlite3BtreeCursorIsValid(u.am.pCrsr) );'), (64976, 1, u'+      assert( rc==SQLITE_OK );   /* DataSize() cannot fail */'), (64980, 1, u'+    assert( u.am.pReg->flags & MEM_Blob );'), (64981, 1, u'+    assert( memIsValid(u.am.pReg) );'), (64985, 1, u'+    assert( u.am.payloadSize==0 || u.am.zRec!=0 );'), (64993, 1, u'+    assert( u.am.pDest->flags&MEM_Null );'), (64996, 1, u'+  assert( db->aLimit[SQLITE_LIMIT_LENGTH]>=0 );'), (65002, 1, u'+  assert( u.am.p2<u.am.nField );'), (65011, 1, u'+    assert(u.am.aType);'), (65031, 1, u'+      assert( u.am.avail>=0 );'), (65140, 1, u'+    assert( rc==SQLITE_OK );'), (65159, 1, u'+      assert( u.am.pDest->flags&MEM_Null );'), (65169, 1, u'+    assert( u.am.sMem.z==u.am.sMem.zMalloc );'), (65170, 1, u'+    assert( !(u.am.pDest->flags & MEM_Dyn) );'), (65171, 1, u'+    assert( !(u.am.pDest->flags & (MEM_Blob|MEM_Str)) || u.am.pDest->z==u.am.sMem.z );'), (65201, 1, u'+  assert( u.an.zAffinity!=0 );'), (65202, 1, u'+  assert( u.an.zAffinity[pOp->p2]==0 );'), (65205, 1, u'+    assert( pIn1 <= &p->aMem[p->nMem] );'), (65206, 1, u'+    assert( memIsValid(pIn1) );'), (65268, 1, u'+  assert( u.ao.nField>0 && pOp->p2>0 && pOp->p2+u.ao.nField<=p->nMem+1 );'), (65275, 1, u'+  assert( pOp->p3<pOp->p1 || pOp->p3>=pOp->p1+pOp->p2 );'), (65283, 1, u'+    assert( memIsValid(u.ao.pRec) );'), (65332, 1, u'+  assert( u.ao.i==u.ao.nByte );'), (65334, 1, u'+  assert( pOp->p3>0 && pOp->p3<=p->nMem );'), (65395, 1, u'+  assert( db->pSavepoint==0 || db->autoCommit==0 );'), (65396, 1, u'+  assert( u.aq.p1==SAVEPOINT_BEGIN||u.aq.p1==SAVEPOINT_RELEASE||u.aq.p1==SAVEPOINT_ROLLBACK );'), (65397, 1, u'+  assert( db->pSavepoint || db->isTransactionSavepoint==0 );'), (65398, 1, u'+  assert( checkSavepointCount(db) );'), (65416, 1, u'+      assert( db->autoCommit==0 || db->nVTrans==0 );'), (65519, 1, u'+        assert( u.aq.pSavepoint==db->pSavepoint );'), (65558, 1, u'+  assert( u.ar.desiredAutoCommit==1 || u.ar.desiredAutoCommit==0 );'), (65559, 1, u'+  assert( u.ar.desiredAutoCommit==1 || u.ar.iRollback==0 );'), (65560, 1, u'+  assert( db->activeVdbeCnt>0 );  /* At least this one VM is active */'), (65579, 1, u'+      assert( u.ar.desiredAutoCommit==1 );'), (65593, 1, u'+    assert( db->nStatement==0 );'), (65648, 1, u'+  assert( pOp->p1>=0 && pOp->p1<db->nDb );'), (65649, 1, u'+  assert( (p->btreeMask & (((yDbMask)1)<<pOp->p1))!=0 );'), (65666, 1, u'+      assert( sqlite3BtreeIsInTrans(u.as.pBt) );'), (65668, 1, u'+        assert( db->nStatement>=0 && db->nSavepoint>=0 );'), (65708, 1, u'+  assert( pOp->p3<SQLITE_N_BTREE_META );'), (65709, 1, u'+  assert( u.at.iDb>=0 && u.at.iDb<db->nDb );'), (65710, 1, u'+  assert( db->aDb[u.at.iDb].pBt!=0 );'), (65711, 1, u'+  assert( (p->btreeMask & (((yDbMask)1)<<u.at.iDb))!=0 );'), (65732, 1, u'+  assert( pOp->p2<SQLITE_N_BTREE_META );'), (65733, 1, u'+  assert( pOp->p1>=0 && pOp->p1<db->nDb );'), (65734, 1, u'+  assert( (p->btreeMask & (((yDbMask)1)<<pOp->p1))!=0 );'), (65736, 1, u'+  assert( u.au.pDb->pBt!=0 );'), (65737, 1, u'+  assert( sqlite3SchemaMutexHeld(db, pOp->p1, 0) );'), (65784, 1, u'+  assert( pOp->p1>=0 && pOp->p1<db->nDb );'), (65785, 1, u'+  assert( (p->btreeMask & (((yDbMask)1)<<pOp->p1))!=0 );'), (65786, 1, u'+  assert( sqlite3SchemaMutexHeld(db, pOp->p1, 0) );'), (65891, 1, u'+  assert( u.aw.iDb>=0 && u.aw.iDb<db->nDb );'), (65892, 1, u'+  assert( (p->btreeMask & (((yDbMask)1)<<u.aw.iDb))!=0 );'), (65895, 1, u'+  assert( u.aw.pX!=0 );'), (65898, 1, u'+    assert( sqlite3SchemaMutexHeld(db, u.aw.iDb, 0) );'), (65906, 1, u'+    assert( u.aw.p2>0 );'), (65907, 1, u'+    assert( u.aw.p2<=p->nMem );'), (65909, 1, u'+    assert( memIsValid(pIn2) );'), (65910, 1, u'+    assert( (pIn2->flags & MEM_Int)!=0 );'), (65929, 1, u'+  assert( pOp->p1>=0 );'), (65941, 1, u'+  assert( rc==SQLITE_EMPTY || rc==SQLITE_OK );'), (65993, 1, u'+  assert( pOp->p1>=0 );'), (66010, 1, u'+      assert( pOp->p4type==P4_KEYINFO );'), (66013, 1, u'+        assert( pgno==MASTER_ROOT+1 );'), (66050, 1, u'+  assert( pOp->p1>=0 );'), (66066, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66137, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66138, 1, u'+  assert( pOp->p2!=0 );'), (66140, 1, u'+  assert( u.az.pC!=0 );'), (66141, 1, u'+  assert( u.az.pC->pseudoTableReg==0 );'), (66142, 1, u'+  assert( OP_SeekLe == OP_SeekLt+1 );'), (66143, 1, u'+  assert( OP_SeekGe == OP_SeekLt+2 );'), (66144, 1, u'+  assert( OP_SeekGt == OP_SeekLt+3 );'), (66145, 1, u'+  assert( u.az.pC->isOrdered );'), (66169, 1, u'+        assert( (pIn3->flags & MEM_Real)!=0 );'), (66176, 1, u'+            if( u.az.oc>=OP_SeekGe ){  assert( u.az.oc==OP_SeekGe || u.az.oc==OP_SeekGt );'), (66181, 1, u'+            if( u.az.oc<=OP_SeekLe ){  assert( u.az.oc==OP_SeekLt || u.az.oc==OP_SeekLe );'), (66195, 1, u'+          assert( u.az.oc==OP_SeekLe || u.az.oc==OP_SeekGt );'), (66209, 1, u'+      assert( pOp->p4type==P4_INT32 );'), (66210, 1, u'+      assert( u.az.nField>0 );'), (66222, 1, u'+      assert( u.az.oc!=OP_SeekGt || u.az.r.flags==UNPACKED_INCRKEY );'), (66223, 1, u'+      assert( u.az.oc!=OP_SeekLe || u.az.r.flags==UNPACKED_INCRKEY );'), (66224, 1, u'+      assert( u.az.oc!=OP_SeekGe || u.az.r.flags==0 );'), (66225, 1, u'+      assert( u.az.oc!=OP_SeekLt || u.az.r.flags==0 );'), (66229, 1, u'+      { int i; for(i=0; i<u.az.r.nField; i++) assert( memIsValid(&u.az.r.aMem[i]) ); }'), (66243, 1, u'+    if( u.az.oc>=OP_SeekGe ){  assert( u.az.oc==OP_SeekGe || u.az.oc==OP_SeekGt );'), (66252, 1, u'+      assert( u.az.oc==OP_SeekLt || u.az.oc==OP_SeekLe );'), (66264, 1, u'+    assert( pOp->p2>0 );'), (66292, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66294, 1, u'+  assert( u.ba.pC!=0 );'), (66296, 1, u'+    assert( u.ba.pC->isTable );'), (66347, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66348, 1, u'+  assert( pOp->p4type==P4_INT32 );'), (66350, 1, u'+  assert( u.bb.pC!=0 );'), (66354, 1, u'+    assert( u.bb.pC->isTable==0 );'), (66360, 1, u'+      { int i; for(i=0; i<u.bb.r.nField; i++) assert( memIsValid(&u.bb.r.aMem[i]) ); }'), (66365, 1, u'+      assert( pIn3->flags & MEM_Blob );'), (66366, 1, u'+      assert( (pIn3->flags & MEM_Zero)==0 );  /* zeroblobs already expanded */'), (66433, 1, u'+  assert( pOp->p4type==P4_INT32 );'), (66434, 1, u'+  assert( pOp->p4.i>0 && pOp->p4.i<=p->nMem );'), (66435, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66439, 1, u'+  assert( u.bc.pCx->deferredMoveto==0 );'), (66453, 1, u'+  assert( (u.bc.aMx[u.bc.nField].flags & MEM_Null)==0 );'), (66462, 1, u'+    { int i; for(i=0; i<u.bc.r.nField; i++) assert( memIsValid(&u.bc.r.aMem[i]) ); }'), (66505, 1, u'+  assert( pIn3->flags & MEM_Int );'), (66506, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66508, 1, u'+  assert( u.bd.pC!=0 );'), (66509, 1, u'+  assert( u.bd.pC->isTable );'), (66510, 1, u'+  assert( u.bd.pC->pseudoTableReg==0 );'), (66523, 1, u'+      assert( u.bd.pC->rowidIsValid==0 );'), (66531, 1, u'+    assert( u.bd.pC->rowidIsValid==0 );'), (66545, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66546, 1, u'+  assert( p->apCsr[pOp->p1]!=0 );'), (66578, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66580, 1, u'+  assert( u.be.pC!=0 );'), (66597, 1, u'+    assert( u.be.pC->isTable );'), (66619, 1, u'+          assert( sqlite3BtreeCursorIsValid(u.be.pC->pCursor) );'), (66621, 1, u'+          assert( rc==SQLITE_OK );   /* Cannot fail following BtreeLast() */'), (66633, 1, u'+        assert( pOp->p3>0 );'), (66637, 1, u'+          assert( pOp->p3<=u.be.pFrame->nMem );'), (66641, 1, u'+          assert( pOp->p3<=p->nMem );'), (66645, 1, u'+        assert( memIsValid(u.be.pMem) );'), (66649, 1, u'+        assert( (u.be.pMem->flags & MEM_Int)!=0 );  /* mem(P3) holds an integer */'), (66693, 1, u'+      assert( u.be.v>0 );  /* EV: R-40812-03570 */'), (66762, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66763, 1, u'+  assert( memIsValid(u.bf.pData) );'), (66765, 1, u'+  assert( u.bf.pC!=0 );'), (66766, 1, u'+  assert( u.bf.pC->pCursor!=0 );'), (66767, 1, u'+  assert( u.bf.pC->pseudoTableReg==0 );'), (66768, 1, u'+  assert( u.bf.pC->isTable );'), (66773, 1, u'+    assert( u.bf.pKey->flags & MEM_Int );'), (66774, 1, u'+    assert( memIsValid(u.bf.pKey) );'), (66778, 1, u'+    assert( pOp->opcode==OP_InsertInt );'), (66788, 1, u'+    assert( u.bf.pData->flags & (MEM_Blob|MEM_Str) );'), (66810, 1, u'+    assert( u.bf.pC->isTable );'), (66812, 1, u'+    assert( u.bf.pC->iDb>=0 );'), (66844, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66846, 1, u'+  assert( u.bg.pC!=0 );'), (66847, 1, u'+  assert( u.bg.pC->pCursor!=0 );  /* Only valid for real tables, no pseudotables */'), (66853, 1, u'+    assert( u.bg.pC->isTable );'), (66854, 1, u'+    assert( u.bg.pC->rowidIsValid );  /* lastRowid set by previous OP_NotFound */'), (66865, 1, u'+  assert( u.bg.pC->deferredMoveto==0 );'), (66878, 1, u'+    assert( u.bg.pC->iDb>=0 );'), (66929, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66931, 1, u'+  assert( u.bh.pC->isTable || pOp->opcode==OP_RowKey );'), (66932, 1, u'+  assert( u.bh.pC->isIndex || pOp->opcode==OP_RowData );'), (66933, 1, u'+  assert( u.bh.pC!=0 );'), (66934, 1, u'+  assert( u.bh.pC->nullRow==0 );'), (66935, 1, u'+  assert( u.bh.pC->pseudoTableReg==0 );'), (66936, 1, u'+  assert( u.bh.pC->pCursor!=0 );'), (66938, 1, u'+  assert( sqlite3BtreeCursorIsValid(u.bh.pCrsr) );'), (66945, 1, u'+  assert( u.bh.pC->deferredMoveto==0 );'), (66950, 1, u'+    assert( !u.bh.pC->isTable );'), (66952, 1, u'+    assert( rc==SQLITE_OK );    /* True because of CursorMoveto() call above */'), (66959, 1, u'+    assert( rc==SQLITE_OK );    /* DataSize() cannot fail */'), (66996, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (66998, 1, u'+  assert( u.bi.pC!=0 );'), (66999, 1, u'+  assert( u.bi.pC->pseudoTableReg==0 );'), (67009, 1, u'+    assert( u.bi.pModule->xRowid );'), (67014, 1, u'+    assert( u.bi.pC->pCursor!=0 );'), (67021, 1, u'+      assert( rc==SQLITE_OK );  /* Always so because of CursorMoveto() above */'), (67039, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (67041, 1, u'+  assert( u.bj.pC!=0 );'), (67065, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (67067, 1, u'+  assert( u.bk.pC!=0 );'), (67120, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (67122, 1, u'+  assert( u.bl.pC!=0 );'), (67132, 1, u'+  assert( pOp->p2>0 && pOp->p2<p->nOp );'), (67174, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (67175, 1, u'+  assert( pOp->p5<=ArraySize(p->aCounter) );'), (67186, 1, u'+  assert( u.bm.pC->deferredMoveto==0 );'), (67222, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (67224, 1, u'+  assert( u.bn.pC!=0 );'), (67226, 1, u'+  assert( pIn2->flags & MEM_Blob );'), (67229, 1, u'+    assert( u.bn.pC->isTable==0 );'), (67237, 1, u'+      assert( u.bn.pC->deferredMoveto==0 );'), (67258, 1, u'+  assert( pOp->p3>0 );'), (67259, 1, u'+  assert( pOp->p2>0 && pOp->p2+pOp->p3<=p->nMem+1 );'), (67260, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (67262, 1, u'+  assert( u.bo.pC!=0 );'), (67270, 1, u'+    { int i; for(i=0; i<u.bo.r.nField; i++) assert( memIsValid(&u.bo.r.aMem[i]) ); }'), (67276, 1, u'+    assert( u.bo.pC->deferredMoveto==0 );'), (67297, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (67299, 1, u'+  assert( u.bp.pC!=0 );'), (67305, 1, u'+    assert( u.bp.pC->deferredMoveto==0 );'), (67306, 1, u'+    assert( u.bp.pC->isTable==0 );'), (67353, 1, u'+  assert( pOp->p1>=0 && pOp->p1<p->nCursor );'), (67355, 1, u'+  assert( u.bq.pC!=0 );'), (67356, 1, u'+  assert( u.bq.pC->isOrdered );'), (67358, 1, u'+    assert( u.bq.pC->deferredMoveto==0 );'), (67359, 1, u'+    assert( pOp->p5==0 || pOp->p5==1 );'), (67360, 1, u'+    assert( pOp->p4type==P4_INT32 );'), (67370, 1, u'+    { int i; for(i=0; i<u.bq.r.nField; i++) assert( memIsValid(&u.bq.r.aMem[i]) ); }'), (67376, 1, u'+      assert( pOp->opcode==OP_IdxGE );'), (67429, 1, u'+    assert( u.br.iCnt==1 );'), (67430, 1, u'+    assert( (p->btreeMask & (((yDbMask)1)<<u.br.iDb))!=0 );'), (67438, 1, u'+      assert( resetSchemaOnFault==0 || resetSchemaOnFault==u.br.iDb+1 );'), (67470, 1, u'+  assert( (p->btreeMask & (((yDbMask)1)<<pOp->p2))!=0 );'), (67477, 1, u'+      assert( memIsValid(&aMem[pOp->p3]) );'), (67516, 1, u'+  assert( pOp->p1>=0 && pOp->p1<db->nDb );'), (67517, 1, u'+  assert( (p->btreeMask & (((yDbMask)1)<<pOp->p1))!=0 );'), (67519, 1, u'+  assert( u.bt.pDb->pBt!=0 );'), (67553, 1, u'+    assert( u.bu.iDb==1 || sqlite3BtreeHoldsMutex(db->aDb[u.bu.iDb].pBt) );'), (67558, 1, u'+  assert( u.bu.iDb>=0 && u.bu.iDb<db->nDb );'), (67559, 1, u'+  assert( DbHasProperty(db, u.bu.iDb, DB_SchemaLoaded) );'), (67571, 1, u'+      assert( db->init.busy==0 );'), (67574, 1, u'+      assert( !db->mallocFailed );'), (67595, 1, u'+  assert( pOp->p1>=0 && pOp->p1<db->nDb );'), (67670, 1, u'+  assert( u.bv.nRoot>0 );'), (67673, 1, u'+  assert( pOp->p3>0 && pOp->p3<=p->nMem );'), (67675, 1, u'+  assert( (u.bv.pnErr->flags & MEM_Int)!=0 );'), (67676, 1, u'+  assert( (u.bv.pnErr->flags & (MEM_Str|MEM_Blob))==0 );'), (67682, 1, u'+  assert( pOp->p5<db->nDb );'), (67683, 1, u'+  assert( (p->btreeMask & (((yDbMask)1)<<pOp->p5))!=0 );'), (67690, 1, u'+    assert( u.bv.z==0 );'), (67712, 1, u'+  assert( (pIn2->flags & MEM_Int)!=0 );'), (67778, 1, u'+  assert( pIn3->flags&MEM_Int );'), (67788, 1, u'+  assert( pOp->p4type==P4_INT32 );'), (67789, 1, u'+  assert( u.bx.iSet==-1 || u.bx.iSet>=0 );'), (67835, 1, u'+  assert( memIsValid(u.by.pRt) );'), (67836, 1, u'+  assert( u.by.pProgram->nOp>0 );'), (67902, 1, u'+    assert( u.by.pProgram->nMem+u.by.pProgram->nCsr==u.by.pFrame->nChildMem );'), (67903, 1, u'+    assert( u.by.pProgram->nCsr==u.by.pFrame->nChildCsr );'), (67904, 1, u'+    assert( pc==u.by.pFrame->pc );'), (68009, 1, u'+  assert( memIsValid(u.ca.pIn1) );'), (68029, 1, u'+  assert( pIn1->flags&MEM_Int );'), (68045, 1, u'+  assert( pIn1->flags&MEM_Int );'), (68062, 1, u'+  assert( pIn1->flags&MEM_Int );'), (68091, 1, u'+  assert( u.cb.n>=0 );'), (68094, 1, u'+  assert( u.cb.apVal || u.cb.n==0 );'), (68096, 1, u'+    assert( memIsValid(u.cb.pRec) );'), (68102, 1, u'+  assert( pOp->p3>0 && pOp->p3<=p->nMem );'), (68113, 1, u'+    assert( pOp>p->aOp );'), (68114, 1, u'+    assert( pOp[-1].p4type==P4_COLLSEQ );'), (68115, 1, u'+    assert( pOp[-1].opcode==OP_CollSeq );'), (68145, 1, u'+  assert( pOp->p1>0 && pOp->p1<=p->nMem );'), (68147, 1, u'+  assert( (u.cc.pMem->flags & ~(MEM_Null|MEM_Agg))==0 );'), (68181, 1, u'+  assert( pOp->p2==SQLITE_CHECKPOINT_PASSIVE'), (68219, 1, u'+  assert( u.ce.eNew==PAGER_JOURNALMODE_DELETE'), (68227, 1, u'+  assert( pOp->p1>=0 && pOp->p1<db->nDb );'), (68279, 1, u'+      assert( sqlite3BtreeIsInTrans(u.ce.pBt)==0 );'), (68327, 1, u'+  assert( pOp->p1>=0 && pOp->p1<db->nDb );'), (68328, 1, u'+  assert( (p->btreeMask & (((yDbMask)1)<<pOp->p1))!=0 );'), (68376, 1, u'+    assert( p1>=0 && p1<db->nDb );'), (68377, 1, u'+    assert( (p->btreeMask & (((yDbMask)1)<<p1))!=0 );'), (68378, 1, u'+    assert( isWriteLock==0 || isWriteLock==1 );'), (68455, 1, u'+  assert(u.ch.pVtab && u.ch.pModule);'), (68513, 1, u'+  assert( memIsValid(u.ci.pQuery) );'), (68515, 1, u'+  assert( u.ci.pCur->pVtabCursor );'), (68521, 1, u'+  assert( (u.ci.pQuery->flags&MEM_Int)!=0 && u.ci.pArgc->flags==MEM_Int );'), (68568, 1, u'+  assert( pCur->pVtabCursor );'), (68569, 1, u'+  assert( pOp->p3>0 && pOp->p3<=p->nMem );'), (68578, 1, u'+  assert( u.cj.pModule->xColumn );'), (68628, 1, u'+  assert( u.ck.pCur->pVtabCursor );'), (68634, 1, u'+  assert( u.ck.pModule->xNext );'), (68673, 1, u'+  assert( u.cl.pVtab->pModule->xRename );'), (68674, 1, u'+  assert( memIsValid(u.cl.pName) );'), (68676, 1, u'+  assert( u.cl.pName->flags & MEM_Str );'), (68720, 1, u'+  assert( pOp->p2==1        || pOp->p5==OE_Fail   || pOp->p5==OE_Rollback'), (68726, 1, u'+  assert( pOp->p4type==P4_VTAB );'), (68732, 1, u'+      assert( memIsValid(u.cm.pX) );'), (68743, 1, u'+      assert( u.cm.nArg>1 && u.cm.apArg[0] && (u.cm.apArg[0]->flags&MEM_Null) );'), (68838, 1, u'+  assert( pOp->opcode==OP_Noop || pOp->opcode==OP_Explain );'), (68868, 1, u'+    assert( pc>=-1 && pc<p->nOp );'), (68888, 1, u'+  assert( rc );'), (68928, 1, u'+  assert( p->zErrMsg==0 );'), (68939, 1, u'+  assert( db->u1.isInterrupted );'), (69007, 1, u'+  assert( v->aVar[0].flags&MEM_Int );'), (69043, 1, u'+  assert( rc!=SQLITE_OK || zErr==0 );'), (69044, 1, u'+  assert( rc!=SQLITE_ROW && rc!=SQLITE_DONE );'), (69199, 1, u'+    assert( pBlob->pStmt || db->mallocFailed );'), (69332, 1, u'+    assert( db == v->db );'), (69405, 1, u'+    assert( rc!=SQLITE_SCHEMA );'), (69409, 1, u'+  assert( rc==SQLITE_OK || p->pStmt==0 );'), (69475, 1, u'+        assert(p->iSize<=p->nBuf);'), (69741, 1, u'+  assert( iOfst+iAmt<=p->endpoint.iOffset );'), (69786, 1, u'+  assert( iOfst==p->endpoint.iOffset );'), (69802, 1, u'+        assert( p->pFirst );'), (69805, 1, u'+        assert( !p->pFirst );'), (69826, 1, u'+  assert(size==0);'), (69897, 1, u'+  assert( EIGHT_BYTE_ALIGNMENT(p) );'), (70110, 1, u'+  assert( iCol>=0 && iCol<pEList->nExpr );'), (70112, 1, u'+  assert( pOrig!=0 );'), (70113, 1, u'+  assert( pOrig->flags & EP_Resolved );'), (70128, 1, u'+    assert( zToken!=0 );'), (70133, 1, u'+    assert( (pDup->flags & (EP_Reduced|EP_TokenOnly))==0 );'), (70197, 1, u'+  assert( pNC );     /* the name context cannot be NULL. */'), (70198, 1, u'+  assert( zCol );    /* The Z in X.Y.Z cannot be NULL */'), (70199, 1, u'+  assert( ~ExprHasAnyProperty(pExpr, EP_TokenOnly|EP_Reduced) );'), (70218, 1, u'+        assert( pTab!=0 && pTab->zName!=0 );'), (70220, 1, u'+        assert( pTab->nCol>0 );'), (70284, 1, u'+      assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );'), (70356, 1, u'+          assert( pExpr->pLeft==0 && pExpr->pRight==0 );'), (70357, 1, u'+          assert( pExpr->x.pList==0 );'), (70358, 1, u'+          assert( pExpr->x.pSelect==0 );'), (70367, 1, u'+          assert( zTab==0 && zDb==0 );'), (70427, 1, u'+    assert( pMatch->iCursor==pExpr->iTable );'), (70440, 1, u'+    assert( pNC!=0 );'), (70445, 1, u'+      assert( pTopNC!=0 );'), (70495, 1, u'+  assert( pNC!=0 );'), (70497, 1, u'+  assert( pParse==pWalker->pParse );'), (70506, 1, u'+      assert( pSrcList->a[i].iCursor>=0 && pSrcList->a[i].iCursor<pParse->nTab);'), (70520, 1, u'+      assert( pSrcList && pSrcList->nSrc==1 );'), (70553, 1, u'+        assert( pRight->op==TK_DOT );'), (70577, 1, u'+      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );'), (70643, 1, u'+        assert( pNC->nRef>=nRef );'), (70725, 1, u'+  assert( sqlite3ExprIsInteger(pE, &i)==0 );'), (70817, 1, u'+    assert( pEList!=0 );'), (70833, 1, u'+            assert(pDup);'), (70895, 1, u'+  assert( pEList!=0 );  /* sqlite3SelectNew() guarantees this */'), (70989, 1, u'+  assert( p!=0 );'), (71014, 1, u'+    assert( (p->selFlags & SF_Expanded)!=0 );'), (71015, 1, u'+    assert( (p->selFlags & SF_Resolved)==0 );'), (71037, 1, u'+    assert( pEList!=0 );'), (71061, 1, u'+    assert( (p->selFlags & SF_Aggregate)==0 );'), (71249, 1, u'+  assert( p!=0 );'), (71293, 1, u'+    assert( pExpr->flags&EP_xIsSelect );'), (71298, 1, u'+    assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (71309, 1, u'+    assert( pExpr->pTab && j<pExpr->pTab->nCol );'), (71406, 1, u'+    assert( aff1==0 || aff2==0 );'), (71417, 1, u'+  assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||'), (71420, 1, u'+  assert( pExpr->pLeft );'), (71478, 1, u'+  assert( pLeft );'), (71480, 1, u'+    assert( pLeft->pColl );'), (71483, 1, u'+    assert( pRight->pColl );'), (71649, 1, u'+      assert( iValue>=0 );'), (71707, 1, u'+    assert( db->mallocFailed );'), (71774, 1, u'+  assert( pToken );'), (71781, 1, u'+  assert( !ExprHasProperty(pNew, EP_xIsSelect) );'), (71807, 1, u'+  assert( !ExprHasAnyProperty(pExpr, EP_IntValue|EP_Reduced|EP_TokenOnly) );'), (71809, 1, u'+  assert( z!=0 );'), (71810, 1, u'+  assert( z[0]!=0 );'), (71813, 1, u"+    assert( z[0]=='?' );"), (71876, 1, u'+  assert( !ExprHasProperty(p, EP_IntValue) || p->u.iValue>=0 );'), (71941, 1, u'+  assert( flags==EXPRDUP_REDUCE || flags==0 ); /* Only one flag value allowed */'), (71945, 1, u'+    assert( !ExprHasAnyProperty(p, EP_TokenOnly|EP_Reduced) );'), (71946, 1, u'+    assert( !ExprHasProperty(p, EP_FromJoin) );'), (71947, 1, u'+    assert( (p->flags2 & EP2_MallocedToken)==0 );'), (71948, 1, u'+    assert( (p->flags2 & EP2_Irreducible)==0 );'), (72010, 1, u'+    assert( pzBuffer==0 || isReduced );'), (72036, 1, u'+        assert( ExprHasProperty(p, EP_Reduced)==0 );'), (72222, 1, u'+  assert( p==0 );'), (72247, 1, u'+    assert( pList->nAlloc==0 );'), (72259, 1, u'+  assert( pList->a!=0 );'), (72288, 1, u'+  assert( pList!=0 || pParse->db->mallocFailed!=0 );'), (72291, 1, u'+    assert( pList->nExpr>0 );'), (72293, 1, u'+    assert( pItem->zName==0 );'), (72313, 1, u'+  assert( pList!=0 || db->mallocFailed!=0 );'), (72316, 1, u'+    assert( pList->nExpr>0 );'), (72317, 1, u'+    assert( db->mallocFailed || pItem->pExpr==pSpan->pExpr );'), (72348, 1, u'+  assert( pList->a!=0 || (pList->nExpr==0 && pList->nAlloc==0) );'), (72349, 1, u'+  assert( pList->nExpr<=pList->nAlloc );'), (72464, 1, u'+  assert( p->op!=TK_INTEGER || (p->flags & EP_IntValue)!=0'), (72567, 1, u'+      assert( p->iTable>=0 );  /* p cannot be part of a CHECK constraint */'), (72611, 1, u'+  assert( p->pGroupBy==0 );              /* Has no GROUP BY clause */'), (72613, 1, u'+  assert( p->pOffset==0 );               /* No LIMIT means no OFFSET */'), (72616, 1, u'+  assert( pSrc!=0 );'), (72621, 1, u'+  assert( pTab->pSelect==0 );            /* FROM clause is not a view */'), (72691, 1, u'+  assert( pX->op==TK_IN );'), (72715, 1, u'+    assert(v);'), (72854, 1, u'+    assert( testAddr>0 || pParse->db->mallocFailed );'), (72908, 1, u'+        assert( !isRowid );'), (72911, 1, u'+        assert( (pExpr->iTable&0x0000FFFF)==pExpr->iTable );'), (72996, 1, u'+      assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );'), (72998, 1, u'+      assert( ExprHasProperty(pExpr, EP_xIsSelect) );'), (73066, 1, u'+  assert( v!=0 );       /* OOM detected prior to this routine */'), (73191, 1, u'+    assert( !sqlite3IsNaN(value) ); /* The new AtoF never returns NaN */'), (73210, 1, u'+    assert( i>=0 );'), (73217, 1, u'+    assert( z!=0 );'), (73257, 1, u'+  assert( iReg>0 );  /* Register numbers are always positive */'), (73258, 1, u'+  assert( iCol>=-1 && iCol<32768 );  /* Finite column numbers */'), (73282, 1, u'+    assert( p->iReg==0 || p->iTable!=iTab || p->iColumn!=iCol );'), (73354, 1, u'+  assert( N>0 );'), (73355, 1, u'+  assert( pParse->iCacheLevel>=N );'), (73429, 1, u'+  assert( v!=0 );'), (73526, 1, u'+  assert( target>0 && target<=pParse->nMem );'), (73528, 1, u'+    assert( pParse->db->mallocFailed );'), (73542, 1, u'+        assert( pCol->iMem>0 );'), (73555, 1, u'+        assert( pParse->ckBase>0 );'), (73569, 1, u'+      assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (73575, 1, u'+      assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (73588, 1, u'+      assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (73589, 1, u"+      assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );"), (73590, 1, u"+      assert( pExpr->u.zToken[1]=='\\'' );"), (73593, 1, u"+      assert( z[n]=='\\'' );"), (73600, 1, u'+      assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (73601, 1, u'+      assert( pExpr->u.zToken!=0 );'), (73602, 1, u'+      assert( pExpr->u.zToken[0]!=0 );'), (73605, 1, u"+        assert( pExpr->u.zToken[0]=='?'"), (73624, 1, u'+      assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (73627, 1, u'+      assert( to_op==OP_ToText    || aff!=SQLITE_AFF_TEXT    );'), (73628, 1, u'+      assert( to_op==OP_ToBlob    || aff!=SQLITE_AFF_NONE    );'), (73629, 1, u'+      assert( to_op==OP_ToNumeric || aff!=SQLITE_AFF_NUMERIC );'), (73630, 1, u'+      assert( to_op==OP_ToInt     || aff!=SQLITE_AFF_INTEGER );'), (73631, 1, u'+      assert( to_op==OP_ToReal    || aff!=SQLITE_AFF_REAL    );'), (73653, 1, u'+      assert( TK_LT==OP_Lt );'), (73654, 1, u'+      assert( TK_LE==OP_Le );'), (73655, 1, u'+      assert( TK_GT==OP_Gt );'), (73656, 1, u'+      assert( TK_GE==OP_Ge );'), (73657, 1, u'+      assert( TK_EQ==OP_Eq );'), (73658, 1, u'+      assert( TK_NE==OP_Ne );'), (73698, 1, u'+      assert( TK_AND==OP_And );'), (73699, 1, u'+      assert( TK_OR==OP_Or );'), (73700, 1, u'+      assert( TK_PLUS==OP_Add );'), (73701, 1, u'+      assert( TK_MINUS==OP_Subtract );'), (73702, 1, u'+      assert( TK_REM==OP_Remainder );'), (73703, 1, u'+      assert( TK_BITAND==OP_BitAnd );'), (73704, 1, u'+      assert( TK_BITOR==OP_BitOr );'), (73705, 1, u'+      assert( TK_SLASH==OP_Divide );'), (73706, 1, u'+      assert( TK_LSHIFT==OP_ShiftLeft );'), (73707, 1, u'+      assert( TK_RSHIFT==OP_ShiftRight );'), (73708, 1, u'+      assert( TK_CONCAT==OP_Concat );'), (73729, 1, u'+      assert( pLeft );'), (73734, 1, u'+        assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (73749, 1, u'+      assert( TK_BITNOT==OP_BitNot );'), (73750, 1, u'+      assert( TK_NOT==OP_Not );'), (73762, 1, u'+      assert( TK_ISNULL==OP_IsNull );'), (73763, 1, u'+      assert( TK_NOTNULL==OP_NotNull );'), (73777, 1, u'+        assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (73796, 1, u'+      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );'), (73805, 1, u'+      assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (73820, 1, u'+        assert( nFarg>=2 );'), (73972, 1, u'+      assert( pExpr->iTable==0 || pExpr->iTable==1 );'), (73973, 1, u'+      assert( pExpr->iColumn>=-1 && pExpr->iColumn<pTab->nCol );'), (73974, 1, u'+      assert( pTab->iPKey<0 || pExpr->iColumn!=pTab->iPKey );'), (73975, 1, u'+      assert( p1>=0 && p1<(pTab->nCol*2+2) );'), (74018, 1, u'+    default: assert( op==TK_CASE ); {'), (74031, 1, u'+      assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );'), (74032, 1, u'+      assert((pExpr->x.pList->nExpr % 2) == 0);'), (74033, 1, u'+      assert(pExpr->x.pList->nExpr > 0);'), (74057, 1, u'+          assert( pTest!=0 );'), (74079, 1, u'+      assert( db->mallocFailed || pParse->nErr>0'), (74086, 1, u'+      assert( pExpr->affinity==OE_Rollback'), (74099, 1, u'+      assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (74145, 1, u'+  assert( target>0 && target<=pParse->nMem );'), (74150, 1, u'+    assert( pParse->pVdbe || pParse->db->mallocFailed );'), (74174, 1, u'+  assert( target>0 );'), (74272, 1, u'+      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );'), (74337, 1, u'+  assert( pList!=0 );'), (74338, 1, u'+  assert( target>0 );'), (74339, 1, u'+  assert( pParse->pVdbe!=0 );  /* Never gets this far otherwise */'), (74377, 1, u'+  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );'), (74429, 1, u'+  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );'), (74461, 1, u'+      assert( TK_LT==OP_Lt );'), (74462, 1, u'+      assert( TK_LE==OP_Le );'), (74463, 1, u'+      assert( TK_GT==OP_Gt );'), (74464, 1, u'+      assert( TK_GE==OP_Ge );'), (74465, 1, u'+      assert( TK_EQ==OP_Eq );'), (74466, 1, u'+      assert( TK_NE==OP_Ne );'), (74497, 1, u'+      assert( TK_ISNULL==OP_IsNull );'), (74498, 1, u'+      assert( TK_NOTNULL==OP_NotNull );'), (74549, 1, u'+  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );'), (74575, 1, u'+  assert( pExpr->op!=TK_ISNULL || op==OP_NotNull );'), (74576, 1, u'+  assert( pExpr->op!=TK_NOTNULL || op==OP_IsNull );'), (74577, 1, u'+  assert( pExpr->op!=TK_NE || op==OP_Eq );'), (74578, 1, u'+  assert( pExpr->op!=TK_EQ || op==OP_Ne );'), (74579, 1, u'+  assert( pExpr->op!=TK_LT || op==OP_Ge );'), (74580, 1, u'+  assert( pExpr->op!=TK_LE || op==OP_Gt );'), (74581, 1, u'+  assert( pExpr->op!=TK_GT || op==OP_Le );'), (74582, 1, u'+  assert( pExpr->op!=TK_GE || op==OP_Lt );'), (74698, 1, u'+  assert( !ExprHasAnyProperty(pA, EP_TokenOnly|EP_Reduced) );'), (74699, 1, u'+  assert( !ExprHasAnyProperty(pB, EP_TokenOnly|EP_Reduced) );'), (74809, 1, u'+          assert( !ExprHasAnyProperty(pExpr, EP_TokenOnly|EP_Reduced) );'), (74887, 1, u'+            assert( !ExprHasProperty(pExpr, EP_xIsSelect) );'), (74891, 1, u'+            assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (74904, 1, u'+        assert( !ExprHasAnyProperty(pExpr, EP_TokenOnly|EP_Reduced) );'), (74939, 1, u'+  assert( pNC->pSrcList!=0 );'), (74999, 1, u'+    assert( !usedAsColumnCache(pParse, i, i+n-1) );'), (75093, 1, u'+      assert( len>0 );'), (75215, 1, u'+      assert( len>0 );'), (75358, 1, u'+  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );'), (75360, 1, u'+  assert( iDb>=0 );'), (75366, 1, u'+    assert( iTrigDb==iDb || iTrigDb==1 );'), (75430, 1, u'+  assert( pSrc->nSrc==1 );'), (75431, 1, u'+  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );'), (75653, 1, u'+  assert( pNew );'), (75655, 1, u'+  assert( sqlite3BtreeHoldsAllMutexes(db) );'), (75662, 1, u'+  assert( pTab );'), (75773, 1, u'+  assert( pParse->pNewTable==0 );'), (75774, 1, u'+  assert( sqlite3BtreeHoldsAllMutexes(db) );'), (75795, 1, u'+  assert( pTab->addColOffset>0 );'), (75810, 1, u'+  assert( pNew->nCol>0 );'), (75812, 1, u'+  assert( nAlloc>=pNew->nCol && nAlloc%8==0 && nAlloc-pNew->nCol<8 );'), (75902, 1, u'+  assert( sqlite3BtreeHoldsAllMutexes(db) );'), (75903, 1, u'+  assert( sqlite3VdbeDb(v)==db );'), (75993, 1, u'+  assert( sqlite3BtreeHoldsAllMutexes(db) );'), (75995, 1, u'+  assert( iDb>=0 );'), (75996, 1, u'+  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (76021, 1, u'+    assert( iDb==sqlite3SchemaToIndex(db, pIdx->pSchema) );'), (76094, 1, u'+        assert( regTabname+1==regIdxname'), (76123, 1, u'+      assert( pIdx->azColl!=0 );'), (76124, 1, u'+      assert( pIdx->azColl[i]!=0 );'), (76238, 1, u'+  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (76255, 1, u'+  assert( pTab!=0 );'), (76256, 1, u'+  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );'), (76293, 1, u'+  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );'), (76298, 1, u'+  assert( pName2!=0 || pName1==0 );'), (76368, 1, u'+  assert( argc==3 );'), (76451, 1, u'+  assert( iDb>=0 && iDb<db->nDb );'), (76452, 1, u'+  assert( db->aDb[iDb].pBt!=0 );'), (76455, 1, u'+  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (76520, 1, u'+            assert( pIdx->aSample );'), (76670, 1, u'+    assert( z && zName );'), (76704, 1, u'+  assert( pVfs );'), (76778, 1, u'+    assert( iDb>=2 );'), (76916, 1, u'+  assert( v || db->mallocFailed );'), (76919, 1, u'+    assert( pFunc->nArg==-1 || (pFunc->nArg&0xff)==pFunc->nArg );'), (76999, 1, u'+  assert( db->nDb>iDb );'), (77279, 1, u'+  assert( pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER );'), (77283, 1, u'+    assert( pTabList );'), (77295, 1, u'+    assert( iCol<pTab->nCol );'), (77298, 1, u'+    assert( pTab->iPKey<pTab->nCol );'), (77303, 1, u'+  assert( iDb>=0 && iDb<db->nDb );'), (77356, 1, u'+  assert( pParse );'), (77444, 1, u'+  assert( iDb>=0 );'), (77478, 1, u'+  assert( pVdbe!=0 ); /* sqlite3GetVdbe cannot fail: VDBE already allocated */'), (77514, 1, u'+  assert( !pParse->isMultiWrite'), (77515, 1, u'+       || sqlite3VdbeAssertMayAbort(v, pParse->mayAbort));'), (77534, 1, u'+          assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (77574, 1, u'+    assert( pParse->iCacheLevel==0 );  /* Disables and re-enables match */'), (77613, 1, u'+  assert( pParse->nested<10 );  /* Nesting should only be of limited depth */'), (77646, 1, u'+  assert( zName!=0 );'), (77649, 1, u'+  assert( zDatabase!=0 || sqlite3BtreeHoldsAllMutexes(db) );'), (77653, 1, u'+    assert( sqlite3SchemaMutexHeld(db, j, 0) );'), (77714, 1, u'+  assert( zDb!=0 || sqlite3BtreeHoldsAllMutexes(db) );'), (77718, 1, u'+    assert( pSchema );'), (77720, 1, u'+    assert( sqlite3SchemaMutexHeld(db, j, 0) );'), (77749, 1, u'+  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (77784, 1, u'+  assert( iDb<db->nDb );'), (77789, 1, u'+    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (77790, 1, u'+    assert( pDb->pSchema!=0 );'), (77799, 1, u'+      assert( pDb->pSchema!=0 );'), (77806, 1, u'+  assert( iDb<0 );'), (77859, 1, u'+  assert( pTable!=0 );'), (77884, 1, u'+  assert( !pTable || pTable->nRef>0 );'), (77893, 1, u'+    assert( pIndex->pSchema==pTable->pSchema );'), (77899, 1, u'+      assert( db==0 || sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );'), (77900, 1, u'+      assert( pOld==pIndex || pOld==0 );'), (77931, 1, u'+  assert( db!=0 );'), (77932, 1, u'+  assert( iDb>=0 && iDb<db->nDb );'), (77933, 1, u'+  assert( zTabName );'), (77934, 1, u'+  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (78056, 1, u'+    assert( db->init.iDb==0 || db->init.busy );'), (78147, 1, u'+  assert( (isTemp & 1)==isTemp );'), (78190, 1, u'+        assert( !db->init.busy );'), (78213, 1, u'+  assert( pParse->pNewTable==0 );'), (78222, 1, u'+    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (78452, 1, u'+  assert( pCol->zType==0 );'), (78550, 1, u'+    assert( autoInc==0 || autoInc==1 );'), (78615, 1, u'+      assert( pIdx->nColumn==1 );'), (78683, 1, u'+  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (78790, 1, u'+    assert( pCol->affinity-SQLITE_AFF_TEXT >= 0 );'), (78791, 1, u'+    assert( pCol->affinity-SQLITE_AFF_TEXT < ArraySize(azType) );'), (78800, 1, u'+    assert( pCol->affinity==SQLITE_AFF_NONE'), (78804, 1, u'+    assert( k<=n );'), (78846, 1, u'+  assert( !db->init.busy || !pSelect );'), (78932, 1, u'+      assert(pParse->nTab==1);'), (78942, 1, u'+        assert( p->aCol==0 );'), (78986, 1, u'+      assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (79007, 1, u'+    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (79011, 1, u'+      assert( p==pOld );  /* Malloc must have failed inside HashInsert() */'), (79023, 1, u'+      assert( !pSelect && pCons && pEnd );'), (79124, 1, u'+  assert( pTable );'), (79158, 1, u'+  assert( pTable->nCol>=0 );'), (79167, 1, u'+  assert( pTable->pSelect );'), (79186, 1, u'+      assert( pTable->aCol==0 );'), (79192, 1, u'+      assert( sqlite3SchemaMutexHeld(db, 0, pTable->pSchema) );'), (79213, 1, u'+  assert( sqlite3SchemaMutexHeld(db, idx, 0) );'), (79252, 1, u'+  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (79342, 1, u'+      assert( pIdx->pSchema==pTab->pSchema );'), (79371, 1, u'+  assert( pParse->nErr==0 );'), (79372, 1, u'+  assert( pName->nSrc==1 );'), (79383, 1, u'+  assert( iDb>=0 && iDb<db->nDb );'), (79467, 1, u'+      assert( pTrigger->pSchema==pTab->pSchema ||'), (79557, 1, u'+  assert( pTo!=0 );'), (79628, 1, u'+  assert( sqlite3SchemaMutexHeld(db, 0, p->pSchema) );'), (79637, 1, u'+    assert( pNextTo->pPrevTo==0 );'), (79666, 1, u'+  assert( isDeferred==0 || isDeferred==1 ); /* EV: R-30323-21917 */'), (79796, 1, u'+  assert( pStart==0 || pEnd!=0 ); /* pEnd must be non-NULL if pStart is */'), (79797, 1, u'+  assert( pParse->nErr==0 );      /* Never called with prior errors */'), (79814, 1, u'+    assert( pName1 && pName2 );'), (79836, 1, u'+      assert(0);'), (79841, 1, u'+    assert( db->aDb[iDb].pSchema==pTab->pSchema );'), (79843, 1, u'+    assert( pName==0 );'), (79850, 1, u'+  assert( pTab!=0 );'), (79851, 1, u'+  assert( pParse->nErr==0 );'), (79899, 1, u'+        assert( !db->init.busy );'), (79987, 1, u'+  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (80032, 1, u'+      assert( nExtra>=nColl );'), (80077, 1, u'+      assert( pIdx->onError!=OE_None );'), (80078, 1, u'+      assert( pIdx->autoIndex );'), (80079, 1, u'+      assert( pIndex->onError!=OE_None );'), (80117, 1, u'+    assert( sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );'), (80122, 1, u'+      assert( p==pIndex );  /* Malloc must have failed */'), (80165, 1, u'+      assert( pEnd!=0 );'), (80258, 1, u'+  assert( a!=0 );'), (80281, 1, u'+  assert( pParse->nErr==0 );   /* Never called with prior errors */'), (80285, 1, u'+  assert( pName->nSrc==1 );'), (80473, 1, u'+  assert( iStart>=0 );'), (80474, 1, u'+  assert( nExtra>=1 );'), (80475, 1, u'+  assert( pSrc!=0 );'), (80476, 1, u'+  assert( iStart<=pSrc->nSrc );'), (80486, 1, u'+      assert( db->mallocFailed );'), (80553, 1, u'+  assert( pDatabase==0 || pTable!=0 );  /* Cannot have C without B */'), (80584, 1, u'+  assert(pList || pParse->db->mallocFailed );'), (80655, 1, u'+  assert( pAlias!=0 );'), (80665, 1, u'+  assert( p==0 );'), (80677, 1, u'+  assert( pIndexedBy!=0 );'), (80680, 1, u'+    assert( pItem->notIndexed==0 && pItem->zIndex==0 );'), (80724, 1, u'+  assert( pParse!=0 );'), (80726, 1, u'+  assert( db!=0 );'), (80749, 1, u'+  assert( pParse!=0 );'), (80751, 1, u'+  assert( db!=0 );'), (80769, 1, u'+  assert( pParse!=0 );'), (80771, 1, u'+  assert( db!=0 );'), (80792, 1, u'+    assert( !SAVEPOINT_BEGIN && SAVEPOINT_RELEASE==1 && SAVEPOINT_ROLLBACK==2 );'), (80826, 1, u'+    assert( db->aDb[1].pSchema );'), (80869, 1, u'+    assert( iDb<db->nDb );'), (80870, 1, u'+    assert( db->aDb[iDb].pBt!=0 || iDb==1 );'), (80871, 1, u'+    assert( iDb<SQLITE_MAX_ATTACHED+2 );'), (80872, 1, u'+    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (80972, 1, u'+  assert( zColl!=0 );'), (80975, 1, u'+    assert( z!=0 );'), (81015, 1, u'+  assert( sqlite3BtreeHoldsAllMutexes(db) );  /* Needed for schema access */'), (81017, 1, u'+    assert( pDb!=0 );'), (81061, 1, u'+    assert( pName1->z );'), (81114, 1, u'+    assert( &pKey->aSortOrder[nCol]==&(((u8 *)pKey)[nBytes]) );'), (81117, 1, u'+      assert( zColl );'), (81155, 1, u'+  assert( !db->xCollNeeded || !db->xCollNeeded16 );'), (81235, 1, u'+  assert( !p || p->xCmp );'), (81260, 1, u'+    assert( p==pColl );'), (81307, 1, u'+      assert( pDel==0 || pDel==pColl );'), (81345, 1, u'+  assert( SQLITE_UTF8==1 && SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );'), (81346, 1, u'+  assert( enc>=SQLITE_UTF8 && enc<=SQLITE_UTF16BE );'), (81424, 1, u'+    assert( pOther!=pDef && pOther->pNext!=pDef );'), (81470, 1, u'+  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );'), (81624, 1, u'+  assert( pItem && pSrc->nSrc==1 );'), (81696, 1, u'+      assert( pFrom->nSrc==1 );'), (81699, 1, u'+      assert( pFrom->a[0].pOn==0 );'), (81700, 1, u'+      assert( pFrom->a[0].pUsing==0 );'), (81750, 1, u'+    assert( pOffset == 0 );'), (81843, 1, u'+  assert( pTabList->nSrc==1 );'), (81878, 1, u'+  assert( iDb<db->nDb );'), (81881, 1, u'+  assert( rcauth==SQLITE_OK || rcauth==SQLITE_DENY || rcauth==SQLITE_IGNORE );'), (81885, 1, u'+  assert(!isView || pTrigger);'), (81889, 1, u'+  assert( pTabList->nSrc==1 );'), (81944, 1, u'+    assert( !isView );'), (81948, 1, u'+      assert( pIdx->pSchema==pTab->pSchema );'), (82083, 1, u'+  assert( v );'), (82283, 1, u'+  assert( argc>1 );'), (82286, 1, u'+  assert( pColl );'), (82287, 1, u'+  assert( mask==-1 || mask==0 );'), (82331, 1, u'+  assert( argc==1 );'), (82365, 1, u'+  assert( argc==1 );'), (82426, 1, u'+  assert( argc==3 || argc==2 );'), (82438, 1, u'+    assert( len==sqlite3_value_bytes(argv[0]) );'), (82477, 1, u'+  assert( p1>=0 && p2>=0 );'), (82504, 1, u'+  assert( argc==1 || argc==2 );'), (82544, 1, u'+  assert( nByte>0 );'), (82570, 1, u'+  assert( z2==(char*)sqlite3_value_text(argv[0]) );'), (82590, 1, u'+  assert( z2==(char*)sqlite3_value_text(argv[0]) );'), (82668, 1, u'+  assert( argc==1 );'), (82821, 1, u'+        assert( esc==0 );         /* This is GLOB, not LIKE */'), (82822, 1, u"+        assert( matchSet<0x80 );  /* '[' is a single-byte character */"), (82851, 1, u'+      assert( esc==0 );    /* This only occurs for GLOB, not LIKE */'), (82943, 1, u'+  assert( zB==sqlite3_value_text(argv[0]) );  /* Encoding did not change */'), (83043, 1, u'+  assert( argc==1 );'), (83067, 1, u'+  assert( argc==1 );'), (83096, 1, u'+  assert( argc==1 );'), (83108, 1, u'+      assert( zBlob==sqlite3_value_blob(argv[0]) ); /* No encoding change */'), (83149, 1, u'+      assert( sqlite3_value_type(argv[0])==SQLITE_NULL );'), (83168, 1, u'+  assert( argc==1 );'), (83172, 1, u'+  assert( pBlob==sqlite3_value_blob(argv[0]) );  /* No encoding change */'), (83195, 1, u'+  assert( argc==1 );'), (83229, 1, u'+  assert( argc==3 );'), (83234, 1, u'+  assert( zStr==sqlite3_value_text(argv[0]) );  /* No encoding change */'), (83237, 1, u'+    assert( sqlite3_value_type(argv[1])==SQLITE_NULL'), (83242, 1, u'+    assert( sqlite3_value_type(argv[1])!=SQLITE_NULL );'), (83247, 1, u'+  assert( zPattern==sqlite3_value_text(argv[1]) );  /* No encoding change */'), (83251, 1, u'+  assert( zRep==sqlite3_value_text(argv[2]) );'), (83253, 1, u'+  assert( nOut<SQLITE_MAX_LENGTH );'), (83285, 1, u'+  assert( j+nStr-i+1==nOut );'), (83288, 1, u'+  assert( j<=nOut );'), (83317, 1, u'+  assert( zIn==sqlite3_value_text(argv[0]) );'), (83407, 1, u'+  assert( argc==1 );'), (83487, 1, u'+  assert( argc==1 );'), (83556, 1, u'+  assert( argc==1 || p==0 || p->n>0x7fffffff'), (83626, 1, u'+  assert( argc==1 || argc==2 );'), (83672, 1, u'+  assert( rc==SQLITE_NOMEM || rc==SQLITE_OK );'), (83726, 1, u'+  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );'), (83739, 1, u'+  assert( (char*)&likeInfoAlt == (char*)&likeInfoAlt.matchAll );'), (83740, 1, u'+  assert( &((char*)&likeInfoAlt)[1] == (char*)&likeInfoAlt.matchOne );'), (83741, 1, u'+  assert( &((char*)&likeInfoAlt)[2] == (char*)&likeInfoAlt.matchSet );'), (84042, 1, u'+  assert( ppIdx && *ppIdx==0 );'), (84043, 1, u'+  assert( !paiCol || *paiCol==0 );'), (84044, 1, u'+  assert( pParse );'), (84067, 1, u'+    assert( nCol>1 );'), (84249, 1, u'+          assert( aiCol[i]!=pTab->iPKey );'), (84274, 1, u'+    assert( nIncr==1 );'), (84335, 1, u'+  assert( !pIdx || pIdx->pTable==pTab );'), (84374, 1, u'+    assert( iCol>=0 );'), (84488, 1, u'+    assert( v );                  /* VDBE has already been allocated */'), (84556, 1, u'+  assert( (regOld==0)!=(regNew==0) );'), (84588, 1, u'+    assert( pFKey->nCol==1 || (aiFree && pIdx) );'), (84641, 1, u'+      assert( regOld==0 && regNew!=0 );'), (84651, 1, u'+    assert( aiCol || pFKey->nCol==1 );'), (84828, 1, u'+    assert( aiCol || pFKey->nCol==1 );'), (84839, 1, u'+      assert( iFromCol>=0 );'), (85017, 1, u'+  assert( db==0 || sqlite3SchemaMutexHeld(db, 0, pTab->pSchema) );'), (85037, 1, u'+    assert( pFKey->isDeferred==0 || pFKey->isDeferred==1 );'), (85081, 1, u'+  assert( opcode==OP_OpenWrite || opcode==OP_OpenRead );'), (85197, 1, u'+    assert( pOp!=0 );'), (85212, 1, u'+      assert( pOp->p4.pVtab!=0 );'), (85213, 1, u'+      assert( pOp->p4type==P4_VTAB );'), (85284, 1, u'+  assert( pParse->pTriggerTab==0 );'), (85285, 1, u'+  assert( pParse==sqlite3ParseToplevel(pParse) );'), (85287, 1, u'+  assert( v );   /* We failed long ago if this is not so */'), (85291, 1, u'+    assert( sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) );'), (85334, 1, u'+  assert( v );'), (85342, 1, u'+    assert( sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) );'), (85538, 1, u'+  assert( pTabList->nSrc==1 );'), (85546, 1, u'+  assert( iDb<db->nDb );'), (85568, 1, u'+  assert( (pTrigger && tmask) || (pTrigger==0 && tmask==0) );'), (85604, 1, u'+    assert( !pTrigger );'), (85605, 1, u'+    assert( pList==0 );'), (85656, 1, u'+    assert( pParse->nErr==0 || rc );'), (85667, 1, u'+    assert( pSelect->pEList );'), (85669, 1, u'+    assert( dest.nMem==nColumn );'), (85723, 1, u'+    assert( useTempTable==0 );'), (85876, 1, u'+        assert( pSelect==0 );  /* Otherwise useTempTable is true */'), (85888, 1, u'+    assert( !IsVirtual(pTab) );'), (85905, 1, u'+        assert( pSelect==0 ); /* Otherwise useTempTable is true */'), (85993, 1, u'+          assert( IsVirtual(pTab) );'), (86214, 1, u'+  assert( v!=0 );'), (86215, 1, u'+  assert( pTab->pSelect==0 );  /* This table is not a VIEW */'), (86235, 1, u'+    assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail'), (86255, 1, u'+        assert( onError==OE_Replace );'), (86350, 1, u'+        assert( seenReplace==0 );'), (86411, 1, u'+    assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail'), (86439, 1, u'+        assert( seenReplace==0 );'), (86445, 1, u'+        assert( onError==OE_Replace );'), (86494, 1, u'+  assert( v!=0 );'), (86495, 1, u'+  assert( pTab->pSelect==0 );  /* This table is not a VIEW */'), (86549, 1, u'+  assert( v!=0 );'), (86553, 1, u'+    assert( pIdx->pSchema==pTab->pSchema );'), (86603, 1, u'+  assert( pDest && pSrc );'), (86604, 1, u'+  assert( pDest->pTable!=pSrc->pTable );'), (86698, 1, u'+  assert(pSelect->pSrc);   /* allocated even if there is no FROM clause */'), (86719, 1, u'+  assert( pSelect->pOffset==0 );  /* Must be so if pLimit==0 */'), (86727, 1, u'+  assert( pEList!=0 );'), (86731, 1, u'+  assert( pEList->a[0].pExpr );'), (86852, 1, u'+    assert( (pDest->tabFlags & TF_Autoincrement)==0 );'), (86863, 1, u'+    assert( pSrcIdx );'), (86951, 1, u'+    assert( rc==SQLITE_OK || pStmt==0 );'), (86981, 1, u'+            assert( azCols[i]!=0 );'), (87038, 1, u'+  assert( (rc&db->errMask)==rc );'), (87954, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (88053, 1, u'+    assert( (rc&0xff)==rc );'), (88329, 1, u'+      assert( v!=0 );  /* Already allocated by sqlite3Pragma() */'), (88374, 1, u'+                      assert( action==OE_None ); break;'), (88393, 1, u'+  assert( PAGER_JOURNALMODE_DELETE==0 );'), (88394, 1, u'+  assert( PAGER_JOURNALMODE_PERSIST==1 );'), (88395, 1, u'+  assert( PAGER_JOURNALMODE_OFF==2 );'), (88396, 1, u'+  assert( PAGER_JOURNALMODE_TRUNCATE==3 );'), (88397, 1, u'+  assert( PAGER_JOURNALMODE_MEMORY==4 );'), (88398, 1, u'+  assert( PAGER_JOURNALMODE_WAL==5 );'), (88399, 1, u'+  assert( eMode>=0 && eMode<=ArraySize(azModeName) );'), (88460, 1, u'+  assert( pId2 );'), (88510, 1, u'+      assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (88527, 1, u'+    assert( pBt!=0 );'), (88553, 1, u'+    assert( pBt!=0 );'), (88623, 1, u'+        assert(pDb==&db->aDb[0]);'), (88634, 1, u'+    assert(eMode==PAGER_LOCKINGMODE_NORMAL||eMode==PAGER_LOCKINGMODE_EXCLUSIVE);'), (88721, 1, u'+    assert( pBt!=0 );'), (88735, 1, u'+      assert( eAuto>=0 && eAuto<=2 );'), (88813, 1, u'+    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (89037, 1, u'+        assert( pTab->nCol>cnum );'), (89081, 1, u'+      assert( db->aDb[i].zName!=0 );'), (89234, 1, u'+      assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (89385, 1, u'+      assert( encnames[SQLITE_UTF8].enc==SQLITE_UTF8 );'), (89386, 1, u'+      assert( encnames[SQLITE_UTF16LE].enc==SQLITE_UTF16LE );'), (89387, 1, u'+      assert( encnames[SQLITE_UTF16BE].enc==SQLITE_UTF16BE );'), (89702, 1, u'+  assert( argc==3 );'), (89704, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (89711, 1, u'+  assert( iDb>=0 && iDb<db->nDb );'), (89725, 1, u'+    assert( db->init.busy );'), (89731, 1, u'+    assert( (rc&0xFF)==(rcp&0xFF) );'), (89735, 1, u'+        assert( iDb==1 );'), (89818, 1, u'+  assert( iDb>=0 && iDb<db->nDb );'), (89819, 1, u'+  assert( db->aDb[iDb].pSchema );'), (89820, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (89821, 1, u'+  assert( iDb==1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) );'), (89959, 1, u'+  assert( db->init.busy );'), (90032, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (90072, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (90095, 1, u'+  assert( pParse->checkSchema );'), (90096, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (90118, 1, u'+    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (90151, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (90158, 1, u'+    assert( i>=0 && i<db->nDb );'), (90187, 1, u'+  assert( ppStmt && *ppStmt==0 );'), (90188, 1, u'+  assert( !db->mallocFailed );'), (90189, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (90217, 1, u'+      assert( sqlite3BtreeHoldsMutex(pBt) );'), (90253, 1, u'+  assert( 1==(int)pParse->nQueryLoop );'), (90293, 1, u'+  assert( db->init.busy==0 || saveSqlFlag==0 );'), (90300, 1, u'+    assert(!(*ppStmt));'), (90323, 1, u'+  assert( (rc&db->errMask)==rc );'), (90336, 1, u'+  assert( ppStmt!=0 );'), (90367, 1, u'+  assert( sqlite3_mutex_held(sqlite3VdbeDb(p)->mutex) );'), (90369, 1, u'+  assert( zSql!=0 );  /* Reprepare only called for prepare_v2() statements */'), (90371, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (90377, 1, u'+    assert( pNew==0 );'), (90380, 1, u'+    assert( pNew!=0 );'), (90407, 1, u'+  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */'), (90419, 1, u'+  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */'), (90444, 1, u'+  assert( ppStmt );'), (90487, 1, u'+  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */'), (90499, 1, u'+  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */'), (90571, 1, u'+  assert( db->mallocFailed || !pOffset || pLimit ); /* OFFSET implies LIMIT */'), (90589, 1, u'+  assert( pOffset==0 || pLimit!=0 );'), (90671, 1, u'+    assert( pB!=0 );'), (90716, 1, u'+  assert( (piTab==0)==(piCol==0) );  /* Both or neither are NULL */'), (90756, 1, u'+  assert( iLeft<iRight );'), (90757, 1, u'+  assert( pSrc->nSrc>iRight );'), (90758, 1, u'+  assert( pSrc->a[iLeft].pTab );'), (90759, 1, u'+  assert( pSrc->a[iRight].pTab );'), (90767, 1, u'+    assert( !ExprHasAnyProperty(pEq, EP_TokenOnly|EP_Reduced) );'), (90803, 1, u'+    assert( !ExprHasAnyProperty(p, EP_TokenOnly|EP_Reduced) );'), (91051, 1, u'+  assert( v );'), (91053, 1, u'+  assert( pEList!=0 );'), (91071, 1, u'+    assert( pDest->nMem==nResultCol );'), (91092, 1, u'+    assert( pEList!=0 );'), (91093, 1, u'+    assert( pEList->nExpr==nColumn );'), (91151, 1, u'+      assert( nColumn==1 );'), (91182, 1, u'+      assert( nColumn==1 );'), (91222, 1, u'+      assert( eDest==SRT_Discard );'), (91351, 1, u'+  assert( op==TK_UNION || op==TK_EXCEPT || op==TK_INTERSECT || op==TK_ALL );'), (91416, 1, u'+      assert( nColumn==1 );'), (91423, 1, u'+      assert( nColumn==1 );'), (91431, 1, u'+      assert( eDest==SRT_Output || eDest==SRT_Coroutine );'), (91435, 1, u'+        assert( regRow!=pDest->iMem+i );'), (91539, 1, u'+      assert( pTab && pExpr->pTab==pTab );'), (91559, 1, u'+        assert( !pS );'), (91561, 1, u'+        assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) );'), (91586, 1, u'+      assert( ExprHasProperty(pExpr, EP_xIsSelect) );'), (91597, 1, u'+    assert( pzOriginTab && pzOriginCol );'), (91685, 1, u'+      assert( j<pTabList->nSrc );'), (91688, 1, u'+      assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) );'), (91747, 1, u'+    assert( p->pRight==0 || ExprHasProperty(p->pRight, EP_IntValue)'), (91764, 1, u'+        assert( !ExprHasProperty(pColExpr, EP_IntValue) );'), (91830, 1, u'+  assert( pSelect!=0 );'), (91831, 1, u'+  assert( (pSelect->selFlags & SF_Resolved)!=0 );'), (91832, 1, u'+  assert( nCol==pSelect->pEList->nExpr || db->mallocFailed );'), (91871, 1, u'+  assert( db->lookaside.bEnabled==0 );'), (91935, 1, u'+  assert( p->pOffset==0 || p->pLimit!=0 );'), (91988, 1, u'+  assert( iCol>=0 );'), (92055, 1, u'+  assert( p && p->pPrior );  /* Calling function guarantees this much */'), (92058, 1, u'+  assert( pPrior->pRightmost!=pPrior );'), (92059, 1, u'+  assert( pPrior->pRightmost==p->pRightmost );'), (92075, 1, u'+  assert( v!=0 );  /* The VDBE already created by calling function */'), (92080, 1, u'+    assert( p->pEList );'), (92089, 1, u'+  assert( p->pEList && pPrior->pEList );'), (92109, 1, u'+      assert( !pPrior->pLimit );'), (92161, 1, u'+        assert( p->pLimit==0 );      /* Not allowed on leftward elements */'), (92162, 1, u'+        assert( p->pOffset==0 );     /* Not allowed on leftward elements */'), (92169, 1, u'+        assert( p->pOrderBy==0 );'), (92171, 1, u'+        assert( p->addrOpenEphm[0] == -1 );'), (92174, 1, u'+        assert( p->pEList );'), (92179, 1, u'+      assert( !pPrior->pOrderBy );'), (92192, 1, u'+        assert( p->op==TK_UNION );'), (92220, 1, u'+      assert( unionTab==dest.iParm || dest.eDest!=priorOp );'), (92223, 1, u'+        assert( p->pEList );'), (92243, 1, u'+    default: assert( p->op==TK_INTERSECT ); {'), (92257, 1, u'+      assert( p->pOrderBy==0 );'), (92260, 1, u'+      assert( p->addrOpenEphm[0] == -1 );'), (92263, 1, u'+      assert( p->pEList );'), (92277, 1, u'+      assert( p->addrOpenEphm[1] == -1 );'), (92298, 1, u'+      assert( p->pEList );'), (92341, 1, u'+    assert( p->pRightmost==p );'), (92366, 1, u'+          assert( pLoop->addrOpenEphm[1]<0 );'), (92466, 1, u'+      assert( pIn->nMem==1 );'), (92492, 1, u'+      assert( pIn->nMem==1 );'), (92521, 1, u'+      assert( pDest->eDest==SRT_Output );'), (92673, 1, u'+  assert( p->pOrderBy!=0 );'), (92674, 1, u'+  assert( pKeyDup==0 ); /* "Managed" code needs this.  Ticket #3382. */'), (92677, 1, u'+  assert( v!=0 );       /* Already thrown the error if VDBE alloc failed */'), (92686, 1, u'+  assert( pPrior->pOrderBy==0 );'), (92688, 1, u'+  assert( pOrderBy );'), (92699, 1, u'+        assert( pItem->iCol>0 );'), (92724, 1, u'+      assert( pItem->iCol>0  && pItem->iCol<=p->pEList->nExpr );'), (92764, 1, u'+    assert( nOrderBy>=nExpr || db->mallocFailed );'), (93008, 1, u'+      assert( pEList!=0 && pExpr->iColumn<pEList->nExpr );'), (93009, 1, u'+      assert( pExpr->pLeft==0 && pExpr->pRight==0 );'), (93057, 1, u'+  assert( pSrc );  /* Even for (SELECT 1) we have: pSrc!=0 but pSrc->nSrc==0 */'), (93199, 1, u'+  assert( p!=0 );'), (93200, 1, u'+  assert( p->pPrior==0 );  /* Unable to flatten compound queries */'), (93203, 1, u'+  assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );'), (93207, 1, u'+  assert( pSub!=0 );'), (93211, 1, u'+  assert( pSubSrc );'), (93428, 1, u'+      assert( pParent==p );  /* First time through the loop */'), (93431, 1, u'+      assert( pParent!=p );  /* 2nd and subsequent times through the loop */'), (93434, 1, u'+        assert( db->mallocFailed );'), (93498, 1, u'+      assert( pParent->pOrderBy==0 );'), (93510, 1, u'+      assert( pParent->pHaving==0 );'), (93516, 1, u'+      assert( pParent->pGroupBy==0 );'), (93571, 1, u'+  assert( !ExprHasProperty(pExpr, EP_IntValue) );'), (93595, 1, u'+  assert( !p->pGroupBy );'), (93604, 1, u'+  assert( pTab && !pTab->pSelect && pExpr );'), (93696, 1, u'+      assert( i==0 );'), (93703, 1, u'+      assert( pSel!=0 );'), (93704, 1, u'+      assert( pFrom->pTab==0 );'), (93718, 1, u'+      assert( pFrom->pTab==0 );'), (93727, 1, u'+        assert( pFrom->pSelect==0 );'), (93759, 1, u'+    assert( pE->op!=TK_DOT || pE->pRight!=0 );'), (93760, 1, u'+    assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );'), (93777, 1, u'+      assert( pE->op!=TK_DOT || pE->pRight!=0 );'), (93795, 1, u'+          assert( pE->pLeft!=0 );'), (93796, 1, u'+          assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );'), (93824, 1, u'+              assert(IsVirtual(pTab));'), (93939, 1, u'+  assert( p->selFlags & SF_Resolved );'), (93949, 1, u'+        assert( pSel );'), (94027, 1, u'+      assert( !ExprHasProperty(pE, EP_xIsSelect) );'), (94051, 1, u'+    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );'), (94074, 1, u'+    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );'), (94085, 1, u'+      assert( nArg==1 );'), (94092, 1, u'+      assert( pList!=0 );  /* pList!=0 if pF->pFunc has NEEDCOLL */'), (94246, 1, u'+    assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union ||'), (94262, 1, u'+  assert( pEList!=0 );'), (94308, 1, u'+      assert( pItem->isPopulated==0 );'), (94358, 1, u'+  assert( p->pGroupBy==0 || (p->selFlags & SF_Aggregate)!=0 );'), (94412, 1, u'+    assert( isAgg || pGroupBy );'), (94442, 1, u'+    assert(!isDistinct);'), (94500, 1, u'+      assert( !ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_xIsSelect) );'), (94801, 1, u'+          assert( !ExprHasProperty(p->pEList->a[0].pExpr, EP_xIsSelect) );'), (95118, 1, u'+  assert( sizeof(res.azResult[0])>= sizeof(res.nData) );'), (95162, 1, u'+    assert( azResult!=0 );'), (95228, 1, u'+    assert( sqlite3SchemaMutexHeld(pParse->db, 0, pTmpSchema) );'), (95272, 1, u'+  assert( pName1!=0 );   /* pName1->z might be NULL, but not pName1 itself */'), (95273, 1, u'+  assert( pName2!=0 );'), (95274, 1, u'+  assert( op==TK_INSERT || op==TK_UPDATE || op==TK_DELETE );'), (95275, 1, u'+  assert( op>0 && op<0xff );'), (95308, 1, u'+  assert( pTableName->nSrc==1 );'), (95340, 1, u'+  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (95346, 1, u'+      assert( !db->init.busy );'), (95410, 1, u'+  assert( pParse->pNewTrigger==0 );'), (95421, 1, u'+    assert( pParse->pNewTrigger==pTrigger );'), (95482, 1, u'+    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (95490, 1, u'+      assert( pTab!=0 );'), (95498, 1, u'+  assert( !pParse->pNewTrigger );'), (95562, 1, u'+  assert(pEList == 0 || pSelect == 0);'), (95563, 1, u'+  assert(pEList != 0 || pSelect != 0 || db->mallocFailed);'), (95660, 1, u'+  assert( pName->nSrc==1 );'), (95664, 1, u'+  assert( zDb!=0 || sqlite3BtreeHoldsAllMutexes(db) );'), (95668, 1, u'+    assert( sqlite3SchemaMutexHeld(db, j, 0) );'), (95707, 1, u'+  assert( iDb>=0 && iDb<db->nDb );'), (95709, 1, u'+  assert( pTable );'), (95710, 1, u'+  assert( pTable->pSchema==pTrigger->pSchema || iDb==1 );'), (95726, 1, u'+  assert( pTable!=0 );'), (95762, 1, u'+  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );'), (95815, 1, u'+  assert( pList==0 || IsVirtual(pTab)==0 );'), (95846, 1, u'+    assert( pSrc->nSrc>0 );'), (95847, 1, u'+    assert( pSrc->a!=0 );'), (95851, 1, u'+      assert( iDb<pParse->db->nDb );'), (95871, 1, u'+  assert( pParse->pTriggerTab && pParse->pToplevel );'), (95872, 1, u'+  assert( pStepList );'), (95873, 1, u'+  assert( v!=0 );'), (95917, 1, u'+      default: assert( pStep->op==TK_SELECT ); {'), (95958, 1, u'+  assert( pFrom->zErrMsg==0 || pFrom->nErr );'), (95959, 1, u'+  assert( pTo->zErrMsg==0 || pTo->nErr );'), (95988, 1, u'+  assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );'), (95989, 1, u'+  assert( pTop->pVdbe );'), (96071, 1, u'+  assert( !pSubParse->pAinc       && !pSubParse->pZombieTab );'), (96072, 1, u'+  assert( !pSubParse->pTriggerPrg && !pSubParse->nMaxArg );'), (96093, 1, u'+  assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );'), (96129, 1, u'+  assert( pPrg || pParse->nErr || pParse->db->mallocFailed );'), (96203, 1, u'+  assert( op==TK_UPDATE || op==TK_INSERT || op==TK_DELETE );'), (96204, 1, u'+  assert( tr_tm==TRIGGER_BEFORE || tr_tm==TRIGGER_AFTER );'), (96205, 1, u'+  assert( (op==TK_UPDATE)==(pChanges!=0) );'), (96212, 1, u'+    assert( p->pSchema!=0 );'), (96213, 1, u'+    assert( p->pTabSchema!=0 );'), (96214, 1, u'+    assert( p->pSchema==p->pTabSchema'), (96265, 1, u'+  assert( isNew==1 || isNew==0 );'), (96345, 1, u'+  assert( pTab!=0 );'), (96351, 1, u'+    assert( i<pTab->nCol );'), (96421, 1, u'+  assert( pTabList->nSrc==1 );'), (96435, 1, u'+  assert( pTrigger || tmask==0 );'), (96644, 1, u'+        assert( pParse->nTab>iCur+i+1 );'), (96667, 1, u'+  assert( chngRowid || pTrigger || hasFK || regOldRowid==regNewRowid );'), (96907, 1, u'+  assert( pTab->iPKey<0 );'), (96921, 1, u'+  assert( v );'), (97000, 1, u'+  assert( rc!=SQLITE_ROW );'), (97107, 1, u'+    assert( strcmp(pDb->zName,"vacuum_db")==0 );'), (97243, 1, u'+    assert( 1==sqlite3BtreeIsInTrans(pTemp) );'), (97244, 1, u'+    assert( 1==sqlite3BtreeIsInTrans(pMain) );'), (97264, 1, u'+  assert( rc==SQLITE_OK );'), (97417, 1, u'+  assert( IsVirtual(pTab) );'), (97429, 1, u'+  assert( db );'), (97430, 1, u'+  assert( pVTab->nRef>0 );'), (97431, 1, u'+  assert( sqlite3SafetyCheckOk(db) );'), (97461, 1, u'+  assert( db==0 || sqlite3SchemaMutexHeld(db, 0, p->pSchema) );'), (97466, 1, u'+    assert( db2 );'), (97478, 1, u'+  assert( !db || pRet );'), (97507, 1, u'+  assert( sqlite3BtreeHoldsAllMutexes(db) );'), (97508, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (97589, 1, u'+  assert( 0==pTable->pIndex );'), (97593, 1, u'+  assert( iDb>=0 );'), (97700, 1, u'+    assert( sqlite3SchemaMutexHeld(db, 0, pSchema) );'), (97704, 1, u'+      assert( pTab==pOld );  /* Malloc must have failed inside HashInsert() */'), (97731, 1, u'+    assert(pArg->z < p->z);'), (97769, 1, u'+  assert( &db->pVtabCtx );'), (97770, 1, u'+  assert( xConstruct );'), (97829, 1, u"+            assert(zType[i-1]==' ');"), (97855, 1, u'+  assert( pTab );'), (97926, 1, u'+  assert( pTab && (pTab->tabFlags & TF_Virtual)!=0 && !pTab->pVTable );'), (97973, 1, u'+  assert( (pTab->tabFlags & TF_Virtual)!=0 );'), (98010, 1, u'+  assert( (rc&0xff)==rc );'), (98031, 1, u'+    assert( rc==SQLITE_OK );'), (98036, 1, u'+      assert( pTab->pVTable==p && p->pNext==0 );'), (98186, 1, u'+  assert( op==SAVEPOINT_RELEASE||op==SAVEPOINT_ROLLBACK||op==SAVEPOINT_BEGIN );'), (98187, 1, u'+  assert( iSavepoint>=0 );'), (98253, 1, u'+  assert( pVtab!=0 );'), (98254, 1, u'+  assert( pVtab->pModule!=0 );'), (98300, 1, u'+  assert( IsVirtual(pTab) );'), (98325, 1, u'+  assert( OE_Rollback==1 && OE_Abort==2 && OE_Fail==3 );'), (98326, 1, u'+  assert( OE_Ignore==4 && OE_Replace==5 );'), (98327, 1, u'+  assert( db->vtabOnConflict>=1 && db->vtabOnConflict<=5 );'), (98349, 1, u'+        assert( p->pTab==0 || (p->pTab->tabFlags & TF_Virtual)!=0 );'), (98769, 1, u'+  assert( pMaskSet->n<=(int)sizeof(Bitmask)*8 );'), (98787, 1, u'+  assert( pMaskSet->n < ArraySize(pMaskSet->ix) );'), (98859, 1, u'+  assert( TK_GT>TK_EQ && TK_GT<TK_GE );'), (98860, 1, u'+  assert( TK_LT>TK_EQ && TK_LT<TK_GE );'), (98861, 1, u'+  assert( TK_LE>TK_EQ && TK_LE<TK_GE );'), (98862, 1, u'+  assert( TK_GE==TK_EQ+4 );'), (98886, 1, u'+  assert( allowedOp(pExpr->op) && pExpr->op!=TK_IN );'), (98894, 1, u'+    assert( TK_LT==TK_GT+2 );'), (98895, 1, u'+    assert( TK_GE==TK_LE+2 );'), (98896, 1, u'+    assert( TK_GT>TK_EQ );'), (98897, 1, u'+    assert( TK_GT<TK_LE );'), (98898, 1, u'+    assert( pExpr->op>=TK_GT && pExpr->op<=TK_GE );'), (98908, 1, u'+  assert( allowedOp(op) );'), (98914, 1, u'+    assert( (WO_EQ<<(op-TK_EQ)) < 0x7fff );'), (98917, 1, u'+  assert( op!=TK_ISNULL || c==WO_ISNULL );'), (98918, 1, u'+  assert( op!=TK_IN || c==WO_IN );'), (98919, 1, u'+  assert( op!=TK_EQ || c==WO_EQ );'), (98920, 1, u'+  assert( op!=TK_LT || c==WO_LT );'), (98921, 1, u'+  assert( op!=TK_LE || c==WO_LE );'), (98922, 1, u'+  assert( op!=TK_GT || c==WO_GT );'), (98923, 1, u'+  assert( op!=TK_GE || c==WO_GE );'), (98943, 1, u'+  assert( iCur>=0 );'), (98965, 1, u'+        assert(pX->pLeft);'), (98967, 1, u'+        assert(pColl || pParse->nErr);'), (99037, 1, u'+  assert( pLeft->iColumn!=(-1) ); /* Because IPK never has AFF_TEXT */'), (99052, 1, u'+    assert( pRight->op==TK_VARIABLE || pRight->op==TK_REGISTER );'), (99232, 1, u'+  assert( (pTerm->wtFlags & (TERM_DYNAMIC|TERM_ORINFO|TERM_ANDINFO))==0 );'), (99233, 1, u'+  assert( pExpr->op==TK_OR );'), (99242, 1, u'+  assert( pOrWc->nTerm>=2 );'), (99252, 1, u'+      assert( pOrTerm->eOperator==0 );'), (99253, 1, u'+      assert( (pOrTerm->wtFlags & (TERM_ANDINFO|TERM_ORINFO))==0 );'), (99271, 1, u'+            assert( pAndTerm->pExpr );'), (99341, 1, u'+        assert( pOrTerm->eOperator==WO_EQ );'), (99346, 1, u'+          assert( j==1 );'), (99356, 1, u'+          assert( pOrTerm->wtFlags & (TERM_COPIED|TERM_VIRTUAL) );'), (99366, 1, u'+        assert( j==1 );'), (99367, 1, u'+        assert( (chngToIN&(chngToIN-1))==0 );'), (99368, 1, u'+        assert( chngToIN==getMask(pMaskSet, iCursor) );'), (99377, 1, u'+        assert( pOrTerm->eOperator==WO_EQ );'), (99413, 1, u'+        assert( pOrTerm->eOperator==WO_EQ );'), (99414, 1, u'+        assert( pOrTerm->leftCursor==iCursor );'), (99415, 1, u'+        assert( pOrTerm->u.leftColumn==iColumn );'), (99420, 1, u'+      assert( pLeft!=0 );'), (99426, 1, u'+        assert( !ExprHasProperty(pNew, EP_xIsSelect) );'), (99489, 1, u'+    assert( pExpr->pRight==0 );'), (99571, 1, u'+    assert( pList!=0 );'), (99572, 1, u'+    assert( pList->nExpr==2 );'), (99594, 1, u'+    assert( pWC->op==TK_AND );'), (99803, 1, u'+  assert( pOrderBy!=0 );'), (99805, 1, u'+  assert( nTerm>0 );'), (99810, 1, u'+  assert( pIdx->zName || (pIdx->nColumn==1 && pIdx->aiColumn[0]==-1) );'), (99867, 1, u'+    assert( pIdx->aSortOrder!=0 || iColumn==-1 );'), (99868, 1, u'+    assert( pTerm->sortOrder==0 || pTerm->sortOrder==1 );'), (99869, 1, u'+    assert( iSortOrder==0 || iSortOrder==1 );'), (100129, 1, u'+  assert( pParse->nQueryLoop >= (double)1 );'), (100194, 1, u'+  assert( v!=0 );'), (100217, 1, u'+  assert( nColumn>0 );'), (100270, 1, u'+  assert( (u32)n==pLevel->plan.nEq );'), (100288, 1, u'+  assert( n==nColumn );'), (100292, 1, u'+  assert( pLevel->iIdxCur>=0 );'), (100340, 1, u'+    assert( (pTerm->eOperator&(pTerm->eOperator-1))==0 );'), (100390, 1, u'+    assert( (pTerm->eOperator&(pTerm->eOperator-1))==0 );'), (100400, 1, u'+    assert( WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ );'), (100401, 1, u'+    assert( WO_LT==SQLITE_INDEX_CONSTRAINT_LT );'), (100402, 1, u'+    assert( WO_LE==SQLITE_INDEX_CONSTRAINT_LE );'), (100403, 1, u'+    assert( WO_GT==SQLITE_INDEX_CONSTRAINT_GT );'), (100404, 1, u'+    assert( WO_GE==SQLITE_INDEX_CONSTRAINT_GE );'), (100405, 1, u'+    assert( WO_MATCH==SQLITE_INDEX_CONSTRAINT_MATCH );'), (100406, 1, u'+    assert( pTerm->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE|WO_MATCH) );'), (100529, 1, u'+  assert( pTab->azModuleArg && pTab->azModuleArg[0] );'), (100530, 1, u'+  assert( sqlite3GetVTable(pParse->db, pTab) );'), (100650, 1, u'+  assert( roundUp==0 || roundUp==1 );'), (100679, 1, u'+      assert( eType==SQLITE_TEXT || eType==SQLITE_BLOB );'), (100684, 1, u'+        assert( pColl->enc==SQLITE_UTF8 );'), (100696, 1, u'+        assert( z && pColl && pColl->xCmp );'), (100712, 1, u'+            assert( db->mallocFailed );'), (100726, 1, u'+    assert( i>=0 && i<=SQLITE_INDEX_SAMPLES );'), (100834, 1, u'+      assert( pLower->eOperator==WO_GT || pLower->eOperator==WO_GE );'), (100840, 1, u'+      assert( pUpper->eOperator==WO_LT || pUpper->eOperator==WO_LE );'), (100864, 1, u'+    assert( iEst<=SQLITE_INDEX_SAMPLES );'), (100880, 1, u'+  assert( pLower || pUpper );'), (100917, 1, u'+  assert( p->aSample!=0 );'), (100980, 1, u'+  assert( p->aSample!=0 );'), (100999, 1, u'+      assert( iLower>=0 && iUpper<=SQLITE_INDEX_SAMPLES );'), (101492, 1, u'+  assert( pOrderBy || (pCost->plan.wsFlags&WHERE_ORDERBY)==0 );'), (101493, 1, u'+  assert( pCost->plan.u.pIdx==0 || (pCost->plan.wsFlags&WHERE_ROWID_EQ)==0 );'), (101494, 1, u'+  assert( pSrc->pIndex==0'), (101594, 1, u'+    assert( pParse->db->mallocFailed );'), (101597, 1, u'+  assert( v!=0 );'), (101641, 1, u'+  assert( iTarget>0 );'), (101653, 1, u'+    assert( pX->op==TK_IN );'), (101658, 1, u'+    assert( pLevel->plan.wsFlags & WHERE_IN_ABLE );'), (101743, 1, u'+  assert( pLevel->plan.wsFlags & WHERE_INDEXED );'), (101759, 1, u'+  assert( pIdx->nColumn>=nEq );'), (102063, 1, u'+    assert( pTerm!=0 );'), (102064, 1, u'+    assert( pTerm->pExpr!=0 );'), (102065, 1, u'+    assert( pTerm->leftCursor==iCur );'), (102066, 1, u'+    assert( omitTable==0 );'), (102083, 1, u'+    assert( omitTable==0 );'), (102104, 1, u'+      assert( TK_LE==TK_GT+1 );      /* Make sure the ordering.. */'), (102105, 1, u'+      assert( TK_LT==TK_GT+2 );      /*  ... of the TK_xx values... */'), (102106, 1, u'+      assert( TK_GE==TK_GT+3 );      /*  ... is correcct. */'), (102110, 1, u'+      assert( pX!=0 );'), (102111, 1, u'+      assert( pStart->leftCursor==iCur );'), (102124, 1, u'+      assert( pX!=0 );'), (102125, 1, u'+      assert( pEnd->leftCursor==iCur );'), (102143, 1, u'+      assert( pLevel->p5==0 );'), (102305, 1, u'+    assert( op!=0 );'), (102445, 1, u'+    assert( pTerm!=0 );'), (102446, 1, u'+    assert( pTerm->eOperator==WO_OR );'), (102447, 1, u'+    assert( (pTerm->wtFlags & TERM_ORINFO)!=0 );'), (102541, 1, u'+    assert( bRev==0 || bRev==1 );'), (102542, 1, u'+    assert( omitTable==0 );'), (102569, 1, u'+    assert( pE!=0 );'), (102590, 1, u'+        assert( pWInfo->untestedTerms );'), (102593, 1, u'+      assert( pTerm->pExpr );'), (102835, 1, u'+  assert( pWC->vmask==0 && pMaskSet->n==0 );'), (102849, 1, u'+      assert( (m-1)==toTheLeft );'), (102962, 1, u'+        assert( pTabItem->pTab );'), (102974, 1, u'+        assert( isOptimal || (sCost.used&notReady)==0 );'), (102978, 1, u'+        assert( pTabItem->pIndex==0'), (103025, 1, u'+    assert( bestJ>=0 );'), (103026, 1, u'+    assert( notReady & getMask(pMaskSet, pTabList->a[bestJ].iCursor) );'), (103062, 1, u'+        assert( bestPlan.plan.u.pIdx==pIdx );'), (103083, 1, u'+  assert( (wctrlFlags & WHERE_ONEPASS_DESIRED)==0 || pWInfo->nLevel==1 );'), (103126, 1, u'+        assert( n<=pTab->nCol );'), (103140, 1, u'+      assert( pIx->pSchema==pTab->pSchema );'), (103141, 1, u'+      assert( iIdxCur>=0 );'), (103264, 1, u'+      assert( (pLevel->plan.wsFlags & WHERE_IDX_ONLY)==0'), (103288, 1, u'+  assert( pWInfo->nLevel==1 || pWInfo->nLevel==pTabList->nSrc );'), (103292, 1, u'+    assert( pTab!=0 );'), (103324, 1, u'+      assert( pIdx!=0 );'), (103337, 1, u'+          assert( (pLevel->plan.wsFlags & WHERE_IDX_ONLY)==0'), (104892, 1, u'+  assert( iLookAhead!=YYNOCODE );'), (104956, 1, u'+  assert( stateno<=YY_REDUCE_COUNT );'), (104959, 1, u'+  assert( i!=YY_REDUCE_USE_DFLT );'), (104960, 1, u'+  assert( iLookAhead!=YYNOCODE );'), (104967, 1, u'+  assert( i>=0 && i<YY_ACTTAB_COUNT );'), (104968, 1, u'+  assert( yy_lookahead[i]==iLookAhead );'), (106349, 1, u'+  assert( yymsp[-2].minor.yy203!=0 );'), (106357, 1, u'+  assert( yymsp[-1].minor.yy203!=0 );'), (106552, 1, u'+    assert( yyact == YYNSTATE + YYNRULE + 1 );'), (106589, 1, u'+  assert( TOKEN.z[0] );  /* The tokenizer always gives us a token */'), (106675, 1, u'+      assert( !yyendofinput );  /* Impossible to shift the $ token */'), (106682, 1, u'+      assert( yyact == YY_ERROR_ACTION );'), (107461, 1, u'+  assert( pzErrMsg!=0 );'), (107467, 1, u'+  assert( pParse->pNewTable==0 );'), (107468, 1, u'+  assert( pParse->pNewTrigger==0 );'), (107469, 1, u'+  assert( pParse->nVar==0 );'), (107470, 1, u'+  assert( pParse->nzVar==0 );'), (107471, 1, u'+  assert( pParse->azVar==0 );'), (107475, 1, u'+    assert( i>=0 );'), (107534, 1, u'+  assert( pzErrMsg!=0 );'), (108169, 1, u'+    assert( sqlite3GlobalConfig.nRefInitMutex==0 );'), (108186, 1, u'+    assert(sizeof(x)==8);'), (108187, 1, u'+    assert(sizeof(x)==sizeof(y));'), (108189, 1, u'+    assert( sqlite3IsNaN(y) );'), (108446, 1, u'+    assert( sz > (int)sizeof(LookasideSlot*) );'), (108671, 1, u'+  assert( sqlite3SafetyCheckSickOrOk(db) );'), (108703, 1, u'+  assert( db->nDb<=2 );'), (108704, 1, u'+  assert( db->aDb==db->aDbStatic );'), (108757, 1, u'+  assert( db->lookaside.nOut==0 );  /* Fails on a lookaside memory leak */'), (108771, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (108861, 1, u'+  assert( count>=0 );'), (108991, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (109038, 1, u'+      assert( !db->mallocFailed );'), (109046, 1, u'+  assert(p || db->mallocFailed);'), (109110, 1, u'+    assert( rc!=SQLITE_OK );'), (109135, 1, u'+  assert( !db->mallocFailed );'), (109361, 1, u'+  assert( SQLITE_CHECKPOINT_FULL>SQLITE_CHECKPOINT_PASSIVE );'), (109362, 1, u'+  assert( SQLITE_CHECKPOINT_FULL<SQLITE_CHECKPOINT_RESTART );'), (109363, 1, u'+  assert( SQLITE_CHECKPOINT_PASSIVE+2==SQLITE_CHECKPOINT_RESTART );'), (109420, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (109421, 1, u'+  assert( !pnLog || *pnLog==-1 );'), (109422, 1, u'+  assert( !pnCkpt || *pnCkpt==-1 );'), (109491, 1, u'+    assert( !db->mallocFailed );'), (109587, 1, u'+  assert( sqlite3_mutex_held(db->mutex) );'), (109722, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_LENGTH]==SQLITE_MAX_LENGTH );'), (109723, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_SQL_LENGTH]==SQLITE_MAX_SQL_LENGTH );'), (109724, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_COLUMN]==SQLITE_MAX_COLUMN );'), (109725, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_EXPR_DEPTH]==SQLITE_MAX_EXPR_DEPTH );'), (109726, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_COMPOUND_SELECT]==SQLITE_MAX_COMPOUND_SELECT);'), (109727, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_VDBE_OP]==SQLITE_MAX_VDBE_OP );'), (109728, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_FUNCTION_ARG]==SQLITE_MAX_FUNCTION_ARG );'), (109729, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_ATTACHED]==SQLITE_MAX_ATTACHED );'), (109730, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]=='), (109732, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_VARIABLE_NUMBER]==SQLITE_MAX_VARIABLE_NUMBER);'), (109733, 1, u'+  assert( aHardLimit[SQLITE_LIMIT_TRIGGER_DEPTH]==SQLITE_MAX_TRIGGER_DEPTH );'), (109734, 1, u'+  assert( SQLITE_LIMIT_TRIGGER_DEPTH==(SQLITE_N_LIMIT-1) );'), (109789, 1, u'+  assert( *pzErrMsg==0 );'), (109843, 1, u'+        assert( octet>=0 && octet<256 );'), (110013, 1, u'+  assert( SQLITE_OPEN_READONLY  == 0x01 );'), (110014, 1, u'+  assert( SQLITE_OPEN_READWRITE == 0x02 );'), (110015, 1, u'+  assert( SQLITE_OPEN_CREATE    == 0x04 );'), (110076, 1, u'+  assert( sizeof(db->aLimit)==sizeof(aHardLimit) );'), (110116, 1, u'+  assert( db->pDfltColl!=0 );'), (110228, 1, u'+    assert( db->mutex!=0 || isThreadsafe==0 || sqlite3GlobalConfig.bFullMutex==0 );'), (110273, 1, u'+  assert( zFilename );'), (110274, 1, u'+  assert( ppDb );'), (110286, 1, u'+    assert( *ppDb || rc==SQLITE_NOMEM );'), (110311, 1, u'+  assert( !db->mallocFailed );'), (110331, 1, u'+  assert( !db->mallocFailed );'), (110352, 1, u'+  assert( !db->mallocFailed );'), (110628, 1, u'+      assert( pPager!=0 );'), (110630, 1, u'+      assert( fd!=0 );'), (110749, 1, u'+    case SQLITE_TESTCTRL_ASSERT: {'), (110751, 1, u'+      assert( (x = va_arg(ap,int))!=0 );'), (110932, 1, u'+#define assertMutexHeld() \\'), (110933, 1, u'+  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) )'), (110965, 1, u'+    assert( p->pUnlockConnection || p->pBlockingConnection );'), (110970, 1, u'+      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );'), (110971, 1, u'+      assert( db==0 || p->pUnlockConnection!=db );'), (110972, 1, u'+      assert( db==0 || p->pBlockingConnection!=db );'), (110986, 1, u'+  assertMutexHeld();'), (111001, 1, u'+  assertMutexHeld();'), (111023, 1, u'+  assertMutexHeld();'), (111087, 1, u'+  assert( !db->mallocFailed );'), (111149, 1, u'+      assert( p->xUnlockNotify );'), (111156, 1, u'+      assert( aArg==aDyn || (aDyn==0 && aArg==aStatic) );'), (111157, 1, u'+      assert( nArg<=(int)ArraySize(aStatic) || aArg==aDyn );'), (112347, 1, u'+  assert( q - (unsigned char *)p <= FTS3_VARINT_MAX );'), (112475, 1, u'+  assert( p->nPendingData==0 );'), (112476, 1, u'+  assert( p->pSegments==0 );'), (112671, 1, u'+    assert( p->nPgsz>0 || rc!=SQLITE_OK );'), (112940, 1, u'+  assert( strlen(argv[0])==4 );'), (112941, 1, u'+  assert( (sqlite3_strnicmp(argv[0], "fts4", 4)==0 && isFts4)'), (113056, 1, u'+    assert( nString==0 );'), (113066, 1, u'+  assert( pTokenizer );'), (113070, 1, u'+    assert( zPrefix );'), (113126, 1, u'+    assert( zCsr <= &((char *)p)[nByte] );'), (113166, 1, u'+    assert( p->pSegments==0 );'), (113268, 1, u'+  assert( p->pSegments==0 );'), (113298, 1, u'+  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );'), (113304, 1, u'+  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );'), (113487, 1, u'+  assert( piLeaf || piLeaf2 );'), (113491, 1, u'+  assert( !piLeaf2 || !piLeaf || rc!=SQLITE_OK || (*piLeaf<=*piLeaf2) );'), (113528, 1, u'+  assert( iVal-*piPrev > 0 || (*piPrev==0 && iVal==0) );'), (113783, 1, u'+  assert( isSaveLeft==0 || isExact==0 );'), (113785, 1, u'+  assert( *p1!=0 && *p2!=0 );'), (113807, 1, u'+      assert( *p1!=POS_END && *p1!=POS_COLUMN );'), (113808, 1, u'+      assert( *p2!=POS_END && *p2!=POS_COLUMN );'), (113838, 1, u'+        assert( pp && p );'), (113844, 1, u'+      assert( (*p1&0xFE)==0 && (*p2&0xFE)==0 );'), (113976, 1, u'+  assert( *pbFirst || *piPrev==0 );'), (113977, 1, u'+  assert( *pbFirst==0 || iWrite>0 );'), (114051, 1, u'+  assert( nDist>0 );'), (114170, 1, u'+        assert( iOut>0 );'), (114304, 1, u'+  assert( iIndex>=0 && iIndex<p->nIndex );'), (114305, 1, u'+  assert( iLevel==FTS3_SEGCURSOR_ALL'), (114309, 1, u'+  assert( iLevel<FTS3_SEGDIR_MAXLEVEL );'), (114310, 1, u'+  assert( FTS3_SEGCURSOR_ALL<0 && FTS3_SEGCURSOR_PENDING<0 );'), (114311, 1, u'+  assert( isPrefix==0 || isScan==0 );'), (114315, 1, u'+  assert( isScan==0 || p->aIndex==0 );'), (114511, 1, u'+  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );'), (114546, 1, u'+  assert( idxNum>=0 && idxNum<=(FTS3_FULLTEXT_SEARCH+p->nColumn) );'), (114547, 1, u'+  assert( nVal==0 || nVal==1 );'), (114548, 1, u'+  assert( (nVal==0)==(idxNum==FTS3_FULLSCAN_SEARCH) );'), (114549, 1, u'+  assert( p->pSegments==0 );'), (114654, 1, u'+  assert( iCol>=0 && iCol<=p->nColumn+1 );'), (114673, 1, u'+  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );'), (114707, 1, u'+  assert( p->pSegments==0 );'), (114708, 1, u'+  assert( p->nPendingData==0 );'), (114709, 1, u'+  assert( p->inTransaction!=1 );'), (114723, 1, u'+  assert( p->nPendingData==0 );'), (114724, 1, u'+  assert( p->inTransaction!=0 );'), (114725, 1, u'+  assert( p->pSegments==0 );'), (114738, 1, u'+  assert( p->inTransaction!=0 );'), (114811, 1, u'+  assert( nVal>=1 );'), (114846, 1, u'+  assert( nVal==1 );'), (114848, 1, u'+  assert( pCsr );'), (114874, 1, u'+  assert( nVal==1 );'), (114877, 1, u'+  assert( p );'), (114903, 1, u'+  assert( nVal==1 || nVal==2 );'), (114995, 1, u'+  assert( ((Fts3Table *)pVtab)->inTransaction );'), (114996, 1, u'+  assert( ((Fts3Table *)pVtab)->mxSavepoint < iSavepoint );'), (115004, 1, u'+  assert( p->inTransaction );'), (115005, 1, u'+  assert( p->mxSavepoint >= iSavepoint );'), (115012, 1, u'+  assert( p->inTransaction );'), (115013, 1, u'+  assert( p->mxSavepoint >= iSavepoint );'), (115150, 1, u'+  assert( rc!=SQLITE_OK );'), (115207, 1, u'+      assert( pExpr->pPhrase->iDoclistToken==0 );'), (115224, 1, u'+  assert( iToken!=p->iDoclistToken );'), (115281, 1, u'+    assert( pToken->pDeferred==0 || pToken->pSegcsr==0 );'), (115291, 1, u'+    assert( pToken->pSegcsr==0 );'), (115306, 1, u'+  assert( pPhrase->doclist.bFreeList==0 );'), (115333, 1, u'+        assert( iPrev>=0 );'), (115422, 1, u'+  assert( rc!=SQLITE_OK || p->nToken<1 || p->aToken[0].pSegcsr==0 || p->bIncr );'), (115441, 1, u'+  assert( nDoclist>0 );'), (115442, 1, u'+  assert( *pbEof==0 );'), (115443, 1, u'+  assert( p || *piDocid==0 );'), (115444, 1, u'+  assert( !p || (p>aDoclist && p<&aDoclist[nDoclist]) );'), (115502, 1, u'+    assert( p->nToken==1 );'), (115503, 1, u'+    assert( pDL->pNextDocid==0 );'), (115548, 1, u'+      assert( pIter>=&pDL->aAll[pDL->nAll] || *pIter );'), (115651, 1, u'+    assert( a );'), (115665, 1, u'+    assert( pCsr->nRowAvg>0 );'), (115710, 1, u'+    assert( pTC );'), (115721, 1, u'+        assert( rc==SQLITE_OK || pList==0 );'), (115830, 1, u'+  assert( pPhrase->doclist.pList );'), (115838, 1, u"+    assert( pPhrase->doclist.pList[nNew]=='\\0' );"), (115839, 1, u'+    assert( nNew<=pPhrase->doclist.nList && nNew>0 );'), (115932, 1, u'+    assert( pExpr->bEof==0 );'), (115940, 1, u'+        assert( !pLeft->bDeferred || !pRight->bDeferred );'), (115974, 1, u'+        assert( pLeft->bStart || pLeft->iDocid==pRight->iDocid );'), (115975, 1, u'+        assert( pRight->bStart || pLeft->iDocid==pRight->iDocid );'), (116003, 1, u'+          assert( *pRc!=SQLITE_OK || pRight->bStart );'), (116094, 1, u'+          assert( pExpr->bDeferred || pPhrase->doclist.bFreeList==0 );'), (116146, 1, u'+  assert( pCsr->isEof==0 );'), (116154, 1, u'+      assert( sqlite3_data_count(pCsr->pStmt)==0 );'), (116185, 1, u'+        assert( pPhrase->nToken==1 );'), (116186, 1, u'+        assert( pPhrase->aToken[0].pSegcsr );'), (116219, 1, u'+      assert( *p );'), (116261, 1, u'+  assert( pExpr->eType==FTSQUERY_PHRASE );'), (116278, 1, u'+    assert( pRoot->bStart );'), (116283, 1, u'+      assert( pE->aMI==0 );'), (116296, 1, u'+        assert( sqlite3_data_count(pCsr->pStmt)==0 );'), (116329, 1, u'+        assert( pRoot->bEof==0 );'), (116377, 1, u'+    assert( pCsr->nDoc>0 );'), (116385, 1, u'+      assert( pExpr->aMI );'), (116425, 1, u'+  assert( iCol>=0 && iCol<pTab->nColumn );'), (116434, 1, u'+  assert( pPhrase->doclist.nList>0 );'), (116764, 1, u'+          assert( iCol==0 );'), (116783, 1, u'+        default: assert( eState==3 );'), (116818, 1, u'+  assert( idxStr==0 );'), (116819, 1, u'+  assert( idxNum==FTS4AUX_EQ_CONSTRAINT || idxNum==0'), (116879, 1, u'+  assert( p->isEof==0 );'), (117220, 1, u'+        assert( nToken==ii );'), (117341, 1, u'+        assert( nKey==4 );'), (117460, 1, u'+  assert( p->eType!=FTSQUERY_PHRASE );'), (117468, 1, u'+  assert( p->eType==FTSQUERY_AND );'), (117491, 1, u'+    assert( pSplit->pParent->pRight==pSplit );'), (117567, 1, u'+          assert( pRet && pPrev );'), (117599, 1, u'+            assert( pPrev && pPrev->pLeft && pPrev->pRight==0 );'), (117610, 1, u'+      assert( nByte>0 );'), (117612, 1, u'+    assert( rc!=SQLITE_OK || (nByte>0 && nByte<=nIn) );'), (117713, 1, u'+    assert( p->eType==FTSQUERY_PHRASE || p->pPhrase==0 );'), (117857, 1, u'+  assert( rc==SQLITE_NOMEM || rc==SQLITE_OK );'), (117966, 1, u'+  assert( pNew!=0 );'), (117967, 1, u'+  assert( keyClass>=FTS3_HASH_STRING && keyClass<=FTS3_HASH_BINARY );'), (117983, 1, u'+  assert( pH!=0 );'), (118050, 1, u'+    assert( keyClass==FTS3_HASH_BINARY );'), (118065, 1, u'+    assert( keyClass==FTS3_HASH_BINARY );'), (118107, 1, u'+  assert( (new_size & (new_size-1))==0 );'), (118182, 1, u'+    assert( pH->first==0 );'), (118183, 1, u'+    assert( pH->count==0 );'), (118198, 1, u'+  assert( xHash!=0 );'), (118200, 1, u'+  assert( (pH->htsize & (pH->htsize-1))==0 );'), (118243, 1, u'+  assert( pH!=0 );'), (118245, 1, u'+  assert( xHash!=0 );'), (118247, 1, u'+  assert( (pH->htsize & (pH->htsize-1))==0 );'), (118266, 1, u'+  assert( pH->htsize>0 );'), (118281, 1, u'+  assert( pH->htsize>0 );'), (118282, 1, u'+  assert( (pH->htsize & (pH->htsize-1))==0 );'), (118440, 1, u"+  assert( x>='a' && x<='z' );"), (118449, 1, u"+  assert( x>='a' && x<='z' );"), (118997, 1, u'+  assert( argc==1 || argc==2 );'), (119125, 1, u'+    assert( rc!=SQLITE_OK || *ppTok );'), (119195, 1, u'+  assert( argc==2 || argc==3 );'), (119340, 1, u'+  assert( rc==SQLITE_OK );'), (119341, 1, u'+  assert( p1==p2 );'), (119343, 1, u'+  assert( rc==SQLITE_ERROR );'), (119344, 1, u'+  assert( p2==0 );'), (119345, 1, u'+  assert( 0==strcmp(sqlite3_errmsg(db), "unknown tokenizer: nosuchtokenizer") );'), (119349, 1, u'+  assert( rc==SQLITE_OK );'), (119351, 1, u'+  assert( rc==SQLITE_OK );'), (119352, 1, u'+  assert( p2==p1 );'), (119943, 1, u'+  assert( SizeofArray(azSql)==SizeofArray(p->aStmt) );'), (119944, 1, u'+  assert( eStmt<SizeofArray(azSql) && eStmt>=0 );'), (119961, 1, u'+      assert( rc==SQLITE_OK || pStmt==0 );'), (119985, 1, u'+  assert( eStmt==SQL_SELECT_DOCSIZE || eStmt==SQL_SELECT_DOCTOTAL );'), (120103, 1, u'+  assert( iLevel==FTS3_SEGCURSOR_ALL || iLevel>=0 );'), (120104, 1, u'+  assert( iLevel<FTS3_SEGDIR_MAXLEVEL );'), (120105, 1, u'+  assert( iIndex>=0 && iIndex<p->nIndex );'), (120192, 1, u'+  assert( !p || p->iLastDocid<=iDocid );'), (120197, 1, u'+      assert( p->nData<p->nSpace );'), (120198, 1, u'+      assert( p->aData[p->nData]==0 );'), (120218, 1, u'+    assert( iPos>p->iLastPos || (iPos==0 && p->iLastPos==0) );'), (120264, 1, u'+      assert( 0==fts3HashFind(pHash, zToken, nToken) );'), (120303, 1, u'+  assert( pTokenizer && pModule );'), (120635, 1, u'+  assert( pnBlob);'), (120710, 1, u'+  assert( !pReader->pBlob'), (120755, 1, u'+        assert( pReader->aNode );'), (120769, 1, u'+    assert( pReader->iCurrentBlock<=pReader->iLeafEndBlock );'), (120779, 1, u'+    assert( pReader->pBlob==0 );'), (120787, 1, u'+  assert( !fts3SegReaderIsPending(pReader) );'), (120840, 1, u'+  assert( pReader->aDoclist );'), (120841, 1, u'+  assert( !pReader->pOffsetList );'), (120880, 1, u'+  assert( p );'), (120915, 1, u'+      assert( *p==0 );'), (120969, 1, u'+  assert( p->bHasStat );'), (120970, 1, u'+  assert( pgsz>0 );'), (121023, 1, u'+  assert( iStartLeaf<=iEndLeaf );'), (121203, 1, u'+  assert( rc!=0 );'), (121227, 1, u'+  assert( pLhs->aNode && pRhs->aNode );'), (121239, 1, u'+  assert( pLhs->aNode && pRhs->aNode );'), (121284, 1, u'+  assert( nSuspect<=nSegment );'), (121301, 1, u'+    assert( xCmp(apSegment[i], apSegment[i+1])<0 );'), (121412, 1, u'+        assert( pTree->aData==(char *)&pTree[1] );'), (121495, 1, u'+  assert( iHeight>=1 && iHeight<128 );'), (121546, 1, u'+      assert( iNextLeaf==iFree );'), (121568, 1, u'+      assert( pRight==0 || p->zMalloc==0 );'), (121655, 1, u'+    assert( nPrefix<nTerm );'), (121680, 1, u'+  assert( nData+nReq<=pWriter->nSize );'), (121706, 1, u'+    assert( pWriter->zTerm==pWriter->zMalloc );'), (121800, 1, u'+  assert( iIndex>=0 && iIndex<p->nIndex );'), (121857, 1, u'+  assert( iLevel>=0 || iLevel==FTS3_SEGCURSOR_ALL );'), (121899, 1, u'+  assert( iCol>=0 );'), (122000, 1, u'+          assert( (pMsr->aBuffer[nList] & 0xFE)==0x00 );'), (122064, 1, u'+  assert( pCsr->pFilter==0 );'), (122065, 1, u'+  assert( zTerm && nTerm>0 );'), (122087, 1, u'+  assert( iCol<0 || iCol<p->nColumn );'), (122108, 1, u'+  assert( pCsr->zTerm==0 );'), (122109, 1, u'+  assert( pCsr->nTerm==0 );'), (122110, 1, u'+  assert( pCsr->aDoclist==0 );'), (122111, 1, u'+  assert( pCsr->nDoclist==0 );'), (122161, 1, u'+    assert( rc==SQLITE_OK );'), (122192, 1, u'+    assert( isIgnoreEmpty || (isRequirePos && !isColFilter) );'), (122247, 1, u'+          assert( iDelta>0 || (nDoclist==0 && iDelta==iDocid) );'), (122248, 1, u'+          assert( nDoclist>0 || iDelta==iDocid );'), (122321, 1, u'+  assert( iLevel==FTS3_SEGCURSOR_ALL'), (122325, 1, u'+  assert( iLevel<FTS3_SEGDIR_MAXLEVEL );'), (122326, 1, u'+  assert( iIndex>=0 && iIndex<p->nIndex );'), (122355, 1, u'+  assert( csr.nSegment>0 );'), (122356, 1, u'+  assert( iNewLevel>=(iIndex*FTS3_SEGDIR_MAXLEVEL) );'), (122357, 1, u'+  assert( iNewLevel<((iIndex+1)*FTS3_SEGDIR_MAXLEVEL) );'), (122371, 1, u'+  assert( pWriter );'), (122430, 1, u'+    assert(j<=nBuf);'), (122643, 1, u'+    assert( pCsr->isRequireSeek==0 );'), (122729, 1, u'+  assert( pToken->pDeferred==0 );'), (122789, 1, u'+  assert( p->pSegments==0 );'), (122863, 1, u'+    assert( sqlite3_value_type(apVal[0])==SQLITE_INTEGER );'), (123067, 1, u'+    assert( pExpr->pLeft && pExpr->pRight );'), (123249, 1, u'+        assert( iCsr>=iStart );'), (123295, 1, u'+    assert( pPhrase->pList==0 && pPhrase->pHead==0 && pPhrase->pTail==0 );'), (123379, 1, u'+    assert( iScore>=0 );'), (123501, 1, u'+      assert( nShift<=nDesired );'), (123743, 1, u'+      assert( cArg==FTS3_MATCHINFO_HITS );'), (123766, 1, u'+  assert( sqlite3_data_count(pStmt)==1 );'), (123996, 1, u'+        assert( zArg[i]==FTS3_MATCHINFO_HITS );'), (124042, 1, u'+    assert( pCsr->aMatchinfo );'), (124169, 1, u'+    assert( (mCovered&mSeen)==mCovered );'), (124173, 1, u'+  assert( nFToken>0 );'), (124224, 1, u'+    assert( iPos>=0 );'), (124260, 1, u'+  assert( pCsr->isRequireSeek==0 );'), (124333, 1, u'+        assert( iCurrent<=iMinPos );'), (124363, 1, u'+  assert( rc!=SQLITE_DONE );'), (124774, 1, u'+  assert( sizeof(RtreeCoord)==4 );'), (124775, 1, u'+  assert( sizeof(u32)==4 );'), (124838, 1, u'+  assert( pNode->pNext==0 );'), (124851, 1, u'+    for( ; (*pp)!=pNode; pp = &(*pp)->pNext){ assert(*pp); }'), (124895, 1, u'+    assert( !pParent || !pNode->pParent || pNode->pParent==pParent );'), (125014, 1, u'+  assert( nCell<=nMaxCell );'), (125057, 1, u'+    assert( pNode->nRef>0 );'), (125086, 1, u'+  assert( iCell<NCELL(pNode) );'), (125291, 1, u'+  assert( pConstraint->op==RTREE_MATCH );'), (125292, 1, u'+  assert( pConstraint->pGeom );'), (125321, 1, u'+    assert(p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE'), (125339, 1, u'+        assert( p->op==RTREE_MATCH );'), (125373, 1, u'+    assert(p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE'), (125384, 1, u'+        assert( p->op==RTREE_MATCH );'), (125423, 1, u'+  assert( iHeight>=0 );'), (125452, 1, u'+    assert( pCursor->pNode==pChild );'), (125510, 1, u'+  assert( pCsr->pNode );'), (125550, 1, u'+  assert(pCsr->pNode);'), (125572, 1, u'+      assert( pRtree->eCoordType==RTREE_COORD_INT32 );'), (125674, 1, u'+      assert( rc==SQLITE_OK );'), (125688, 1, u'+        assert( (idxStr==0 && argc==0) || (int)strlen(idxStr)==argc*2 );'), (125718, 1, u'+        assert( pCsr->pNode==pRoot );'), (125725, 1, u'+        assert( pCsr->pNode==pRoot );'), (125729, 1, u'+      assert( rc!=SQLITE_OK || !pCsr->pNode || pCsr->iCell<NCELL(pCsr->pNode) );'), (125780, 1, u'+  assert( pIdxInfo->idxStr==0 );'), (125813, 1, u'+          assert( p->op==SQLITE_INDEX_CONSTRAINT_MATCH );'), (125829, 1, u'+  assert( iIdx>=0 );'), (125922, 1, u'+    assert( iExclude==-1 );'), (126328, 1, u'+        assert( left<=right );'), (126395, 1, u'+        assert( xleft1<=xright1 && (xleft1<xright1 || xleft2<=xright2) );'), (126763, 1, u'+  assert( pNode->nRef==1 );'), (126852, 1, u'+  assert( pParent || pNode->iNode==1 );'), (127144, 1, u'+  assert(nData>=1);'), (127161, 1, u'+    assert( nData==(pRtree->nDim*2 + 3) );'), (127783, 1, u'+    assert(uPattern!=0);'), (127967, 1, u'+      assert(!pExpr);'), (128033, 1, u'+  assert(nArg==1 || nArg==2);'), (128092, 1, u'+  assert(!"Unexpected return value from ucol_strcoll()");'), (128121, 1, u'+  assert(nArg==2);'), (128134, 1, u'+  assert(p);'), (128401, 1, u'+    assert(iStart<=iEnd);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(46, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSCallbackFunction);'), (49, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(35, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSCallbackObject<JSObjectWithGlobalObject>);'), (36, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSCallbackObject<JSGlobalObject>);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 1, u'+    ASSERT(obj->inherits(&JSCallbackObject<JSGlobalObject>::s_info) || obj->inherits(&JSCallbackObject<JSObjectWithGlobalObject>::s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+    ASSERT(diff >= 1);'), (46, 1, u'+        ASSERT(diff <= 0xfff);'), (129, 1, u'+    ASSERT((imm & 0xff) == 0);'), (296, 1, u'+    ASSERT(scale >= 0 && scale <= 3);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 1, u'+    ASSERT(address.scale >= 0 && address.scale <= 3);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(137, 1, u'+    ASSERT_NOT_REACHED();'), (222, 1, u'+    ASSERT_NOT_REACHED();'), (274, 1, u'+        ASSERT_NOT_REACHED();'), (328, 1, u'+    ASSERT(vPC[0].u.opcode == interpreter->getOpcode(op_get_by_id_generic) || vPC[0].u.opcode == interpreter->getOpcode(op_put_by_id_generic) || vPC[0].u.opcode == interpreter->getOpcode(op_call) || vPC[0].u.opcode == interpreter->getOpcode(op_call_eval) || vPC[0].u.opcode == interpreter->getOpcode(op_construct));'), (457, 1, u'+                ASSERT(!((i + m_rareData->m_characterSwitchJumpTables[i].min) & ~0xFFFF));'), (1385, 1, u'+    ASSERT(m_source);'), (1450, 1, u'+    ASSERT(vPC[0].u.opcode == interpreter->getOpcode(op_get_by_id) || vPC[0].u.opcode == interpreter->getOpcode(op_put_by_id) || vPC[0].u.opcode == interpreter->getOpcode(op_get_by_id_generic) || vPC[0].u.opcode == interpreter->getOpcode(op_put_by_id_generic) || vPC[0].u.opcode == interpreter->getOpcode(op_get_array_length) || vPC[0].u.opcode == interpreter->getOpcode(op_get_string_length));'), (1493, 1, u'+            ASSERT(!!m_methodCallLinkInfos[i].cachedPrototypeStructure);'), (1502, 1, u'+    ASSERT(bytecodeOffset < m_instructionCount);'), (1520, 1, u'+    ASSERT(bytecodeOffset < m_instructionCount);'), (1544, 1, u'+    ASSERT(bytecodeOffset < m_instructionCount);'), (1565, 1, u'+    ASSERT(low);'), (1654, 1, u'+    ASSERT(codeType() == FunctionCode);'), (1655, 1, u'+    ASSERT(needsFullScopeChain());'), (1656, 1, u'+    ASSERT(!callFrame->uncheckedR(activationRegister()).jsValue());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(145, 1, u'+    ASSERT(!s_running);'), (154, 1, u'+    ASSERT(s_running);'), (201, 1, u'+        ASSERT(record);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(62, 1, u'+        ASSERT_NOT_REACHED();'), (107, 1, u'+        ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(372, 1, u'+        ASSERT_UNUSED(unmodifiedArgumentsRegister, unmodifiedArgumentsRegister->index() == JSC::unmodifiedArgumentsRegister(codeBlock->argumentsRegister()));'), (596, 1, u'+    ASSERT(willResolveToArguments(propertyNames().arguments));'), (599, 1, u'+    ASSERT(!entry.isNull());'), (692, 1, u'+        ASSERT(lastLabelIndex <= newLabelIndex);'), (710, 1, u'+    ASSERT(opcodePosition - m_lastOpcodePosition == opcodeLength(m_lastOpcodeID) || m_lastOpcodeID == op_end);'), (719, 1, u'+    ASSERT(instructions().size() >= 4);'), (728, 1, u'+    ASSERT(instructions().size() >= 3);'), (736, 1, u'+    ASSERT(instructions().size() >= 4);'), (743, 1, u'+    ASSERT(instructions().size() >= 3);'), (1143, 1, u'+            ASSERT((++iter) == m_scopeChain->end());'), (1413, 1, u'+    ASSERT(base->index() == m_codeBlock->argumentsRegister());'), (1492, 1, u'+    ASSERT(base->index() == m_codeBlock->argumentsRegister());'), (1562, 1, u'+        ASSERT(argv.size() == 1 || argv[argv.size() - 1]->index() == argv[argv.size() - 2]->index() + 1);'), (1655, 1, u'+    ASSERT(opcodeID == op_call || opcodeID == op_call_eval);'), (1656, 1, u'+    ASSERT(func->refCount());'), (1702, 1, u'+    ASSERT(argCountDst->index() < arguments->index());'), (1712, 1, u'+    ASSERT(func->refCount());'), (1713, 1, u'+    ASSERT(thisRegister->refCount());'), (1714, 1, u'+    ASSERT(dst != func);'), (1771, 1, u'+    ASSERT(func->refCount());'), (1835, 1, u'+    ASSERT(scope->isTemporary());'), (1846, 1, u'+    ASSERT(m_scopeContextStack.size());'), (1847, 1, u'+    ASSERT(!m_scopeContextStack.last().isFinallyBlock);'), (1882, 1, u'+    ASSERT(m_scopeContextStack.size());'), (1883, 1, u'+    ASSERT(m_scopeContextStack.last().isFinallyBlock);'), (1884, 1, u'+    ASSERT(m_finallyDepth > 0);'), (1914, 1, u'+                ASSERT(scope->breakTarget());'), (1924, 1, u'+            ASSERT(scope->breakTarget());'), (1944, 1, u'+                ASSERT(scope->continueTarget());'), (1957, 1, u'+            ASSERT(scope->continueTarget());'), (2011, 1, u'+    ASSERT(scopeDepth() - targetScopeDepth >= 0);'), (2012, 1, u'+    ASSERT(target->isForward());'), (2015, 1, u'+    ASSERT(scopeDelta <= m_scopeContextStack.size());'), (2122, 1, u'+            ASSERT_NOT_REACHED();'), (2134, 1, u'+    ASSERT(node->isNumber());'), (2137, 1, u'+    ASSERT(key == value);'), (2138, 1, u'+    ASSERT(key >= min);'), (2139, 1, u'+    ASSERT(key <= max);'), (2151, 1, u'+        ASSERT(!labels[i]->isForward());'), (2159, 1, u'+    ASSERT(node->isString());'), (2161, 1, u'+    ASSERT(clause->length() == 1);'), (2164, 1, u'+    ASSERT(key >= min);'), (2165, 1, u'+    ASSERT(key <= max);'), (2177, 1, u'+        ASSERT(!labels[i]->isForward());'), (2187, 1, u'+        ASSERT(!labels[i]->isForward());'), (2189, 1, u'+        ASSERT(nodes[i]->isString());'), (2214, 1, u'+        ASSERT(switchInfo.switchType == SwitchInfo::SwitchString);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(46, 1, u'+#include <wtf/Assertions.h>'), (206, 1, u'+    ASSERT(!m_elision && !m_optional);'), (214, 1, u'+        ASSERT(!ptr->elision());'), (257, 1, u'+                ASSERT_NOT_REACHED();'), (304, 1, u'+    ASSERT(m_expr);'), (327, 1, u'+            ASSERT(m_argv[m_argv.size() - 1]->index() == m_argv[m_argv.size() - 2]->index() + 1);'), (473, 1, u'+                    ASSERT(m_args->m_listNode->m_next->m_expr->isSimpleArray());'), (474, 1, u'+                    ASSERT(!m_args->m_listNode->m_next->m_next);'), (495, 1, u'+            ASSERT(m_args->m_listNode && m_args->m_listNode->m_next);'), (822, 1, u'+    ASSERT(expr()->hasConditionContextCodegen());'), (861, 1, u'+    ASSERT(isAdd());'), (862, 1, u'+    ASSERT(resultDescriptor().definitelyIsString());'), (934, 1, u'+    ASSERT(temporaryRegisters.size() >= 3);'), (1136, 1, u'+            ASSERT_NOT_REACHED();'), (1287, 1, u'+    ASSERT(m_expressions.size() > 1);'), (1389, 1, u'+    ASSERT(m_expr);'), (1398, 1, u'+    ASSERT(m_expr);'), (1604, 1, u'+        ASSERT(m_lexpr->isBracketAccessorNode());'), (1635, 1, u'+    ASSERT(scope);'), (1649, 1, u'+    ASSERT(scope);'), (1660, 1, u'+    ASSERT(generator.codeType() == FunctionCode);'), (1769, 1, u'+    ASSERT(typeForTable == SwitchString);'), (1836, 1, u'+    ASSERT(i == labelVector.size());'), (1838, 1, u'+        ASSERT(labelVector.size() == literalVector.size());'), (1865, 1, u'+    ASSERT(!generator.breakTarget(m_name));')]
===========================================
Class:class Recompiler { class Recompiler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+    ASSERT(activation);'), (37, 1, u'+    ASSERT(activation->isActivationObject());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 1, u'+    ASSERT(result);')]
===========================================
Class:class ByteCodeParser { class ByteCodeParser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(89, 1, u'+            ASSERT(constant < m_constants.size());'), (123, 1, u'+            ASSERT(node.op == SetLocal);'), (146, 1, u'+        ASSERT(argument < m_numArguments);'), (154, 1, u'+            ASSERT(node.op == SetLocal);'), (167, 1, u'+        ASSERT(argument < m_numArguments);'), (216, 1, u'+            ASSERT(result.second == (result.first->second == NoNode));'), (249, 1, u'+            ASSERT(result.second == (result.first->second == NoNode));'), (324, 1, u'+        ASSERT(isInt32Constant(index));'), (329, 1, u'+        ASSERT(isDoubleConstant(index));'), (334, 1, u'+        ASSERT(isJSConstant(index));'), (352, 1, u'+            ASSERT(m_constants.size() == numberOfConstants);'), (355, 1, u'+            ASSERT(m_constants.size() == m_codeBlock->numberOfConstantRegisters());'), (359, 1, u'+        ASSERT(m_codeBlock->getConstant(FirstConstantRegisterIndex + m_constantUndefined).isUndefined());'), (377, 1, u'+            ASSERT(m_constants.size() == numberOfConstants);'), (380, 1, u'+            ASSERT(m_constants.size() == m_codeBlock->numberOfConstantRegisters());'), (384, 1, u'+        ASSERT(m_codeBlock->getConstant(FirstConstantRegisterIndex + m_constantNull).isNull());'), (402, 1, u'+            ASSERT(m_constants.size() == numberOfConstants);'), (405, 1, u'+            ASSERT(m_constants.size() == m_codeBlock->numberOfConstantRegisters());'), (409, 1, u'+        ASSERT(m_codeBlock->getConstant(FirstConstantRegisterIndex + m_constant1).isInt32());'), (410, 1, u'+        ASSERT(m_codeBlock->getConstant(FirstConstantRegisterIndex + m_constant1).asInt32() == 1);'), (1053, 1, u'+            ASSERT(m_graph[valueInPredecessor].op == SetLocal || m_graph[valueInPredecessor].op == Phi);'), (1091, 1, u'+        ASSERT(block->end != NoNode);'), (1093, 1, u'+        ASSERT(node.isTerminal());'), (1146, 1, u'+    ASSERT(!m_currentIndex);'), (1151, 1, u'+        ASSERT(m_currentIndex < limit);'), (1162, 1, u'+            ASSERT(m_currentIndex <= limit);'), (1169, 1, u'+    ASSERT(m_currentIndex == m_codeBlock->instructions().size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(150, 1, u'+        ASSERT(node.child2 == NoNode && node.child3 == NoNode);'), (156, 1, u'+        ASSERT(node.child3 == NoNode);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(58, 1, u'+                ASSERT(isJSConstant(nodeIndex));'), (63, 1, u'+            ASSERT(info.spillFormat() == DataFormatJS || info.spillFormat() == DataFormatJSInteger);'), (84, 1, u'+        ASSERT_NOT_REACHED();'), (89, 1, u'+        m_jit.jitAssertIsJSInt32(gpr);'), (97, 1, u'+        m_jit.jitAssertIsInt32(gpr);'), (103, 1, u'+    ASSERT_NOT_REACHED();'), (134, 1, u'+                ASSERT(isJSConstant(nodeIndex));'), (143, 1, u'+            ASSERT(spillFormat & DataFormatJS);'), (157, 1, u'+        ASSERT_NOT_REACHED();'), (167, 1, u'+        m_jit.jitAssertIsJSDouble(jsValueGpr);'), (222, 1, u'+    ASSERT_NOT_REACHED();'), (246, 1, u'+                ASSERT(isJSConstant(nodeIndex));'), (255, 1, u'+            ASSERT(spillFormat & DataFormatJS);'), (302, 1, u'+    ASSERT_NOT_REACHED();'), (310, 1, u'+        ASSERT(node.child2 == NoNode && node.child3 == NoNode);'), (317, 1, u'+        ASSERT(node.child3 == NoNode);'), (372, 1, u'+            ASSERT(info.gpr() != InvalidGPRReg);'), (416, 1, u'+            ASSERT(gpr != InvalidGPRReg);'), (425, 1, u'+            ASSERT(fpr != InvalidFPRReg);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+        ASSERT(node.op == DoubleConstant);'), (54, 1, u'+        jitAssertIsJSDouble(temporary);'), (70, 1, u'+        ASSERT(node.op == Int32Constant);'), (73, 1, u'+#if DFG_JIT_ASSERT'), (76, 1, u'+        jitAssertIsJSInt32(gpr);'), (95, 1, u'+            ASSERT(isJSConstant(nodeIndex));'), (107, 1, u'+    ASSERT(check.m_nodeIndex == entry.m_nodeIndex);'), (117, 1, u'+        ASSERT(recovery->type() == SpeculativeAdd);'), (138, 1, u'+        ASSERT(dataFormat == DataFormatInteger || DataFormatCell || dataFormat & DataFormatJS);'), (176, 1, u'+            ASSERT(dataFormat & DataFormatJS || dataFormat == DataFormatCell); // Treat cell as JSValue for now!'), (198, 1, u'+        ASSERT(checksIter->m_nodeIndex == entriesIter->m_nodeIndex);'), (202, 1, u'+            ASSERT(checksIter != checksEnd);'), (203, 1, u'+            ASSERT(entriesIter != entriesEnd);'), (215, 1, u'+    ASSERT(!(checksIter != checksEnd));'), (216, 1, u'+    ASSERT(!(entriesIter != entriesEnd));'), (382, 1, u'+#if DFG_JIT_ASSERT'), (383, 1, u'+void JITCompiler::jitAssertIsInt32(GPRReg gpr)'), (394, 1, u'+void JITCompiler::jitAssertIsJSInt32(GPRReg gpr)'), (401, 1, u'+void JITCompiler::jitAssertIsJSNumber(GPRReg gpr)'), (408, 1, u'+void JITCompiler::jitAssertIsJSDouble(GPRReg gpr)'), (437, 1, u'+    ASSERT(flag >= 1);'), (438, 1, u'+    ASSERT(flag <= 32);'), (444, 1, u'+    ASSERT(flag >= 1);'), (445, 1, u'+    ASSERT(flag <= 32);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(52, 1, u'+            ASSERT(info.registerFormat() == DataFormatDouble);'), (140, 1, u'+    ASSERT(isConstant(nodeIndex));'), (158, 1, u'+    ASSERT(isConstant(nodeIndex));'), (251, 1, u'+            ASSERT(shiftAmount);'), (292, 1, u'+        ASSERT(!isInt32Constant(node.child1));'), (311, 1, u'+        ASSERT(op != NumberToInt32);'), (321, 1, u'+        ASSERT(!isInt32Constant(node.child1));'), (322, 1, u'+        ASSERT(!isDoubleConstant(node.child1));'), (618, 1, u'+        ASSERT(GPRInfo::callFrameRegister != GPRInfo::regT1);'), (619, 1, u'+        ASSERT(GPRInfo::regT1 != GPRInfo::returnValueGPR);'), (620, 1, u'+        ASSERT(GPRInfo::returnValueGPR != GPRInfo::callFrameRegister);'), (644, 1, u'+        ASSERT_NOT_REACHED();'), (653, 1, u'+    ASSERT(m_compileIndex == block.begin);'), (684, 1, u'+    ASSERT(!m_compileIndex);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(218, 1, u'+    ASSERT(exceptionValue);'), (224, 1, u'+    ASSERT(catchRoutine);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 1, u'+            ASSERT(spillFormat & DataFormatJS);'), (137, 1, u'+    ASSERT_NOT_REACHED();'), (157, 1, u'+            ASSERT(info.registerFormat() == DataFormatDouble);'), (173, 1, u'+    ASSERT(mustBeDataFormatInteger == DataFormatInteger);'), (198, 1, u'+        ASSERT(info.spillFormat() & DataFormatJS);'), (232, 1, u'+    ASSERT_NOT_REACHED();'), (555, 1, u'+            ASSERT(node.adjustedRefCount() == 1);'), (583, 1, u'+            ASSERT(node.adjustedRefCount() == 1);'), (771, 1, u'+        ASSERT(GPRInfo::callFrameRegister != GPRInfo::regT1);'), (772, 1, u'+        ASSERT(GPRInfo::regT1 != GPRInfo::returnValueGPR);'), (773, 1, u'+        ASSERT(GPRInfo::returnValueGPR != GPRInfo::callFrameRegister);'), (866, 1, u'+        ASSERT_NOT_REACHED();'), (875, 1, u'+    ASSERT(m_compileIndex == block.begin);'), (904, 1, u'+    ASSERT(!m_compileIndex);'), (932, 1, u'+    ASSERT(!m_compileIndex);'), (944, 1, u'+    ASSERT(!m_compileIndex);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 1, u'+    ASSERT(begin <= end);'), (50, 1, u'+    ASSERT((static_cast<char*>(end) - static_cast<char*>(begin)) < 0x1000000);'), (51, 1, u'+    ASSERT(isPointerAligned(begin));'), (52, 1, u'+    ASSERT(isPointerAligned(end));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+        ASSERT(isValidWeakNode(node));'), (98, 1, u'+        ASSERT(isValidWeakNode(node));'), (119, 1, u'+    ASSERT(!m_nextToFinalize); // Forbid assignment to handles during the finalization phase, since it would violate many GC invariants.'), (151, 1, u'+#if !ASSERT_DISABLED')]
===========================================
Class:class TypeCounter { class TypeCounter 
Class:class MachineThreads::Thread { class MachineThreads::Thread 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+    ASSERT(s_pageSize);'), (59, 1, u'+    ASSERT(Heap::isMarked(cell));'), (66, 1, u'+        ASSERT(cell->isObject());'), (70, 1, u'+        ASSERT(!m_isCheckingForDefaultMarkViolation);'), (73, 1, u'+        ASSERT(m_isCheckingForDefaultMarkViolation);'), (87, 1, u'+#if !ASSERT_DISABLED'), (88, 1, u'+    ASSERT(!m_isDraining);'), (93, 1, u'+            ASSERT(!m_markSets.isEmpty());'), (95, 1, u'+            ASSERT(current.m_values);'), (97, 1, u'+            ASSERT(current.m_values);'), (98, 1, u'+            ASSERT(current.m_values != end);'), (100, 1, u'+            ASSERT(current.m_values != end);'), (130, 1, u'+#if !ASSERT_DISABLED')]
===========================================
Class:class Structure;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 1, u'+    ASSERT(iter != end);'), (131, 1, u'+    ASSERT(iter != end);'), (133, 1, u'+    ASSERT(skip || !checkTopLevel);'), (140, 1, u'+        ASSERT(iter != end);'), (151, 1, u'+            ASSERT(result);'), (165, 1, u'+    ASSERT(globalObject->isGlobalObject());'), (202, 1, u'+    ASSERT(globalObject->isGlobalObject());'), (211, 1, u'+    ASSERT(iter != end);'), (213, 1, u'+    ASSERT(skip || !checkTopLevel);'), (229, 1, u'+                    ASSERT(result);'), (246, 1, u'+        ASSERT(callFrame->uncheckedR(dst).jsValue());'), (257, 1, u'+            ASSERT(result);'), (265, 1, u'+        ASSERT(result);'), (283, 1, u'+        ASSERT(callFrame->uncheckedR(dst).jsValue());'), (300, 1, u'+    ASSERT(iter != end);'), (408, 1, u'+    ASSERT(!eval == exceptionValue);'), (661, 1, u'+            ASSERT(codeBlock->hasLineInfo());'), (708, 1, u'+    ASSERT(scopeDelta >= 0);'), (718, 1, u'+    ASSERT(returnValue);'), (724, 1, u'+    ASSERT(returnValue);'), (730, 1, u'+    ASSERT(!scopeChain->globalData->exception);'), (752, 1, u"+    ASSERT(codeBlock->m_numParameters == 1); // 1 parameter for 'this'."), (788, 1, u'+    ASSERT(!callFrame->hadException());'), (852, 1, u'+    ASSERT(callType == CallTypeHost);'), (878, 1, u'+    ASSERT(!callFrame->hadException());'), (940, 1, u'+        ASSERT(result.isObject());'), (944, 1, u'+    ASSERT(constructType == ConstructTypeHost);'), (967, 1, u'+    ASSERT(result.isObject());'), (973, 1, u'+    ASSERT(!scopeChain->globalData->exception);'), (1062, 1, u'+    ASSERT(!scopeChain->globalData->exception);'), (1076, 1, u'+        ASSERT(node);'), (1120, 1, u"+    ASSERT(codeBlock->m_numParameters == 1); // 1 parameter for 'this'."), (1259, 1, u'+        ASSERT(vPC[6].u.structureChain);'), (1350, 1, u'+        ASSERT(slot.slotBase().isObject());'), (1362, 1, u'+        ASSERT(!baseObject->structure()->isUncacheableDictionary());'), (1437, 1, u'+        ASSERT_NOT_REACHED();'), (1907, 1, u'+            ASSERT(result);'), (2141, 1, u'+        ASSERT(!isInvalidParamForInstanceOf(callFrame, baseVal, exceptionValue));'), (2348, 1, u'+        ASSERT(scope->isGlobalObject());'), (2361, 1, u'+        ASSERT(scope->isGlobalObject());'), (2382, 1, u'+        ASSERT(iter != end);'), (2383, 1, u'+        ASSERT(codeBlock == callFrame->codeBlock());'), (2385, 1, u'+        ASSERT(skip || !checkTopLevel);'), (2392, 1, u'+            ASSERT(iter != end);'), (2394, 1, u'+        ASSERT((*iter)->isVariableObject());'), (2397, 1, u'+        ASSERT(callFrame->r(dst).jsValue());'), (2412, 1, u'+        ASSERT(codeBlock == callFrame->codeBlock());'), (2413, 1, u'+        ASSERT(iter != end);'), (2415, 1, u'+        ASSERT(skip || !checkTopLevel);'), (2422, 1, u'+            ASSERT(iter != end);'), (2425, 1, u'+        ASSERT((*iter)->isVariableObject());'), (2427, 1, u'+        ASSERT(callFrame->r(value).jsValue());'), (2522, 1, u'+                ASSERT(baseCell->isObject());'), (2527, 1, u'+                ASSERT(baseObject->get(callFrame, codeBlock->identifier(vPC[3].u.operand)) == baseObject->getDirectOffset(offset));'), (2553, 1, u'+                ASSERT(structure->prototypeForLookup(callFrame).isObject());'), (2561, 1, u'+                    ASSERT(protoObject->get(callFrame, codeBlock->identifier(vPC[3].u.operand)) == protoObject->getDirectOffset(offset));'), (2562, 1, u'+                    ASSERT(baseValue.get(callFrame, codeBlock->identifier(vPC[3].u.operand)) == protoObject->getDirectOffset(offset));'), (2592, 1, u'+                ASSERT(structure->prototypeForLookup(callFrame).isObject());'), (2637, 1, u'+                ASSERT(structure->prototypeForLookup(callFrame).isObject());'), (2663, 1, u'+        ASSERT_NOT_REACHED();'), (2670, 1, u'+        ASSERT_NOT_REACHED();'), (2677, 1, u'+        ASSERT_NOT_REACHED();'), (2684, 1, u'+        ASSERT_NOT_REACHED();'), (2691, 1, u'+        ASSERT_NOT_REACHED();'), (2698, 1, u'+        ASSERT_NOT_REACHED();'), (2735, 1, u'+                        ASSERT(baseObject->get(callFrame, codeBlock->identifier(vPC[3].u.operand)) == baseObject->getDirectOffset(offset));'), (2736, 1, u'+                        ASSERT(baseValue.get(callFrame, codeBlock->identifier(vPC[3].u.operand)) == baseObject->getDirectOffset(offset));'), (2771, 1, u'+                ASSERT(baseCell->isObject());'), (2814, 1, u'+                ASSERT(baseCell->isObject());'), (3032, 1, u'+            ASSERT(slot.base() == baseValue);'), (3065, 1, u'+                ASSERT(baseCell->isObject());'), (3086, 1, u'+                ASSERT(baseObject->offsetForLocation(baseObject->getDirectLocation(*globalData, codeBlock->identifier(vPC[2].u.operand))) == offset);'), (3116, 1, u'+                ASSERT(baseCell->isObject());'), (3121, 1, u'+                ASSERT(baseObject->offsetForLocation(baseObject->getDirectLocation(*globalData, codeBlock->identifier(vPC[2].u.operand))) == offset);'), (3151, 1, u'+            ASSERT(slot.base() == baseValue);'), (3776, 1, u'+        ASSERT(codeBlock->codeType() != FunctionCode || !codeBlock->needsFullScopeChain() || callFrame->r(codeBlock->activationRegister()).jsValue());'), (3794, 1, u'+        ASSERT(codeBlock->codeType() != FunctionCode || !codeBlock->needsFullScopeChain() || callFrame->r(codeBlock->activationRegister()).jsValue());'), (3831, 1, u'+        ASSERT(codeBlock->codeType() != FunctionCode || !codeBlock->needsFullScopeChain() || callFrame->r(codeBlock->activationRegister()).jsValue());'), (3893, 1, u'+            ASSERT(codeBlock == callFrame->codeBlock());'), (3926, 1, u'+        ASSERT(callType == CallTypeNone);'), (3946, 1, u'+            ASSERT(!asFunction(callFrame->callee())->isHostFunction());'), (4052, 1, u'+            ASSERT(codeBlock == callFrame->codeBlock());'), (4084, 1, u'+        ASSERT(callType == CallTypeNone);'), (4102, 1, u'+        ASSERT(codeBlock->needsFullScopeChain());'), (4132, 1, u'+        ASSERT(!codeBlock->needsFullScopeChain() && codeBlock->ownerExecutable()->usesArguments());'), (4162, 1, u'+        ASSERT(codeBlock == callFrame->codeBlock());'), (4203, 1, u'+        ASSERT(codeBlock == callFrame->codeBlock());'), (4263, 1, u'+#if !ASSERT_DISABLED'), (4265, 1, u'+        ASSERT(constructor->getConstructData(constructData) == ConstructTypeJS);'), (4422, 1, u'+        ASSERT(constructType == ConstructTypeNone);'), (4590, 1, u'+        ASSERT(exceptionValue);'), (4591, 1, u'+        ASSERT(!globalData->exception);'), (4657, 1, u'+        ASSERT(callFrame->r(base).jsValue().isObject());'), (4660, 1, u'+        ASSERT(callFrame->r(function).jsValue().isObject());'), (4681, 1, u'+        ASSERT(callFrame->r(base).jsValue().isObject());'), (4684, 1, u'+        ASSERT(callFrame->r(function).jsValue().isObject());'), (4799, 1, u'+        ASSERT(codeBlock->codeType() == FunctionCode);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(97, 1, u'+    ASSERT(static_cast<long>(committedBytesCount) + byteCount > -1);')]
===========================================
Class:class AllocationTableSizeClass { class AllocationTableSizeClass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(178, 1, u'+        ASSERT_WITH_MESSAGE(m_interpreter->isOpcode(currentInstruction->u.opcode), "privateCompileMainPass gone bad @ %d", m_bytecodeOffset);'), (341, 1, u'+            ASSERT_NOT_REACHED();'), (345, 1, u'+    ASSERT(m_propertyAccessInstructionIndex == m_codeBlock->numberOfStructureStubInfos());'), (346, 1, u'+    ASSERT(m_callLinkInfoIndex == m_codeBlock->numberOfCallLinkInfos());'), (439, 1, u'+            ASSERT_NOT_REACHED();'), (442, 1, u'+        ASSERT_WITH_MESSAGE(iter == m_slowCases.end() || firstTo != iter->to,"Not enough jumps linked in slow case codegen.");'), (443, 1, u'+        ASSERT_WITH_MESSAGE(firstTo == (iter - 1)->to, "Too many jumps linked in slow case codegen.");'), (449, 1, u'+    ASSERT(m_propertyAccessInstructionIndex == m_codeBlock->numberOfStructureStubInfos());'), (451, 1, u'+    ASSERT(m_callLinkInfoIndex == m_codeBlock->numberOfCallLinkInfos());'), (513, 1, u'+    ASSERT(m_jmpTable.isEmpty());'), (523, 1, u'+            ASSERT(record.type == SwitchRecord::Immediate || record.type == SwitchRecord::Character);'), (524, 1, u'+            ASSERT(record.jumpTable.simpleJumpTable->branchOffsets.size() == record.jumpTable.simpleJumpTable->ctiOffsets.size());'), (533, 1, u'+            ASSERT(record.type == SwitchRecord::String);'), (603, 1, u'+        ASSERT(!callLinkInfo->isLinked());'), (620, 1, u'+        ASSERT(!callLinkInfo->isLinked());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(882, 1, u'+    ASSERT(regT0 == X86Registers::eax);'), (883, 1, u'+    ASSERT(regT1 == X86Registers::edx);'), (884, 1, u'+    ASSERT(regT2 == X86Registers::ecx);'), (939, 1, u'+    ASSERT_NOT_REACHED();'), (959, 1, u'+        ASSERT(opcodeID == op_mul);'), (969, 1, u'+    COMPILE_ASSERT(((TagTypeNumber + DoubleEncodeOffset) == 0), TagTypeNumber_PLUS_DoubleEncodeOffset_EQUALS_0);'), (1045, 1, u'+        ASSERT(opcodeID == op_div);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(1018, 1, u'+        ASSERT(op1IsInRegisters);'), (1079, 1, u'+                ASSERT_NOT_REACHED();'), (1090, 1, u'+        ASSERT(op2IsInRegisters);'), (1140, 1, u'+                ASSERT_NOT_REACHED();'), (1306, 1, u'+    ASSERT(regT0 == X86Registers::eax);'), (1307, 1, u'+    ASSERT(regT1 == X86Registers::edx);'), (1308, 1, u'+    ASSERT(regT2 == X86Registers::ecx);'), (1309, 1, u'+    ASSERT(regT3 == X86Registers::ebx);'), (1413, 1, u'+    ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(195, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(addressOfLinkedFunctionCheck, jumpToSlow), patchOffsetOpCallCompareToJump);'), (240, 1, u'+    ASSERT(OPCODE_LENGTH(op_call) == OPCODE_LENGTH(op_call_eval));'), (241, 1, u'+    ASSERT(OPCODE_LENGTH(op_call) == OPCODE_LENGTH(op_construct));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(274, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(addressOfLinkedFunctionCheck, jumpToSlow), patchOffsetOpCallCompareToJump);'), (324, 1, u'+    ASSERT(OPCODE_LENGTH(op_call) == OPCODE_LENGTH(op_call_eval));'), (325, 1, u'+    ASSERT(OPCODE_LENGTH(op_call) == OPCODE_LENGTH(op_construct));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(66, 1, u'+    COMPILE_ASSERT(sizeof(CodeType) == 4, CodeTypeEnumMustBe32Bit);'), (330, 1, u'+    ASSERT(returnValueRegister != callFrameRegister);'), (470, 1, u'+    ASSERT(skip || !checkTopLevel);'), (494, 1, u'+    ASSERT(skip || !checkTopLevel);'), (537, 1, u'+    ASSERT(callFrameRegister != regT1);'), (538, 1, u'+    ASSERT(regT1 != returnValueRegister);'), (539, 1, u'+    ASSERT(returnValueRegister != callFrameRegister);'), (557, 1, u'+    ASSERT(callFrameRegister != regT1);'), (558, 1, u'+    ASSERT(regT1 != returnValueRegister);'), (559, 1, u'+    ASSERT(returnValueRegister != callFrameRegister);'), (866, 1, u'+    ASSERT(regT0 == returnValueRegister);'), (1613, 1, u'+    ASSERT(skip || !checkTopLevel);'), (1665, 1, u'+    ASSERT(argsOffset <= registerOffset);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(491, 1, u'+    ASSERT(returnValueRegister != callFrameRegister);'), (649, 1, u'+    ASSERT(globalObject->isGlobalObject());'), (662, 1, u'+    ASSERT(globalObject->isGlobalObject());'), (681, 1, u'+    ASSERT(skip || !checkTopLevel);'), (710, 1, u'+    ASSERT(skip || !checkTopLevel);'), (898, 1, u'+    ASSERT((JSValue::BooleanTag + 1 == JSValue::Int32Tag) && !(JSValue::Int32Tag + 1));'), (934, 1, u'+    ASSERT((JSValue::BooleanTag + 1 == JSValue::Int32Tag) && !(JSValue::Int32Tag + 1));'), (981, 1, u'+    ASSERT((JSValue::UndefinedTag + 1 == JSValue::NullTag) && (JSValue::NullTag & 0x1));'), (1006, 1, u'+    ASSERT((JSValue::UndefinedTag + 1 == JSValue::NullTag) && (JSValue::NullTag & 0x1));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(265, 1, u'+void JIT::emitSlow_op_method_check(Instruction*, Vector<SlowCaseEntry>::iterator&) { ASSERT_NOT_REACHED(); }'), (287, 1, u'+    ASSERT_NOT_REACHED();'), (310, 1, u'+    ASSERT_NOT_REACHED();'), (322, 1, u'+    ASSERT(m_interpreter->getOpcodeID((currentInstruction + OPCODE_LENGTH(op_method_check))->u.opcode) == op_get_by_id);'), (350, 1, u'+    ASSERT_JIT_OFFSET_UNUSED(protoObj, differenceBetween(info.structureToCompare, protoObj), patchOffsetMethodCheckProtoObj);'), (351, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(info.structureToCompare, protoStructureToCompare), patchOffsetMethodCheckProtoStruct);'), (352, 1, u'+    ASSERT_JIT_OFFSET_UNUSED(putFunction, differenceBetween(info.structureToCompare, putFunction), patchOffsetMethodCheckPutFunction);'), (387, 1, u'+void JIT::emitSlow_op_method_check(Instruction*, Vector<SlowCaseEntry>::iterator&) { ASSERT_NOT_REACHED(); }'), (419, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(hotPathBegin, structureToCompare), patchOffsetGetByIdStructure);'), (420, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(hotPathBegin, structureCheck), patchOffsetGetByIdBranchToSlowCase)'), (424, 1, u'+    ASSERT_JIT_OFFSET_UNUSED(displacementLabel, differenceBetween(hotPathBegin, displacementLabel), patchOffsetGetByIdPropertyMapOffset);'), (430, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(hotPathBegin, putResult), patchOffsetGetByIdPutResult);'), (465, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(coldPathBegin, call), patchOffsetGetByIdSlowCaseCall);'), (496, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(hotPathBegin, structureToCompare), patchOffsetPutByIdStructure);'), (503, 1, u'+    ASSERT_JIT_OFFSET_UNUSED(displacementLabel, differenceBetween(hotPathBegin, displacementLabel), patchOffsetPutByIdPropertyMapOffset);'), (599, 1, u'+    ASSERT(!failureCases.empty());'), (609, 1, u'+        ASSERT(m_calls.size() == 1);'), (638, 1, u'+    ASSERT(!methodCallLinkInfo.cachedStructure);'), (886, 1, u'+    ASSERT(count);'), (901, 1, u'+    ASSERT(protoObject);'), (954, 1, u'+    ASSERT(count);'), (969, 1, u'+    ASSERT(protoObject);'), (1031, 1, u'+    ASSERT(prototype.isCell());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(110, 1, u'+void JIT::emitSlow_op_method_check(Instruction*, Vector<SlowCaseEntry>::iterator&) { ASSERT_NOT_REACHED(); }'), (129, 1, u'+    ASSERT_NOT_REACHED();'), (147, 1, u'+    ASSERT_NOT_REACHED();'), (167, 1, u'+    ASSERT_NOT_REACHED();'), (188, 1, u'+    ASSERT_NOT_REACHED();'), (200, 1, u'+    ASSERT(m_interpreter->getOpcodeID((currentInstruction + OPCODE_LENGTH(op_method_check))->u.opcode) == op_get_by_id);'), (228, 1, u'+    ASSERT_JIT_OFFSET_UNUSED(protoObj, differenceBetween(info.structureToCompare, protoObj), patchOffsetMethodCheckProtoObj);'), (229, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(info.structureToCompare, protoStructureToCompare), patchOffsetMethodCheckProtoStruct);'), (230, 1, u'+    ASSERT_JIT_OFFSET_UNUSED(putFunction, differenceBetween(info.structureToCompare, putFunction), patchOffsetMethodCheckPutFunction);'), (266, 1, u'+void JIT::emitSlow_op_method_check(Instruction*, Vector<SlowCaseEntry>::iterator&) { ASSERT_NOT_REACHED(); }'), (434, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(hotPathBegin, structureToCompare), patchOffsetGetByIdStructure);'), (435, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(hotPathBegin, structureCheck), patchOffsetGetByIdBranchToSlowCase);'), (439, 1, u'+    ASSERT_JIT_OFFSET_UNUSED(displacementLabel1, differenceBetween(hotPathBegin, displacementLabel1), patchOffsetGetByIdPropertyMapOffset1);'), (441, 1, u'+    ASSERT_JIT_OFFSET_UNUSED(displacementLabel2, differenceBetween(hotPathBegin, displacementLabel2), patchOffsetGetByIdPropertyMapOffset2);'), (444, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(hotPathBegin, putResult), patchOffsetGetByIdPutResult);'), (480, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(coldPathBegin, call), patchOffsetGetByIdSlowCaseCall);'), (509, 1, u'+    ASSERT_JIT_OFFSET(differenceBetween(hotPathBegin, structureToCompare), patchOffsetPutByIdStructure);'), (517, 1, u'+    ASSERT_JIT_OFFSET_UNUSED(displacementLabel1, differenceBetween(hotPathBegin, displacementLabel1), patchOffsetPutByIdPropertyMapOffset1);'), (518, 1, u'+    ASSERT_JIT_OFFSET_UNUSED(displacementLabel2, differenceBetween(hotPathBegin, displacementLabel2), patchOffsetPutByIdPropertyMapOffset2);'), (622, 1, u'+    ASSERT(!failureCases.empty());'), (632, 1, u'+        ASSERT(m_calls.size() == 1);'), (662, 1, u'+    ASSERT(!methodCallLinkInfo.cachedStructure);'), (918, 1, u'+    ASSERT(count);'), (933, 1, u'+    ASSERT(protoObject);'), (986, 1, u'+    ASSERT(count);'), (1001, 1, u'+    ASSERT(protoObject);'), (1056, 1, u'+    ASSERT(sizeof(JSValue) == 8);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, code) % 16 == 0x0, JITStackFrame_maintains_16byte_stack_alignment);'), (118, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, savedEBX) == 0x3c, JITStackFrame_stub_argument_space_matches_ctiTrampoline);'), (119, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, callFrame) == 0x58, JITStackFrame_callFrame_offset_matches_ctiTrampoline);'), (120, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, code) == 0x50, JITStackFrame_code_offset_matches_ctiTrampoline);'), (169, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, code) % 32 == 0x0, JITStackFrame_maintains_32byte_stack_alignment);'), (170, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, savedRBX) == 0x48, JITStackFrame_stub_argument_space_matches_ctiTrampoline);'), (171, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, callFrame) == 0x90, JITStackFrame_callFrame_offset_matches_ctiTrampoline);'), (172, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, code) == 0x80, JITStackFrame_code_offset_matches_ctiTrampoline);'), (247, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, code) % 16 == 0x0, JITStackFrame_maintains_16byte_stack_alignment);'), (248, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, savedEBX) == 0x3c, JITStackFrame_stub_argument_space_matches_ctiTrampoline);'), (249, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, callFrame) == 0x58, JITStackFrame_callFrame_offset_matches_ctiTrampoline);'), (250, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, code) == 0x50, JITStackFrame_code_offset_matches_ctiTrampoline);'), (400, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, callFrame) == 0x58, JITStackFrame_callFrame_offset_matches_ctiTrampoline);'), (401, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, code) == 0x48, JITStackFrame_code_offset_matches_ctiTrampoline);'), (402, 1, u'+COMPILE_ASSERT(offsetof(struct JITStackFrame, savedRBX) == 0x78, JITStackFrame_stub_argument_space_matches_ctiTrampoline);'), (761, 1, u'+    ASSERT(m_executablePool);'), (766, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedReturnAddress) == PRESERVED_RETURN_ADDRESS_OFFSET);'), (767, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedR4) == PRESERVED_R4_OFFSET);'), (768, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedR5) == PRESERVED_R5_OFFSET);'), (769, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedR6) == PRESERVED_R6_OFFSET);'), (771, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, registerFile) == REGISTER_FILE_OFFSET);'), (772, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, callFrame) == CALLFRAME_OFFSET);'), (774, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, enabledProfilerReference) == ENABLE_PROFILER_REFERENCE_OFFSET);'), (776, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, thunkReturnAddress) == THUNK_RETURN_ADDRESS_OFFSET);'), (780, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, thunkReturnAddress) == THUNK_RETURN_ADDRESS_OFFSET);'), (781, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedR4) == PRESERVEDR4_OFFSET);'), (785, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedGP) == PRESERVED_GP_OFFSET);'), (786, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedS0) == PRESERVED_S0_OFFSET);'), (787, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedS1) == PRESERVED_S1_OFFSET);'), (788, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedS2) == PRESERVED_S2_OFFSET);'), (789, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, preservedReturnAddress) == PRESERVED_RETURN_ADDRESS_OFFSET);'), (790, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, thunkReturnAddress) == THUNK_RETURN_ADDRESS_OFFSET);'), (791, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, registerFile) == REGISTER_FILE_OFFSET);'), (792, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, callFrame) == CALLFRAME_OFFSET);'), (793, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, unused1) == EXCEPTION_OFFSET);'), (794, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, enabledProfilerReference) == ENABLE_PROFILER_REFERENCE_OFFSET);'), (795, 1, u'+    ASSERT(OBJECT_OFFSETOF(struct JITStackFrame, globalData) == GLOBAL_DATA_OFFSET);'), (913, 1, u'+        ASSERT(slot.slotBase().isObject());'), (927, 1, u'+        ASSERT(!structure->isDictionary());'), (928, 1, u'+        ASSERT(!slotBaseObject->structure()->isDictionary());'), (995, 1, u'+    ASSERT(globalData->exception);'), (1040, 1, u'+    ASSERT(exceptionValue);'), (1048, 1, u'+    ASSERT(catchRoutine);'), (1264, 1, u'+#if !ASSERT_DISABLED'), (1266, 1, u'+    ASSERT(constructor->getConstructData(constructData) == ConstructTypeJS);'), (1298, 1, u'+    ASSERT(v1.asCell()->structure()->typeInfo().needsThisConversion());'), (1504, 1, u'+    ASSERT(baseValue.isObject());'), (1534, 1, u'+    ASSERT(!slot.isCacheableValue() || slot.slotBase().isObject());'), (1559, 1, u'+        ASSERT(result == JSValue(callee));'), (1626, 1, u'+        ASSERT(slot.slotBase().isObject());'), (1632, 1, u'+            ASSERT(!stubInfo->stubRoutine);'), (1674, 1, u'+        ASSERT_NOT_REACHED();'), (1677, 1, u'+    ASSERT(listIndex <= POLYMORPHIC_LIST_CACHE_SIZE);'), (1734, 1, u'+    ASSERT(slot.slotBase().isObject());'), (1742, 1, u'+        ASSERT(!baseValue.asCell()->structure()->isDictionary());'), (1759, 1, u'+        ASSERT(!baseValue.asCell()->structure()->isDictionary());'), (1837, 1, u'+    ASSERT(!baseVal.isObject() || !(typeInfo = asObject(baseVal)->structure()->typeInfo()).implementsHasInstance());'), (1853, 1, u'+    ASSERT(!value.isCell() || !baseVal.isCell() || !proto.isCell()'), (1865, 1, u'+    ASSERT(typeInfo.type() != UnspecifiedType);'), (1922, 1, u'+    ASSERT(stackFrame.callFrame->codeBlock()->codeType() != FunctionCode || !stackFrame.callFrame->codeBlock()->needsFullScopeChain() || stackFrame.callFrame->uncheckedR(stackFrame.callFrame->codeBlock()->activationRegister()).jsValue());'), (1930, 1, u'+#if !ASSERT_DISABLED'), (1932, 1, u'+    ASSERT(stackFrame.callFrame->callee()->getCallData(callData) == CallTypeJS);'), (1936, 1, u'+    ASSERT(!function->isHostFunction());'), (1951, 1, u'+#if !ASSERT_DISABLED'), (1953, 1, u'+    ASSERT(asFunction(stackFrame.callFrame->callee())->getConstructData(constructData) == ConstructTypeJS);'), (1957, 1, u'+    ASSERT(!function->isHostFunction());'), (1974, 1, u'+    ASSERT(!callee->isHostFunction());'), (1979, 1, u'+    ASSERT(argCount != newCodeBlock->m_numParameters);'), (2023, 1, u'+    ASSERT((void*)callFrame <= stackFrame.registerFile->end());'), (2033, 1, u'+    ASSERT(!callee->isHostFunction());'), (2038, 1, u'+    ASSERT(argCount != newCodeBlock->m_numParameters);'), (2082, 1, u'+    ASSERT((void*)callFrame <= stackFrame.registerFile->end());'), (2174, 1, u'+    ASSERT(callType != CallTypeJS);'), (2198, 1, u'+    ASSERT(callType == CallTypeNone);'), (2224, 1, u'+    ASSERT(stackFrame.callFrame->codeBlock()->needsFullScopeChain());'), (2245, 1, u'+    ASSERT(stackFrame.callFrame->codeBlock()->usesArguments() && !stackFrame.callFrame->codeBlock()->needsFullScopeChain());'), (2253, 1, u'+    ASSERT(*stackFrame.enabledProfilerReference);'), (2261, 1, u'+    ASSERT(*stackFrame.enabledProfilerReference);'), (2282, 1, u'+    ASSERT(iter != end);'), (2308, 1, u'+    ASSERT(constructType != ConstructTypeJS);'), (2332, 1, u'+    ASSERT(constructType == ConstructTypeNone);'), (2693, 1, u'+    ASSERT(stackFrame.callFrame->codeBlock()->isStrictMode());'), (2713, 1, u'+    ASSERT(iter != end);'), (2716, 1, u'+    ASSERT(skip || !checkTopLevel);'), (2723, 1, u'+        ASSERT(iter != end);'), (2749, 1, u'+    ASSERT(globalObject->isGlobalObject());'), (2972, 1, u'+    ASSERT(string1->isString());'), (2973, 1, u'+    ASSERT(string2->isString());'), (2977, 1, u'+    ASSERT_NOT_REACHED();'), (3002, 1, u'+    ASSERT(!src1.isInt32() || !src2.isInt32());'), (3029, 1, u'+    ASSERT(!src.isInt32());'), (3048, 1, u'+    ASSERT(iter != end);'), (3077, 1, u'+    ASSERT(callFrame->codeBlock()->codeType() != FunctionCode || !callFrame->codeBlock()->needsFullScopeChain() || callFrame->uncheckedR(callFrame->codeBlock()->activationRegister()).jsValue());'), (3192, 1, u'+    ASSERT(stackFrame.callFrame->codeBlock()->codeType() != FunctionCode || !stackFrame.callFrame->codeBlock()->needsFullScopeChain() || stackFrame.callFrame->uncheckedR(stackFrame.callFrame->codeBlock()->activationRegister()).jsValue());'), (3522, 1, u'+    ASSERT(stackFrame.args[0].jsValue().isObject());'), (3524, 1, u'+    ASSERT(stackFrame.args[2].jsValue().isObject());'), (3534, 1, u'+    ASSERT(stackFrame.args[0].jsValue().isObject());'), (3536, 1, u'+    ASSERT(stackFrame.args[2].jsValue().isObject());')]
===========================================
Class: class StopWatch { class StopWatch 
Class: class GlobalObject : public JSGlobalObject { class GlobalObject : public JSGlobalObject 
Class:class JSParser { class JSParser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+#include <wtf/Assertions.h>'), (238, 1, u'+    ASSERT(m_code <= m_codeEnd);'), (271, 1, u'+    ASSERT(currentOffset() == source.startOffset());'), (277, 1, u'+    ASSERT(m_current != -1);'), (287, 1, u'+    ASSERT(offset > 0 && offset < 5);'), (311, 1, u'+    ASSERT(isLineTerminator(m_current));'), (385, 1, u'+    ASSERT(c >= 0);'), (386, 1, u'+    ASSERT(c <= 0xFF);'), (397, 1, u'+    ASSERT(c >= 0);'), (398, 1, u'+    ASSERT(c <= USHRT_MAX);'), (717, 1, u'+    ASSERT(!m_error);'), (718, 1, u'+    ASSERT(m_buffer8.isEmpty());'), (719, 1, u'+    ASSERT(m_buffer16.isEmpty());'), (1035, 1, u'+        ASSERT(isIdentStart(m_current));'), (1041, 1, u'+        ASSERT(isLineTerminator(m_current));'), (1049, 1, u'+        ASSERT_NOT_REACHED();'), (1086, 1, u'+    ASSERT(m_buffer16.isEmpty());'), (1092, 1, u'+        ASSERT(!isLineTerminator(patternPrefix));'), (1093, 1, u"+        ASSERT(patternPrefix != '/');"), (1094, 1, u"+        ASSERT(patternPrefix != '[');"), (1200, 1, u"+    ASSERT(m_source->provider()->data()[openBrace] == '{');"), (1201, 1, u"+    ASSERT(m_source->provider()->data()[closeBrace] == '}');")]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+#include <wtf/Assertions.h>'), (124, 1, u'+    ASSERT(node->data()->m_arena.last() == node);'), (126, 1, u'+    ASSERT(!node->data()->m_arena.contains(node.get()));'), (142, 1, u'+    ASSERT(node->data()->m_arena.last() == node);'), (144, 1, u'+    ASSERT(!node->data()->m_arena.contains(node.get()));'), (175, 1, u'+    ASSERT(!source().isNull());'), (189, 1, u'+    ASSERT(node->data()->m_arena.last() == node);'), (191, 1, u'+    ASSERT(!node->data()->m_arena.contains(node.get()));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(34, 1, u'+    ASSERT(globalData);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+    ASSERT(m_freeablePoolEnd);'), (108, 1, u'+    ASSERT(freeablePool() == pool);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 1, u'+    ASSERT(m_currentNode);'), (101, 1, u'+    ASSERT(m_currentNode);'), (117, 1, u'+    ASSERT(m_currentNode);'), (120, 1, u'+        ASSERT(m_currentNode);'), (131, 1, u'+    ASSERT(m_currentNode);'), (177, 1, u'+    ASSERT(currentNode->callIdentifier() == (currentNode->parent()->children()[currentNode->parent()->children().size() - 1])->callIdentifier());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(169, 1, u'+    ASSERT(m_actualSelfTime == 0.0 && m_startTime == 0.0);'), (175, 1, u'+    ASSERT(m_actualSelfTime <= m_actualTotalTime);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(65, 1, u'+    ASSERT_ARG(title, !title.isNull());'), (125, 1, u'+    ASSERT(!m_currentProfiles.isEmpty());'), (132, 1, u'+    ASSERT(!m_currentProfiles.isEmpty());'), (141, 1, u'+    ASSERT(!m_currentProfiles.isEmpty());'), (148, 1, u'+    ASSERT(!m_currentProfiles.isEmpty());'), (155, 1, u'+    ASSERT(!m_currentProfiles.isEmpty());'), (180, 1, u'+    ASSERT(!function->isHostFunction());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+ASSERT_CLASS_FITS_IN_CELL(Arguments);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+ASSERT_CLASS_FITS_IN_CELL(ArrayConstructor);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+#include <wtf/Assertions.h>'), (42, 1, u'+ASSERT_CLASS_FITS_IN_CELL(ArrayPrototype);'), (120, 1, u'+    ASSERT(inherits(&s_info));'), (225, 1, u'+    ASSERT(buffer.size() == totalSize);'), (1136, 1, u'+        ASSERT(index < length);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 1, u'+ASSERT_CLASS_FITS_IN_CELL(BooleanConstructor);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(26, 1, u'+ASSERT_CLASS_FITS_IN_CELL(BooleanObject);'), (33, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+ASSERT_CLASS_FITS_IN_CELL(BooleanPrototype);'), (69, 1, u'+    ASSERT(asBooleanObject(thisValue)->internalValue() == jsBoolean(true));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+    ASSERT(callType == CallTypeJS || callType == CallTypeHost);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 1, u'+    ASSERT(exec->globalData().identifierTable == wtfThreadData().currentIdentifierTable());'), (53, 1, u'+    ASSERT(exec->globalData().identifierTable == wtfThreadData().currentIdentifierTable());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(38, 1, u'+    ASSERT(constructType == ConstructTypeJS || constructType == ConstructTypeHost);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+ASSERT_CLASS_FITS_IN_CELL(DateConstructor);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 1, u'+    ASSERT(inherits(&s_info));'), (47, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+#include <wtf/Assertions.h>'), (74, 1, u'+ASSERT_CLASS_FITS_IN_CELL(DatePrototype);'), (187, 1, u'+    ASSERT(length <= bufferLength);'), (435, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
Class:class StrictModeTypeErrorFunction : public InternalFunction { class StrictModeTypeErrorFunction : public InternalFunction 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+ASSERT_CLASS_FITS_IN_CELL(ErrorConstructor);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+    ASSERT(inherits(&s_info));'), (40, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+ASSERT_CLASS_FITS_IN_CELL(ErrorPrototype);')]
===========================================
Class:class InterruptedExecutionError : public JSNonFinalObject { class InterruptedExecutionError : public JSNonFinalObject 
Class: class TerminatedExecutionError : public JSNonFinalObject { class TerminatedExecutionError : public JSNonFinalObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(109, 1, u'+        ASSERT(exception);'), (116, 1, u'+    ASSERT(!m_evalCodeBlock);'), (161, 1, u'+    ASSERT(exception);'), (167, 1, u'+    ASSERT(!m_programCodeBlock);'), (174, 1, u'+        ASSERT(exception);'), (251, 1, u'+        ASSERT(exception);'), (261, 1, u'+    ASSERT(!m_codeBlockForCall);'), (271, 1, u'+    ASSERT(m_numParametersForCall);'), (305, 1, u'+        ASSERT(exception);'), (315, 1, u'+    ASSERT(!m_codeBlockForConstruct);'), (325, 1, u'+    ASSERT(m_numParametersForConstruct);'), (376, 1, u'+        ASSERT(*exception);'), (382, 1, u'+    ASSERT(exprStatement);'), (383, 1, u'+    ASSERT(exprStatement->isExprStatement());'), (385, 1, u'+    ASSERT(funcExpr);'), (386, 1, u'+    ASSERT(funcExpr->isFuncExprNode());'), (388, 1, u'+    ASSERT(body);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(38, 1, u'+ASSERT_CLASS_FITS_IN_CELL(FunctionConstructor);'), (104, 1, u'+        ASSERT(exception);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 1, u'+#include <wtf/Assertions.h>')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+#include <wtf/Assertions.h>'), (240, 1, u'+    ASSERT(!r->isIdentifier());'), (243, 1, u'+    ASSERT(r->length());'), (297, 1, u'+    ASSERT_UNUSED(globalData, globalData->identifierTable == wtfThreadData().currentIdentifierTable());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(35, 1, u'+ASSERT_CLASS_FITS_IN_CELL(InternalFunction);'), (47, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(38, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSActivation);'), (49, 1, u'+    ASSERT(inherits(&s_info));'), (90, 1, u'+    ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));'), (120, 1, u'+    ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));'), (126, 1, u'+    ASSERT(!entry.isNull());'), (152, 1, u'+    ASSERT(!hasGetterSetterProperties());'), (153, 1, u'+    ASSERT(prototype().isNull());'), (159, 1, u'+    ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));'), (167, 1, u'+    ASSERT(!hasGetterSetterProperties());'), (174, 1, u'+    ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));'), (182, 1, u'+    ASSERT(!hasGetterSetterProperties());'), (224, 1, u'+    ASSERT(callFrame->uncheckedR(realArgumentsRegister).jsValue().inherits(&Arguments::s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+#include <wtf/Assertions.h>'), (41, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSArray);'), (104, 1, u'+    ASSERT(vectorLength <= MAX_STORAGE_VECTOR_LENGTH);'), (111, 1, u'+    ASSERT(((size - (sizeof(ArrayStorage) - sizeof(JSValue))) / sizeof(JSValue) == vectorLength) && (size >= (sizeof(ArrayStorage) - sizeof(JSValue))));'), (137, 1, u'+    ASSERT(inherits(&s_info));'), (154, 1, u'+    ASSERT(inherits(&s_info));'), (196, 1, u'+    ASSERT(inherits(&s_info));'), (236, 1, u'+    ASSERT(vptr() == JSGlobalData::jsArrayVPtr);'), (469, 1, u'+    ASSERT(i < newVectorLength);'), (559, 1, u'+    ASSERT(desiredLength <= MAX_STORAGE_VECTOR_LENGTH);'), (577, 1, u'+    ASSERT(increasedLength >= desiredLength);'), (592, 1, u'+    ASSERT(newLength > vectorLength);'), (593, 1, u'+    ASSERT(newLength <= MAX_STORAGE_VECTOR_INDEX);'), (622, 1, u'+    ASSERT(newLength > vectorLength);'), (623, 1, u'+    ASSERT(newLength <= MAX_STORAGE_VECTOR_INDEX);'), (775, 1, u'+    ASSERT(count > 0);'), (828, 1, u'+    ASSERT(m_indexBias >= 0);'), (829, 1, u'+    ASSERT(count >= 0);'), (946, 1, u'+        ASSERT(!value.isUndefined());'), (1039, 1, u'+        ASSERT(!va.isUndefined());'), (1040, 1, u'+        ASSERT(!vb.isUndefined());'), (1076, 1, u'+    ASSERT(storage->m_length <= static_cast<unsigned>(std::numeric_limits<int>::max()));'), (1154, 1, u'+    ASSERT(tree.abstractor().m_nodes.size() >= numDefined);'), (1201, 1, u'+    ASSERT(m_storage->m_length >= maxSize);'), (1293, 1, u'+    ASSERT(storage);'), (1295, 1, u'+        ASSERT(!storage->m_sparseValueMap);'), (1300, 1, u'+            ASSERT(i < storage->m_length);'), (1306, 1, u'+                ASSERT(i >= storage->m_numValuesInVector);'), (1309, 1, u'+    ASSERT(numValuesInVector == storage->m_numValuesInVector);'), (1310, 1, u'+    ASSERT(numValuesInVector <= storage->m_length);'), (1316, 1, u'+            ASSERT(index < storage->m_length);'), (1317, 1, u'+            ASSERT(index >= storage->m_vectorLength);'), (1318, 1, u'+            ASSERT(index <= MAX_ARRAY_INDEX);'), (1319, 1, u'+            ASSERT(it->second);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 1, u'+#if !ASSERT_DISABLED'), (48, 1, u'+    ASSERT(vptr() == JSGlobalData::jsByteArrayVPtr);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(180, 1, u'+    ASSERT_NOT_REACHED();'), (186, 1, u'+    ASSERT_NOT_REACHED();'), (192, 1, u'+    ASSERT_NOT_REACHED();'), (198, 1, u'+    ASSERT_NOT_REACHED();'), (204, 1, u'+    ASSERT_NOT_REACHED();'), (210, 1, u'+    ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSFunction);'), (69, 1, u'+    ASSERT(inherits(&s_info));'), (78, 1, u'+    ASSERT(inherits(&s_info));'), (92, 1, u'+    ASSERT(inherits(&s_info));'), (99, 1, u'+    ASSERT(vptr() == JSGlobalData::jsFunctionVPtr);'), (159, 1, u'+    ASSERT(!thisObj->isHostFunction());'), (166, 1, u'+    ASSERT(!thisObj->isHostFunction());'), (173, 1, u'+    ASSERT(!thisObj->isHostFunction());')]
===========================================
Class:class Recompiler { class Recompiler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSGlobalObject);'), (89, 1, u'+    ASSERT(JSLock::currentThreadIsHoldingLock());'), (102, 1, u'+    ASSERT(JSLock::currentThreadIsHoldingLock());'), (120, 1, u'+    ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));'), (129, 1, u'+    ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));'), (381, 1, u'+    ASSERT(m_isEvalEnabled);'), (387, 1, u'+    ASSERT(!m_registerArray);'), (388, 1, u'+    ASSERT(!m_registerArraySize);'), (419, 1, u'+    ASSERT(oldSize <= newSize);'), (422, 1, u'+    ASSERT(newSize && newSize > oldSize);'), (424, 1, u'+        ASSERT(static_cast<size_t>(oldSize) == m_registerArraySize);'), (431, 1, u'+        ASSERT(static_cast<size_t>(newSize) < globalData().interpreter->registerFile().maxGlobals());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+#include <wtf/Assertions.h>'), (317, 1, u'+    ASSERT(data < end);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(63, 1, u'+    ASSERT(count >= 0);'), (68, 1, u'+    : m_lockBehavior(exec->globalData().isSharedInstance() ? LockForReal : SilenceAssertionsOnly)'), (74, 1, u'+    : m_lockBehavior(globalData->isSharedInstance() ? LockForReal : SilenceAssertionsOnly)'), (83, 1, u'+    if (lockBehavior == SilenceAssertionsOnly)'), (93, 1, u'+        ASSERT(!result);'), (100, 1, u'+    ASSERT(lockCount());'), (104, 1, u'+    if (lockBehavior == SilenceAssertionsOnly)'), (113, 1, u'+        ASSERT(!result);'), (119, 1, u'+    lock(exec->globalData().isSharedInstance() ? LockForReal : SilenceAssertionsOnly);'), (124, 1, u'+    unlock(exec->globalData().isSharedInstance() ? LockForReal : SilenceAssertionsOnly);'), (176, 1, u'+    : m_lockBehavior(exec->globalData().isSharedInstance() ? LockForReal : SilenceAssertionsOnly)'), (219, 1, u'+    : m_lockBehavior(SilenceAssertionsOnly)')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSNotAnObject);'), (42, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (48, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (54, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (60, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (66, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (72, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (79, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (85, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (91, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (97, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (102, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (107, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (113, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());'), (119, 1, u'+    ASSERT_UNUSED(exec, exec->hadException());')]
===========================================
Class:class PropertyNameForFunctionCall { class PropertyNameForFunctionCall 
Class: class Stringifier { class Stringifier 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 1, u'+#include <wtf/Assertions.h>'), (44, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSObject);'), (45, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSNonFinalObject);'), (46, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSFinalObject);'), (60, 1, u'+        ASSERT(table->table);'), (88, 1, u'+    ASSERT(info);'), (105, 1, u'+    ASSERT(value);'), (106, 1, u'+    ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));'), (262, 1, u'+    ASSERT(!result.isGetterSetter());'), (297, 1, u'+    ASSERT(!exec->hadException());'), (317, 1, u'+        ASSERT(m_structure->hasGetterSetterProperties());'), (343, 1, u'+        ASSERT(m_structure->hasGetterSetterProperties());'), (583, 1, u'+    ASSERT(m_inheritorID->isEmpty());'), (589, 1, u'+    ASSERT(newSize > oldSize);'), (750, 1, u'+    ASSERT(descriptor.isAccessorDescriptor());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+    COMPILE_ASSERT(AnonymousSlotCount == 1, AnonymousSlotCount_must_be_one);'), (37, 1, u'+    ASSERT(!globalObject || globalObject->isGlobalObject());'), (47, 1, u'+    COMPILE_ASSERT(AnonymousSlotCount == 1, AnonymousSlotCount_must_be_one);'), (48, 1, u'+    ASSERT(!globalObject || globalObject->isGlobalObject());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSPropertyNameIterator);'), (53, 1, u'+    ASSERT(!o->structure()->enumerationCache() ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSStaticScopeObject);'), (71, 1, u'+    ASSERT_NOT_REACHED();'), (79, 1, u'+    ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+    ASSERT(isRope());'), (73, 1, u'+    ASSERT((buffer + m_length) == position);'), (80, 1, u'+    ASSERT(!isRope());'), (123, 1, u'+                ASSERT(buffer == position);'), (130, 1, u'+                ASSERT(!isRope());'), (148, 1, u'+    ASSERT(!isRope());'), (149, 1, u'+    ASSERT(m_value == UString());'), (159, 1, u'+    ASSERT(isRope());'), (160, 1, u'+    ASSERT(substringLength);'), (193, 1, u'+    ASSERT(substringFiberCount && substringFiberCount <= 3);'), (196, 1, u'+        ASSERT(substringFiberCount == 1);'), (262, 1, u'+    ASSERT(isRope());'), (267, 1, u'+    ASSERT(!isRope());'), (268, 1, u'+    ASSERT(i < m_value.length());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 1, u'+    ASSERT(!isCell());'), (66, 1, u'+    ASSERT(isUndefinedOrNull());'), (73, 1, u'+    ASSERT(!isCell());'), (79, 1, u'+    ASSERT(isUndefinedOrNull());'), (85, 1, u'+    ASSERT(!isCell());'), (91, 1, u'+    ASSERT(isUndefinedOrNull());'), (98, 1, u'+    ASSERT(!isCell());'), (104, 1, u'+    ASSERT(isUndefinedOrNull());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSWrapperObject);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+    ASSERT(m_ptr <= m_end);'), (280, 1, u'+        ASSERT(static_cast<char>(token.start[i]) == token.start[i]);'), (286, 1, u'+    ASSERT(buffer.data() + (token.end - token.start) == end);'), (444, 1, u'+                ASSERT(stateStack.isEmpty());'), (452, 1, u'+                ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+    ASSERT(!table);'), (44, 1, u'+            ASSERT(linkIndex < compactSize);'), (73, 1, u'+    ASSERT(thisObj->structure()->anonymousSlotCount() > 0);'), (74, 1, u'+    ASSERT(thisObj->getAnonymousValue(0).isCell() && asObject(thisObj->getAnonymousValue(0).asCell())->isGlobalObject());'), (75, 1, u'+    ASSERT(entry->attributes() & Function);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 1, u'+#include <wtf/Assertions.h>'), (35, 1, u'+ASSERT_CLASS_FITS_IN_CELL(MathObject);'), (92, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+ASSERT_CLASS_FITS_IN_CELL(NativeErrorConstructor);'), (38, 1, u'+    ASSERT(inherits(&s_info));'), (45, 1, u'+    ASSERT(m_errorStructure);'), (46, 1, u'+    ASSERT(m_errorStructure->typeInfo().type() == ObjectType);'), (60, 1, u'+    ASSERT(errorStructure);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+ASSERT_CLASS_FITS_IN_CELL(NativeErrorPrototype);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+ASSERT_CLASS_FITS_IN_CELL(NumberConstructor);'), (60, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+ASSERT_CLASS_FITS_IN_CELL(NumberObject);'), (37, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+#include <wtf/Assertions.h>'), (37, 1, u'+ASSERT_CLASS_FITS_IN_CELL(NumberPrototype);'), (152, 1, u'+    ASSERT(!isnan(x) && !isinf(x));'), (266, 1, u'+    ASSERT(s <= startOfResultString);'), (282, 1, u'+    ASSERT(p < s + sizeof(s));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+ASSERT_CLASS_FITS_IN_CELL(ObjectConstructor);'), (291, 1, u'+    ASSERT((descriptor.attributes() & (Getter | Setter)) || (!descriptor.isAccessorDescriptor()));'), (292, 1, u'+    ASSERT(!exec->hadException());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+ASSERT_CLASS_FITS_IN_CELL(ObjectPrototype);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 1, u'+    ASSERT(!isAccessorDescriptor());'), (77, 1, u'+    ASSERT(isAccessorDescriptor());'), (83, 1, u'+    ASSERT(isAccessorDescriptor());'), (89, 1, u'+    ASSERT(value);'), (95, 1, u'+        ASSERT(m_getter || m_setter);'), (106, 1, u'+    ASSERT(attributes & (Getter | Setter));'), (107, 1, u'+    ASSERT(getter || setter);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(35, 1, u'+    ASSERT(!identifier || identifier == StringImpl::empty() || identifier->isIdentifier());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+#include <wtf/Assertions.h>'), (157, 1, u'+        ASSERT(offsetVector);'), (174, 1, u'+        ASSERT(result >= -1);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 1, u'+ASSERT_CLASS_FITS_IN_CELL(RegExpConstructor);'), (102, 1, u'+    ASSERT(inherits(&s_info));'), (134, 1, u'+    ASSERT(d);'), (173, 1, u'+        ASSERT(!d->lastOvector().isEmpty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+ASSERT_CLASS_FITS_IN_CELL(RegExpObject);'), (68, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+ASSERT_CLASS_FITS_IN_CELL(RegExpPrototype);')]
===========================================
Class:class SmallStringsStorage { class SmallStringsStorage 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 1, u'+ASSERT_CLASS_FITS_IN_CELL(StringConstructor);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 1, u'+ASSERT_CLASS_FITS_IN_CELL(StringObject);'), (35, 1, u'+    ASSERT(inherits(&s_info));'), (42, 1, u'+    ASSERT(inherits(&s_info));'), (49, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 1, u'+ASSERT_CLASS_FITS_IN_CELL(StringPrototype);'), (137, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(93, 1, u'+        ASSERT(singleTransition() == structure);'), (134, 1, u'+        ASSERT(result.first.get().second->m_specificValueInPrevious);'), (135, 1, u'+        ASSERT(!structure->m_specificValueInPrevious);'), (202, 1, u'+    ASSERT(m_prototype);'), (203, 1, u'+    ASSERT(m_prototype.isObject() || m_prototype.isNull());'), (225, 1, u'+    ASSERT(m_prototype);'), (226, 1, u'+    ASSERT(m_prototype.isNull());'), (227, 1, u'+    ASSERT(!globalData.structureStructure);'), (247, 1, u'+    ASSERT(m_prototype);'), (248, 1, u'+    ASSERT(m_prototype.isObject() || m_prototype.isNull());'), (257, 1, u'+    ASSERT(structure()->classInfo() == &s_info);'), (258, 1, u'+    ASSERT(!m_propertyTable);'), (268, 1, u'+            ASSERT(structure->m_propertyTable);'), (269, 1, u'+            ASSERT(!structure->m_previous);'), (302, 1, u'+    ASSERT(isDictionary());'), (303, 1, u'+    ASSERT(m_propertyTable);'), (306, 1, u'+    ASSERT(entry);'), (312, 1, u'+    ASSERT(!structure->isDictionary());'), (313, 1, u'+    ASSERT(structure->typeInfo().type() == ObjectType);'), (319, 1, u'+        ASSERT(existingTransition->m_offset != noOffset);'), (321, 1, u'+        ASSERT(offset >= structure->m_anonymousSlotCount);'), (322, 1, u'+        ASSERT(structure->m_anonymousSlotCount == existingTransition->m_anonymousSlotCount);'), (341, 1, u'+    ASSERT(!structure->isDictionary());'), (342, 1, u'+    ASSERT(structure->typeInfo().type() == ObjectType);'), (343, 1, u'+    ASSERT(!Structure::addPropertyTransitionToExistingStructure(structure, propertyName, attributes, specificValue, offset));'), (350, 1, u'+        ASSERT(structure != transition);'), (352, 1, u'+        ASSERT(offset >= structure->m_anonymousSlotCount);'), (353, 1, u'+        ASSERT(structure->m_anonymousSlotCount == transition->m_anonymousSlotCount);'), (380, 1, u'+    ASSERT(offset >= structure->m_anonymousSlotCount);'), (381, 1, u'+    ASSERT(structure->m_anonymousSlotCount == transition->m_anonymousSlotCount);'), (386, 1, u'+    ASSERT(structure->anonymousSlotCount() == transition->anonymousSlotCount());'), (393, 1, u'+    ASSERT(!structure->isUncacheableDictionary());'), (398, 1, u'+    ASSERT(offset >= structure->m_anonymousSlotCount);'), (399, 1, u'+    ASSERT(structure->m_anonymousSlotCount == transition->m_anonymousSlotCount);'), (416, 1, u'+    ASSERT(structure->anonymousSlotCount() == transition->anonymousSlotCount());'), (422, 1, u'+    ASSERT(structure->m_specificFunctionThrashCount < maxSpecificFunctionThrashCount);'), (437, 1, u'+        ASSERT_UNUSED(removed, removed);'), (440, 1, u'+    ASSERT(structure->anonymousSlotCount() == transition->anonymousSlotCount());'), (454, 1, u'+    ASSERT(structure->anonymousSlotCount() == transition->anonymousSlotCount());'), (460, 1, u'+    ASSERT(!structure->isUncacheableDictionary());'), (469, 1, u'+    ASSERT(structure->anonymousSlotCount() == transition->anonymousSlotCount());'), (523, 1, u'+    ASSERT(structure->anonymousSlotCount() == transition->anonymousSlotCount());'), (565, 1, u'+    ASSERT(isDictionary());'), (567, 1, u'+        ASSERT(m_propertyTable);'), (594, 1, u'+    ASSERT(!m_enumerationCache);'), (604, 1, u'+    ASSERT(offset >= m_anonymousSlotCount);'), (612, 1, u'+    ASSERT(isUncacheableDictionary());'), (613, 1, u'+    ASSERT(!m_enumerationCache);'), (619, 1, u'+    ASSERT(offset >= m_anonymousSlotCount);'), (667, 1, u'+    ASSERT(entry->offset >= m_anonymousSlotCount);'), (677, 1, u'+    ASSERT(!propertyName.isNull());'), (682, 1, u'+    ASSERT(entry->specificValue);'), (700, 1, u'+    ASSERT(!propertyName.isNull());'), (701, 1, u'+    ASSERT(get(globalData, propertyName) == notFound);'), (718, 1, u'+    ASSERT(newOffset >= m_anonymousSlotCount);'), (728, 1, u'+    ASSERT(!propertyName.isNull());'), (742, 1, u'+    ASSERT(offset >= m_anonymousSlotCount);'), (753, 1, u'+    ASSERT(!m_propertyTable);'), (770, 1, u'+        ASSERT(m_hasNonEnumerableProperties || !(iter->attributes & DontEnum));'), (806, 1, u'+    ASSERT(m_indexSize >= PropertyTable::MinimumTableSize);'), (807, 1, u'+    ASSERT(m_indexMask);'), (808, 1, u'+    ASSERT(m_indexSize == m_indexMask + 1);'), (809, 1, u'+    ASSERT(!(m_indexSize & m_indexMask));'), (811, 1, u'+    ASSERT(m_keyCount <= m_indexSize / 2);'), (812, 1, u'+    ASSERT(m_keyCount + m_deletedCount <= m_indexSize / 2);'), (813, 1, u'+    ASSERT(m_deletedCount <= m_indexSize / 4);'), (825, 1, u'+        ASSERT(entryIndex < deletedEntryIndex());'), (826, 1, u'+        ASSERT(entryIndex - 1 <= usedCount());'), (830, 1, u'+            ASSERT(m_index[b] != entryIndex);'), (832, 1, u'+    ASSERT(indexCount == m_keyCount);'), (833, 1, u'+    ASSERT(deletedIndexCount == m_deletedCount);'), (835, 1, u'+    ASSERT(!table()[deletedEntryIndex() - 1].key);'), (848, 1, u'+            ASSERT(entryIndex != PropertyTable::EmptyEntryIndex);'), (855, 1, u'+        ASSERT(entryIndex == c + 1);'), (858, 1, u'+    ASSERT(nonEmptyEntryCount == m_keyCount);'), (869, 1, u'+            ASSERT(!(iter->attributes & DontEnum));'), (870, 1, u'+            ASSERT(iter->offset >= m_anonymousSlotCount);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(92, 1, u'+    ASSERT_WITH_MESSAGE(err == KErrNone, "GetCpuTime failed with %d", err);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+#include <wtf/Assertions.h>'), (57, 1, u'+COMPILE_ASSERT(sizeof(UString) == sizeof(void*), UString_should_stay_small);'), (315, 1, u'+    ASSERT(ch >= 0x0800);'), (342, 1, u'+    ASSERT(result != targetExhausted); // (length * 3) should be sufficient for any conversion'), (356, 1, u'+        ASSERT((characters + 1) == (this->characters() + length));'), (357, 1, u'+        ASSERT((*characters >= 0xD800) && (*characters <= 0xDBFF));'), (359, 1, u'+        ASSERT((buffer + 3) <= (buffer + bufferVector.size()));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(190, 1, u'+void WTFReportAssertionFailure(const char* file, int line, const char* function, const char* assertion)'), (192, 1, u'+    if (assertion)'), (193, 1, u'+        printf_stderr_common("ASSERTION FAILED: %s\\n", assertion);'), (199, 1, u'+void WTFReportAssertionFailureWithMessage(const char* file, int line, const char* function, const char* assertion, const char* format, ...)'), (206, 1, u'+    printf_stderr_common("\\n%s\\n", assertion);'), (210, 1, u'+void WTFReportArgumentAssertionFailure(const char* file, int line, const char* function, const char* argName, const char* assertion)'), (212, 1, u'+    printf_stderr_common("ARGUMENT BAD: %s, %s\\n", argName, assertion);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(35, 1, u'+    ASSERT((reinterpret_cast<size_t>(buffer) & 3) == 0);')]
===========================================
Class:class ARC4Stream { class ARC4Stream 
Class:class ARC4RandomNumberGenerator { class ARC4RandomNumberGenerator 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(332, 1, u'+    ASSERT((year >= 1970 && yearday >= 0) || (year < 1970 && yearday < 0));'), (384, 1, u'+    ASSERT((year >= minYear && year <= maxYear) || (product - year == static_cast<int>(NaN)));'), (483, 1, u'+    ASSERT(!alreadyInitialized);'), (541, 1, u'+    ASSERT(monthStr);'), (1143, 1, u'+    ASSERT(exec);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(104, 1, u'+    ASSERT_UNUSED(bufferLength, bufferLength >= bufferLengthForStringDecimal());'), (107, 1, u'+    ASSERT(m_precision);'), (160, 1, u'+    ASSERT_UNUSED(bufferLength, bufferLength >= bufferLengthForStringExponential());'), (163, 1, u'+    ASSERT(m_precision);')]
===========================================
Class:class TCMalloc_Central_FreeListPadded;
Class: class FastMallocZone { class FastMallocZone 
Class: template <class T> class PageHeapAllocator { class PageHeapAllocator 
Class:          template <int BITS> class MapSelector { template <int BITS> class MapSelector 
Class: class TCMalloc_PageHeap { class TCMalloc_PageHeap 
Class:     class TCMalloc_ThreadCache_FreeList { class TCMalloc_ThreadCache_FreeList 
Class:     class TCMalloc_ThreadCache { class TCMalloc_ThreadCache 
Class:     class TCMalloc_Central_FreeList { class TCMalloc_Central_FreeList 
Class:  class TCMalloc_Central_FreeListPadded : public TCMalloc_Central_FreeList { class TCMalloc_Central_FreeListPadded : public TCMalloc_Central_FreeList 
Class:class LockInverter { class LockInverter 
Class:class TCMallocImplementation : public MallocExtension { class TCMallocImplementation : public MallocExtension 
Class: class PageMapFreeObjectFinder { class PageMapFreeObjectFinder 
Class: class PageMapMemoryUsageRecorder { class PageMapMemoryUsageRecorder 
Class: class AdminRegionRecorder { class AdminRegionRecorder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(79, 1, u'+    ASSERT_WITH_MESSAGE(actual == expected, "input:%s[%lu] actual:%s expected:%s", input.data(), static_cast<unsigned long>(input.length()), actual.data(), expected.data());'), (103, 1, u'+    ASSERT(longs > 0);'), (106, 1, u'+        ASSERT_WITH_MESSAGE(!(reinterpret_cast<uintptr_t>(buf) % sizeof(t)), "alignment error of buf");'), (215, 1, u'+    ASSERT_WITH_MESSAGE(!(reinterpret_cast<uintptr_t>(m_in) % sizeof(uint32_t)), "alignment error of m_in");')]
===========================================
Class:class FunctionWithContextFinder { class FunctionWithContextFinder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+#include <wtf/Assertions.h>')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 1, u'+    __ASSERT_ALWAYS(error == KErrNone, User::Panic(KErrorStringChunkCreation, error));'), (137, 1, u'+    __ASSERT_ALWAYS(m_pageSize == WTF::pageSize(), User::Panic(KErrorStringPageSize, m_pageSize));'), (141, 1, u'+    __ASSERT_ALWAYS(error == KErrNone, User::Panic(KErrorStringChunkCreation, error));'), (183, 1, u'+    __ASSERT_ALWAYS(m_map.get(idx), User::Panic(KErrorStringInternalConsistency, idx));'), (184, 1, u'+    __ASSERT_ALWAYS(m_map.get(idx+nPages-1), User::Panic(KErrorStringInternalConsistency, idx+nPages-1));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+#include <wtf/Assertions.h>')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+    ASSERT(isPageAligned(size));'), (34, 1, u'+    ASSERT(isPageAligned(alignment));'), (35, 1, u'+    ASSERT(isPowerOfTwo(alignment));'), (36, 1, u'+    ASSERT(size >= alignment);'), (76, 1, u'+    ASSERT(tmp);'), (77, 1, u'+    ASSERT(!*this);'), (82, 1, u'+    ASSERT(tmp.m_reservation.contains(tmp.base(), tmp.size()));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 1, u'+    ASSERT(isPowerOfTwo(s_pageSize));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 1, u'+    ASSERT(leakMessageSuppressionReasons);'), (57, 1, u'+    ASSERT(leakMessageSuppressionReasons->contains(reason));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(64, 1, u'+    ASSERT_WITH_MESSAGE(actual == expected, "input: %s, repeat: %d, actual: %s, expected: %s", input.data(), repeat, actual.data(), expected.data());'), (83, 1, u'+    ASSERT(t >= 0 && t < 80);'), (95, 1, u'+    ASSERT(t >= 0 && t < 80);'), (107, 1, u'+    ASSERT(n >= 0 && n < 32);'), (121, 1, u'+        ASSERT(m_cursor < 64);'), (149, 1, u'+    ASSERT(m_cursor < 64);'), (173, 1, u'+    ASSERT(m_cursor == 64);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+#include <wtf/Assertions.h>'), (50, 1, u'+COMPILE_ASSERT(sizeof(OwnPtr<int>) == sizeof(int*), OwnPtr_should_stay_small);'), (51, 1, u'+COMPILE_ASSERT(sizeof(PassRefPtr<RefCounted<int> >) == sizeof(int*), PassRefPtr_should_stay_small);'), (52, 1, u'+COMPILE_ASSERT(sizeof(RefCounted<int>) == sizeof(int) + refCountedExtraDebugSize, RefCounted_should_stay_small);'), (53, 1, u'+COMPILE_ASSERT(sizeof(RefCountedCustomAllocated<int>) == sizeof(int) + refCountedExtraDebugSize, RefCountedCustomAllocated_should_stay_small);'), (54, 1, u'+COMPILE_ASSERT(sizeof(RefPtr<RefCounted<int> >) == sizeof(int*), RefPtr_should_stay_small);'), (55, 1, u'+COMPILE_ASSERT(sizeof(Vector<int>) == 3 * sizeof(int*), Vector_should_stay_small);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(109, 1, u'+    ASSERT(stackBase);'), (176, 1, u'+    ASSERT(stackBase);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 1, u'+    ASSERT(!identifier());'), (69, 1, u'+    ASSERT(threadIdentifierData);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(88, 1, u'+    ASSERT(atomicallyInitializedStaticMutex);'), (118, 1, u'+    ASSERT(!identifierByPthreadHandle(pthreadHandle));'), (140, 1, u'+    ASSERT(threadMap().contains(id));'), (204, 1, u'+    ASSERT(id);'), (210, 1, u'+    ASSERT(threadID);'), (225, 1, u'+    ASSERT(threadID);'), (270, 1, u'+    ASSERT_UNUSED(result, !result);'), (282, 1, u'+    ASSERT_NOT_REACHED();'), (289, 1, u'+    ASSERT_UNUSED(result, !result);'), (306, 1, u'+    ASSERT_UNUSED(result, !result);'), (318, 1, u'+    ASSERT_NOT_REACHED();'), (325, 1, u'+    ASSERT_UNUSED(result, !result);'), (337, 1, u'+    ASSERT_NOT_REACHED();'), (344, 1, u'+    ASSERT_UNUSED(result, !result);'), (361, 1, u'+    ASSERT_UNUSED(result, !result);'), (387, 1, u'+    ASSERT_UNUSED(result, !result);'), (393, 1, u'+    ASSERT_UNUSED(result, !result);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(143, 1, u'+    ASSERT(atomicallyInitializedStaticMutex);'), (177, 1, u'+    ASSERT(!threadMap().contains(threadID));'), (190, 1, u'+    ASSERT(threadMap().contains(id));'), (241, 1, u'+    ASSERT(threadID);'), (259, 1, u'+    ASSERT(threadID);'), (330, 1, u'+    ASSERT(res == WAIT_OBJECT_0);'), (333, 1, u'+    ASSERT(res);'), (342, 1, u'+    ASSERT(res == WAIT_OBJECT_0);'), (353, 1, u'+        ASSERT(res == WAIT_OBJECT_0);'), (356, 1, u'+        ASSERT(res);'), (361, 1, u'+    ASSERT(res);'), (365, 1, u'+        ASSERT(res);'), (379, 1, u'+    ASSERT(res == WAIT_OBJECT_0);'), (384, 1, u'+            ASSERT(res);'), (399, 1, u'+        ASSERT(res == WAIT_OBJECT_0);'), (415, 1, u'+        ASSERT(res);'), (420, 1, u'+    ASSERT(res);'), (424, 1, u'+        ASSERT(res);')]
===========================================
Class:class TestBaseClass { class TestBaseClass 
Class: class TestDerivedClass : public TestBaseClass<int> { class TestDerivedClass : public TestBaseClass<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 1, u'+COMPILE_ASSERT(IsInteger<bool>::value, WTF_IsInteger_bool_true);'), (30, 1, u'+COMPILE_ASSERT(IsInteger<char>::value, WTF_IsInteger_char_true);'), (31, 1, u'+COMPILE_ASSERT(IsInteger<signed char>::value, WTF_IsInteger_signed_char_true);'), (32, 1, u'+COMPILE_ASSERT(IsInteger<unsigned char>::value, WTF_IsInteger_unsigned_char_true);'), (33, 1, u'+COMPILE_ASSERT(IsInteger<short>::value, WTF_IsInteger_short_true);'), (34, 1, u'+COMPILE_ASSERT(IsInteger<unsigned short>::value, WTF_IsInteger_unsigned_short_true);'), (35, 1, u'+COMPILE_ASSERT(IsInteger<int>::value, WTF_IsInteger_int_true);'), (36, 1, u'+COMPILE_ASSERT(IsInteger<unsigned int>::value, WTF_IsInteger_unsigned_int_true);'), (37, 1, u'+COMPILE_ASSERT(IsInteger<long>::value, WTF_IsInteger_long_true);'), (38, 1, u'+COMPILE_ASSERT(IsInteger<unsigned long>::value, WTF_IsInteger_unsigned_long_true);'), (39, 1, u'+COMPILE_ASSERT(IsInteger<long long>::value, WTF_IsInteger_long_long_true);'), (40, 1, u'+COMPILE_ASSERT(IsInteger<unsigned long long>::value, WTF_IsInteger_unsigned_long_long_true);'), (42, 1, u'+COMPILE_ASSERT(IsInteger<wchar_t>::value, WTF_IsInteger_wchar_t_true);'), (44, 1, u'+COMPILE_ASSERT(!IsInteger<char*>::value, WTF_IsInteger_char_pointer_false);'), (45, 1, u'+COMPILE_ASSERT(!IsInteger<const char*>::value, WTF_IsInteger_const_char_pointer_false);'), (46, 1, u'+COMPILE_ASSERT(!IsInteger<volatile char*>::value, WTF_IsInteger_volatile_char_pointer_false);'), (47, 1, u'+COMPILE_ASSERT(!IsInteger<double>::value, WTF_IsInteger_double_false);'), (48, 1, u'+COMPILE_ASSERT(!IsInteger<float>::value, WTF_IsInteger_float_false);'), (50, 1, u'+COMPILE_ASSERT(IsFloatingPoint<float>::value, WTF_IsFloatingPoint_float_true);'), (51, 1, u'+COMPILE_ASSERT(IsFloatingPoint<double>::value, WTF_IsFloatingPoint_double_true);'), (52, 1, u'+COMPILE_ASSERT(IsFloatingPoint<long double>::value, WTF_IsFloatingPoint_long_double_true);'), (53, 1, u'+COMPILE_ASSERT(!IsFloatingPoint<int>::value, WTF_IsFloatingPoint_int_false);'), (55, 1, u'+COMPILE_ASSERT(IsPod<bool>::value, WTF_IsPod_bool_true);'), (56, 1, u'+COMPILE_ASSERT(IsPod<char>::value, WTF_IsPod_char_true);'), (57, 1, u'+COMPILE_ASSERT(IsPod<signed char>::value, WTF_IsPod_signed_char_true);'), (58, 1, u'+COMPILE_ASSERT(IsPod<unsigned char>::value, WTF_IsPod_unsigned_char_true);'), (59, 1, u'+COMPILE_ASSERT(IsPod<short>::value, WTF_IsPod_short_true);'), (60, 1, u'+COMPILE_ASSERT(IsPod<unsigned short>::value, WTF_IsPod_unsigned_short_true);'), (61, 1, u'+COMPILE_ASSERT(IsPod<int>::value, WTF_IsPod_int_true);'), (62, 1, u'+COMPILE_ASSERT(IsPod<unsigned int>::value, WTF_IsPod_unsigned_int_true);'), (63, 1, u'+COMPILE_ASSERT(IsPod<long>::value, WTF_IsPod_long_true);'), (64, 1, u'+COMPILE_ASSERT(IsPod<unsigned long>::value, WTF_IsPod_unsigned_long_true);'), (65, 1, u'+COMPILE_ASSERT(IsPod<long long>::value, WTF_IsPod_long_long_true);'), (66, 1, u'+COMPILE_ASSERT(IsPod<unsigned long long>::value, WTF_IsPod_unsigned_long_long_true);'), (68, 1, u'+COMPILE_ASSERT(IsPod<wchar_t>::value, WTF_IsPod_wchar_t_true);'), (70, 1, u'+COMPILE_ASSERT(IsPod<char*>::value, WTF_IsPod_char_pointer_true);'), (71, 1, u'+COMPILE_ASSERT(IsPod<const char*>::value, WTF_IsPod_const_char_pointer_true);'), (72, 1, u'+COMPILE_ASSERT(IsPod<volatile char*>::value, WTF_IsPod_volatile_char_pointer_true);'), (73, 1, u'+COMPILE_ASSERT(IsPod<double>::value, WTF_IsPod_double_true);'), (74, 1, u'+COMPILE_ASSERT(IsPod<long double>::value, WTF_IsPod_long_double_true);'), (75, 1, u'+COMPILE_ASSERT(IsPod<float>::value, WTF_IsPod_float_true);'), (76, 1, u'+COMPILE_ASSERT(!IsPod<IsPod<bool> >::value, WTF_IsPod_struct_false);'), (79, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<IsConvertibleToIntegerCheck>::value, WTF_IsConvertibleToInteger_enum_true);'), (80, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<bool>::value, WTF_IsConvertibleToInteger_bool_true);'), (81, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<char>::value, WTF_IsConvertibleToInteger_char_true);'), (82, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<signed char>::value, WTF_IsConvertibleToInteger_signed_char_true);'), (83, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<unsigned char>::value, WTF_IsConvertibleToInteger_unsigned_char_true);'), (84, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<short>::value, WTF_IsConvertibleToInteger_short_true);'), (85, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<unsigned short>::value, WTF_IsConvertibleToInteger_unsigned_short_true);'), (86, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<int>::value, WTF_IsConvertibleToInteger_int_true);'), (87, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<unsigned int>::value, WTF_IsConvertibleToInteger_unsigned_int_true);'), (88, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<long>::value, WTF_IsConvertibleToInteger_long_true);'), (89, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<unsigned long>::value, WTF_IsConvertibleToInteger_unsigned_long_true);'), (90, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<long long>::value, WTF_IsConvertibleToInteger_long_long_true);'), (91, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<unsigned long long>::value, WTF_IsConvertibleToInteger_unsigned_long_long_true);'), (93, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<wchar_t>::value, WTF_IsConvertibleToInteger_wchar_t_true);'), (95, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<double>::value, WTF_IsConvertibleToInteger_double_true);'), (96, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<long double>::value, WTF_IsConvertibleToInteger_long_double_true);'), (97, 1, u'+COMPILE_ASSERT(IsConvertibleToInteger<float>::value, WTF_IsConvertibleToInteger_float_true);'), (98, 1, u'+COMPILE_ASSERT(!IsConvertibleToInteger<char*>::value, WTF_IsConvertibleToInteger_char_pointer_false);'), (99, 1, u'+COMPILE_ASSERT(!IsConvertibleToInteger<const char*>::value, WTF_IsConvertibleToInteger_const_char_pointer_false);'), (100, 1, u'+COMPILE_ASSERT(!IsConvertibleToInteger<volatile char*>::value, WTF_IsConvertibleToInteger_volatile_char_pointer_false);'), (101, 1, u'+COMPILE_ASSERT(!IsConvertibleToInteger<IsConvertibleToInteger<bool> >::value, WTF_IsConvertibleToInteger_struct_false);'), (103, 1, u'+COMPILE_ASSERT((IsSameType<bool, bool>::value), WTF_IsSameType_bool_true);'), (104, 1, u'+COMPILE_ASSERT((IsSameType<int*, int*>::value), WTF_IsSameType_int_pointer_true);'), (105, 1, u'+COMPILE_ASSERT((!IsSameType<int, int*>::value), WTF_IsSameType_int_int_pointer_false);'), (106, 1, u'+COMPILE_ASSERT((!IsSameType<bool, const bool>::value), WTF_IsSameType_const_change_false);'), (107, 1, u'+COMPILE_ASSERT((!IsSameType<bool, volatile bool>::value), WTF_IsSameType_volatile_change_false);'), (116, 1, u'+COMPILE_ASSERT((IsSubclass<TestDerivedClass, TestBaseClass<int> >::value), WTF_Test_IsSubclass_Derived_From_Base);'), (117, 1, u'+COMPILE_ASSERT((!IsSubclass<TestBaseClass<int>, TestDerivedClass>::value), WTF_Test_IsSubclass_Base_From_Derived);'), (118, 1, u'+COMPILE_ASSERT((IsSubclassOfTemplate<TestDerivedClass, TestBaseClass>::value), WTF_Test_IsSubclassOfTemplate_Base_From_Derived);'), (119, 1, u'+COMPILE_ASSERT((IsSameType<RemoveTemplate<TestBaseClass<int>, TestBaseClass>::Type, int>::value), WTF_Test_RemoveTemplate);'), (120, 1, u'+COMPILE_ASSERT((IsSameType<RemoveTemplate<int, TestBaseClass>::Type, int>::value), WTF_Test_RemoveTemplate_WithoutTemplate);'), (123, 1, u'+COMPILE_ASSERT((IsSameType<bool, RemoveConst<const bool>::Type>::value), WTF_test_RemoveConst_const_bool);'), (124, 1, u'+COMPILE_ASSERT((!IsSameType<bool, RemoveConst<volatile bool>::Type>::value), WTF_test_RemoveConst_volatile_bool);'), (126, 1, u'+COMPILE_ASSERT((IsSameType<bool, RemoveVolatile<bool>::Type>::value), WTF_test_RemoveVolatile_bool);'), (127, 1, u'+COMPILE_ASSERT((!IsSameType<bool, RemoveVolatile<const bool>::Type>::value), WTF_test_RemoveVolatile_const_bool);'), (128, 1, u'+COMPILE_ASSERT((IsSameType<bool, RemoveVolatile<volatile bool>::Type>::value), WTF_test_RemoveVolatile_volatile_bool);'), (130, 1, u'+COMPILE_ASSERT((IsSameType<bool, RemoveConstVolatile<bool>::Type>::value), WTF_test_RemoveConstVolatile_bool);'), (131, 1, u'+COMPILE_ASSERT((IsSameType<bool, RemoveConstVolatile<const bool>::Type>::value), WTF_test_RemoveConstVolatile_const_bool);'), (132, 1, u'+COMPILE_ASSERT((IsSameType<bool, RemoveConstVolatile<volatile bool>::Type>::value), WTF_test_RemoveConstVolatile_volatile_bool);'), (133, 1, u'+COMPILE_ASSERT((IsSameType<bool, RemoveConstVolatile<const volatile bool>::Type>::value), WTF_test_RemoveConstVolatile_const_volatile_bool);'), (135, 1, u'+COMPILE_ASSERT((IsSameType<int, RemovePointer<int>::Type>::value), WTF_Test_RemovePointer_int);'), (136, 1, u'+COMPILE_ASSERT((IsSameType<int, RemovePointer<int*>::Type>::value), WTF_Test_RemovePointer_int_pointer);'), (137, 1, u'+COMPILE_ASSERT((!IsSameType<int, RemovePointer<int**>::Type>::value), WTF_Test_RemovePointer_int_pointer_pointer);'), (139, 1, u'+COMPILE_ASSERT((IsSameType<int, RemoveReference<int>::Type>::value), WTF_Test_RemoveReference_int);'), (140, 1, u'+COMPILE_ASSERT((IsSameType<int, RemoveReference<int&>::Type>::value), WTF_Test_RemoveReference_int_reference);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 1, u'+#include <wtf/Assertions.h>'), (470, 1, u'+                ASSERT(!p5->next);'), (511, 1, u'+        ASSERT(dst == dstStart + n);'), (523, 1, u'+    ASSERT(b.size() <= 1 || b.words()[b.size() - 1]);'), (533, 1, u'+    ASSERT(i <= 1 || a.words()[i - 1]);'), (534, 1, u'+    ASSERT(j <= 1 || b.words()[j - 1]);'), (643, 1, u'+    ASSERT(y);'), (1199, 1, u'+    ASSERT(b.size() <= 1 || b.words()[b.size() - 1]);'), (1200, 1, u'+    ASSERT(S.size() <= 1 || S.words()[S.size() - 1]);'), (1203, 1, u'+    ASSERT_WITH_MESSAGE(b.size() <= n, "oversize b in quorem");'), (1211, 1, u'+    ASSERT_WITH_MESSAGE(q <= 9, "oversized quotient in quorem");'), (1316, 1, u'+    ASSERT(roundingNone + roundingSignificantFigures + roundingDecimalPlaces == 1);'), (1318, 1, u'+    ASSERT(!roundingNone || leftright);'), (1320, 1, u'+    ASSERT(!isnan(dd) && !isinf(dd));'), (1337, 1, u'+    ASSERT((word0(&u) & Exp_mask) != Exp_mask);'), (1781, 1, u'+    ASSERT(s > result);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 1, u'+    ASSERT(g_thread_supported());'), (71, 1, u'+    ASSERT(atomicallyInitializedStaticMutex);'), (101, 1, u'+    ASSERT(!identifierByGthreadHandle(thread));'), (123, 1, u'+    ASSERT(threadMap().contains(id));'), (146, 1, u'+    ASSERT(threadID);')]
===========================================
Class:class MainThreadInvoker : public QObject { class MainThreadInvoker : public QObject 
Class:class ThreadPrivate : public QThread { class ThreadPrivate : public QThread 
Class: class ThreadMonitor : public QObject { class ThreadMonitor : public QObject 
Class:class AtomicStringTable { class AtomicStringTable 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 1, u'+    ASSERT(length < numeric_limits<size_t>::max());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+        ASSERT(m_string.length() == m_length);'), (48, 1, u'+    ASSERT(m_buffer && m_length <= m_buffer->length());'), (57, 1, u'+    ASSERT(newSize <= m_length);'), (60, 1, u'+    ASSERT(m_length);'), (72, 1, u'+    ASSERT(!m_string.isEmpty());'), (73, 1, u'+    ASSERT(m_length == m_string.length());'), (74, 1, u'+    ASSERT(newSize < m_string.length());'), (109, 1, u'+    ASSERT(length);'), (118, 1, u'+        ASSERT(m_buffer->length() >= m_length);'), (131, 1, u'+        ASSERT(m_string.length() == m_length);'), (144, 1, u'+    ASSERT(characters);'), (153, 1, u'+    ASSERT(characters);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+COMPILE_ASSERT(sizeof(StringImpl) == 2 * sizeof(int) + 3 * sizeof(void*), StringImpl_should_stay_small);'), (46, 1, u'+    ASSERT(!isStatic());'), (60, 1, u'+            ASSERT(!m_sharedBuffer);'), (61, 1, u'+            ASSERT(m_data);'), (64, 1, u'+            ASSERT(m_substringBuffer);'), (67, 1, u'+            ASSERT(ownership == BufferShared);'), (68, 1, u'+            ASSERT(m_sharedBuffer);'), (130, 1, u'+    ASSERT(characters);'), (131, 1, u'+    ASSERT(minLengthToShare && length >= minLengthToShare);'), (140, 1, u'+    ASSERT(!isStatic());'), (149, 1, u'+        ASSERT(!m_sharedBuffer);'), (154, 1, u'+    ASSERT(bufferOwnership() == BufferShared);'), (155, 1, u'+    ASSERT(m_sharedBuffer);'), (471, 1, u'+    ASSERT(length >= 0);'), (492, 1, u'+    ASSERT(length >= 0);'), (764, 1, u'+    ASSERT(matchString);'), (867, 1, u'+    ASSERT(dstOffset + srcSegmentLength == newImpl->length());'), (925, 1, u'+    ASSERT(dstOffset + srcSegmentLength == newImpl->length());'), (1035, 1, u'+    ASSERT(strippedLength < length);  // Only take the slow case when stripping.')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 1, u'+        ASSERT(isMainThread());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(349, 1, u'+        ASSERT(!isASCII(character));'), (386, 1, u'+        ASSERT(!isASCII(character));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 1, u'+    ASSERT(!m_collator);'), (109, 1, u'+            ASSERT(U_SUCCESS(status));'), (110, 1, u'+            ASSERT(cachedCollatorLocale);'), (113, 1, u'+            ASSERT(U_SUCCESS(status));'), (130, 1, u'+    ASSERT(U_SUCCESS(status));'), (133, 1, u'+    ASSERT(U_SUCCESS(status));')]
===========================================
Class:class Interpreter { class Interpreter 
Class:    class InputStream {     class InputStream 
Class:   class ByteCompiler { class ByteCompiler 
Class:class YarrGenerator : private MacroAssembler { class YarrGenerator : private MacroAssembler 
Class:    class BacktrackingState {     class BacktrackingState 
Class:class CharacterClassConstructor { class CharacterClassConstructor 
Class:class YarrPatternConstructor { class YarrPatternConstructor 
Class:class SyntaxChecker { class SyntaxChecker 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(35, 1, u'+    void assertionBOL() {}'), (36, 1, u'+    void assertionEOL() {}'), (37, 1, u'+    void assertionWordBoundary(bool) {}'), (46, 1, u'+    void atomParentheticalAssertionBegin(bool = false) {}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(164, 1, u'+    ASSERT(!HashTraits<AXID>::isDeletedValue(axID));'), (177, 1, u'+    ASSERT(!HashTraits<AXID>::isDeletedValue(axID));'), (359, 1, u'+    ASSERT(m_objects.size() >= m_idsInUse.size());'), (405, 1, u'+        ASSERT(m_idsInUse.contains(objID));'), (425, 1, u'+    ASSERT(!HashTraits<AXID>::isDeletedValue(objID));'), (426, 1, u'+    ASSERT(m_idsInUse.contains(objID));'), (468, 1, u'+                ASSERT(!renderer->view()->layoutState());'), (614, 1, u'+    ASSERT(domNode);'), (626, 1, u'+    ASSERT(renderer);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 1, u'+    ASSERT(!m_haveChildren);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 1, u'+    ASSERT(result.isEmpty());'), (131, 1, u'+    ASSERT(result.isEmpty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 1, u'+    ASSERT(renderer->node() && renderer->node()->isMediaControlElement());'), (274, 1, u'+    ASSERT(m_renderer->node()->hasTagName(inputTag));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+    ASSERT(m_children.size() == 1);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 1, u'+    ASSERT_ARG(element, element->hasTagName(optionTag));'), (105, 1, u'+    ASSERT(parent->isMenuListPopup());'), (108, 1, u'+    ASSERT(grandparent->isMenuList());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 1, u'+    ASSERT(object->isMenuListOption());'), (93, 1, u'+    ASSERT(selectNode->hasTagName(selectTag));'), (121, 1, u'+    ASSERT_ARG(menuList, menuList);'), (122, 1, u'+    ASSERT(!m_menuList);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 1, u'+    ASSERT(isDetached());'), (98, 1, u'+    ASSERT(AXObjectCache::accessibilityEnabled());'), (458, 1, u'+            ASSERT(node == it.range()->endContainer(exception));'), (485, 1, u'+            ASSERT(node == it.range()->endContainer(exception));'), (979, 1, u'+    ASSERT(!value.isEmpty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(105, 1, u'+    ASSERT(isDetached());'), (187, 1, u'+            ASSERT_UNUSED(prev, cur || !toRenderInline(prev)->continuation());'), (245, 1, u'+            ASSERT(cur || !toRenderInline(prev)->continuation());'), (280, 1, u'+    ASSERT_NOT_REACHED();'), (383, 1, u'+    ASSERT(renderer);'), (495, 1, u'+    ASSERT(!isWidget || (renderer->isReplaced() && !isImage()));'), (501, 1, u'+    ASSERT(m_renderer);'), (576, 1, u'+    ASSERT(m_renderer);'), (596, 1, u'+    ASSERT(m_renderer);'), (621, 1, u'+    ASSERT(m_renderer);'), (644, 1, u'+    ASSERT(m_renderer);'), (650, 1, u'+    ASSERT(m_renderer);'), (665, 1, u'+    ASSERT(m_renderer);'), (692, 1, u'+    ASSERT(m_renderer);'), (1965, 1, u'+    ASSERT(isTextControl());'), (1993, 1, u'+    ASSERT(isTextControl());'), (2026, 1, u'+    ASSERT(isTextControl());'), (2287, 1, u'+    ASSERT(m_renderer);'), (2359, 1, u'+            ASSERT(axobj);'), (3226, 1, u'+    ASSERT(m_renderer);'), (3378, 1, u'+    ASSERT(!m_haveChildren);'), (3398, 1, u'+            ASSERT(obj->parentObject() == this);'), (3433, 1, u'+    DEFINE_STATIC_LOCAL(const AtomicString, liveRegionStatusAssertive, ("assertive"));'), (3443, 1, u'+            return liveRegionStatusAssertive;'), (3526, 1, u'+    ASSERT(result.isEmpty());'), (3550, 1, u'+    ASSERT(result.isEmpty());'), (3554, 1, u'+        ASSERT_NOT_REACHED();'), (3562, 1, u'+    ASSERT(roleValue() == TabListRole);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(118, 1, u'+    ASSERT(!m_haveChildren);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+    ASSERT(scrollbar);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(88, 1, u'+    ASSERT(!m_haveChildren);'), (113, 1, u'+        ASSERT(m_children.size() == 1);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(291, 1, u'+    ASSERT(!m_haveChildren);'), (516, 1, u'+    ASSERT(cellObject->isTableCell());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(178, 1, u'+    ASSERT(!m_haveChildren);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(85, 1, u'+    ASSERT(!m_haveChildren);')]
===========================================
Class:class ActiveDOMObjectCallbackImpl : public ActiveDOMObject { class ActiveDOMObjectCallbackImpl : public ActiveDOMObject 
Class: class DestroyOnContextThreadTask : public ScriptExecutionContext::Task { class DestroyOnContextThreadTask : public ScriptExecutionContext::Task 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 1, u'+    ASSERT(targetWindow);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(57, 1, u'+    ASSERT(cacheData);'), (78, 1, u'+        ASSERT(data);'), (121, 1, u'+    ASSERT(data->object);'), (147, 1, u'+    ASSERT(data);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+    ASSERT(m_coreTarget);'), (56, 1, u'+    ASSERT(m_coreTarget);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(52, 1, u'+    ASSERT(node);'), (53, 1, u'+    ASSERT(node->nodeType());'), (126, 1, u'+    ASSERT(target);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+    ASSERT(clientData);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+    ASSERT_UNUSED(jsString, m_world->m_stringCache.find(stringImpl)->second.get() == jsString);'), (54, 1, u'+    ASSERT(clientData);'), (61, 1, u'+    ASSERT(clientData);'), (82, 1, u'+    ASSERT(clientData);'), (88, 1, u'+    ASSERT(isMainThread());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (70, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(93, 1, u'+    ASSERT(audioContext);'), (99, 1, u'+        ASSERT(arrayBuffer);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 1, u'+    ASSERT(*prefix);'), (63, 1, u'+        ASSERT(isASCIILower(*p));'), (64, 1, u'+    ASSERT(propertyName.length());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 1, u'+    ASSERT(callback());'), (48, 1, u'+    ASSERT(globalObject());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(58, 1, u'+    ASSERT(object->is2d());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 1, u'+    JSC::JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 1, u'+    JSC::JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+    JSC::JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(62, 1, u'+    ASSERT(m_data);'), (66, 1, u'+    JSC::JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 1, u'+    ASSERT(m_customResolver);'), (70, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(132, 1, u'+    ASSERT(impl->existingHash());'), (181, 1, u'+    ASSERT(scriptExecutionContext);'), (252, 1, u'+    ASSERT(errorObject);'), (320, 1, u'+    ASSERT(!structures.contains(classInfo));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+    ASSERT(inherits(&s_info));'), (104, 1, u'+    ASSERT_NOT_REACHED();'), (123, 1, u'+    ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(52, 1, u'+    ASSERT(inherits(&s_info));'), (64, 1, u'+    ASSERT(m_impl->document());'), (126, 1, u'+    ASSERT(enabled || !debugger());'), (127, 1, u'+    ASSERT(enabled || !supportsProfiling());'), (134, 1, u'+    ASSERT(impl()->frame());'), (143, 1, u'+    ASSERT(page);'), (172, 1, u'+    ASSERT(isMainThread());')]
===========================================
Class:class DialogHandler { class DialogHandler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSDOMWindowShell);'), (50, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+    ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(95, 1, u'+        ASSERT_NOT_REACHED();'), (142, 1, u'+        ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+#include <wtf/Assertions.h>')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+#include <wtf/Assertions.h>')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 1, u'+    ASSERT(!getCachedWrapper(currentWorld(exec), element));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+#include <wtf/Assertions.h>'), (55, 1, u'+    ASSERT(entry->isDirectory());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+#include <wtf/Assertions.h>'), (55, 1, u'+    ASSERT(entry->isDirectory());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(58, 1, u'+    ASSERT(scriptExecutionContext);'), (64, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(119, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 1, u'+        ASSERT(!function);'), (55, 1, u'+    ASSERT_NOT_REACHED();'), (67, 1, u'+    ASSERT(scriptExecutionContext);'), (71, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(192, 1, u'+    ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(119, 1, u'+    ASSERT(positionCallback);'), (128, 1, u'+    ASSERT(positionOptions);'), (141, 1, u'+    ASSERT(positionCallback);'), (150, 1, u'+    ASSERT(positionOptions);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 1, u'+    ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 1, u'+    ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSImageConstructor);'), (40, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (86, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (84, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (102, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(64, 1, u'+    ASSERT_NOT_REACHED();'), (78, 1, u'+    ASSERT(iter != end);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+    ASSERT(executionContext);'), (74, 1, u'+    ASSERT(executionContext->isDocument());'), (110, 1, u'+            JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(207, 1, u'+    ASSERT(node);'), (208, 1, u'+    ASSERT(!getCachedWrapper(currentWorld(exec), node));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSNodeFilterCondition);'), (42, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(34, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSOptionConstructor);'), (41, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(158, 1, u'+    ASSERT(scriptObject);'), (167, 1, u'+    ASSERT(callType == CallTypeHost);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 1, u'+              ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 1, u'+    ASSERT(element);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(191, 1, u'+    ASSERT_NOT_REACHED();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+ASSERT_CLASS_FITS_IN_CELL(JSWorkerContextBase);'), (52, 1, u'+    ASSERT(inherits(&s_info));'), (77, 1, u'+    ASSERT(contextWrapper);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 1, u'+    ASSERT(m_isValid);'), (69, 1, u'+    ASSERT(m_isValid);'), (77, 1, u'+    ASSERT(m_isValid);'), (88, 1, u'+    ASSERT(m_isValid);'), (96, 1, u'+    ASSERT(m_isValid);'), (105, 1, u'+    ASSERT(m_isValid);'), (109, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 1, u'+    ASSERT_ARG(globalObject, globalObject);'), (81, 1, u'+    ASSERT_ARG(listener, listener);'), (82, 1, u'+    ASSERT_ARG(page, page);'), (97, 1, u'+    ASSERT_ARG(listener, listener);'), (98, 1, u'+    ASSERT_ARG(page, page);'), (115, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (167, 1, u'+    ASSERT_ARG(page, page);'), (177, 1, u'+    ASSERT_ARG(frame, frame);'), (202, 1, u'+    ASSERT(children);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 1, u'+        ASSERT(context->isWorkerContext());'), (87, 1, u'+    ASSERT(context->isDocument());'), (93, 1, u'+    ASSERT(m_function);'), (94, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (144, 1, u'+    ASSERT(workerContext->thread()->threadID() == currentThread());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (76, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (104, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 1, u'+        ASSERT(callFrame);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(104, 1, u'+    ASSERT(m_windowShells.contains(world));'), (111, 1, u'+    ASSERT(!m_windowShells.contains(world));'), (136, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (184, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (214, 1, u'+    ASSERT(!m_windowShells.contains(world));'), (216, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (259, 1, u'+    ASSERT(scriptController);'), (347, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (363, 1, u'+        JSLock lock(SilenceAssertionsOnly);'), (375, 1, u'+        JSLock lock(SilenceAssertionsOnly);'), (407, 1, u'+            JSC::JSLock lock(SilenceAssertionsOnly);'), (409, 1, u'+            ASSERT(win);'), (441, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (476, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(201, 1, u'+    ASSERT(m_paused);'), (208, 1, u'+            JSLock lock(SilenceAssertionsOnly);'), (289, 1, u'+    ASSERT(!listeners->isEmpty());'), (318, 1, u'+        ASSERT(!listeners->isEmpty());'), (334, 1, u'+    ASSERT(m_currentCallFrame);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+    ASSERT(node);'), (55, 1, u'+    ASSERT(attr);'), (80, 1, u'+    ASSERT(attr);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+        ASSERT_NOT_REACHED();'), (61, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (67, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (73, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (84, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (90, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (96, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (102, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (108, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (128, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (166, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (208, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(64, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (72, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (80, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (89, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (103, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (117, 1, u'+        ASSERT_NOT_REACHED();'), (139, 1, u'+                    ASSERT_NOT_REACHED();'), (155, 1, u'+                ASSERT_NOT_REACHED();'), (162, 1, u'+    ASSERT_NOT_REACHED();')]
===========================================
Class:class CloneBase { class CloneBase 
Class: class CloneSerializer : CloneBase { class CloneSerializer : CloneBase 
Class: class CloneDeserializer : CloneBase { class CloneDeserializer : CloneBase 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(70, 1, u'+    ASSERT(!m_workerContextWrapper);'), (72, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (90, 1, u'+        ASSERT(m_workerContext->isSharedWorkerContext());'), (110, 1, u'+        JSLock lock(SilenceAssertionsOnly);'), (122, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (164, 1, u'+    ASSERT(m_workerContext->isContextThread());'), (170, 1, u'+    ASSERT(m_workerContext->isContextThread());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (84, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (102, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (121, 1, u'+    JSLock lock(SilenceAssertionsOnly);')]
===========================================
Class:class JSTestInterfaceConstructor : public DOMConstructorObject { class JSTestInterfaceConstructor : public DOMConstructorObject 
Class:class JSTestMediaQueryListListenerConstructor : public DOMConstructorObject { class JSTestMediaQueryListListenerConstructor : public DOMConstructorObject 
Class:class JSTestObjConstructor : public DOMConstructorObject { class JSTestObjConstructor : public DOMConstructorObject 
Class:class JSTestSerializedScriptValueInterfaceConstructor : public DOMConstructorObject { class JSTestSerializedScriptValueInterfaceConstructor : public DOMConstructorObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+#include <wtf/Assertions.h>')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(1275, 1, u'+COMPILE_ASSERT(0 == TestObj::CONST_VALUE_0, TestObjEnumCONST_VALUE_0IsWrongUseDontCheckEnums);'), (1276, 1, u'+COMPILE_ASSERT(1 == TestObj::CONST_VALUE_1, TestObjEnumCONST_VALUE_1IsWrongUseDontCheckEnums);'), (1277, 1, u'+COMPILE_ASSERT(2 == TestObj::CONST_VALUE_2, TestObjEnumCONST_VALUE_2IsWrongUseDontCheckEnums);'), (1278, 1, u'+COMPILE_ASSERT(4 == TestObj::CONST_VALUE_4, TestObjEnumCONST_VALUE_4IsWrongUseDontCheckEnums);'), (1279, 1, u'+COMPILE_ASSERT(8 == TestObj::CONST_VALUE_8, TestObjEnumCONST_VALUE_8IsWrongUseDontCheckEnums);'), (1280, 1, u'+COMPILE_ASSERT(-1 == TestObj::CONST_VALUE_9, TestObjEnumCONST_VALUE_9IsWrongUseDontCheckEnums);'), (1281, 1, u'+COMPILE_ASSERT("my constant string" == TestObj::CONST_VALUE_10, TestObjEnumCONST_VALUE_10IsWrongUseDontCheckEnums);'), (1282, 1, u'+COMPILE_ASSERT(0xffffffff == TestObj::CONST_VALUE_11, TestObjEnumCONST_VALUE_11IsWrongUseDontCheckEnums);'), (1283, 1, u'+COMPILE_ASSERT(0x01 == TestObj::CONST_VALUE_12, TestObjEnumCONST_VALUE_12IsWrongUseDontCheckEnums);'), (1284, 1, u'+COMPILE_ASSERT(0X20 == TestObj::CONST_VALUE_13, TestObjEnumCONST_VALUE_13IsWrongUseDontCheckEnums);'), (1285, 1, u'+COMPILE_ASSERT(0x1abc == TestObj::CONST_VALUE_14, TestObjEnumCONST_VALUE_14IsWrongUseDontCheckEnums);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(72, 1, u'+        ASSERT(!result.first->second);'), (91, 1, u'+    ASSERT(name);'), (98, 1, u'+        ASSERT(!result.first->second);')]
===========================================
Class: class ObjectMap { class ObjectMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 1, u'+    ASSERT(inherits(&s_info));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+    JSLock lock(SilenceAssertionsOnly);'), (92, 1, u'+            JSLock lock(SilenceAssertionsOnly);'), (113, 1, u'+            JSLock lock(SilenceAssertionsOnly);')]
===========================================
Class:Class *CInstance::getClass() const Class *CInstance::getClass() const
