projects/top_C++/YouCompleteMe
Going to process projects/top_C++/YouCompleteMe/all_log.txt 
---------- YouCompleteMe ------------

Class:    class     class
Class:  class codecvt_error_cat : public boost::system::error_category   class codecvt_error_cat : public boost::system::error_category
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(441, 2, u'-      BOOST_ASSERT(infile >= 0);'), (850, 2, u'-    BOOST_ASSERT_MSG(result.is_absolute(), "canonical() implementation error; please report");'), (1374, 2, u'-    BOOST_ASSERT_MSG(!((prms & add_perms) && (prms & remove_perms)),'), (1974, 2, u'-    BOOST_ASSERT(buffer != 0);'), (2182, 2, u'-    BOOST_ASSERT_MSG(it.m_imp.get(), "attempt to increment end iterator");'), (2183, 2, u'-    BOOST_ASSERT_MSG(it.m_imp->handle != 0, "internal program error");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(470, 2, u'-    BOOST_ASSERT_MSG(!str.empty() && is_separator(str[pos]),'), (653, 2, u'-        BOOST_ASSERT(first2->native() == first1->native());'), (691, 2, u'-    BOOST_ASSERT_MSG(it.m_pos < it.m_path_ptr->m_pathname.size(),'), (750, 2, u'-    BOOST_ASSERT_MSG(it.m_pos, "path::iterator decrement past begin()");'), (888, 2, u'-    BOOST_ASSERT_MSG(codecvt_facet_ptr(), "codecvt_facet_ptr() facet hasn\'t been properly initialized");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(138, 2, u'-    BOOST_ASSERT(from);'), (172, 2, u'-    BOOST_ASSERT(from);')]
===========================================
Class:  template <class T, class SlotPolicy>   template <class T, class SlotPolicy>
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(164, 2, u'-          assert(p != visited.end());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(197, 2, u'-          assert(entries().invariants());'), (212, 2, u'-      assert(slot->m_to_python == 0); // we have a problem otherwise')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(130, 2, u'-          assert(status != -3); // invalid argument error')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(306, 2, u'-    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self)), &class_metatype_object));'), (551, 2, u'-      assert(num_types >= 1);'), (576, 2, u'-      assert(PyType_IsSubtype(Py_TYPE(result.ptr()), &PyType_Type));'), (731, 2, u'-    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self_)), &class_metatype_object));'), (739, 2, u'-        assert(holder_offset >= offsetof(objects::instance<>,storage));'), (756, 2, u'-    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self_)), &class_metatype_object));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(169, 2, u'-                        assert(max_arity <= static_cast<std::size_t>(ssize_t_max));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(217, 2, u'-      assert(v == v2);'), (482, 2, u'-        assert(added);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(147, 2, u'-   BOOST_ASSERT(std::size_t(idx+1) < sizeof(masks) / sizeof(masks[0]));')]
===========================================
Class:class RegExData class RegExData
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(132, 2, u'-      BOOST_REGEX_NOEH_ASSERT(hfile != INVALID_HANDLE_VALUE);'), (243, 2, u'-   BOOST_ASSERT(node >= _first);'), (244, 2, u'-   BOOST_ASSERT(node <= _last);'), (276, 2, u'-        BOOST_REGEX_NOEH_ASSERT((0 == std::ferror(hfile)) && (read_size != 0));'), (294, 2, u'-   BOOST_ASSERT(node >= _first);'), (295, 2, u'-   BOOST_ASSERT(node <= _last);'), (423, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (425, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)'), (430, 2, u'-   BOOST_REGEX_NOEH_ASSERT(ref)'), (453, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (455, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)'), (476, 2, u'-   BOOST_REGEX_NOEH_ASSERT(ref)'), (511, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (513, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)'), (601, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (603, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)'), (608, 2, u'-   BOOST_REGEX_NOEH_ASSERT(ref)'), (631, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (633, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)'), (655, 2, u'-   BOOST_REGEX_NOEH_ASSERT(ref)'), (701, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (703, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(426, 2, u'-   BOOST_ASSERT(std::size_t(idx+1) < sizeof(masks) / sizeof(masks[0]));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-   BOOST_REGEX_NOEH_ASSERT(ptr)'), (63, 2, u'-   BOOST_ASSERT(pos <= size_type(end - start));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(373, 2, u'-      regex_constants::escape_type_not_word_assert,  /*B*/'), (405, 2, u'-      regex_constants::escape_type_word_assert,        /*b*/')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 2, u'-BOOST_STATIC_ASSERT(sizeof(LONG) == sizeof(boost::int32_t));'), (137, 2, u'-   BOOST_ASSERT(0 == r);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(123, 2, u'-   BOOST_ASSERT(r != 0);'), (126, 2, u'-   BOOST_ASSERT(code_page != 0);'), (130, 2, u'-   BOOST_ASSERT(conv_r != 0);'), (134, 2, u'-   BOOST_ASSERT(r != 0);'), (137, 2, u'-   BOOST_ASSERT(conv_r != 0);'), (152, 2, u'-   BOOST_ASSERT(0 != r);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(187, 2, u'-   BOOST_ASSERT(idx+1 < static_cast<int>(sizeof(masks) / sizeof(masks[0])));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(108, 2, u'-        BOOST_ASSERT(false);')]
===========================================
Class:class basic_iarchive_impl { class basic_iarchive_impl 
Class:    class cobject_id     class cobject_id
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(316, 2, u'-        BOOST_ASSERT(cobject_info_set.size() == cobject_id_vector.size());'), (454, 2, u'-        BOOST_ASSERT(NULL != bpis_ptr);'), (458, 2, u'-        BOOST_ASSERT(new_cid == cid);'), (505, 2, u'-        BOOST_ASSERT(NULL != t);')]
===========================================
Class:class basic_oarchive_impl { class basic_oarchive_impl 
Class:    class bosarg :     class bosarg :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(62, 2, u'-            BOOST_ASSERT(NULL != address);'), (63, 2, u'-            BOOST_ASSERT(NULL != rhs.address);'), (181, 2, u'-            BOOST_ASSERT(false);'), (186, 2, u'-            BOOST_ASSERT(false);'), (191, 2, u'-            BOOST_ASSERT(false);'), (196, 2, u'-            BOOST_ASSERT(false);'), (202, 2, u'-            BOOST_ASSERT(false);')]
===========================================
Class:        class extended_type_info;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 2, u'-        BOOST_ASSERT(false);')]
===========================================
Class:template class basic_binary_iprimitive< template class basic_binary_iprimitive<
Class:template class binary_iarchive_impl< template class binary_iarchive_impl<
Class:template class basic_binary_oprimitive< template class basic_binary_oprimitive<
Class:template class binary_oarchive_impl< template class binary_oarchive_impl<
Class:template class basic_binary_iprimitive< template class basic_binary_iprimitive<
Class:template class binary_iarchive_impl< template class binary_iarchive_impl<
Class:template class basic_binary_oprimitive< template class basic_binary_oprimitive<
Class:template class binary_oarchive_impl< template class binary_oarchive_impl<
Class:class extended_type_info_arg : public extended_type_info class extended_type_info_arg : public extended_type_info
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 2, u'-    BOOST_ASSERT(NULL != l);'), (56, 2, u'-    BOOST_ASSERT(NULL != r);'), (69, 2, u'-    BOOST_ASSERT(NULL != l);'), (73, 2, u'-    BOOST_ASSERT(NULL != r);')]
===========================================
Class:class extended_type_info_typeid_arg : class extended_type_info_typeid_arg :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 2, u'-        BOOST_ASSERT(result.second);')]
===========================================
Class:class void_caster_shortcut : public void_caster class void_caster_shortcut : public void_caster
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-            BOOST_ASSERT(false);')]
===========================================
Class:    class X;
Class:  class generic_error_category : public error_category   class generic_error_category : public error_category
Class:    class  future_error_category :     class  future_error_category :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 2, u'-    BOOST_STATIC_ASSERT_MSG(sizeof(atomic_int_type) == sizeof(atomic_type), "Boost.Thread: unsupported platform");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(203, 2, u'-              BOOST_ASSERT(notify.empty());'), (205, 2, u'-              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 2, u'-            BOOST_ASSERT(current_thread_tls_key!=TLS_OUT_OF_INDEXES);'), (283, 2, u'-              BOOST_ASSERT(notify.empty());'), (285, 2, u'-              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 2, u'-namespace assert_ns'), (38, 2, u'-Assert::FailBehavior DefaultHandler(const char* condition,'), (53, 2, u'-  return Assert::Halt;'), (56, 2, u'-Assert::Handler& GetAssertHandlerInstance()'), (58, 2, u'-  static Assert::Handler s_handler = &DefaultHandler;'), (64, 2, u'-Assert::Handler Assert::GetHandler()'), (66, 2, u'-  return GetAssertHandlerInstance();'), (69, 2, u'-void Assert::SetHandler(Assert::Handler newHandler)'), (71, 2, u'-  GetAssertHandlerInstance() = newHandler;'), (74, 2, u'-Assert::FailBehavior Assert::ReportFailure(const char* condition,'), (99, 2, u'-  return GetAssertHandlerInstance()(condition, message, file, line);')]
===========================================
Class:class TranslationUnitTest : public ::testing::Test { class TranslationUnitTest : public ::testing::Test 
Class:class Water { class Water 
Class:     class LeakChecker : public EmptyTestEventListener { class LeakChecker : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 2, u'-    ASSERT_EQ(q->Size(), new_q->Size());'), (134, 2, u'-  ASSERT_TRUE(n != NULL);'), (140, 2, u'-  ASSERT_TRUE(n != NULL);')]
===========================================
Class:     class IntegerFunctionTest : public QuickTest { class IntegerFunctionTest : public QuickTest 
Class:        class QueueTest : public QuickTest { class QueueTest : public QuickTest 
Class:  template <class T> class PrimeTableTest : public testing::Test { class PrimeTableTest : public testing::Test 
Class:                 template <class T> class PrimeTableTest2 : public PrimeTableTest<T> { class PrimeTableTest2 : public PrimeTableTest<T> 
Class:     class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> { class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> 
Class:      class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > { class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > 
Class:class TersePrinter : public EmptyTestEventListener { class TersePrinter : public EmptyTestEventListener 
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class TestNameIs { class TestNameIs 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class: class TestException : public std::exception { class TestException : public std::exception 
Class:class ReplaceDeathTestFactory { class ReplaceDeathTestFactory 
Class:   class TestForDeathTest : public testing::Test { class TestForDeathTest : public testing::Test 
Class:  class MayDie { class MayDie 
Class:  class MockDeathTestFactory : public DeathTestFactory { class MockDeathTestFactory : public DeathTestFactory 
Class:      class MockDeathTest : public DeathTest { class MockDeathTest : public DeathTest 
Class:    class MacroLogicDeathTest : public testing::Test { class MacroLogicDeathTest : public testing::Test 
Class:class DirectoryCreationTest : public Test { class DirectoryCreationTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(98, 2, u'-  ASSERT_TRUE(cwd_without_drive != NULL);')]
===========================================
Class:class A { class A 
Class:  class B : public A { class B : public A 
Class: class LinkedPtrTest : public testing::Test { class LinkedPtrTest : public testing::Test 
Class:class EventRecordingListener : public TestEventListener { class EventRecordingListener : public TestEventListener 
Class:class XmlOutputChangeDirTest : public Test { class XmlOutputChangeDirTest : public Test 
Class:   class DogAdder { class DogAdder 
Class: class IntWrapper { class IntWrapper 
Class:          template <int kExpectedCalls> class TestGenerationEnvironment : public ::testing::Environment { class TestGenerationEnvironment : public ::testing::Environment 
Class: class TestGenerationTest : public TestWithParam<int> { class TestGenerationTest : public TestWithParam<int> 
Class:           class GeneratorEvaluationTest : public TestWithParam<int> { class GeneratorEvaluationTest : public TestWithParam<int> 
Class:class ExternalGeneratorTest : public TestWithParam<int> 
Class:class MultipleInstantiationTest : public TestWithParam<int> 
Class:   class SeparateInstanceTest : public TestWithParam<int> { class SeparateInstanceTest : public TestWithParam<int> 
Class:class NamingTest : public TestWithParam<int> 
Class:     class Unstreamable { class Unstreamable 
Class:class CommentTest : public TestWithParam<Unstreamable> 
Class:     class NonParameterizedBaseTest : public ::testing::Test { class NonParameterizedBaseTest : public ::testing::Test 
Class: class ParameterizedDerivedTest : public NonParameterizedBaseTest,                                  public ::testing::WithParamInterface<int> {                                  public ::testing::WithParamInterface<int> 
Class:class Base { class Base 
Class:  class BiggestIntConvertible { class BiggestIntConvertible 
Class:  template <typename T> class UnprintableTemplateInGlobal { class UnprintableTemplateInGlobal 
Class:  class StreamableInGlobal { class StreamableInGlobal 
Class:class UnprintableInFoo { class UnprintableInFoo 
Class:  template <typename T> class PrintableViaPrintToTemplate { class PrintableViaPrintToTemplate 
Class:  template <typename T> class StreamableTemplateInFoo { class StreamableTemplateInFoo 
Class:class AllowsGenericStreaming 
Class:class AllowsGenericStreamingTemplate 
Class:    template <typename T> class AllowsGenericStreamingAndImplicitConversionTemplate { class AllowsGenericStreamingAndImplicitConversionTemplate 
Class:class TestPartResultTest : public Test { class TestPartResultTest : public Test 
Class:   class TestPartResultArrayTest : public Test { class TestPartResultArrayTest : public Test 
Class:class BigTupleTest : public testing::Test { class BigTupleTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 2, u'-using ::testing::StaticAssertTypeEq;'), (47, 2, u'-  StaticAssertTypeEq<int, tuple_element<0, tuple<int, char> >::type>();'), (48, 2, u'-  StaticAssertTypeEq<int&, tuple_element<1, tuple<double, int&> >::type>();'), (49, 2, u'-  StaticAssertTypeEq<bool, tuple_element<2, tuple<double, int, bool> >::type>();')]
===========================================
Class:    template <typename T> class CommonTest : public Test { class CommonTest : public Test 
Class:    template <typename T> class TypedTest1 : public Test { class TypedTest1 : public Test 
Class: template <typename T> class TypedTest2 : public Test { class TypedTest2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
Class:   class TypedTestCasePStateTest : public Test { class TypedTestCasePStateTest : public Test 
Class:    template <typename T> class DerivedTest : public CommonTest<T> { class DerivedTest : public CommonTest<T> 
Class:    template <typename T> class TypedTestP1 : public Test { class TypedTestP1 : public Test 
Class: template <typename T> class TypedTestP2 : public Test { class TypedTestP2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(120, 2, u'-  ASSERT_TRUE(this->shared_ != NULL);'), (257, 2, u'-  ASSERT_TRUE(this->shared_ != NULL);')]
===========================================
Class:class UnitTestHelper { class UnitTestHelper 
Class:class FinalSuccessChecker : public Environment { class FinalSuccessChecker : public Environment 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 2, u'-  ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (140, 2, u'-AssertionResult IsNull(const char* str) {'), (142, 2, u'-    return testing::AssertionFailure() << "argument is " << str;'), (144, 2, u'-  return AssertionSuccess();'), (149, 2, u'-  ASSERT_TRUE(test_case != NULL);'), (156, 2, u'-  ASSERT_EQ(4, test_case->total_test_count());'), (189, 2, u'-  ASSERT_TRUE(test_case != NULL);'), (196, 2, u'-  ASSERT_EQ(1, test_case->total_test_count());'), (212, 2, u'-  ASSERT_TRUE(test_case != NULL);'), (219, 2, u'-  ASSERT_EQ(1, test_case->total_test_count());'), (245, 2, u'-    ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (253, 2, u'-    ASSERT_EQ(4, test_cases[0]->total_test_count());'), (263, 2, u'-    ASSERT_EQ(1, test_cases[1]->total_test_count());'), (272, 2, u'-    ASSERT_EQ(1, test_cases[2]->total_test_count());')]
===========================================
Class: class SehExceptionInDestructorTest : public Test { class SehExceptionInDestructorTest : public Test 
Class: class SehExceptionInSetUpTestCaseTest : public Test { class SehExceptionInSetUpTestCaseTest : public Test 
Class: class SehExceptionInTearDownTestCaseTest : public Test { class SehExceptionInTearDownTestCaseTest : public Test 
Class: class SehExceptionInSetUpTest : public Test { class SehExceptionInSetUpTest : public Test 
Class: class SehExceptionInTearDownTest : public Test { class SehExceptionInTearDownTest : public Test 
Class: class CxxExceptionInTearDownTestCaseTest : public Test { class CxxExceptionInTearDownTestCaseTest : public Test 
Class: class CxxExceptionInSetUpTest : public Test { class CxxExceptionInSetUpTest : public Test 
Class: class CxxExceptionInTearDownTest : public Test { class CxxExceptionInTearDownTest : public Test 
Class: class CxxExceptionInTestBodyTest : public Test { class CxxExceptionInTestBodyTest : public Test 
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 2, u'-  ASSERT_TRUE(false) << "Tests shouldn\'t be run when --help is specified.";')]
===========================================
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
Class:class FailingParamTest : public testing::TestWithParam<int> 
Class:  class NonFatalFailureInFixtureConstructorTest : public testing::Test { class NonFatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class FatalFailureInFixtureConstructorTest : public testing::Test { class FatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class NonFatalFailureInSetUpTest : public testing::Test { class NonFatalFailureInSetUpTest : public testing::Test 
Class:  class FatalFailureInSetUpTest : public testing::Test { class FatalFailureInSetUpTest : public testing::Test 
Class:    class DeathTestAndMultiThreadsTest : public testing::Test { class DeathTestAndMultiThreadsTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class: class TEST_before_TEST_F_in_same_test_case : public testing::Test { class TEST_before_TEST_F_in_same_test_case : public testing::Test 
Class:    class FooEnvironment : public testing::Environment { class FooEnvironment : public testing::Environment 
Class: class BarEnvironment : public testing::Environment { class BarEnvironment : public testing::Environment 
Class:   class Predicate1Test : public testing::Test { class Predicate1Test : public testing::Test 
Class:   class Predicate2Test : public testing::Test { class Predicate2Test : public testing::Test 
Class:   class Predicate3Test : public testing::Test { class Predicate3Test : public testing::Test 
Class:   class Predicate4Test : public testing::Test { class Predicate4Test : public testing::Test 
Class:   class Predicate5Test : public testing::Test { class Predicate5Test : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 2, u'-testing::AssertionResult PredFormatFunction1(const char* e1,'), (104, 2, u'-    return testing::AssertionSuccess();'), (106, 2, u'-  return testing::AssertionFailure()'), (115, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (161, 2, u'-typedef Predicate1Test ASSERT_PRED_FORMAT1Test;'), (163, 2, u'-typedef Predicate1Test ASSERT_PRED1Test;'), (239, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeSuccess) {'), (240, 2, u'-  ASSERT_PRED1(PredFunction1Int,'), (247, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeSuccess) {'), (248, 2, u'-  ASSERT_PRED1(PredFunction1Bool,'), (255, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeSuccess) {'), (256, 2, u'-  ASSERT_PRED1(PredFunctor1(),'), (263, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeSuccess) {'), (264, 2, u'-  ASSERT_PRED1(PredFunctor1(),'), (271, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeFailure) {'), (274, 2, u'-    ASSERT_PRED1(PredFunction1Int,'), (282, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeFailure) {'), (285, 2, u'-    ASSERT_PRED1(PredFunction1Bool,'), (293, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeFailure) {'), (296, 2, u'-    ASSERT_PRED1(PredFunctor1(),'), (304, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeFailure) {'), (307, 2, u'-    ASSERT_PRED1(PredFunctor1(),'), (387, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeSuccess) {'), (388, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (395, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeSuccess) {'), (396, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (403, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeSuccess) {'), (404, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (411, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeSuccess) {'), (412, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (419, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeFailure) {'), (422, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (430, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeFailure) {'), (433, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (441, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeFailure) {'), (444, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (452, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeFailure) {'), (455, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (489, 2, u'-testing::AssertionResult PredFormatFunction2(const char* e1,'), (494, 2, u'-    return testing::AssertionSuccess();'), (496, 2, u'-  return testing::AssertionFailure()'), (505, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (558, 2, u'-typedef Predicate2Test ASSERT_PRED_FORMAT2Test;'), (560, 2, u'-typedef Predicate2Test ASSERT_PRED2Test;'), (644, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeSuccess) {'), (645, 2, u'-  ASSERT_PRED2(PredFunction2Int,'), (653, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeSuccess) {'), (654, 2, u'-  ASSERT_PRED2(PredFunction2Bool,'), (662, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeSuccess) {'), (663, 2, u'-  ASSERT_PRED2(PredFunctor2(),'), (671, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeSuccess) {'), (672, 2, u'-  ASSERT_PRED2(PredFunctor2(),'), (680, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeFailure) {'), (683, 2, u'-    ASSERT_PRED2(PredFunction2Int,'), (692, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeFailure) {'), (695, 2, u'-    ASSERT_PRED2(PredFunction2Bool,'), (704, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeFailure) {'), (707, 2, u'-    ASSERT_PRED2(PredFunctor2(),'), (716, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeFailure) {'), (719, 2, u'-    ASSERT_PRED2(PredFunctor2(),'), (808, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeSuccess) {'), (809, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (817, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeSuccess) {'), (818, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (826, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeSuccess) {'), (827, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (835, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeSuccess) {'), (836, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (844, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeFailure) {'), (847, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (856, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeFailure) {'), (859, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (868, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeFailure) {'), (871, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (880, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeFailure) {'), (883, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (919, 2, u'-testing::AssertionResult PredFormatFunction3(const char* e1,'), (926, 2, u'-    return testing::AssertionSuccess();'), (928, 2, u'-  return testing::AssertionFailure()'), (937, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (997, 2, u'-typedef Predicate3Test ASSERT_PRED_FORMAT3Test;'), (999, 2, u'-typedef Predicate3Test ASSERT_PRED3Test;'), (1091, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeSuccess) {'), (1092, 2, u'-  ASSERT_PRED3(PredFunction3Int,'), (1101, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeSuccess) {'), (1102, 2, u'-  ASSERT_PRED3(PredFunction3Bool,'), (1111, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeSuccess) {'), (1112, 2, u'-  ASSERT_PRED3(PredFunctor3(),'), (1121, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeSuccess) {'), (1122, 2, u'-  ASSERT_PRED3(PredFunctor3(),'), (1131, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeFailure) {'), (1134, 2, u'-    ASSERT_PRED3(PredFunction3Int,'), (1144, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeFailure) {'), (1147, 2, u'-    ASSERT_PRED3(PredFunction3Bool,'), (1157, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeFailure) {'), (1160, 2, u'-    ASSERT_PRED3(PredFunctor3(),'), (1170, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeFailure) {'), (1173, 2, u'-    ASSERT_PRED3(PredFunctor3(),'), (1271, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeSuccess) {'), (1272, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1281, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeSuccess) {'), (1282, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1291, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeSuccess) {'), (1292, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1301, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeSuccess) {'), (1302, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1311, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeFailure) {'), (1314, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1324, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeFailure) {'), (1327, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1337, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeFailure) {'), (1340, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1350, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeFailure) {'), (1353, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1391, 2, u'-testing::AssertionResult PredFormatFunction4(const char* e1,'), (1400, 2, u'-    return testing::AssertionSuccess();'), (1402, 2, u'-  return testing::AssertionFailure()'), (1411, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (1478, 2, u'-typedef Predicate4Test ASSERT_PRED_FORMAT4Test;'), (1480, 2, u'-typedef Predicate4Test ASSERT_PRED4Test;'), (1580, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeSuccess) {'), (1581, 2, u'-  ASSERT_PRED4(PredFunction4Int,'), (1591, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeSuccess) {'), (1592, 2, u'-  ASSERT_PRED4(PredFunction4Bool,'), (1602, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeSuccess) {'), (1603, 2, u'-  ASSERT_PRED4(PredFunctor4(),'), (1613, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeSuccess) {'), (1614, 2, u'-  ASSERT_PRED4(PredFunctor4(),'), (1624, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeFailure) {'), (1627, 2, u'-    ASSERT_PRED4(PredFunction4Int,'), (1638, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeFailure) {'), (1641, 2, u'-    ASSERT_PRED4(PredFunction4Bool,'), (1652, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeFailure) {'), (1655, 2, u'-    ASSERT_PRED4(PredFunctor4(),'), (1666, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeFailure) {'), (1669, 2, u'-    ASSERT_PRED4(PredFunctor4(),'), (1776, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeSuccess) {'), (1777, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1787, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeSuccess) {'), (1788, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1798, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeSuccess) {'), (1799, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1809, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeSuccess) {'), (1810, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1820, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeFailure) {'), (1823, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1834, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeFailure) {'), (1837, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1848, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeFailure) {'), (1851, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1862, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeFailure) {'), (1865, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1905, 2, u'-testing::AssertionResult PredFormatFunction5(const char* e1,'), (1916, 2, u'-    return testing::AssertionSuccess();'), (1918, 2, u'-  return testing::AssertionFailure()'), (1927, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (2001, 2, u'-typedef Predicate5Test ASSERT_PRED_FORMAT5Test;'), (2003, 2, u'-typedef Predicate5Test ASSERT_PRED5Test;'), (2111, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeSuccess) {'), (2112, 2, u'-  ASSERT_PRED5(PredFunction5Int,'), (2123, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeSuccess) {'), (2124, 2, u'-  ASSERT_PRED5(PredFunction5Bool,'), (2135, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeSuccess) {'), (2136, 2, u'-  ASSERT_PRED5(PredFunctor5(),'), (2147, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeSuccess) {'), (2148, 2, u'-  ASSERT_PRED5(PredFunctor5(),'), (2159, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeFailure) {'), (2162, 2, u'-    ASSERT_PRED5(PredFunction5Int,'), (2174, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeFailure) {'), (2177, 2, u'-    ASSERT_PRED5(PredFunction5Bool,'), (2189, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeFailure) {'), (2192, 2, u'-    ASSERT_PRED5(PredFunctor5(),'), (2204, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeFailure) {'), (2207, 2, u'-    ASSERT_PRED5(PredFunctor5(),'), (2323, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeSuccess) {'), (2324, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2335, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeSuccess) {'), (2336, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2347, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeSuccess) {'), (2348, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2359, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeSuccess) {'), (2360, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2371, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeFailure) {'), (2374, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2386, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeFailure) {'), (2389, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2401, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeFailure) {'), (2404, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2416, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeFailure) {'), (2419, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),')]
===========================================
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class MyParamTest : public testing::TestWithParam<int> 
Class:class A : public Test 
Class:   class TestNamePrinter : public EmptyTestEventListener { class TestNamePrinter : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-TEST(NoFatalFailureTest, AssertNoFatalFailure) {'), (51, 2, u'-  ASSERT_NO_FATAL_FAILURE(;);'), (52, 2, u'-  ASSERT_NO_FATAL_FAILURE(SUCCEED());'), (53, 2, u'-  ASSERT_NO_FATAL_FAILURE(Subroutine());'), (54, 2, u'-  ASSERT_NO_FATAL_FAILURE({ SUCCEED(); });')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 2, u'-  ASSERT_TRUE(property != properties.end())'), (90, 2, u'-void ManyAsserts(int id) {'), (100, 2, u'-    ASSERT_FALSE(false) << "This shouldn\'t fail.";'), (102, 2, u'-    ASSERT_LE(5, 6);'), (128, 2, u'-TEST(StressTest, CanUseScopedTraceAndAssertionsInManyThreads) {'), (133, 2, u'-      threads[i].reset(new ThreadWithParam<int>(&ManyAsserts,'), (186, 2, u'-void AssertNoFatalFailureIgnoresFailuresInOtherThreads() {'), (187, 2, u'-  ASSERT_NO_FATAL_FAILURE(GenerateFatalFailureInAnotherThread(true));'), (189, 2, u'-TEST(NoFatalFailureTest, AssertNoFatalFailureIgnoresFailuresInOtherThreads) {'), (191, 2, u'-  AssertNoFatalFailureIgnoresFailuresInOtherThreads();')]
===========================================
Class:class TestEventListenersAccessor { class TestEventListenersAccessor 
Class:class SubClassOfTest : public Test 
Class:class AnotherSubClassOfTest : public Test 
Class:       class FormatEpochTimeInMillisAsIso8601Test : public Test { class FormatEpochTimeInMillisAsIso8601Test : public Test 
Class: class VectorShuffleTest : public Test { class VectorShuffleTest : public Test 
Class: class ScopedFakeTestPartResultReporterTest : public Test { class ScopedFakeTestPartResultReporterTest : public Test 
Class:    class TestResultTest : public Test { class TestResultTest : public Test 
Class:   class GTestFlagSaverTest : public Test { class GTestFlagSaverTest : public Test 
Class: class ShouldShardTest : public testing::Test { class ShouldShardTest : public testing::Test 
Class:   class DisabledTestsTest : public Test { class DisabledTestsTest : public Test 
Class: template <typename T> class DISABLED_TypedTest : public Test { class DISABLED_TypedTest : public Test 
Class: template <typename T> class DISABLED_TypedTestP : public Test { class DISABLED_TypedTestP : public Test 
Class:  class Uncopyable { class Uncopyable 
Class:class UnprintableChar { class UnprintableChar 
Class:     class Foo { class Foo 
Class:  class FRIEND_TEST_Test2 : public Test { class FRIEND_TEST_Test2 : public Test 
Class:       class TestLifeCycleTest : public Test { class TestLifeCycleTest : public Test 
Class:   class Base { class Base 
Class:class MyTypeInUnnamedNameSpace : public Base { class MyTypeInUnnamedNameSpace : public Base 
Class:class MyTypeInNameSpace1 : public Base { class MyTypeInNameSpace1 : public Base 
Class:class MyTypeInNameSpace2 : public ::Base { class MyTypeInNameSpace2 : public ::Base 
Class:class TestInfoTest : public Test { class TestInfoTest : public Test 
Class:   class SetUpTestCaseTest : public Test { class SetUpTestCaseTest : public Test 
Class:  class InitGoogleTestTest : public Test { class InitGoogleTestTest : public Test 
Class:class Test 
Class:class Message 
Class:class AssertionResult 
Class:   template <typename T> class StaticAssertTypeEqTestHelper { class StaticAssertTypeEqTestHelper 
Class: class TestListener : public EmptyTestEventListener { class TestListener : public EmptyTestEventListener 
Class:    class SequenceTestingListener : public EmptyTestEventListener { class SequenceTestingListener : public EmptyTestEventListener 
Class:class ConversionHelperBase 
Class:class ConversionHelperDerived : public ConversionHelperBase 
Class:class NonContainer 
Class: class SuccessfulTest : public Test { class SuccessfulTest : public Test 
Class: class FailedTest : public Test { class FailedTest : public Test 
Class: class DisabledTest : public Test { class DisabledTest : public Test 
Class: class PropertyRecordingTest : public Test { class PropertyRecordingTest : public Test 
Class:class ValueParamTest : public TestWithParam<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 2, u'-  ASSERT_EQ(1, 1);'), (62, 2, u'-  ASSERT_EQ(1, 2);'), (74, 2, u'-  ASSERT_EQ(1, 1);'), (79, 2, u'-  ASSERT_EQ(2, 3);')]
===========================================
Class:class BetweenCardinalityImpl : public CardinalityInterface { class BetweenCardinalityImpl : public CardinalityInterface 
Class:class GoogleTestFailureReporter : public FailureReporterInterface { class GoogleTestFailureReporter : public FailureReporterInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 2, u'-    AssertHelper(type == kFatal ?')]
===========================================
Class:class MockObjectRegistry { class MockObjectRegistry 
Class:class MyActionImpl : public ActionInterface<MyFunction> { class MyActionImpl : public ActionInterface<MyFunction> 
Class:    class IsNotZero : public ActionInterface<bool(int)> {   class IsNotZero : public ActionInterface<bool(int)> 
Class:   class ReturnZeroFromNullaryFunctionAction { class ReturnZeroFromNullaryFunctionAction 
Class:     class FromType { class FromType 
Class: class ToType { class ToType 
Class:class DestinationType 
Class: class SourceType { class SourceType 
Class:class MyClass 
Class: class MockClass { class MockClass 
Class: class NullaryFunctor { class NullaryFunctor 
Class: class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:class MockFoo { class MockFoo 
Class:    class EvenCardinality : public CardinalityInterface { class EvenCardinality : public CardinalityInterface 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class SubstractAction : public ActionInterface<int(int, int)> {   class SubstractAction : public ActionInterface<int(int, int)> 
Class: class NullaryConstructorClass { class NullaryConstructorClass 
Class: class UnaryConstructorClass { class UnaryConstructorClass 
Class: class TenArgConstructorClass { class TenArgConstructorClass 
Class:  class BoolResetter { class BoolResetter 
Class:class FooInterface { class FooInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 2, u'-using ::testing::internal::CompileAssertTypesEqual;'), (52, 2, u'-  CompileAssertTypesEqual<tuple<>, MatcherTuple<tuple<> >::type>();'), (56, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<int> >,'), (61, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char> >,'), (66, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char>, Matcher<bool>,'), (76, 2, u'-  CompileAssertTypesEqual<int, F::Result>();'), (77, 2, u'-  CompileAssertTypesEqual<tuple<>, F::ArgumentTuple>();'), (78, 2, u'-  CompileAssertTypesEqual<tuple<>, F::ArgumentMatcherTuple>();'), (79, 2, u'-  CompileAssertTypesEqual<void(), F::MakeResultVoid>();'), (80, 2, u'-  CompileAssertTypesEqual<IgnoredValue(), F::MakeResultIgnoredValue>();'), (85, 2, u'-  CompileAssertTypesEqual<int, F::Result>();'), (86, 2, u'-  CompileAssertTypesEqual<bool, F::Argument1>();'), (87, 2, u'-  CompileAssertTypesEqual<tuple<bool>, F::ArgumentTuple>();'), (88, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<bool> >, F::ArgumentMatcherTuple>();'), (89, 2, u'-  CompileAssertTypesEqual<void(bool), F::MakeResultVoid>();  // NOLINT'), (90, 2, u'-  CompileAssertTypesEqual<IgnoredValue(bool),  // NOLINT'), (96, 2, u'-  CompileAssertTypesEqual<int, F::Result>();'), (97, 2, u'-  CompileAssertTypesEqual<bool, F::Argument1>();'), (98, 2, u'-  CompileAssertTypesEqual<const long&, F::Argument2>();  // NOLINT'), (99, 2, u'-  CompileAssertTypesEqual<tuple<bool, const long&>, F::ArgumentTuple>();  // NOLINT'), (100, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<const long&> >,  // NOLINT'), (102, 2, u'-  CompileAssertTypesEqual<void(bool, const long&), F::MakeResultVoid>();  // NOLINT'), (103, 2, u'-  CompileAssertTypesEqual<IgnoredValue(bool, const long&),  // NOLINT'), (109, 2, u'-  CompileAssertTypesEqual<char, F::Result>();'), (110, 2, u'-  CompileAssertTypesEqual<bool, F::Argument1>();'), (111, 2, u'-  CompileAssertTypesEqual<int, F::Argument2>();'), (112, 2, u'-  CompileAssertTypesEqual<char*, F::Argument3>();'), (113, 2, u'-  CompileAssertTypesEqual<int&, F::Argument4>();'), (114, 2, u'-  CompileAssertTypesEqual<const long&, F::Argument5>();  // NOLINT'), (115, 2, u'-  CompileAssertTypesEqual<tuple<bool, int, char*, int&, const long&>,  // NOLINT'), (117, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<int>, Matcher<char*>,'), (120, 2, u'-  CompileAssertTypesEqual<void(bool, int, char*, int&, const long&),  // NOLINT'), (122, 2, u'-  CompileAssertTypesEqual<')]
===========================================
Class:class LessThanMatcher : public MatcherInterface<tuple<char, int> > { class LessThanMatcher : public MatcherInterface<tuple<char, int> > 
Class:  class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class: class NativeArrayPassedAsPointerAndSize { class NativeArrayPassedAsPointerAndSize 
Class:    class UncopyableFoo { class UncopyableFoo 
Class:class Message;
Class:class Base 
Class:class Derived : public Base 
Class:class LogIsVisibleTest : public ::testing::Test { class LogIsVisibleTest : public ::testing::Test 
Class: class DummyMock { class DummyMock 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 2, u'-  CompileAssertTypesEqual<const char,'), (105, 2, u'-  CompileAssertTypesEqual<int, PointeeOf<int*>::type>();'), (106, 2, u'-  CompileAssertTypesEqual<const char, PointeeOf<const char*>::type>();'), (107, 2, u'-  CompileAssertTypesEqual<void, PointeeOf<void*>::type>();'), (308, 2, u'-TEST(AssertTest, SucceedsOnTrue) {'), (309, 2, u'-  Assert(true, __FILE__, __LINE__, "This should succeed.");'), (310, 2, u'-  Assert(true, __FILE__, __LINE__);  // This should succeed too.'), (314, 2, u'-TEST(AssertTest, FailsFatallyOnFalse) {'), (316, 2, u'-    Assert(false, __FILE__, __LINE__, "This should fail.");'), (320, 2, u'-    Assert(false, __FILE__, __LINE__);'), (577, 2, u'-  StaticAssertTypeEq<std::vector<int>,'), (579, 2, u'-  StaticAssertTypeEq<const std::vector<double>&,'), (593, 2, u'-  StaticAssertTypeEq<NativeArray<int>,'), (595, 2, u'-  StaticAssertTypeEq<NativeArray<double>,'), (597, 2, u'-  StaticAssertTypeEq<NativeArray<char[3]>,'), (600, 2, u'-  StaticAssertTypeEq<const NativeArray<int>,'), (609, 2, u'-  ASSERT_EQ(3U, a3.size());'), (620, 2, u'-  StaticAssertTypeEq<NativeArray<int>,'), (622, 2, u'-  StaticAssertTypeEq<NativeArray<double>,'), (625, 2, u'-  StaticAssertTypeEq<const NativeArray<int>,'), (637, 2, u'-  ASSERT_EQ(3U, a3.size());')]
===========================================
Class:class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:   class DeletionTester { class DeletionTester 
Class:class MyException 
Class:class Foo { class Foo 
Class:class ExpectationTester { class ExpectationTester 
Class:class Incomplete;
Class: class MockIncomplete { class MockIncomplete 
Class:class Result 
Class: class MockA { class MockA 
Class: class MockB { class MockB 
Class: class ReferenceHoldingMock { class ReferenceHoldingMock 
Class:class MockCC : public CC { class MockCC : public CC 
Class: class EvenNumberCardinality : public CardinalityInterface { class EvenNumberCardinality : public CardinalityInterface 
Class: class MockC { class MockC 
Class: class VerboseFlagPreservingFixture : public testing::Test { class VerboseFlagPreservingFixture : public testing::Test 
Class:   class GMockVerboseFlagTest : public VerboseFlagPreservingFixture { class GMockVerboseFlagTest : public VerboseFlagPreservingFixture 
Class:class PrintMeNot 
Class: class LogTestHelper { class LogTestHelper 
Class: class GMockLogTest : public VerboseFlagPreservingFixture { class GMockLogTest : public VerboseFlagPreservingFixture 
Class:class FooInterface { class FooInterface 
Class: class MockFoo : public FooInterface { class MockFoo : public FooInterface 
Class: class MockFoo { class MockFoo 
Class: class GMockOutputTest : public testing::Test { class GMockOutputTest : public testing::Test 
Class:class MockFoo { class MockFoo 
Class:class Base { class Base 
Class: class Derived1 : public Base { class Derived1 : public Base 
Class: class Derived2 : public Base { class Derived2 : public Base 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 2, u'-  ASSERT_EQ(N, argc) << "The new argv has wrong number of elements.";')]
===========================================
Class:    class     class
Class:  class codecvt_error_cat : public boost::system::error_category   class codecvt_error_cat : public boost::system::error_category
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(441, 2, u'-      BOOST_ASSERT(infile >= 0);'), (850, 2, u'-    BOOST_ASSERT_MSG(result.is_absolute(), "canonical() implementation error; please report");'), (1374, 2, u'-    BOOST_ASSERT_MSG(!((prms & add_perms) && (prms & remove_perms)),'), (1974, 2, u'-    BOOST_ASSERT(buffer != 0);'), (2182, 2, u'-    BOOST_ASSERT_MSG(it.m_imp.get(), "attempt to increment end iterator");'), (2183, 2, u'-    BOOST_ASSERT_MSG(it.m_imp->handle != 0, "internal program error");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(470, 2, u'-    BOOST_ASSERT_MSG(!str.empty() && is_separator(str[pos]),'), (653, 2, u'-        BOOST_ASSERT(first2->native() == first1->native());'), (691, 2, u'-    BOOST_ASSERT_MSG(it.m_pos < it.m_path_ptr->m_pathname.size(),'), (750, 2, u'-    BOOST_ASSERT_MSG(it.m_pos, "path::iterator decrement past begin()");'), (888, 2, u'-    BOOST_ASSERT_MSG(codecvt_facet_ptr(), "codecvt_facet_ptr() facet hasn\'t been properly initialized");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(138, 2, u'-    BOOST_ASSERT(from);'), (172, 2, u'-    BOOST_ASSERT(from);')]
===========================================
Class:  template <class T, class SlotPolicy>   template <class T, class SlotPolicy>
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(164, 2, u'-          assert(p != visited.end());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(197, 2, u'-          assert(entries().invariants());'), (212, 2, u'-      assert(slot->m_to_python == 0); // we have a problem otherwise')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(130, 2, u'-          assert(status != -3); // invalid argument error')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(306, 2, u'-    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self)), &class_metatype_object));'), (551, 2, u'-      assert(num_types >= 1);'), (576, 2, u'-      assert(PyType_IsSubtype(Py_TYPE(result.ptr()), &PyType_Type));'), (731, 2, u'-    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self_)), &class_metatype_object));'), (739, 2, u'-        assert(holder_offset >= offsetof(objects::instance<>,storage));'), (756, 2, u'-    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self_)), &class_metatype_object));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(169, 2, u'-                        assert(max_arity <= static_cast<std::size_t>(ssize_t_max));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(217, 2, u'-      assert(v == v2);'), (482, 2, u'-        assert(added);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(147, 2, u'-   BOOST_ASSERT(std::size_t(idx+1) < sizeof(masks) / sizeof(masks[0]));')]
===========================================
Class:class RegExData class RegExData
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(132, 2, u'-      BOOST_REGEX_NOEH_ASSERT(hfile != INVALID_HANDLE_VALUE);'), (243, 2, u'-   BOOST_ASSERT(node >= _first);'), (244, 2, u'-   BOOST_ASSERT(node <= _last);'), (276, 2, u'-        BOOST_REGEX_NOEH_ASSERT((0 == std::ferror(hfile)) && (read_size != 0));'), (294, 2, u'-   BOOST_ASSERT(node >= _first);'), (295, 2, u'-   BOOST_ASSERT(node <= _last);'), (423, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (425, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)'), (430, 2, u'-   BOOST_REGEX_NOEH_ASSERT(ref)'), (453, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (455, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)'), (476, 2, u'-   BOOST_REGEX_NOEH_ASSERT(ref)'), (511, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (513, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)'), (601, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (603, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)'), (608, 2, u'-   BOOST_REGEX_NOEH_ASSERT(ref)'), (631, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (633, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)'), (655, 2, u'-   BOOST_REGEX_NOEH_ASSERT(ref)'), (701, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_root)'), (703, 2, u'-   BOOST_REGEX_NOEH_ASSERT(_path)')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(426, 2, u'-   BOOST_ASSERT(std::size_t(idx+1) < sizeof(masks) / sizeof(masks[0]));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-   BOOST_REGEX_NOEH_ASSERT(ptr)'), (63, 2, u'-   BOOST_ASSERT(pos <= size_type(end - start));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(373, 2, u'-      regex_constants::escape_type_not_word_assert,  /*B*/'), (405, 2, u'-      regex_constants::escape_type_word_assert,        /*b*/')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 2, u'-BOOST_STATIC_ASSERT(sizeof(LONG) == sizeof(boost::int32_t));'), (137, 2, u'-   BOOST_ASSERT(0 == r);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(123, 2, u'-   BOOST_ASSERT(r != 0);'), (126, 2, u'-   BOOST_ASSERT(code_page != 0);'), (130, 2, u'-   BOOST_ASSERT(conv_r != 0);'), (134, 2, u'-   BOOST_ASSERT(r != 0);'), (137, 2, u'-   BOOST_ASSERT(conv_r != 0);'), (152, 2, u'-   BOOST_ASSERT(0 != r);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(187, 2, u'-   BOOST_ASSERT(idx+1 < static_cast<int>(sizeof(masks) / sizeof(masks[0])));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(108, 2, u'-        BOOST_ASSERT(false);')]
===========================================
Class:class basic_iarchive_impl { class basic_iarchive_impl 
Class:    class cobject_id     class cobject_id
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(316, 2, u'-        BOOST_ASSERT(cobject_info_set.size() == cobject_id_vector.size());'), (454, 2, u'-        BOOST_ASSERT(NULL != bpis_ptr);'), (458, 2, u'-        BOOST_ASSERT(new_cid == cid);'), (505, 2, u'-        BOOST_ASSERT(NULL != t);')]
===========================================
Class:class basic_oarchive_impl { class basic_oarchive_impl 
Class:    class bosarg :     class bosarg :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(62, 2, u'-            BOOST_ASSERT(NULL != address);'), (63, 2, u'-            BOOST_ASSERT(NULL != rhs.address);'), (181, 2, u'-            BOOST_ASSERT(false);'), (186, 2, u'-            BOOST_ASSERT(false);'), (191, 2, u'-            BOOST_ASSERT(false);'), (196, 2, u'-            BOOST_ASSERT(false);'), (202, 2, u'-            BOOST_ASSERT(false);')]
===========================================
Class:        class extended_type_info;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 2, u'-        BOOST_ASSERT(false);')]
===========================================
Class:template class basic_binary_iprimitive< template class basic_binary_iprimitive<
Class:template class binary_iarchive_impl< template class binary_iarchive_impl<
Class:template class basic_binary_oprimitive< template class basic_binary_oprimitive<
Class:template class binary_oarchive_impl< template class binary_oarchive_impl<
Class:template class basic_binary_iprimitive< template class basic_binary_iprimitive<
Class:template class binary_iarchive_impl< template class binary_iarchive_impl<
Class:template class basic_binary_oprimitive< template class basic_binary_oprimitive<
Class:template class binary_oarchive_impl< template class binary_oarchive_impl<
Class:class extended_type_info_arg : public extended_type_info class extended_type_info_arg : public extended_type_info
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 2, u'-    BOOST_ASSERT(NULL != l);'), (56, 2, u'-    BOOST_ASSERT(NULL != r);'), (69, 2, u'-    BOOST_ASSERT(NULL != l);'), (73, 2, u'-    BOOST_ASSERT(NULL != r);')]
===========================================
Class:class extended_type_info_typeid_arg : class extended_type_info_typeid_arg :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 2, u'-        BOOST_ASSERT(result.second);')]
===========================================
Class:class void_caster_shortcut : public void_caster class void_caster_shortcut : public void_caster
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-            BOOST_ASSERT(false);')]
===========================================
Class:    class X;
Class:  class generic_error_category : public error_category   class generic_error_category : public error_category
Class:    class  future_error_category :     class  future_error_category :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 2, u'-    BOOST_STATIC_ASSERT_MSG(sizeof(atomic_int_type) == sizeof(atomic_type), "Boost.Thread: unsupported platform");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(203, 2, u'-              BOOST_ASSERT(notify.empty());'), (205, 2, u'-              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 2, u'-            BOOST_ASSERT(current_thread_tls_key!=TLS_OUT_OF_INDEXES);'), (283, 2, u'-              BOOST_ASSERT(notify.empty());'), (285, 2, u'-              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 2, u'-namespace assert_ns'), (38, 2, u'-Assert::FailBehavior DefaultHandler(const char* condition,'), (53, 2, u'-  return Assert::Halt;'), (56, 2, u'-Assert::Handler& GetAssertHandlerInstance()'), (58, 2, u'-  static Assert::Handler s_handler = &DefaultHandler;'), (64, 2, u'-Assert::Handler Assert::GetHandler()'), (66, 2, u'-  return GetAssertHandlerInstance();'), (69, 2, u'-void Assert::SetHandler(Assert::Handler newHandler)'), (71, 2, u'-  GetAssertHandlerInstance() = newHandler;'), (74, 2, u'-Assert::FailBehavior Assert::ReportFailure(const char* condition,'), (99, 2, u'-  return GetAssertHandlerInstance()(condition, message, file, line);')]
===========================================
Class:class TranslationUnitTest : public ::testing::Test { class TranslationUnitTest : public ::testing::Test 
Class:class Water { class Water 
Class:     class LeakChecker : public EmptyTestEventListener { class LeakChecker : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 2, u'-    ASSERT_EQ(q->Size(), new_q->Size());'), (134, 2, u'-  ASSERT_TRUE(n != NULL);'), (140, 2, u'-  ASSERT_TRUE(n != NULL);')]
===========================================
Class:     class IntegerFunctionTest : public QuickTest { class IntegerFunctionTest : public QuickTest 
Class:        class QueueTest : public QuickTest { class QueueTest : public QuickTest 
Class:  template <class T> class PrimeTableTest : public testing::Test { class PrimeTableTest : public testing::Test 
Class:                 template <class T> class PrimeTableTest2 : public PrimeTableTest<T> { class PrimeTableTest2 : public PrimeTableTest<T> 
Class:     class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> { class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> 
Class:      class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > { class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > 
Class:class TersePrinter : public EmptyTestEventListener { class TersePrinter : public EmptyTestEventListener 
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class TestNameIs { class TestNameIs 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class: class TestException : public std::exception { class TestException : public std::exception 
Class:class ReplaceDeathTestFactory { class ReplaceDeathTestFactory 
Class:   class TestForDeathTest : public testing::Test { class TestForDeathTest : public testing::Test 
Class:  class MayDie { class MayDie 
Class:  class MockDeathTestFactory : public DeathTestFactory { class MockDeathTestFactory : public DeathTestFactory 
Class:      class MockDeathTest : public DeathTest { class MockDeathTest : public DeathTest 
Class:    class MacroLogicDeathTest : public testing::Test { class MacroLogicDeathTest : public testing::Test 
Class:class DirectoryCreationTest : public Test { class DirectoryCreationTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(98, 2, u'-  ASSERT_TRUE(cwd_without_drive != NULL);')]
===========================================
Class:class A { class A 
Class:  class B : public A { class B : public A 
Class: class LinkedPtrTest : public testing::Test { class LinkedPtrTest : public testing::Test 
Class:class EventRecordingListener : public TestEventListener { class EventRecordingListener : public TestEventListener 
Class:class XmlOutputChangeDirTest : public Test { class XmlOutputChangeDirTest : public Test 
Class:   class DogAdder { class DogAdder 
Class: class IntWrapper { class IntWrapper 
Class:          template <int kExpectedCalls> class TestGenerationEnvironment : public ::testing::Environment { class TestGenerationEnvironment : public ::testing::Environment 
Class: class TestGenerationTest : public TestWithParam<int> { class TestGenerationTest : public TestWithParam<int> 
Class:           class GeneratorEvaluationTest : public TestWithParam<int> { class GeneratorEvaluationTest : public TestWithParam<int> 
Class:class ExternalGeneratorTest : public TestWithParam<int> 
Class:class MultipleInstantiationTest : public TestWithParam<int> 
Class:   class SeparateInstanceTest : public TestWithParam<int> { class SeparateInstanceTest : public TestWithParam<int> 
Class:class NamingTest : public TestWithParam<int> 
Class:     class Unstreamable { class Unstreamable 
Class:class CommentTest : public TestWithParam<Unstreamable> 
Class:     class NonParameterizedBaseTest : public ::testing::Test { class NonParameterizedBaseTest : public ::testing::Test 
Class: class ParameterizedDerivedTest : public NonParameterizedBaseTest,                                  public ::testing::WithParamInterface<int> {                                  public ::testing::WithParamInterface<int> 
Class:class Base { class Base 
Class:  class BiggestIntConvertible { class BiggestIntConvertible 
Class:  template <typename T> class UnprintableTemplateInGlobal { class UnprintableTemplateInGlobal 
Class:  class StreamableInGlobal { class StreamableInGlobal 
Class:class UnprintableInFoo { class UnprintableInFoo 
Class:  template <typename T> class PrintableViaPrintToTemplate { class PrintableViaPrintToTemplate 
Class:  template <typename T> class StreamableTemplateInFoo { class StreamableTemplateInFoo 
Class:class AllowsGenericStreaming 
Class:class AllowsGenericStreamingTemplate 
Class:    template <typename T> class AllowsGenericStreamingAndImplicitConversionTemplate { class AllowsGenericStreamingAndImplicitConversionTemplate 
Class:class TestPartResultTest : public Test { class TestPartResultTest : public Test 
Class:   class TestPartResultArrayTest : public Test { class TestPartResultArrayTest : public Test 
Class:class BigTupleTest : public testing::Test { class BigTupleTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 2, u'-using ::testing::StaticAssertTypeEq;'), (47, 2, u'-  StaticAssertTypeEq<int, tuple_element<0, tuple<int, char> >::type>();'), (48, 2, u'-  StaticAssertTypeEq<int&, tuple_element<1, tuple<double, int&> >::type>();'), (49, 2, u'-  StaticAssertTypeEq<bool, tuple_element<2, tuple<double, int, bool> >::type>();')]
===========================================
Class:    template <typename T> class CommonTest : public Test { class CommonTest : public Test 
Class:    template <typename T> class TypedTest1 : public Test { class TypedTest1 : public Test 
Class: template <typename T> class TypedTest2 : public Test { class TypedTest2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
Class:   class TypedTestCasePStateTest : public Test { class TypedTestCasePStateTest : public Test 
Class:    template <typename T> class DerivedTest : public CommonTest<T> { class DerivedTest : public CommonTest<T> 
Class:    template <typename T> class TypedTestP1 : public Test { class TypedTestP1 : public Test 
Class: template <typename T> class TypedTestP2 : public Test { class TypedTestP2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(120, 2, u'-  ASSERT_TRUE(this->shared_ != NULL);'), (257, 2, u'-  ASSERT_TRUE(this->shared_ != NULL);')]
===========================================
Class:class UnitTestHelper { class UnitTestHelper 
Class:class FinalSuccessChecker : public Environment { class FinalSuccessChecker : public Environment 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 2, u'-  ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (140, 2, u'-AssertionResult IsNull(const char* str) {'), (142, 2, u'-    return testing::AssertionFailure() << "argument is " << str;'), (144, 2, u'-  return AssertionSuccess();'), (149, 2, u'-  ASSERT_TRUE(test_case != NULL);'), (156, 2, u'-  ASSERT_EQ(4, test_case->total_test_count());'), (189, 2, u'-  ASSERT_TRUE(test_case != NULL);'), (196, 2, u'-  ASSERT_EQ(1, test_case->total_test_count());'), (212, 2, u'-  ASSERT_TRUE(test_case != NULL);'), (219, 2, u'-  ASSERT_EQ(1, test_case->total_test_count());'), (245, 2, u'-    ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (253, 2, u'-    ASSERT_EQ(4, test_cases[0]->total_test_count());'), (263, 2, u'-    ASSERT_EQ(1, test_cases[1]->total_test_count());'), (272, 2, u'-    ASSERT_EQ(1, test_cases[2]->total_test_count());')]
===========================================
Class: class SehExceptionInDestructorTest : public Test { class SehExceptionInDestructorTest : public Test 
Class: class SehExceptionInSetUpTestCaseTest : public Test { class SehExceptionInSetUpTestCaseTest : public Test 
Class: class SehExceptionInTearDownTestCaseTest : public Test { class SehExceptionInTearDownTestCaseTest : public Test 
Class: class SehExceptionInSetUpTest : public Test { class SehExceptionInSetUpTest : public Test 
Class: class SehExceptionInTearDownTest : public Test { class SehExceptionInTearDownTest : public Test 
Class: class CxxExceptionInTearDownTestCaseTest : public Test { class CxxExceptionInTearDownTestCaseTest : public Test 
Class: class CxxExceptionInSetUpTest : public Test { class CxxExceptionInSetUpTest : public Test 
Class: class CxxExceptionInTearDownTest : public Test { class CxxExceptionInTearDownTest : public Test 
Class: class CxxExceptionInTestBodyTest : public Test { class CxxExceptionInTestBodyTest : public Test 
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 2, u'-  ASSERT_TRUE(false) << "Tests shouldn\'t be run when --help is specified.";')]
===========================================
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
Class:class FailingParamTest : public testing::TestWithParam<int> 
Class:  class NonFatalFailureInFixtureConstructorTest : public testing::Test { class NonFatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class FatalFailureInFixtureConstructorTest : public testing::Test { class FatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class NonFatalFailureInSetUpTest : public testing::Test { class NonFatalFailureInSetUpTest : public testing::Test 
Class:  class FatalFailureInSetUpTest : public testing::Test { class FatalFailureInSetUpTest : public testing::Test 
Class:    class DeathTestAndMultiThreadsTest : public testing::Test { class DeathTestAndMultiThreadsTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class: class TEST_before_TEST_F_in_same_test_case : public testing::Test { class TEST_before_TEST_F_in_same_test_case : public testing::Test 
Class:    class FooEnvironment : public testing::Environment { class FooEnvironment : public testing::Environment 
Class: class BarEnvironment : public testing::Environment { class BarEnvironment : public testing::Environment 
Class:   class Predicate1Test : public testing::Test { class Predicate1Test : public testing::Test 
Class:   class Predicate2Test : public testing::Test { class Predicate2Test : public testing::Test 
Class:   class Predicate3Test : public testing::Test { class Predicate3Test : public testing::Test 
Class:   class Predicate4Test : public testing::Test { class Predicate4Test : public testing::Test 
Class:   class Predicate5Test : public testing::Test { class Predicate5Test : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 2, u'-testing::AssertionResult PredFormatFunction1(const char* e1,'), (104, 2, u'-    return testing::AssertionSuccess();'), (106, 2, u'-  return testing::AssertionFailure()'), (115, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (161, 2, u'-typedef Predicate1Test ASSERT_PRED_FORMAT1Test;'), (163, 2, u'-typedef Predicate1Test ASSERT_PRED1Test;'), (239, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeSuccess) {'), (240, 2, u'-  ASSERT_PRED1(PredFunction1Int,'), (247, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeSuccess) {'), (248, 2, u'-  ASSERT_PRED1(PredFunction1Bool,'), (255, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeSuccess) {'), (256, 2, u'-  ASSERT_PRED1(PredFunctor1(),'), (263, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeSuccess) {'), (264, 2, u'-  ASSERT_PRED1(PredFunctor1(),'), (271, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeFailure) {'), (274, 2, u'-    ASSERT_PRED1(PredFunction1Int,'), (282, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeFailure) {'), (285, 2, u'-    ASSERT_PRED1(PredFunction1Bool,'), (293, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeFailure) {'), (296, 2, u'-    ASSERT_PRED1(PredFunctor1(),'), (304, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeFailure) {'), (307, 2, u'-    ASSERT_PRED1(PredFunctor1(),'), (387, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeSuccess) {'), (388, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (395, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeSuccess) {'), (396, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (403, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeSuccess) {'), (404, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (411, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeSuccess) {'), (412, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (419, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeFailure) {'), (422, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (430, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeFailure) {'), (433, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (441, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeFailure) {'), (444, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (452, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeFailure) {'), (455, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (489, 2, u'-testing::AssertionResult PredFormatFunction2(const char* e1,'), (494, 2, u'-    return testing::AssertionSuccess();'), (496, 2, u'-  return testing::AssertionFailure()'), (505, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (558, 2, u'-typedef Predicate2Test ASSERT_PRED_FORMAT2Test;'), (560, 2, u'-typedef Predicate2Test ASSERT_PRED2Test;'), (644, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeSuccess) {'), (645, 2, u'-  ASSERT_PRED2(PredFunction2Int,'), (653, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeSuccess) {'), (654, 2, u'-  ASSERT_PRED2(PredFunction2Bool,'), (662, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeSuccess) {'), (663, 2, u'-  ASSERT_PRED2(PredFunctor2(),'), (671, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeSuccess) {'), (672, 2, u'-  ASSERT_PRED2(PredFunctor2(),'), (680, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeFailure) {'), (683, 2, u'-    ASSERT_PRED2(PredFunction2Int,'), (692, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeFailure) {'), (695, 2, u'-    ASSERT_PRED2(PredFunction2Bool,'), (704, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeFailure) {'), (707, 2, u'-    ASSERT_PRED2(PredFunctor2(),'), (716, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeFailure) {'), (719, 2, u'-    ASSERT_PRED2(PredFunctor2(),'), (808, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeSuccess) {'), (809, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (817, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeSuccess) {'), (818, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (826, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeSuccess) {'), (827, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (835, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeSuccess) {'), (836, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (844, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeFailure) {'), (847, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (856, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeFailure) {'), (859, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (868, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeFailure) {'), (871, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (880, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeFailure) {'), (883, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (919, 2, u'-testing::AssertionResult PredFormatFunction3(const char* e1,'), (926, 2, u'-    return testing::AssertionSuccess();'), (928, 2, u'-  return testing::AssertionFailure()'), (937, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (997, 2, u'-typedef Predicate3Test ASSERT_PRED_FORMAT3Test;'), (999, 2, u'-typedef Predicate3Test ASSERT_PRED3Test;'), (1091, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeSuccess) {'), (1092, 2, u'-  ASSERT_PRED3(PredFunction3Int,'), (1101, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeSuccess) {'), (1102, 2, u'-  ASSERT_PRED3(PredFunction3Bool,'), (1111, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeSuccess) {'), (1112, 2, u'-  ASSERT_PRED3(PredFunctor3(),'), (1121, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeSuccess) {'), (1122, 2, u'-  ASSERT_PRED3(PredFunctor3(),'), (1131, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeFailure) {'), (1134, 2, u'-    ASSERT_PRED3(PredFunction3Int,'), (1144, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeFailure) {'), (1147, 2, u'-    ASSERT_PRED3(PredFunction3Bool,'), (1157, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeFailure) {'), (1160, 2, u'-    ASSERT_PRED3(PredFunctor3(),'), (1170, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeFailure) {'), (1173, 2, u'-    ASSERT_PRED3(PredFunctor3(),'), (1271, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeSuccess) {'), (1272, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1281, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeSuccess) {'), (1282, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1291, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeSuccess) {'), (1292, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1301, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeSuccess) {'), (1302, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1311, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeFailure) {'), (1314, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1324, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeFailure) {'), (1327, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1337, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeFailure) {'), (1340, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1350, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeFailure) {'), (1353, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1391, 2, u'-testing::AssertionResult PredFormatFunction4(const char* e1,'), (1400, 2, u'-    return testing::AssertionSuccess();'), (1402, 2, u'-  return testing::AssertionFailure()'), (1411, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (1478, 2, u'-typedef Predicate4Test ASSERT_PRED_FORMAT4Test;'), (1480, 2, u'-typedef Predicate4Test ASSERT_PRED4Test;'), (1580, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeSuccess) {'), (1581, 2, u'-  ASSERT_PRED4(PredFunction4Int,'), (1591, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeSuccess) {'), (1592, 2, u'-  ASSERT_PRED4(PredFunction4Bool,'), (1602, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeSuccess) {'), (1603, 2, u'-  ASSERT_PRED4(PredFunctor4(),'), (1613, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeSuccess) {'), (1614, 2, u'-  ASSERT_PRED4(PredFunctor4(),'), (1624, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeFailure) {'), (1627, 2, u'-    ASSERT_PRED4(PredFunction4Int,'), (1638, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeFailure) {'), (1641, 2, u'-    ASSERT_PRED4(PredFunction4Bool,'), (1652, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeFailure) {'), (1655, 2, u'-    ASSERT_PRED4(PredFunctor4(),'), (1666, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeFailure) {'), (1669, 2, u'-    ASSERT_PRED4(PredFunctor4(),'), (1776, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeSuccess) {'), (1777, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1787, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeSuccess) {'), (1788, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1798, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeSuccess) {'), (1799, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1809, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeSuccess) {'), (1810, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1820, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeFailure) {'), (1823, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1834, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeFailure) {'), (1837, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1848, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeFailure) {'), (1851, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1862, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeFailure) {'), (1865, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1905, 2, u'-testing::AssertionResult PredFormatFunction5(const char* e1,'), (1916, 2, u'-    return testing::AssertionSuccess();'), (1918, 2, u'-  return testing::AssertionFailure()'), (1927, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (2001, 2, u'-typedef Predicate5Test ASSERT_PRED_FORMAT5Test;'), (2003, 2, u'-typedef Predicate5Test ASSERT_PRED5Test;'), (2111, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeSuccess) {'), (2112, 2, u'-  ASSERT_PRED5(PredFunction5Int,'), (2123, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeSuccess) {'), (2124, 2, u'-  ASSERT_PRED5(PredFunction5Bool,'), (2135, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeSuccess) {'), (2136, 2, u'-  ASSERT_PRED5(PredFunctor5(),'), (2147, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeSuccess) {'), (2148, 2, u'-  ASSERT_PRED5(PredFunctor5(),'), (2159, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeFailure) {'), (2162, 2, u'-    ASSERT_PRED5(PredFunction5Int,'), (2174, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeFailure) {'), (2177, 2, u'-    ASSERT_PRED5(PredFunction5Bool,'), (2189, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeFailure) {'), (2192, 2, u'-    ASSERT_PRED5(PredFunctor5(),'), (2204, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeFailure) {'), (2207, 2, u'-    ASSERT_PRED5(PredFunctor5(),'), (2323, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeSuccess) {'), (2324, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2335, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeSuccess) {'), (2336, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2347, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeSuccess) {'), (2348, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2359, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeSuccess) {'), (2360, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2371, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeFailure) {'), (2374, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2386, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeFailure) {'), (2389, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2401, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeFailure) {'), (2404, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2416, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeFailure) {'), (2419, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),')]
===========================================
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class MyParamTest : public testing::TestWithParam<int> 
Class:class A : public Test 
Class:   class TestNamePrinter : public EmptyTestEventListener { class TestNamePrinter : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-TEST(NoFatalFailureTest, AssertNoFatalFailure) {'), (51, 2, u'-  ASSERT_NO_FATAL_FAILURE(;);'), (52, 2, u'-  ASSERT_NO_FATAL_FAILURE(SUCCEED());'), (53, 2, u'-  ASSERT_NO_FATAL_FAILURE(Subroutine());'), (54, 2, u'-  ASSERT_NO_FATAL_FAILURE({ SUCCEED(); });')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 2, u'-  ASSERT_TRUE(property != properties.end())'), (90, 2, u'-void ManyAsserts(int id) {'), (100, 2, u'-    ASSERT_FALSE(false) << "This shouldn\'t fail.";'), (102, 2, u'-    ASSERT_LE(5, 6);'), (128, 2, u'-TEST(StressTest, CanUseScopedTraceAndAssertionsInManyThreads) {'), (133, 2, u'-      threads[i].reset(new ThreadWithParam<int>(&ManyAsserts,'), (186, 2, u'-void AssertNoFatalFailureIgnoresFailuresInOtherThreads() {'), (187, 2, u'-  ASSERT_NO_FATAL_FAILURE(GenerateFatalFailureInAnotherThread(true));'), (189, 2, u'-TEST(NoFatalFailureTest, AssertNoFatalFailureIgnoresFailuresInOtherThreads) {'), (191, 2, u'-  AssertNoFatalFailureIgnoresFailuresInOtherThreads();')]
===========================================
Class:class TestEventListenersAccessor { class TestEventListenersAccessor 
Class:class SubClassOfTest : public Test 
Class:class AnotherSubClassOfTest : public Test 
Class:       class FormatEpochTimeInMillisAsIso8601Test : public Test { class FormatEpochTimeInMillisAsIso8601Test : public Test 
Class: class VectorShuffleTest : public Test { class VectorShuffleTest : public Test 
Class: class ScopedFakeTestPartResultReporterTest : public Test { class ScopedFakeTestPartResultReporterTest : public Test 
Class:    class TestResultTest : public Test { class TestResultTest : public Test 
Class:   class GTestFlagSaverTest : public Test { class GTestFlagSaverTest : public Test 
Class: class ShouldShardTest : public testing::Test { class ShouldShardTest : public testing::Test 
Class:   class DisabledTestsTest : public Test { class DisabledTestsTest : public Test 
Class: template <typename T> class DISABLED_TypedTest : public Test { class DISABLED_TypedTest : public Test 
Class: template <typename T> class DISABLED_TypedTestP : public Test { class DISABLED_TypedTestP : public Test 
Class:  class Uncopyable { class Uncopyable 
Class:class UnprintableChar { class UnprintableChar 
Class:     class Foo { class Foo 
Class:  class FRIEND_TEST_Test2 : public Test { class FRIEND_TEST_Test2 : public Test 
Class:       class TestLifeCycleTest : public Test { class TestLifeCycleTest : public Test 
Class:   class Base { class Base 
Class:class MyTypeInUnnamedNameSpace : public Base { class MyTypeInUnnamedNameSpace : public Base 
Class:class MyTypeInNameSpace1 : public Base { class MyTypeInNameSpace1 : public Base 
Class:class MyTypeInNameSpace2 : public ::Base { class MyTypeInNameSpace2 : public ::Base 
Class:class TestInfoTest : public Test { class TestInfoTest : public Test 
Class:   class SetUpTestCaseTest : public Test { class SetUpTestCaseTest : public Test 
Class:  class InitGoogleTestTest : public Test { class InitGoogleTestTest : public Test 
Class:class Test 
Class:class Message 
Class:class AssertionResult 
Class:   template <typename T> class StaticAssertTypeEqTestHelper { class StaticAssertTypeEqTestHelper 
Class: class TestListener : public EmptyTestEventListener { class TestListener : public EmptyTestEventListener 
Class:    class SequenceTestingListener : public EmptyTestEventListener { class SequenceTestingListener : public EmptyTestEventListener 
Class:class ConversionHelperBase 
Class:class ConversionHelperDerived : public ConversionHelperBase 
Class:class NonContainer 
Class: class SuccessfulTest : public Test { class SuccessfulTest : public Test 
Class: class FailedTest : public Test { class FailedTest : public Test 
Class: class DisabledTest : public Test { class DisabledTest : public Test 
Class: class PropertyRecordingTest : public Test { class PropertyRecordingTest : public Test 
Class:class ValueParamTest : public TestWithParam<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 2, u'-  ASSERT_EQ(1, 1);'), (62, 2, u'-  ASSERT_EQ(1, 2);'), (74, 2, u'-  ASSERT_EQ(1, 1);'), (79, 2, u'-  ASSERT_EQ(2, 3);')]
===========================================
Class:class BetweenCardinalityImpl : public CardinalityInterface { class BetweenCardinalityImpl : public CardinalityInterface 
Class:class GoogleTestFailureReporter : public FailureReporterInterface { class GoogleTestFailureReporter : public FailureReporterInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 2, u'-    AssertHelper(type == kFatal ?')]
===========================================
Class:class MockObjectRegistry { class MockObjectRegistry 
Class:class MyActionImpl : public ActionInterface<MyFunction> { class MyActionImpl : public ActionInterface<MyFunction> 
Class:    class IsNotZero : public ActionInterface<bool(int)> {   class IsNotZero : public ActionInterface<bool(int)> 
Class:   class ReturnZeroFromNullaryFunctionAction { class ReturnZeroFromNullaryFunctionAction 
Class:     class FromType { class FromType 
Class: class ToType { class ToType 
Class:class DestinationType 
Class: class SourceType { class SourceType 
Class:class MyClass 
Class: class MockClass { class MockClass 
Class: class NullaryFunctor { class NullaryFunctor 
Class: class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:class MockFoo { class MockFoo 
Class:    class EvenCardinality : public CardinalityInterface { class EvenCardinality : public CardinalityInterface 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class SubstractAction : public ActionInterface<int(int, int)> {   class SubstractAction : public ActionInterface<int(int, int)> 
Class: class NullaryConstructorClass { class NullaryConstructorClass 
Class: class UnaryConstructorClass { class UnaryConstructorClass 
Class: class TenArgConstructorClass { class TenArgConstructorClass 
Class:  class BoolResetter { class BoolResetter 
Class:class FooInterface { class FooInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 2, u'-using ::testing::internal::CompileAssertTypesEqual;'), (52, 2, u'-  CompileAssertTypesEqual<tuple<>, MatcherTuple<tuple<> >::type>();'), (56, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<int> >,'), (61, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char> >,'), (66, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char>, Matcher<bool>,'), (76, 2, u'-  CompileAssertTypesEqual<int, F::Result>();'), (77, 2, u'-  CompileAssertTypesEqual<tuple<>, F::ArgumentTuple>();'), (78, 2, u'-  CompileAssertTypesEqual<tuple<>, F::ArgumentMatcherTuple>();'), (79, 2, u'-  CompileAssertTypesEqual<void(), F::MakeResultVoid>();'), (80, 2, u'-  CompileAssertTypesEqual<IgnoredValue(), F::MakeResultIgnoredValue>();'), (85, 2, u'-  CompileAssertTypesEqual<int, F::Result>();'), (86, 2, u'-  CompileAssertTypesEqual<bool, F::Argument1>();'), (87, 2, u'-  CompileAssertTypesEqual<tuple<bool>, F::ArgumentTuple>();'), (88, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<bool> >, F::ArgumentMatcherTuple>();'), (89, 2, u'-  CompileAssertTypesEqual<void(bool), F::MakeResultVoid>();  // NOLINT'), (90, 2, u'-  CompileAssertTypesEqual<IgnoredValue(bool),  // NOLINT'), (96, 2, u'-  CompileAssertTypesEqual<int, F::Result>();'), (97, 2, u'-  CompileAssertTypesEqual<bool, F::Argument1>();'), (98, 2, u'-  CompileAssertTypesEqual<const long&, F::Argument2>();  // NOLINT'), (99, 2, u'-  CompileAssertTypesEqual<tuple<bool, const long&>, F::ArgumentTuple>();  // NOLINT'), (100, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<const long&> >,  // NOLINT'), (102, 2, u'-  CompileAssertTypesEqual<void(bool, const long&), F::MakeResultVoid>();  // NOLINT'), (103, 2, u'-  CompileAssertTypesEqual<IgnoredValue(bool, const long&),  // NOLINT'), (109, 2, u'-  CompileAssertTypesEqual<char, F::Result>();'), (110, 2, u'-  CompileAssertTypesEqual<bool, F::Argument1>();'), (111, 2, u'-  CompileAssertTypesEqual<int, F::Argument2>();'), (112, 2, u'-  CompileAssertTypesEqual<char*, F::Argument3>();'), (113, 2, u'-  CompileAssertTypesEqual<int&, F::Argument4>();'), (114, 2, u'-  CompileAssertTypesEqual<const long&, F::Argument5>();  // NOLINT'), (115, 2, u'-  CompileAssertTypesEqual<tuple<bool, int, char*, int&, const long&>,  // NOLINT'), (117, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<int>, Matcher<char*>,'), (120, 2, u'-  CompileAssertTypesEqual<void(bool, int, char*, int&, const long&),  // NOLINT'), (122, 2, u'-  CompileAssertTypesEqual<')]
===========================================
Class:class LessThanMatcher : public MatcherInterface<tuple<char, int> > { class LessThanMatcher : public MatcherInterface<tuple<char, int> > 
Class:  class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class: class NativeArrayPassedAsPointerAndSize { class NativeArrayPassedAsPointerAndSize 
Class:    class UncopyableFoo { class UncopyableFoo 
Class:class Message;
Class:class Base 
Class:class Derived : public Base 
Class:class LogIsVisibleTest : public ::testing::Test { class LogIsVisibleTest : public ::testing::Test 
Class: class DummyMock { class DummyMock 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 2, u'-  CompileAssertTypesEqual<const char,'), (105, 2, u'-  CompileAssertTypesEqual<int, PointeeOf<int*>::type>();'), (106, 2, u'-  CompileAssertTypesEqual<const char, PointeeOf<const char*>::type>();'), (107, 2, u'-  CompileAssertTypesEqual<void, PointeeOf<void*>::type>();'), (308, 2, u'-TEST(AssertTest, SucceedsOnTrue) {'), (309, 2, u'-  Assert(true, __FILE__, __LINE__, "This should succeed.");'), (310, 2, u'-  Assert(true, __FILE__, __LINE__);  // This should succeed too.'), (314, 2, u'-TEST(AssertTest, FailsFatallyOnFalse) {'), (316, 2, u'-    Assert(false, __FILE__, __LINE__, "This should fail.");'), (320, 2, u'-    Assert(false, __FILE__, __LINE__);'), (577, 2, u'-  StaticAssertTypeEq<std::vector<int>,'), (579, 2, u'-  StaticAssertTypeEq<const std::vector<double>&,'), (593, 2, u'-  StaticAssertTypeEq<NativeArray<int>,'), (595, 2, u'-  StaticAssertTypeEq<NativeArray<double>,'), (597, 2, u'-  StaticAssertTypeEq<NativeArray<char[3]>,'), (600, 2, u'-  StaticAssertTypeEq<const NativeArray<int>,'), (609, 2, u'-  ASSERT_EQ(3U, a3.size());'), (620, 2, u'-  StaticAssertTypeEq<NativeArray<int>,'), (622, 2, u'-  StaticAssertTypeEq<NativeArray<double>,'), (625, 2, u'-  StaticAssertTypeEq<const NativeArray<int>,'), (637, 2, u'-  ASSERT_EQ(3U, a3.size());')]
===========================================
Class:class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:   class DeletionTester { class DeletionTester 
Class:class MyException 
Class:class Foo { class Foo 
Class:class ExpectationTester { class ExpectationTester 
Class:class Incomplete;
Class: class MockIncomplete { class MockIncomplete 
Class:class Result 
Class: class MockA { class MockA 
Class: class MockB { class MockB 
Class: class ReferenceHoldingMock { class ReferenceHoldingMock 
Class:class MockCC : public CC { class MockCC : public CC 
Class: class EvenNumberCardinality : public CardinalityInterface { class EvenNumberCardinality : public CardinalityInterface 
Class: class MockC { class MockC 
Class: class VerboseFlagPreservingFixture : public testing::Test { class VerboseFlagPreservingFixture : public testing::Test 
Class:   class GMockVerboseFlagTest : public VerboseFlagPreservingFixture { class GMockVerboseFlagTest : public VerboseFlagPreservingFixture 
Class:class PrintMeNot 
Class: class LogTestHelper { class LogTestHelper 
Class: class GMockLogTest : public VerboseFlagPreservingFixture { class GMockLogTest : public VerboseFlagPreservingFixture 
Class:class FooInterface { class FooInterface 
Class: class MockFoo : public FooInterface { class MockFoo : public FooInterface 
Class: class MockFoo { class MockFoo 
Class: class GMockOutputTest : public testing::Test { class GMockOutputTest : public testing::Test 
Class:class MockFoo { class MockFoo 
Class:class Base { class Base 
Class: class Derived1 : public Base { class Derived1 : public Base 
Class: class Derived2 : public Base { class Derived2 : public Base 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 2, u'-  ASSERT_EQ(N, argc) << "The new argv has wrong number of elements.";')]
===========================================
Class:    class     class
Class:  class codecvt_error_cat : public boost::system::error_category   class codecvt_error_cat : public boost::system::error_category
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(441, 1, u'+      BOOST_ASSERT(infile >= 0);'), (850, 1, u'+    BOOST_ASSERT_MSG(result.is_absolute(), "canonical() implementation error; please report");'), (1374, 1, u'+    BOOST_ASSERT_MSG(!((prms & add_perms) && (prms & remove_perms)),'), (1974, 1, u'+    BOOST_ASSERT(buffer != 0);'), (2182, 1, u'+    BOOST_ASSERT_MSG(it.m_imp.get(), "attempt to increment end iterator");'), (2183, 1, u'+    BOOST_ASSERT_MSG(it.m_imp->handle != 0, "internal program error");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(470, 1, u'+    BOOST_ASSERT_MSG(!str.empty() && is_separator(str[pos]),'), (653, 1, u'+        BOOST_ASSERT(first2->native() == first1->native());'), (691, 1, u'+    BOOST_ASSERT_MSG(it.m_pos < it.m_path_ptr->m_pathname.size(),'), (750, 1, u'+    BOOST_ASSERT_MSG(it.m_pos, "path::iterator decrement past begin()");'), (888, 1, u'+    BOOST_ASSERT_MSG(codecvt_facet_ptr(), "codecvt_facet_ptr() facet hasn\'t been properly initialized");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(138, 1, u'+    BOOST_ASSERT(from);'), (172, 1, u'+    BOOST_ASSERT(from);')]
===========================================
Class:  template <class T, class SlotPolicy>   template <class T, class SlotPolicy>
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(164, 1, u'+          assert(p != visited.end());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(197, 1, u'+          assert(entries().invariants());'), (212, 1, u'+      assert(slot->m_to_python == 0); // we have a problem otherwise')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(130, 1, u'+          assert(status != -3); // invalid argument error')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(306, 1, u'+    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self)), &class_metatype_object));'), (551, 1, u'+      assert(num_types >= 1);'), (576, 1, u'+      assert(PyType_IsSubtype(Py_TYPE(result.ptr()), &PyType_Type));'), (731, 1, u'+    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self_)), &class_metatype_object));'), (739, 1, u'+        assert(holder_offset >= offsetof(objects::instance<>,storage));'), (756, 1, u'+    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self_)), &class_metatype_object));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(169, 1, u'+                        assert(max_arity <= static_cast<std::size_t>(ssize_t_max));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(217, 1, u'+      assert(v == v2);'), (482, 1, u'+        assert(added);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(147, 1, u'+   BOOST_ASSERT(std::size_t(idx+1) < sizeof(masks) / sizeof(masks[0]));')]
===========================================
Class:class RegExData class RegExData
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(132, 1, u'+      BOOST_REGEX_NOEH_ASSERT(hfile != INVALID_HANDLE_VALUE);'), (243, 1, u'+   BOOST_ASSERT(node >= _first);'), (244, 1, u'+   BOOST_ASSERT(node <= _last);'), (276, 1, u'+        BOOST_REGEX_NOEH_ASSERT((0 == std::ferror(hfile)) && (read_size != 0));'), (294, 1, u'+   BOOST_ASSERT(node >= _first);'), (295, 1, u'+   BOOST_ASSERT(node <= _last);'), (423, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (425, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)'), (430, 1, u'+   BOOST_REGEX_NOEH_ASSERT(ref)'), (453, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (455, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)'), (476, 1, u'+   BOOST_REGEX_NOEH_ASSERT(ref)'), (511, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (513, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)'), (601, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (603, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)'), (608, 1, u'+   BOOST_REGEX_NOEH_ASSERT(ref)'), (631, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (633, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)'), (655, 1, u'+   BOOST_REGEX_NOEH_ASSERT(ref)'), (701, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (703, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(426, 1, u'+   BOOST_ASSERT(std::size_t(idx+1) < sizeof(masks) / sizeof(masks[0]));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+   BOOST_REGEX_NOEH_ASSERT(ptr)'), (63, 1, u'+   BOOST_ASSERT(pos <= size_type(end - start));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(373, 1, u'+      regex_constants::escape_type_not_word_assert,  /*B*/'), (405, 1, u'+      regex_constants::escape_type_word_assert,        /*b*/')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+BOOST_STATIC_ASSERT(sizeof(LONG) == sizeof(boost::int32_t));'), (137, 1, u'+   BOOST_ASSERT(0 == r);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(123, 1, u'+   BOOST_ASSERT(r != 0);'), (126, 1, u'+   BOOST_ASSERT(code_page != 0);'), (130, 1, u'+   BOOST_ASSERT(conv_r != 0);'), (134, 1, u'+   BOOST_ASSERT(r != 0);'), (137, 1, u'+   BOOST_ASSERT(conv_r != 0);'), (152, 1, u'+   BOOST_ASSERT(0 != r);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(187, 1, u'+   BOOST_ASSERT(idx+1 < static_cast<int>(sizeof(masks) / sizeof(masks[0])));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(108, 1, u'+        BOOST_ASSERT(false);')]
===========================================
Class:class basic_iarchive_impl { class basic_iarchive_impl 
Class:    class cobject_id     class cobject_id
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(316, 1, u'+        BOOST_ASSERT(cobject_info_set.size() == cobject_id_vector.size());'), (454, 1, u'+        BOOST_ASSERT(NULL != bpis_ptr);'), (458, 1, u'+        BOOST_ASSERT(new_cid == cid);'), (505, 1, u'+        BOOST_ASSERT(NULL != t);')]
===========================================
Class:class basic_oarchive_impl { class basic_oarchive_impl 
Class:    class bosarg :     class bosarg :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(62, 1, u'+            BOOST_ASSERT(NULL != address);'), (63, 1, u'+            BOOST_ASSERT(NULL != rhs.address);'), (181, 1, u'+            BOOST_ASSERT(false);'), (186, 1, u'+            BOOST_ASSERT(false);'), (191, 1, u'+            BOOST_ASSERT(false);'), (196, 1, u'+            BOOST_ASSERT(false);'), (202, 1, u'+            BOOST_ASSERT(false);')]
===========================================
Class:        class extended_type_info;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 1, u'+        BOOST_ASSERT(false);')]
===========================================
Class:template class basic_binary_iprimitive< template class basic_binary_iprimitive<
Class:template class binary_iarchive_impl< template class binary_iarchive_impl<
Class:template class basic_binary_oprimitive< template class basic_binary_oprimitive<
Class:template class binary_oarchive_impl< template class binary_oarchive_impl<
Class:template class basic_binary_iprimitive< template class basic_binary_iprimitive<
Class:template class binary_iarchive_impl< template class binary_iarchive_impl<
Class:template class basic_binary_oprimitive< template class basic_binary_oprimitive<
Class:template class binary_oarchive_impl< template class binary_oarchive_impl<
Class:class extended_type_info_arg : public extended_type_info class extended_type_info_arg : public extended_type_info
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 1, u'+    BOOST_ASSERT(NULL != l);'), (56, 1, u'+    BOOST_ASSERT(NULL != r);'), (69, 1, u'+    BOOST_ASSERT(NULL != l);'), (73, 1, u'+    BOOST_ASSERT(NULL != r);')]
===========================================
Class:class extended_type_info_typeid_arg : class extended_type_info_typeid_arg :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 1, u'+        BOOST_ASSERT(result.second);')]
===========================================
Class:class void_caster_shortcut : public void_caster class void_caster_shortcut : public void_caster
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+            BOOST_ASSERT(false);')]
===========================================
Class:    class X;
Class:  class generic_error_category : public error_category   class generic_error_category : public error_category
Class:    class  future_error_category :     class  future_error_category :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 1, u'+    BOOST_STATIC_ASSERT_MSG(sizeof(atomic_int_type) == sizeof(atomic_type), "Boost.Thread: unsupported platform");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(203, 1, u'+              BOOST_ASSERT(notify.empty());'), (205, 1, u'+              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 1, u'+            BOOST_ASSERT(current_thread_tls_key!=TLS_OUT_OF_INDEXES);'), (283, 1, u'+              BOOST_ASSERT(notify.empty());'), (285, 1, u'+              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+namespace assert_ns'), (38, 1, u'+Assert::FailBehavior DefaultHandler(const char* condition,'), (53, 1, u'+  return Assert::Halt;'), (56, 1, u'+Assert::Handler& GetAssertHandlerInstance()'), (58, 1, u'+  static Assert::Handler s_handler = &DefaultHandler;'), (64, 1, u'+Assert::Handler Assert::GetHandler()'), (66, 1, u'+  return GetAssertHandlerInstance();'), (69, 1, u'+void Assert::SetHandler(Assert::Handler newHandler)'), (71, 1, u'+  GetAssertHandlerInstance() = newHandler;'), (74, 1, u'+Assert::FailBehavior Assert::ReportFailure(const char* condition,'), (99, 1, u'+  return GetAssertHandlerInstance()(condition, message, file, line);')]
===========================================
Class:class TranslationUnitTest : public ::testing::Test { class TranslationUnitTest : public ::testing::Test 
Class:class Water { class Water 
Class:     class LeakChecker : public EmptyTestEventListener { class LeakChecker : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 1, u'+    ASSERT_EQ(q->Size(), new_q->Size());'), (134, 1, u'+  ASSERT_TRUE(n != NULL);'), (140, 1, u'+  ASSERT_TRUE(n != NULL);')]
===========================================
Class:     class IntegerFunctionTest : public QuickTest { class IntegerFunctionTest : public QuickTest 
Class:        class QueueTest : public QuickTest { class QueueTest : public QuickTest 
Class:  template <class T> class PrimeTableTest : public testing::Test { class PrimeTableTest : public testing::Test 
Class:                 template <class T> class PrimeTableTest2 : public PrimeTableTest<T> { class PrimeTableTest2 : public PrimeTableTest<T> 
Class:     class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> { class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> 
Class:      class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > { class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > 
Class:class TersePrinter : public EmptyTestEventListener { class TersePrinter : public EmptyTestEventListener 
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class TestNameIs { class TestNameIs 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class: class TestException : public std::exception { class TestException : public std::exception 
Class:class ReplaceDeathTestFactory { class ReplaceDeathTestFactory 
Class:   class TestForDeathTest : public testing::Test { class TestForDeathTest : public testing::Test 
Class:  class MayDie { class MayDie 
Class:  class MockDeathTestFactory : public DeathTestFactory { class MockDeathTestFactory : public DeathTestFactory 
Class:      class MockDeathTest : public DeathTest { class MockDeathTest : public DeathTest 
Class:    class MacroLogicDeathTest : public testing::Test { class MacroLogicDeathTest : public testing::Test 
Class:class DirectoryCreationTest : public Test { class DirectoryCreationTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(98, 1, u'+  ASSERT_TRUE(cwd_without_drive != NULL);')]
===========================================
Class:class A { class A 
Class:  class B : public A { class B : public A 
Class: class LinkedPtrTest : public testing::Test { class LinkedPtrTest : public testing::Test 
Class:class EventRecordingListener : public TestEventListener { class EventRecordingListener : public TestEventListener 
Class:class XmlOutputChangeDirTest : public Test { class XmlOutputChangeDirTest : public Test 
Class:   class DogAdder { class DogAdder 
Class: class IntWrapper { class IntWrapper 
Class:          template <int kExpectedCalls> class TestGenerationEnvironment : public ::testing::Environment { class TestGenerationEnvironment : public ::testing::Environment 
Class: class TestGenerationTest : public TestWithParam<int> { class TestGenerationTest : public TestWithParam<int> 
Class:           class GeneratorEvaluationTest : public TestWithParam<int> { class GeneratorEvaluationTest : public TestWithParam<int> 
Class:class ExternalGeneratorTest : public TestWithParam<int> 
Class:class MultipleInstantiationTest : public TestWithParam<int> 
Class:   class SeparateInstanceTest : public TestWithParam<int> { class SeparateInstanceTest : public TestWithParam<int> 
Class:class NamingTest : public TestWithParam<int> 
Class:     class Unstreamable { class Unstreamable 
Class:class CommentTest : public TestWithParam<Unstreamable> 
Class:     class NonParameterizedBaseTest : public ::testing::Test { class NonParameterizedBaseTest : public ::testing::Test 
Class: class ParameterizedDerivedTest : public NonParameterizedBaseTest,                                  public ::testing::WithParamInterface<int> {                                  public ::testing::WithParamInterface<int> 
Class:class Base { class Base 
Class:  class BiggestIntConvertible { class BiggestIntConvertible 
Class:  template <typename T> class UnprintableTemplateInGlobal { class UnprintableTemplateInGlobal 
Class:  class StreamableInGlobal { class StreamableInGlobal 
Class:class UnprintableInFoo { class UnprintableInFoo 
Class:  template <typename T> class PrintableViaPrintToTemplate { class PrintableViaPrintToTemplate 
Class:  template <typename T> class StreamableTemplateInFoo { class StreamableTemplateInFoo 
Class:class AllowsGenericStreaming 
Class:class AllowsGenericStreamingTemplate 
Class:    template <typename T> class AllowsGenericStreamingAndImplicitConversionTemplate { class AllowsGenericStreamingAndImplicitConversionTemplate 
Class:class TestPartResultTest : public Test { class TestPartResultTest : public Test 
Class:   class TestPartResultArrayTest : public Test { class TestPartResultArrayTest : public Test 
Class:class BigTupleTest : public testing::Test { class BigTupleTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+using ::testing::StaticAssertTypeEq;'), (47, 1, u'+  StaticAssertTypeEq<int, tuple_element<0, tuple<int, char> >::type>();'), (48, 1, u'+  StaticAssertTypeEq<int&, tuple_element<1, tuple<double, int&> >::type>();'), (49, 1, u'+  StaticAssertTypeEq<bool, tuple_element<2, tuple<double, int, bool> >::type>();')]
===========================================
Class:    template <typename T> class CommonTest : public Test { class CommonTest : public Test 
Class:    template <typename T> class TypedTest1 : public Test { class TypedTest1 : public Test 
Class: template <typename T> class TypedTest2 : public Test { class TypedTest2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
Class:   class TypedTestCasePStateTest : public Test { class TypedTestCasePStateTest : public Test 
Class:    template <typename T> class DerivedTest : public CommonTest<T> { class DerivedTest : public CommonTest<T> 
Class:    template <typename T> class TypedTestP1 : public Test { class TypedTestP1 : public Test 
Class: template <typename T> class TypedTestP2 : public Test { class TypedTestP2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(120, 1, u'+  ASSERT_TRUE(this->shared_ != NULL);'), (257, 1, u'+  ASSERT_TRUE(this->shared_ != NULL);')]
===========================================
Class:class UnitTestHelper { class UnitTestHelper 
Class:class FinalSuccessChecker : public Environment { class FinalSuccessChecker : public Environment 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 1, u'+  ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (140, 1, u'+AssertionResult IsNull(const char* str) {'), (142, 1, u'+    return testing::AssertionFailure() << "argument is " << str;'), (144, 1, u'+  return AssertionSuccess();'), (149, 1, u'+  ASSERT_TRUE(test_case != NULL);'), (156, 1, u'+  ASSERT_EQ(4, test_case->total_test_count());'), (189, 1, u'+  ASSERT_TRUE(test_case != NULL);'), (196, 1, u'+  ASSERT_EQ(1, test_case->total_test_count());'), (212, 1, u'+  ASSERT_TRUE(test_case != NULL);'), (219, 1, u'+  ASSERT_EQ(1, test_case->total_test_count());'), (245, 1, u'+    ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (253, 1, u'+    ASSERT_EQ(4, test_cases[0]->total_test_count());'), (263, 1, u'+    ASSERT_EQ(1, test_cases[1]->total_test_count());'), (272, 1, u'+    ASSERT_EQ(1, test_cases[2]->total_test_count());')]
===========================================
Class: class SehExceptionInDestructorTest : public Test { class SehExceptionInDestructorTest : public Test 
Class: class SehExceptionInSetUpTestCaseTest : public Test { class SehExceptionInSetUpTestCaseTest : public Test 
Class: class SehExceptionInTearDownTestCaseTest : public Test { class SehExceptionInTearDownTestCaseTest : public Test 
Class: class SehExceptionInSetUpTest : public Test { class SehExceptionInSetUpTest : public Test 
Class: class SehExceptionInTearDownTest : public Test { class SehExceptionInTearDownTest : public Test 
Class: class CxxExceptionInTearDownTestCaseTest : public Test { class CxxExceptionInTearDownTestCaseTest : public Test 
Class: class CxxExceptionInSetUpTest : public Test { class CxxExceptionInSetUpTest : public Test 
Class: class CxxExceptionInTearDownTest : public Test { class CxxExceptionInTearDownTest : public Test 
Class: class CxxExceptionInTestBodyTest : public Test { class CxxExceptionInTestBodyTest : public Test 
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+  ASSERT_TRUE(false) << "Tests shouldn\'t be run when --help is specified.";')]
===========================================
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
Class:class FailingParamTest : public testing::TestWithParam<int> 
Class:  class NonFatalFailureInFixtureConstructorTest : public testing::Test { class NonFatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class FatalFailureInFixtureConstructorTest : public testing::Test { class FatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class NonFatalFailureInSetUpTest : public testing::Test { class NonFatalFailureInSetUpTest : public testing::Test 
Class:  class FatalFailureInSetUpTest : public testing::Test { class FatalFailureInSetUpTest : public testing::Test 
Class:    class DeathTestAndMultiThreadsTest : public testing::Test { class DeathTestAndMultiThreadsTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class: class TEST_before_TEST_F_in_same_test_case : public testing::Test { class TEST_before_TEST_F_in_same_test_case : public testing::Test 
Class:    class FooEnvironment : public testing::Environment { class FooEnvironment : public testing::Environment 
Class: class BarEnvironment : public testing::Environment { class BarEnvironment : public testing::Environment 
Class:   class Predicate1Test : public testing::Test { class Predicate1Test : public testing::Test 
Class:   class Predicate2Test : public testing::Test { class Predicate2Test : public testing::Test 
Class:   class Predicate3Test : public testing::Test { class Predicate3Test : public testing::Test 
Class:   class Predicate4Test : public testing::Test { class Predicate4Test : public testing::Test 
Class:   class Predicate5Test : public testing::Test { class Predicate5Test : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 1, u'+testing::AssertionResult PredFormatFunction1(const char* e1,'), (104, 1, u'+    return testing::AssertionSuccess();'), (106, 1, u'+  return testing::AssertionFailure()'), (115, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (161, 1, u'+typedef Predicate1Test ASSERT_PRED_FORMAT1Test;'), (163, 1, u'+typedef Predicate1Test ASSERT_PRED1Test;'), (239, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeSuccess) {'), (240, 1, u'+  ASSERT_PRED1(PredFunction1Int,'), (247, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeSuccess) {'), (248, 1, u'+  ASSERT_PRED1(PredFunction1Bool,'), (255, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeSuccess) {'), (256, 1, u'+  ASSERT_PRED1(PredFunctor1(),'), (263, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeSuccess) {'), (264, 1, u'+  ASSERT_PRED1(PredFunctor1(),'), (271, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeFailure) {'), (274, 1, u'+    ASSERT_PRED1(PredFunction1Int,'), (282, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeFailure) {'), (285, 1, u'+    ASSERT_PRED1(PredFunction1Bool,'), (293, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeFailure) {'), (296, 1, u'+    ASSERT_PRED1(PredFunctor1(),'), (304, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeFailure) {'), (307, 1, u'+    ASSERT_PRED1(PredFunctor1(),'), (387, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeSuccess) {'), (388, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (395, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeSuccess) {'), (396, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (403, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeSuccess) {'), (404, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (411, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeSuccess) {'), (412, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (419, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeFailure) {'), (422, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (430, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeFailure) {'), (433, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (441, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeFailure) {'), (444, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (452, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeFailure) {'), (455, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (489, 1, u'+testing::AssertionResult PredFormatFunction2(const char* e1,'), (494, 1, u'+    return testing::AssertionSuccess();'), (496, 1, u'+  return testing::AssertionFailure()'), (505, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (558, 1, u'+typedef Predicate2Test ASSERT_PRED_FORMAT2Test;'), (560, 1, u'+typedef Predicate2Test ASSERT_PRED2Test;'), (644, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeSuccess) {'), (645, 1, u'+  ASSERT_PRED2(PredFunction2Int,'), (653, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeSuccess) {'), (654, 1, u'+  ASSERT_PRED2(PredFunction2Bool,'), (662, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeSuccess) {'), (663, 1, u'+  ASSERT_PRED2(PredFunctor2(),'), (671, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeSuccess) {'), (672, 1, u'+  ASSERT_PRED2(PredFunctor2(),'), (680, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeFailure) {'), (683, 1, u'+    ASSERT_PRED2(PredFunction2Int,'), (692, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeFailure) {'), (695, 1, u'+    ASSERT_PRED2(PredFunction2Bool,'), (704, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeFailure) {'), (707, 1, u'+    ASSERT_PRED2(PredFunctor2(),'), (716, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeFailure) {'), (719, 1, u'+    ASSERT_PRED2(PredFunctor2(),'), (808, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeSuccess) {'), (809, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (817, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeSuccess) {'), (818, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (826, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeSuccess) {'), (827, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (835, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeSuccess) {'), (836, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (844, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeFailure) {'), (847, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (856, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeFailure) {'), (859, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (868, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeFailure) {'), (871, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (880, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeFailure) {'), (883, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (919, 1, u'+testing::AssertionResult PredFormatFunction3(const char* e1,'), (926, 1, u'+    return testing::AssertionSuccess();'), (928, 1, u'+  return testing::AssertionFailure()'), (937, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (997, 1, u'+typedef Predicate3Test ASSERT_PRED_FORMAT3Test;'), (999, 1, u'+typedef Predicate3Test ASSERT_PRED3Test;'), (1091, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeSuccess) {'), (1092, 1, u'+  ASSERT_PRED3(PredFunction3Int,'), (1101, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeSuccess) {'), (1102, 1, u'+  ASSERT_PRED3(PredFunction3Bool,'), (1111, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeSuccess) {'), (1112, 1, u'+  ASSERT_PRED3(PredFunctor3(),'), (1121, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeSuccess) {'), (1122, 1, u'+  ASSERT_PRED3(PredFunctor3(),'), (1131, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeFailure) {'), (1134, 1, u'+    ASSERT_PRED3(PredFunction3Int,'), (1144, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeFailure) {'), (1147, 1, u'+    ASSERT_PRED3(PredFunction3Bool,'), (1157, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeFailure) {'), (1160, 1, u'+    ASSERT_PRED3(PredFunctor3(),'), (1170, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeFailure) {'), (1173, 1, u'+    ASSERT_PRED3(PredFunctor3(),'), (1271, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeSuccess) {'), (1272, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1281, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeSuccess) {'), (1282, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1291, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeSuccess) {'), (1292, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1301, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeSuccess) {'), (1302, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1311, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeFailure) {'), (1314, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1324, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeFailure) {'), (1327, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1337, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeFailure) {'), (1340, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1350, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeFailure) {'), (1353, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1391, 1, u'+testing::AssertionResult PredFormatFunction4(const char* e1,'), (1400, 1, u'+    return testing::AssertionSuccess();'), (1402, 1, u'+  return testing::AssertionFailure()'), (1411, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (1478, 1, u'+typedef Predicate4Test ASSERT_PRED_FORMAT4Test;'), (1480, 1, u'+typedef Predicate4Test ASSERT_PRED4Test;'), (1580, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeSuccess) {'), (1581, 1, u'+  ASSERT_PRED4(PredFunction4Int,'), (1591, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeSuccess) {'), (1592, 1, u'+  ASSERT_PRED4(PredFunction4Bool,'), (1602, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeSuccess) {'), (1603, 1, u'+  ASSERT_PRED4(PredFunctor4(),'), (1613, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeSuccess) {'), (1614, 1, u'+  ASSERT_PRED4(PredFunctor4(),'), (1624, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeFailure) {'), (1627, 1, u'+    ASSERT_PRED4(PredFunction4Int,'), (1638, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeFailure) {'), (1641, 1, u'+    ASSERT_PRED4(PredFunction4Bool,'), (1652, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeFailure) {'), (1655, 1, u'+    ASSERT_PRED4(PredFunctor4(),'), (1666, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeFailure) {'), (1669, 1, u'+    ASSERT_PRED4(PredFunctor4(),'), (1776, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeSuccess) {'), (1777, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1787, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeSuccess) {'), (1788, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1798, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeSuccess) {'), (1799, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1809, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeSuccess) {'), (1810, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1820, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeFailure) {'), (1823, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1834, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeFailure) {'), (1837, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1848, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeFailure) {'), (1851, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1862, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeFailure) {'), (1865, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1905, 1, u'+testing::AssertionResult PredFormatFunction5(const char* e1,'), (1916, 1, u'+    return testing::AssertionSuccess();'), (1918, 1, u'+  return testing::AssertionFailure()'), (1927, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (2001, 1, u'+typedef Predicate5Test ASSERT_PRED_FORMAT5Test;'), (2003, 1, u'+typedef Predicate5Test ASSERT_PRED5Test;'), (2111, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeSuccess) {'), (2112, 1, u'+  ASSERT_PRED5(PredFunction5Int,'), (2123, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeSuccess) {'), (2124, 1, u'+  ASSERT_PRED5(PredFunction5Bool,'), (2135, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeSuccess) {'), (2136, 1, u'+  ASSERT_PRED5(PredFunctor5(),'), (2147, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeSuccess) {'), (2148, 1, u'+  ASSERT_PRED5(PredFunctor5(),'), (2159, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeFailure) {'), (2162, 1, u'+    ASSERT_PRED5(PredFunction5Int,'), (2174, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeFailure) {'), (2177, 1, u'+    ASSERT_PRED5(PredFunction5Bool,'), (2189, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeFailure) {'), (2192, 1, u'+    ASSERT_PRED5(PredFunctor5(),'), (2204, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeFailure) {'), (2207, 1, u'+    ASSERT_PRED5(PredFunctor5(),'), (2323, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeSuccess) {'), (2324, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2335, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeSuccess) {'), (2336, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2347, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeSuccess) {'), (2348, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2359, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeSuccess) {'), (2360, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2371, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeFailure) {'), (2374, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2386, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeFailure) {'), (2389, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2401, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeFailure) {'), (2404, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2416, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeFailure) {'), (2419, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),')]
===========================================
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class MyParamTest : public testing::TestWithParam<int> 
Class:class A : public Test 
Class:   class TestNamePrinter : public EmptyTestEventListener { class TestNamePrinter : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+TEST(NoFatalFailureTest, AssertNoFatalFailure) {'), (51, 1, u'+  ASSERT_NO_FATAL_FAILURE(;);'), (52, 1, u'+  ASSERT_NO_FATAL_FAILURE(SUCCEED());'), (53, 1, u'+  ASSERT_NO_FATAL_FAILURE(Subroutine());'), (54, 1, u'+  ASSERT_NO_FATAL_FAILURE({ SUCCEED(); });')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 1, u'+  ASSERT_TRUE(property != properties.end())'), (90, 1, u'+void ManyAsserts(int id) {'), (100, 1, u'+    ASSERT_FALSE(false) << "This shouldn\'t fail.";'), (102, 1, u'+    ASSERT_LE(5, 6);'), (128, 1, u'+TEST(StressTest, CanUseScopedTraceAndAssertionsInManyThreads) {'), (133, 1, u'+      threads[i].reset(new ThreadWithParam<int>(&ManyAsserts,'), (186, 1, u'+void AssertNoFatalFailureIgnoresFailuresInOtherThreads() {'), (187, 1, u'+  ASSERT_NO_FATAL_FAILURE(GenerateFatalFailureInAnotherThread(true));'), (189, 1, u'+TEST(NoFatalFailureTest, AssertNoFatalFailureIgnoresFailuresInOtherThreads) {'), (191, 1, u'+  AssertNoFatalFailureIgnoresFailuresInOtherThreads();')]
===========================================
Class:class TestEventListenersAccessor { class TestEventListenersAccessor 
Class:class SubClassOfTest : public Test 
Class:class AnotherSubClassOfTest : public Test 
Class:       class FormatEpochTimeInMillisAsIso8601Test : public Test { class FormatEpochTimeInMillisAsIso8601Test : public Test 
Class: class VectorShuffleTest : public Test { class VectorShuffleTest : public Test 
Class: class ScopedFakeTestPartResultReporterTest : public Test { class ScopedFakeTestPartResultReporterTest : public Test 
Class:    class TestResultTest : public Test { class TestResultTest : public Test 
Class:   class GTestFlagSaverTest : public Test { class GTestFlagSaverTest : public Test 
Class: class ShouldShardTest : public testing::Test { class ShouldShardTest : public testing::Test 
Class:   class DisabledTestsTest : public Test { class DisabledTestsTest : public Test 
Class: template <typename T> class DISABLED_TypedTest : public Test { class DISABLED_TypedTest : public Test 
Class: template <typename T> class DISABLED_TypedTestP : public Test { class DISABLED_TypedTestP : public Test 
Class:  class Uncopyable { class Uncopyable 
Class:class UnprintableChar { class UnprintableChar 
Class:     class Foo { class Foo 
Class:  class FRIEND_TEST_Test2 : public Test { class FRIEND_TEST_Test2 : public Test 
Class:       class TestLifeCycleTest : public Test { class TestLifeCycleTest : public Test 
Class:   class Base { class Base 
Class:class MyTypeInUnnamedNameSpace : public Base { class MyTypeInUnnamedNameSpace : public Base 
Class:class MyTypeInNameSpace1 : public Base { class MyTypeInNameSpace1 : public Base 
Class:class MyTypeInNameSpace2 : public ::Base { class MyTypeInNameSpace2 : public ::Base 
Class:class TestInfoTest : public Test { class TestInfoTest : public Test 
Class:   class SetUpTestCaseTest : public Test { class SetUpTestCaseTest : public Test 
Class:  class InitGoogleTestTest : public Test { class InitGoogleTestTest : public Test 
Class:class Test 
Class:class Message 
Class:class AssertionResult 
Class:   template <typename T> class StaticAssertTypeEqTestHelper { class StaticAssertTypeEqTestHelper 
Class: class TestListener : public EmptyTestEventListener { class TestListener : public EmptyTestEventListener 
Class:    class SequenceTestingListener : public EmptyTestEventListener { class SequenceTestingListener : public EmptyTestEventListener 
Class:class ConversionHelperBase 
Class:class ConversionHelperDerived : public ConversionHelperBase 
Class:class NonContainer 
Class: class SuccessfulTest : public Test { class SuccessfulTest : public Test 
Class: class FailedTest : public Test { class FailedTest : public Test 
Class: class DisabledTest : public Test { class DisabledTest : public Test 
Class: class PropertyRecordingTest : public Test { class PropertyRecordingTest : public Test 
Class:class ValueParamTest : public TestWithParam<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 1, u'+  ASSERT_EQ(1, 1);'), (62, 1, u'+  ASSERT_EQ(1, 2);'), (74, 1, u'+  ASSERT_EQ(1, 1);'), (79, 1, u'+  ASSERT_EQ(2, 3);')]
===========================================
Class:class BetweenCardinalityImpl : public CardinalityInterface { class BetweenCardinalityImpl : public CardinalityInterface 
Class:class GoogleTestFailureReporter : public FailureReporterInterface { class GoogleTestFailureReporter : public FailureReporterInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 1, u'+    AssertHelper(type == kFatal ?')]
===========================================
Class:class MockObjectRegistry { class MockObjectRegistry 
Class:class MyActionImpl : public ActionInterface<MyFunction> { class MyActionImpl : public ActionInterface<MyFunction> 
Class:    class IsNotZero : public ActionInterface<bool(int)> {   class IsNotZero : public ActionInterface<bool(int)> 
Class:   class ReturnZeroFromNullaryFunctionAction { class ReturnZeroFromNullaryFunctionAction 
Class:     class FromType { class FromType 
Class: class ToType { class ToType 
Class:class DestinationType 
Class: class SourceType { class SourceType 
Class:class MyClass 
Class: class MockClass { class MockClass 
Class: class NullaryFunctor { class NullaryFunctor 
Class: class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:class MockFoo { class MockFoo 
Class:    class EvenCardinality : public CardinalityInterface { class EvenCardinality : public CardinalityInterface 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class SubstractAction : public ActionInterface<int(int, int)> {   class SubstractAction : public ActionInterface<int(int, int)> 
Class: class NullaryConstructorClass { class NullaryConstructorClass 
Class: class UnaryConstructorClass { class UnaryConstructorClass 
Class: class TenArgConstructorClass { class TenArgConstructorClass 
Class:  class BoolResetter { class BoolResetter 
Class:class FooInterface { class FooInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+using ::testing::internal::CompileAssertTypesEqual;'), (52, 1, u'+  CompileAssertTypesEqual<tuple<>, MatcherTuple<tuple<> >::type>();'), (56, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<int> >,'), (61, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char> >,'), (66, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char>, Matcher<bool>,'), (76, 1, u'+  CompileAssertTypesEqual<int, F::Result>();'), (77, 1, u'+  CompileAssertTypesEqual<tuple<>, F::ArgumentTuple>();'), (78, 1, u'+  CompileAssertTypesEqual<tuple<>, F::ArgumentMatcherTuple>();'), (79, 1, u'+  CompileAssertTypesEqual<void(), F::MakeResultVoid>();'), (80, 1, u'+  CompileAssertTypesEqual<IgnoredValue(), F::MakeResultIgnoredValue>();'), (85, 1, u'+  CompileAssertTypesEqual<int, F::Result>();'), (86, 1, u'+  CompileAssertTypesEqual<bool, F::Argument1>();'), (87, 1, u'+  CompileAssertTypesEqual<tuple<bool>, F::ArgumentTuple>();'), (88, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<bool> >, F::ArgumentMatcherTuple>();'), (89, 1, u'+  CompileAssertTypesEqual<void(bool), F::MakeResultVoid>();  // NOLINT'), (90, 1, u'+  CompileAssertTypesEqual<IgnoredValue(bool),  // NOLINT'), (96, 1, u'+  CompileAssertTypesEqual<int, F::Result>();'), (97, 1, u'+  CompileAssertTypesEqual<bool, F::Argument1>();'), (98, 1, u'+  CompileAssertTypesEqual<const long&, F::Argument2>();  // NOLINT'), (99, 1, u'+  CompileAssertTypesEqual<tuple<bool, const long&>, F::ArgumentTuple>();  // NOLINT'), (100, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<const long&> >,  // NOLINT'), (102, 1, u'+  CompileAssertTypesEqual<void(bool, const long&), F::MakeResultVoid>();  // NOLINT'), (103, 1, u'+  CompileAssertTypesEqual<IgnoredValue(bool, const long&),  // NOLINT'), (109, 1, u'+  CompileAssertTypesEqual<char, F::Result>();'), (110, 1, u'+  CompileAssertTypesEqual<bool, F::Argument1>();'), (111, 1, u'+  CompileAssertTypesEqual<int, F::Argument2>();'), (112, 1, u'+  CompileAssertTypesEqual<char*, F::Argument3>();'), (113, 1, u'+  CompileAssertTypesEqual<int&, F::Argument4>();'), (114, 1, u'+  CompileAssertTypesEqual<const long&, F::Argument5>();  // NOLINT'), (115, 1, u'+  CompileAssertTypesEqual<tuple<bool, int, char*, int&, const long&>,  // NOLINT'), (117, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<int>, Matcher<char*>,'), (120, 1, u'+  CompileAssertTypesEqual<void(bool, int, char*, int&, const long&),  // NOLINT'), (122, 1, u'+  CompileAssertTypesEqual<')]
===========================================
Class:class LessThanMatcher : public MatcherInterface<tuple<char, int> > { class LessThanMatcher : public MatcherInterface<tuple<char, int> > 
Class:  class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class: class NativeArrayPassedAsPointerAndSize { class NativeArrayPassedAsPointerAndSize 
Class:    class UncopyableFoo { class UncopyableFoo 
Class:class Message;
Class:class Base 
Class:class Derived : public Base 
Class:class LogIsVisibleTest : public ::testing::Test { class LogIsVisibleTest : public ::testing::Test 
Class: class DummyMock { class DummyMock 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 1, u'+  CompileAssertTypesEqual<const char,'), (105, 1, u'+  CompileAssertTypesEqual<int, PointeeOf<int*>::type>();'), (106, 1, u'+  CompileAssertTypesEqual<const char, PointeeOf<const char*>::type>();'), (107, 1, u'+  CompileAssertTypesEqual<void, PointeeOf<void*>::type>();'), (308, 1, u'+TEST(AssertTest, SucceedsOnTrue) {'), (309, 1, u'+  Assert(true, __FILE__, __LINE__, "This should succeed.");'), (310, 1, u'+  Assert(true, __FILE__, __LINE__);  // This should succeed too.'), (314, 1, u'+TEST(AssertTest, FailsFatallyOnFalse) {'), (316, 1, u'+    Assert(false, __FILE__, __LINE__, "This should fail.");'), (320, 1, u'+    Assert(false, __FILE__, __LINE__);'), (577, 1, u'+  StaticAssertTypeEq<std::vector<int>,'), (579, 1, u'+  StaticAssertTypeEq<const std::vector<double>&,'), (593, 1, u'+  StaticAssertTypeEq<NativeArray<int>,'), (595, 1, u'+  StaticAssertTypeEq<NativeArray<double>,'), (597, 1, u'+  StaticAssertTypeEq<NativeArray<char[3]>,'), (600, 1, u'+  StaticAssertTypeEq<const NativeArray<int>,'), (609, 1, u'+  ASSERT_EQ(3U, a3.size());'), (620, 1, u'+  StaticAssertTypeEq<NativeArray<int>,'), (622, 1, u'+  StaticAssertTypeEq<NativeArray<double>,'), (625, 1, u'+  StaticAssertTypeEq<const NativeArray<int>,'), (637, 1, u'+  ASSERT_EQ(3U, a3.size());')]
===========================================
Class:class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:   class DeletionTester { class DeletionTester 
Class:class MyException 
Class:class Foo { class Foo 
Class:class ExpectationTester { class ExpectationTester 
Class:class Incomplete;
Class: class MockIncomplete { class MockIncomplete 
Class:class Result 
Class: class MockA { class MockA 
Class: class MockB { class MockB 
Class: class ReferenceHoldingMock { class ReferenceHoldingMock 
Class:class MockCC : public CC { class MockCC : public CC 
Class: class EvenNumberCardinality : public CardinalityInterface { class EvenNumberCardinality : public CardinalityInterface 
Class: class MockC { class MockC 
Class: class VerboseFlagPreservingFixture : public testing::Test { class VerboseFlagPreservingFixture : public testing::Test 
Class:   class GMockVerboseFlagTest : public VerboseFlagPreservingFixture { class GMockVerboseFlagTest : public VerboseFlagPreservingFixture 
Class:class PrintMeNot 
Class: class LogTestHelper { class LogTestHelper 
Class: class GMockLogTest : public VerboseFlagPreservingFixture { class GMockLogTest : public VerboseFlagPreservingFixture 
Class:class FooInterface { class FooInterface 
Class: class MockFoo : public FooInterface { class MockFoo : public FooInterface 
Class: class MockFoo { class MockFoo 
Class: class GMockOutputTest : public testing::Test { class GMockOutputTest : public testing::Test 
Class:class MockFoo { class MockFoo 
Class:class Base { class Base 
Class: class Derived1 : public Base { class Derived1 : public Base 
Class: class Derived2 : public Base { class Derived2 : public Base 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+  ASSERT_EQ(N, argc) << "The new argv has wrong number of elements.";')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+              BOOST_ASSERT(notify.empty());'), (6, 1, u'+              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
Total add: 6
Total del: 1
Header: namespace boost
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+              BOOST_ASSERT(notify.empty());'), (6, 1, u'+              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+              BOOST_ASSERT(notify.empty());'), (6, 1, u'+              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 1, u'+              BOOST_ASSERT(notify.empty());'), (5, 1, u'+              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
Total add: 6
Total del: 0
Header: namespace boost
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 1, u'+              BOOST_ASSERT(notify.empty());'), (5, 1, u'+              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 1, u'+              BOOST_ASSERT(notify.empty());'), (5, 1, u'+              BOOST_ASSERT(async_states_.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 1, u'+    BOOST_STATIC_ASSERT_MSG(sizeof(atomic_int_type) == sizeof(atomic_type), "Boost.Thread: unsupported platform");')]
===========================================
Class:class TranslationUnitTest : public ::testing::Test { class TranslationUnitTest : public ::testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  ASSERT_DEBUG_DEATH({  // NOLINT'), (8, 1, u'+  ASSERT_DEBUG_DEATH(DieInDebugElse12(&sideeffect), "death.*DieInDebugElse12")')]
===========================================
===========================================
Total add: 2
Total del: 6
Header: TEST_F
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  ASSERT_DEBUG_DEATH({  // NOLINT'), (8, 1, u'+  ASSERT_DEBUG_DEATH(DieInDebugElse12(&sideeffect), "death.*DieInDebugElse12")')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  ASSERT_DEBUG_DEATH({  // NOLINT'), (8, 1, u'+  ASSERT_DEBUG_DEATH(DieInDebugElse12(&sideeffect), "death.*DieInDebugElse12")')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-      ASSERT_TRUE(isdigit(static_cast<unsigned char>(result[i])) != 0);'), (3, 1, u'+      ASSERT_NE(isdigit(static_cast<unsigned char>(result[i])), 0);')]
===========================================
===========================================
Total add: 1
Total del: 1
Header: TEST
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-      ASSERT_TRUE(isdigit(static_cast<unsigned char>(result[i])) != 0);'), (3, 1, u'+      ASSERT_NE(isdigit(static_cast<unsigned char>(result[i])), 0);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-      ASSERT_TRUE(isdigit(static_cast<unsigned char>(result[i])) != 0);'), (3, 1, u'+      ASSERT_NE(isdigit(static_cast<unsigned char>(result[i])), 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+  ASSERT_STRNE(L"abc\\x8119", L"abc\\x8120") << "This shouldn\'t happen";')]
===========================================
===========================================
Total add: 3
Total del: 0
Header: TEST
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+  ASSERT_STRNE(L"abc\\x8119", L"abc\\x8120") << "This shouldn\'t happen";')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+  ASSERT_STRNE(L"abc\\x8119", L"abc\\x8120") << "This shouldn\'t happen";')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+TEST(AssertionWithMessageTest, EXPECT) {'), (28, 1, u'+TEST(AssertionWithMessageTest, ASSERT) {'), (29, 1, u'+  ASSERT_EQ(1, 1) << "This should succeed.";'), (30, 1, u'+  ASSERT_NE(1, 2) << "This should succeed.";'), (31, 1, u'+  ASSERT_LE(1, 2) << "This should succeed.";'), (32, 1, u'+  ASSERT_LT(1, 2) << "This should succeed.";'), (33, 1, u'+  ASSERT_GE(1, 0) << "This should succeed.";'), (34, 1, u'+  EXPECT_FATAL_FAILURE(ASSERT_GT(1, 2) << "Expected failure.",'), (38, 1, u'+TEST(AssertionWithMessageTest, ASSERT_STR) {'), (39, 1, u'+  ASSERT_STREQ("1", "1") << "This should succeed.";'), (40, 1, u'+  ASSERT_STRNE("1", "2") << "This should succeed.";'), (41, 1, u'+  ASSERT_STRCASEEQ("a", "A") << "This should succeed.";'), (42, 1, u'+  EXPECT_FATAL_FAILURE(ASSERT_STRCASENE("a", "A") << "Expected failure.",'), (46, 1, u'+TEST(AssertionWithMessageTest, ASSERT_FLOATING) {'), (47, 1, u'+  ASSERT_FLOAT_EQ(1, 1) << "This should succeed.";'), (48, 1, u'+  ASSERT_DOUBLE_EQ(1, 1) << "This should succeed.";'), (49, 1, u'+  EXPECT_FATAL_FAILURE(ASSERT_NEAR(1,1.2, 0.1) << "Expect failure.",  // NOLINT'), (56, 1, u'+TEST(AssertionWithMessageTest, ASSERT_FALSE) {'), (57, 1, u'+  ASSERT_FALSE(false) << "This shouldn\'t fail.";'), (59, 1, u'+    ASSERT_FALSE(true) << "Expected failure: " << 2 << " > " << 1'), (65, 1, u'+TEST(AssertionWithMessageTest, FAIL) {'), (71, 1, u'+TEST(AssertionWithMessageTest, SUCCEED) {'), (76, 1, u'+TEST(AssertionWithMessageTest, ASSERT_TRUE) {'), (77, 1, u'+  ASSERT_TRUE(true) << "This should succeed.";'), (78, 1, u'+  ASSERT_TRUE(true) << true;'), (80, 1, u'+    ASSERT_TRUE(false) << static_cast<const char *>(NULL)'), (87, 1, u'+TEST(AssertionWithMessageTest, WideStringMessage) {'), (92, 1, u'+    ASSERT_EQ(1, 2) << "This failure is "')]
===========================================
===========================================
Total add: 101
Total del: 0
Header: namespace {
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+TEST(AssertionWithMessageTest, EXPECT) {'), (28, 1, u'+TEST(AssertionWithMessageTest, ASSERT) {'), (29, 1, u'+  ASSERT_EQ(1, 1) << "This should succeed.";'), (30, 1, u'+  ASSERT_NE(1, 2) << "This should succeed.";'), (31, 1, u'+  ASSERT_LE(1, 2) << "This should succeed.";'), (32, 1, u'+  ASSERT_LT(1, 2) << "This should succeed.";'), (33, 1, u'+  ASSERT_GE(1, 0) << "This should succeed.";'), (34, 1, u'+  EXPECT_FATAL_FAILURE(ASSERT_GT(1, 2) << "Expected failure.",'), (38, 1, u'+TEST(AssertionWithMessageTest, ASSERT_STR) {'), (39, 1, u'+  ASSERT_STREQ("1", "1") << "This should succeed.";'), (40, 1, u'+  ASSERT_STRNE("1", "2") << "This should succeed.";'), (41, 1, u'+  ASSERT_STRCASEEQ("a", "A") << "This should succeed.";'), (42, 1, u'+  EXPECT_FATAL_FAILURE(ASSERT_STRCASENE("a", "A") << "Expected failure.",'), (46, 1, u'+TEST(AssertionWithMessageTest, ASSERT_FLOATING) {'), (47, 1, u'+  ASSERT_FLOAT_EQ(1, 1) << "This should succeed.";'), (48, 1, u'+  ASSERT_DOUBLE_EQ(1, 1) << "This should succeed.";'), (49, 1, u'+  EXPECT_FATAL_FAILURE(ASSERT_NEAR(1,1.2, 0.1) << "Expect failure.",  // NOLINT'), (56, 1, u'+TEST(AssertionWithMessageTest, ASSERT_FALSE) {'), (57, 1, u'+  ASSERT_FALSE(false) << "This shouldn\'t fail.";'), (59, 1, u'+    ASSERT_FALSE(true) << "Expected failure: " << 2 << " > " << 1'), (65, 1, u'+TEST(AssertionWithMessageTest, FAIL) {'), (71, 1, u'+TEST(AssertionWithMessageTest, SUCCEED) {'), (76, 1, u'+TEST(AssertionWithMessageTest, ASSERT_TRUE) {'), (77, 1, u'+  ASSERT_TRUE(true) << "This should succeed.";'), (78, 1, u'+  ASSERT_TRUE(true) << true;'), (80, 1, u'+    ASSERT_TRUE(false) << static_cast<const char *>(NULL)'), (87, 1, u'+TEST(AssertionWithMessageTest, WideStringMessage) {'), (92, 1, u'+    ASSERT_EQ(1, 2) << "This failure is "')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+TEST(AssertionWithMessageTest, EXPECT) {'), (28, 1, u'+TEST(AssertionWithMessageTest, ASSERT) {'), (29, 1, u'+  ASSERT_EQ(1, 1) << "This should succeed.";'), (30, 1, u'+  ASSERT_NE(1, 2) << "This should succeed.";'), (31, 1, u'+  ASSERT_LE(1, 2) << "This should succeed.";'), (32, 1, u'+  ASSERT_LT(1, 2) << "This should succeed.";'), (33, 1, u'+  ASSERT_GE(1, 0) << "This should succeed.";'), (34, 1, u'+  EXPECT_FATAL_FAILURE(ASSERT_GT(1, 2) << "Expected failure.",'), (38, 1, u'+TEST(AssertionWithMessageTest, ASSERT_STR) {'), (39, 1, u'+  ASSERT_STREQ("1", "1") << "This should succeed.";'), (40, 1, u'+  ASSERT_STRNE("1", "2") << "This should succeed.";'), (41, 1, u'+  ASSERT_STRCASEEQ("a", "A") << "This should succeed.";'), (42, 1, u'+  EXPECT_FATAL_FAILURE(ASSERT_STRCASENE("a", "A") << "Expected failure.",'), (46, 1, u'+TEST(AssertionWithMessageTest, ASSERT_FLOATING) {'), (47, 1, u'+  ASSERT_FLOAT_EQ(1, 1) << "This should succeed.";'), (48, 1, u'+  ASSERT_DOUBLE_EQ(1, 1) << "This should succeed.";'), (49, 1, u'+  EXPECT_FATAL_FAILURE(ASSERT_NEAR(1,1.2, 0.1) << "Expect failure.",  // NOLINT'), (56, 1, u'+TEST(AssertionWithMessageTest, ASSERT_FALSE) {'), (57, 1, u'+  ASSERT_FALSE(false) << "This shouldn\'t fail.";'), (59, 1, u'+    ASSERT_FALSE(true) << "Expected failure: " << 2 << " > " << 1'), (65, 1, u'+TEST(AssertionWithMessageTest, FAIL) {'), (71, 1, u'+TEST(AssertionWithMessageTest, SUCCEED) {'), (76, 1, u'+TEST(AssertionWithMessageTest, ASSERT_TRUE) {'), (77, 1, u'+  ASSERT_TRUE(true) << "This should succeed.";'), (78, 1, u'+  ASSERT_TRUE(true) << true;'), (80, 1, u'+    ASSERT_TRUE(false) << static_cast<const char *>(NULL)'), (87, 1, u'+TEST(AssertionWithMessageTest, WideStringMessage) {'), (92, 1, u'+    ASSERT_EQ(1, 2) << "This failure is "')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    AssertHelper(type == FATAL ?'), (3, 1, u'+    AssertHelper(type == kFatal ?')]
===========================================
===========================================
Total add: 1
Total del: 1
Header: class GoogleTestFailureReporter : public FailureReporterInterface {
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    AssertHelper(type == FATAL ?'), (3, 1, u'+    AssertHelper(type == kFatal ?')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-    AssertHelper(type == FATAL ?'), (3, 1, u'+    AssertHelper(type == kFatal ?')]
===========================================
Class: template <typename T> class ConstPropagatingPtr { class ConstPropagatingPtr 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 2, u'-CAMLprim value llvm_assert_valid_module(LLVMModuleRef M) {'), (57, 2, u'-CAMLprim value llvm_assert_valid_function(LLVMValueRef Fn) {')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(139, 2, u'-  assert(LLVMGenericValueIntWidth(Genericvalue_val(GenVal)) <= 8 * sizeof(value)'), (147, 2, u'-  assert(LLVMGenericValueIntWidth(Genericvalue_val(GenVal)) <= 32'), (155, 2, u'-  assert(LLVMGenericValueIntWidth(Genericvalue_val(GenVal)) <= 64'), (163, 2, u'-  assert(LLVMGenericValueIntWidth(Genericvalue_val(GenVal)) <= 8 * sizeof(value)')]
===========================================
Class:   class OurCppRunException : public std::runtime_error { class OurCppRunException : public std::runtime_error 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 2, u"-  assert(Add1F->arg_begin() != Add1F->arg_end()); // Make sure there's an arg")]
===========================================
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:    class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:    class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:    class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:  class IfExprAST : public ExprAST { class IfExprAST : public ExprAST 
Class:  class ForExprAST : public ExprAST { class ForExprAST : public ExprAST 
Class:    class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class UnaryExprAST : public ExprAST { class UnaryExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:  class IfExprAST : public ExprAST { class IfExprAST : public ExprAST 
Class:  class ForExprAST : public ExprAST { class ForExprAST : public ExprAST 
Class:    class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class UnaryExprAST : public ExprAST { class UnaryExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:  class IfExprAST : public ExprAST { class IfExprAST : public ExprAST 
Class:  class ForExprAST : public ExprAST { class ForExprAST : public ExprAST 
Class:  class VarExprAST : public ExprAST { class VarExprAST : public ExprAST 
Class:   class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:    class WaitForThreads { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (54, 2, u'-  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (59, 2, u'-  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (64, 2, u'-  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (69, 2, u'-  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (77, 2, u'-  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (122, 2, u'-  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (195, 2, u'-  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (214, 2, u'-  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (404, 2, u'-  assert(I1.getParent() == I2.getParent() &&')]
===========================================
Class:  class AliasAnalysisCounter : public ModulePass, public AliasAnalysis {   class AliasAnalysisCounter : public ModulePass, public AliasAnalysis 
Class:  class AAEval : public FunctionPass {   class AAEval : public FunctionPass 
Class:  class AliasDebugger : public ModulePass, public AliasAnalysis {   class AliasDebugger : public ModulePass, public AliasAnalysis 
Class:  class AliasSetPrinter : public FunctionPass {   class AliasSetPrinter : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(181, 2, u'-  assert(V->getType()->isIntegerTy() && "Not an integer value");'), (478, 2, u'-      assert(AliasCache.empty() && "AliasCache must be cleared after use!");'), (479, 2, u'-      assert(notDifferentParent(LocA.Ptr, LocB.Ptr) &&'), (574, 2, u'-  assert(Visited.empty() && "Visited must be cleared after use!");'), (682, 2, u'-  assert(notDifferentParent(CS.getInstruction(), Loc.Ptr) &&'), (887, 2, u'-      assert(TD == 0 &&'), (923, 2, u'-      assert(TD == 0 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(175, 2, u'-  assert(Weights.size() == TI->getNumSuccessors() && "Checked above");'), (199, 2, u'-  assert(CI->getOperand(1)->getType()->isPointerTy());'), (382, 2, u'-  assert(PostDominatedByUnreachable.empty());'), (411, 2, u'-  assert(LastF && "Cannot print prior to running over a function");'), (430, 2, u'-    assert(Sum > PrevSum); (void) PrevSum;'), (454, 2, u'-    assert(Sum > PrevSum); (void) PrevSum;')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(58, 2, u'-  assert(!isa<GlobalValue>(V) &&'), (78, 2, u'-  assert(V->getType()->isPointerTy() && "Capture is for pointers only!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(278, 2, u'-  assert(ByteOffset <= TD.getTypeAllocSize(C->getType()) &&'), (625, 2, u'-        assert((CE == 0 || CE->getType() == IntPtrTy) &&'), (684, 2, u'-  assert(Ty->isPointerTy() && "Forming regular GEP of non-pointer type");'), (746, 2, u'-  assert(cast<PointerType>(C->getType())->getElementType() == Ty &&'), (1166, 2, u'-  assert(ResultWidth <= 64 &&'), (1305, 2, u'-        assert(status == APFloat::opOK && !lost &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 2, u'-  assert((Tag & LLVMDebugVersionMask) == 0 &&'), (80, 2, u'-  assert(((Lang <= dwarf::DW_LANG_Python && Lang >= dwarf::DW_LANG_C89) ||'), (83, 2, u'-  assert(!Filename.empty() &&'), (129, 2, u'-  assert(TheCU && "Unable to create DW_TAG_file_type without CompileUnit");'), (130, 2, u'-  assert(!Filename.empty() && "Unable to create file without name");'), (142, 2, u'-  assert(!Name.empty() && "Unable to create enumerator without name");'), (153, 2, u'-  assert(!Name.empty() && "Unable to create type without name");'), (176, 2, u'-  assert(!Name.empty() && "Unable to create type without name");'), (234, 2, u'-  assert(RTy.Verify() && "Unable to create reference type");'), (255, 2, u'-  assert(Ty.Verify() && "Invalid typedef type!");'), (274, 2, u'-  assert(Ty.Verify() && "Invalid type!");'), (275, 2, u'-  assert(FriendTy.Verify() && "Invalid friend type!");'), (295, 2, u'-  assert(Ty.Verify() && "Unable to create inheritance");'), (623, 2, u'-  assert (N && "Unexpected input DIType!");'), (960, 2, u'-  assert(Storage && "no storage passed to dbg.declare");'), (961, 2, u'-  assert(VarInfo.Verify() && "empty DIVariable passed to dbg.declare");'), (972, 2, u'-  assert(Storage && "no storage passed to dbg.declare");'), (973, 2, u'-  assert(VarInfo.Verify() && "invalid DIVariable passed to dbg.declare");'), (991, 2, u'-  assert(V && "no value passed to dbg.value");'), (992, 2, u'-  assert(VarInfo.Verify() && "invalid DIVariable passed to dbg.value");'), (1006, 2, u'-  assert(V && "no value passed to dbg.value");'), (1007, 2, u'-  assert(VarInfo.Verify() && "invalid DIVariable passed to dbg.value");')]
===========================================
Class:  class PrintDbgInfo : public FunctionPass {   class PrintDbgInfo : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(536, 2, u'-  assert(CurFn && "Invalid function");'), (547, 2, u'-  assert(F && "Invalid function");'), (559, 2, u'-  assert (DbgNode && "Invalid subprogram descriptor!");')]
===========================================
Class:  class DFCalculateWorkObject {   class DFCalculateWorkObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(52, 2, u'-    assert (currentW && "Missing work object.");'), (58, 2, u'-    assert (currentBB && "Invalid work object. Missing current Basic Block");'), (59, 2, u'-    assert (currentNode && "Invalid work object. Missing current Node");')]
===========================================
Class:class BasicCallGraph : public ModulePass, public CallGraph { class BasicCallGraph : public ModulePass, public CallGraph 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(216, 2, u'-  assert(CGN->empty() && "Cannot remove function from call "'), (232, 2, u'-  assert(FunctionMap.count(From) && "No CallGraphNode for function!");'), (233, 2, u'-  assert(!FunctionMap.count(To) &&'), (248, 2, u'-  assert((!F || F->getParent() == Mod) && "Function not in current module!");'), (277, 2, u'-    assert(I != CalledFunctions.end() && "Cannot find callsite to remove!");'), (304, 2, u'-    assert(I != CalledFunctions.end() && "Cannot find callee to remove!");'), (321, 2, u'-    assert(I != CalledFunctions.end() && "Cannot find callsite to remove!");')]
===========================================
Class:class CGPassManager : public ModulePass, public PMDataManager { class CGPassManager : public ModulePass, public PMDataManager 
Class:  class PrintCallGraphPass : public CallGraphSCCPass {   class PrintCallGraphPass : public CallGraphSCCPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 2, u'-    assert(N < PassVector.size() && "Pass number out of range!");'), (135, 2, u'-  assert(PM->getPassManagerType() == PMT_FunctionPassManager &&'), (213, 2, u'-        assert(!CheckingMode &&'), (236, 2, u'-      assert(!CallSites.count(I->first) &&'), (274, 2, u'-          assert(!CheckingMode &&'), (299, 2, u'-        assert(!CheckingMode &&'), (333, 2, u'-    assert(CallSites.empty() && "Dangling pointers found in call sites map");'), (476, 2, u'-      assert(PM->getPassManagerType() == PMT_FunctionPassManager &&'), (491, 2, u'-      assert(PM->getPassManagerType() == PMT_FunctionPassManager &&'), (508, 2, u'-  assert(Old != New && "Should not replace node with self");'), (510, 2, u'-    assert(i != Nodes.size() && "Node not in SCC");'), (535, 2, u'-  assert(!PMS.empty() && "Unable to handle Call Graph Pass");'), (542, 2, u'-    assert(!PMS.empty() && "Unable to create Call Graph Pass Manager");')]
===========================================
Class:  class GlobalsModRef : public ModulePass, public AliasAnalysis {   class GlobalsModRef : public ModulePass, public AliasAnalysis 
Class:class CallAnalyzer : public InstVisitor<CallAnalyzer, bool> { class CallAnalyzer : public InstVisitor<CallAnalyzer, bool> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(242, 2, u'-  assert(IntPtrWidth == Offset.getBitWidth());'), (793, 2, u'-    assert(V->getType()->isPointerTy() && "Unexpected operand type!");'), (823, 2, u'-    assert(NumInstructions == 0);'), (824, 2, u'-    assert(NumVectorInstructions == 0);'), (868, 2, u'-    assert(CAI != CS.arg_end());')]
===========================================
Class:  class InstCount : public FunctionPass, public InstVisitor<InstCount> {   class InstCount : public FunctionPass, public InstVisitor<InstCount> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(65, 2, u'-  assert(Ty->getScalarType()->isIntegerTy(1) &&'), (73, 2, u'-  assert(Ty->getScalarType()->isIntegerTy(1) &&'), (262, 2, u'-  assert(Instruction::isAssociative(Opcode) && "Not an associative operation!");'), (368, 2, u'-    assert(isa<SelectInst>(RHS) && "No select instruction operand!");'), (442, 2, u'-  assert(isa<SelectInst>(LHS) && "Not comparing with a select instruction!");'), (525, 2, u'-    assert(isa<PHINode>(RHS) && "No PHI instruction operand!");'), (566, 2, u'-  assert(isa<PHINode>(LHS) && "Not comparing with a phi instruction!");'), (670, 2, u'-  assert(IntPtrWidth == Offset.getBitWidth());'), (725, 2, u'-    assert(V->getType()->isPointerTy() && "Unexpected operand type!");'), (1639, 2, u'-  assert(CmpInst::isIntPredicate(Pred) && "Not an integer compare!");'), (2408, 2, u'-  assert(CmpInst::isFPPredicate(Pred) && "Not an FP compare!");'), (2443, 2, u'-        assert(FCmpInst::isUnordered(Pred) &&'), (2943, 2, u'-  assert(I != SimpleV && "replaceAndRecursivelySimplify(X,X) is not valid!");'), (2944, 2, u'-  assert(SimpleV && "Must provide a simplified value.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 2, u'-  assert(I != intervals_end(&F) && "No intervals in function!?!?!");'), (95, 2, u'-  assert(IP.getRootInterval() && "Cannot operate on empty IntervalPartitions!");'), (99, 2, u'-  assert(I != intervals_end(IP) && "No intervals in interval partition!?!?!");')]
===========================================
Class:class LVILatticeVal { class LVILatticeVal 
Class:  class LazyValueInfoCache;
Class:  class LazyValueInfoCache {   class LazyValueInfoCache 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 2, u'-  assert(FI->DetailsType == LibCallFunctionInfo::DoesOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-  assert(LocID < NumLocations && "Invalid location ID!");')]
===========================================
Class:  class Lint : public FunctionPass, public InstVisitor<Lint> {   class Lint : public FunctionPass, public InstVisitor<Lint> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(78, 2, u'-    assert(V->getType()->isPointerTy() && "Unexpected operand type!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(171, 2, u'-  assert(isZIVPair(A, B) && "Attempted to ZIV-test non-ZIV SCEVs!");'), (294, 2, u'-  assert(isDependencePair(A, B) && "Values form no dependence pair!");')]
===========================================
Class:class UnloopUpdater { class UnloopUpdater 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(138, 2, u'-  assert(PI != pred_end(H) &&'), (244, 2, u'-  assert(hasDedicatedExits() &&'), (361, 2, u'-        assert((NL != Unloop && (!NL || NL->contains(Unloop))) &&'), (368, 2, u'-        assert((FoundIB || Unloop->contains(L)) && "uninitialized successor");'), (376, 2, u'-    assert(NIters < Unloop->getNumBlocks() && "runaway iterative algorithm");'), (387, 2, u'-        assert(NL != Unloop && (!NL || NL->contains(Unloop)) &&'), (413, 2, u'-      assert(OldParent && "new loop is not an ancestor of the original");'), (426, 2, u'-    assert(SubloopParents.count(Subloop) && "DFS failed to visit subloop");'), (451, 2, u'-      assert(Subloop && "subloop is not an ancestor of the original loop");'), (461, 2, u'-    assert(!Subloop && "subloop blocks must have a successor");'), (472, 2, u'-      assert((FoundIB || !DFS.hasPostorder(*I)) && "should have seen IB");'), (481, 2, u'-      assert(L->getParentLoop() == Unloop && "cannot skip into nested loops");'), (540, 2, u'-      assert(I != LI.end() && "Couldn\'t find loop");'), (568, 2, u'-    assert(I != ParentLoop->end() && "Couldn\'t find loop");'), (587, 2, u'-    assert(!(*I)->getParentLoop() && "Top-level loop has a parent!");'), (597, 2, u'-    assert(Loops.count(I->second) && "orphaned loop");'), (598, 2, u'-    assert(I->second->contains(I->first) && "orphaned block");')]
===========================================
Class:class PrintLoopPass : public LoopPass { class PrintLoopPass : public LoopPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(96, 2, u'-  assert (CurrentLoop != L && "Cannot insert CurrentLoop");'), (132, 2, u'-  assert (CurrentLoop == L && "Can redo only CurrentLoop");'), (338, 2, u'-    assert (!PMS.empty() && "Unable to create Loop Pass Manager");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 2, u'-      assert(dep.isUnknown() && "unexptected dependence type");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(137, 2, u'-  assert(isMalloc(CI) && "getMallocType and not malloc call");'), (179, 2, u'-  assert(isMalloc(CI) && "getMallocArraySize and not malloc call");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(109, 2, u'-  assert(InstIt != ReverseMap.end() && "Reverse map out of sync?");'), (111, 2, u'-  assert(Found && "Invalid reverse map!"); (void)Found;'), (655, 2, u'-static void AssertSorted(MemoryDependenceAnalysis::NonLocalDepInfo &Cache,'), (661, 2, u'-    assert(!(Cache[i] < Cache[i-1]) && "Cache isn\'t sorted!");'), (679, 2, u'-  assert(getDependency(QueryCS.getInstruction()).isNonLocal() &&'), (725, 2, u'-  DEBUG(AssertSorted(Cache));'), (738, 2, u'-    DEBUG(AssertSorted(Cache, NumSortedEntries));'), (819, 2, u'-  assert(Loc.Ptr->getType()->isPointerTy() &&'), (872, 2, u'-    assert(ExistingResult->getResult().getInst()->getParent() == BB &&'), (903, 2, u'-  assert(Inst && "Didn\'t depend on anything?");'), (1080, 2, u'-  DEBUG(AssertSorted(*Cache));'), (1089, 2, u'-      assert(Visited.count(BB) && "Should check \'visited\' before adding to WL");'), (1093, 2, u'-      DEBUG(AssertSorted(*Cache, NumSortedEntries));'), (1280, 2, u'-      assert(I != Cache->rend() && "Didn\'t find current block??");'), (1284, 2, u'-      assert(I->getResult().isNonLocal() &&'), (1295, 2, u'-  DEBUG(AssertSorted(*Cache));'), (1314, 2, u'-    assert(Target->getParent() == PInfo[i].getBB());'), (1404, 2, u'-    assert(!ReverseDeps.empty() && !isa<TerminatorInst>(RemInst) &&'), (1410, 2, u'-      assert(InstDependingOnRemInst != RemInst &&'), (1416, 2, u'-      assert(NewDirtyVal.getInst() && "There is no way something else can have "'), (1438, 2, u'-      assert(*I != RemInst && "Already removed NonLocalDep info for RemInst");'), (1477, 2, u'-      assert(P.getPointer() != RemInst &&'), (1512, 2, u'-  assert(!NonLocalDeps.count(RemInst) && "RemInst got reinserted?");'), (1521, 2, u'-    assert(I->first != D && "Inst occurs in data structures");'), (1522, 2, u'-    assert(I->second.getInst() != D &&'), (1528, 2, u'-    assert(I->first.getPointer() != D && "Inst occurs in NLPD map key");'), (1532, 2, u'-      assert(II->getResult().getInst() != D && "Inst occurs as NLPD value");'), (1537, 2, u'-    assert(I->first != D && "Inst occurs in data structures");'), (1541, 2, u'-      assert(II->getResult().getInst() != D && "Inst occurs in data structures");'), (1546, 2, u'-    assert(I->first != D && "Inst occurs in data structures");'), (1549, 2, u'-      assert(*II != D && "Inst occurs in data structures");'), (1555, 2, u'-    assert(I->first != D && "Inst occurs in data structures");'), (1558, 2, u'-      assert(*II != D && "Inst occurs in data structures");'), (1564, 2, u'-    assert(I->first != D && "Inst occurs in rev NLPD map");'), (1568, 2, u'-      assert(*II != ValueIsLoadPair(D, false) &&')]
===========================================
Class:  class ModuleDebugInfoPrinter : public ModulePass {   class ModuleDebugInfoPrinter : public ModulePass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 2, u'-  assert(!isa<PHINode>(I) && "Error, removing something that isn\'t an input");'), (322, 2, u'-  assert(Verify() && "Invalid PHITransAddr!");'), (324, 2, u'-  assert(Verify() && "Invalid PHITransAddr!");')]
===========================================
Class:  class PathProfileLoaderPass : public ModulePass, public PathProfileInfo {   class PathProfileLoaderPass : public ModulePass, public PathProfileInfo 
Class:  class PathProfileVerifier : public ModulePass {   class PathProfileVerifier : public ModulePass 
Class:  class ProfileEstimatorPass : public FunctionPass, public ProfileInfo {   class ProfileEstimatorPass : public FunctionPass, public ProfileInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(185, 2, u'-  assert (oldw != MissingValue && "Adding weight to Edge with no previous weight");'), (195, 2, u'-  assert (oldw != MissingValue && "Adding weight to Block with no previous weight");'), (954, 2, u'-            assert(0 && "Edge should not have value already!");'), (991, 2, u'-    assert(0 && "could not repair function");')]
===========================================
Class:  class LoaderPass : public ModulePass, public ProfileInfo {   class LoaderPass : public ModulePass, public ProfileInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(215, 2, u'-          assert(0 && "No edge calculated!");')]
===========================================
Class:  class ProfileVerifierPassT : public FunctionPass {   class ProfileVerifierPassT : public FunctionPass 
Class:class PrintRegionPass : public RegionPass { class PrintRegionPass : public RegionPass 
Class:  class SCEVComplexityCompare {   class SCEVComplexityCompare 
Class:  class ScalarEvolutionAliasAnalysis : public FunctionPass,   class ScalarEvolutionAliasAnalysis : public FunctionPass,
Class:class LoopCompare { class LoopCompare 
Class:class PostIncTransform { class PostIncTransform 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 2, u'-      assert(S == TransformSubExpr(Result, User, OperandValToReplace) &&'), (147, 2, u'-      assert(S == TransformSubExpr(Result, User, OperandValToReplace) &&')]
===========================================
Class:  class TBAANode {   class TBAANode 
Class:  class TypeBasedAliasAnalysis : public ImmutablePass,   class TypeBasedAliasAnalysis : public ImmutablePass,
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 2, u'-  assert(isa<PointerType>(Ty) && "Expected a pointer type!");'), (82, 2, u'-  assert((LHSKnownZero & LHSKnownOne) == 0 &&'), (87, 2, u'-  assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (139, 2, u'-  assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (140, 2, u'-  assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (197, 2, u'-  assert(NumRanges >= 1);'), (230, 2, u'-  assert(V && "No Value?");'), (231, 2, u'-  assert(Depth <= MaxDepth && "Limit Search Depth");'), (234, 2, u'-  assert((V->getType()->isIntOrIntVectorTy() ||'), (237, 2, u'-  assert((!TD ||'), (339, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (340, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (351, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (352, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (363, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (364, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (401, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (402, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (460, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (477, 2, u'-      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (492, 2, u'-      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (508, 2, u'-      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (555, 2, u'-        assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (578, 2, u'-        assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (992, 2, u'-  assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1008, 2, u'-  assert((TD || V->getType()->isIntOrIntVectorTy()) &&'), (1181, 2, u'-  assert(V && "No Value?");'), (1182, 2, u'-  assert(Depth <= MaxDepth && "Limit Search Depth");'), (1183, 2, u'-  assert(V->getType()->isIntegerTy() && "Not integer or pointer type!");'), (1481, 2, u'-  assert(InsertBefore && "Must have someplace to insert!");'), (1504, 2, u'-  assert((V->getType()->isStructTy() || V->getType()->isArrayTy()) &&'), (1506, 2, u'-  assert(ExtractValueInst::getIndexedType(V->getType(), idx_range) &&'), (1571, 2, u'-    assert(Idxs.size() == size'), (1628, 2, u'-  assert(V);'), (1794, 2, u'-    assert(V->getType()->isPointerTy() && "Unexpected operand type!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 2, u'-    assert(Buffer != End);'), (106, 2, u'-    assert(Buffer != End);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(230, 2, u'-  assert(Lex.getKind() == lltok::kw_module);'), (245, 2, u'-  assert(Lex.getKind() == lltok::kw_target);'), (270, 2, u'-  assert(Lex.getKind() == lltok::kw_deplibs);'), (351, 2, u'-  assert(Lex.getKind() == lltok::kw_declare);'), (361, 2, u'-  assert(Lex.getKind() == lltok::kw_define);'), (421, 2, u'-  assert(Lex.getKind() == lltok::GlobalVar);'), (486, 2, u'-  assert(Lex.getKind() == lltok::MetadataVar);'), (515, 2, u'-  assert(Lex.getKind() == lltok::exclaim);'), (542, 2, u'-    assert(NumberedMetadata[MetadataID] == Init && "Tracking VH didn\'t work");'), (566, 2, u'-  assert(Lex.getKind() == lltok::kw_alias);'), (631, 2, u'-  assert(GA->getName() == Name && "Should not be a name conflict!");'), (1083, 2, u'-      assert(ID.Kind == ValID::t_MDNode);'), (1385, 2, u'-  assert(Lex.getKind() == lltok::lparen);'), (1449, 2, u'-  assert(Lex.getKind() == lltok::lparen);'), (1550, 2, u'-  assert(Lex.getKind() == lltok::lbrace);'), (2163, 2, u'-      assert(Opc == Instruction::ICmp && "Unexpected opcode for CmpInst!");'), (2329, 2, u'-      assert(Opc == Instruction::InsertElement && "Unknown opcode");'), (2389, 2, u'-  assert(Lex.getKind() == lltok::lbrace);'), (2407, 2, u'-  assert(Lex.getKind() == lltok::exclaim);'), (3336, 2, u'-    assert(Opc == Instruction::ICmp && "Unknown opcode for CmpInst!");')]
===========================================
Class:  class ConstantPlaceHolder : public ConstantExpr {   class ConstantPlaceHolder : public ConstantExpr 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(252, 2, u'-    assert(Ty == V->getType() && "Type mismatch in constant table!");'), (267, 2, u'-    assert((Ty == 0 || Ty == V->getType()) && "Type mismatch in value table!");'), (331, 2, u'-          assert(It != ResolveConstants.end() && It->first == *I);'), (347, 2, u'-        assert(isa<ConstantExpr>(UserC) && "Must be a ConstantExpr.");'), (391, 2, u'-    assert(V->getType()->isMetadataTy() && "Type mismatch in value table!");'), (749, 2, u'-    assert(ResultTy && "Didn\'t read a type?");'), (750, 2, u'-    assert(TypeList[NumRecords] == 0 && "Already read type?");'), (864, 2, u'-      assert(NextBitCode == bitc::METADATA_NAMED_NODE); (void)NextBitCode;'), (2424, 2, u'-        assert((CT != LandingPadInst::Catch ||'), (2427, 2, u'-        assert((CT != LandingPadInst::Filter ||'), (2732, 2, u'-  assert(DFII != DeferredFunctionInfo.end() && "Deferred function not found!");'), (2774, 2, u'-  assert(DeferredFunctionInfo.count(F) && "No info to read function later?");'), (2782, 2, u'-  assert(M == TheModule &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(846, 2, u'-        assert (0 && "Unknown FP type!");'), (889, 2, u'-        assert(EltTy->isDoubleTy() && "Unknown ConstantData element type");'), (912, 2, u'-          assert(CE->getNumOperands() == 2 && "Unknown constant expr!");'), (1041, 2, u'-      assert(isa<BinaryOperator>(I) && "Unknown instruction!");'), (1815, 2, u'-  assert(Buffer.size() >= DarwinBCHeaderSize &&')]
===========================================
Class:  class WriteBitcodePass : public ModulePass {   class WriteBitcodePass : public ModulePass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(114, 2, u'-  assert(I != InstructionMap.end() && "Instruction is not mapped!");'), (125, 2, u'-    assert(I != MDValueMap.end() && "Value not in slotcalculator!");'), (130, 2, u'-  assert(I != ValueMap.end() && "Value not in slotcalculator!");'), (242, 2, u'-  assert((isa<MDNode>(MD) || isa<MDString>(MD)) && "Invalid metadata kind");'), (274, 2, u'-  assert(N->isFunctionLocal() && N->getFunction() &&'), (306, 2, u'-  assert(!V->getType()->isVoidTy() && "Can\'t insert void values!");'), (307, 2, u'-  assert(!isa<MDNode>(V) && !isa<MDString>(V) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(115, 2, u'-    assert(GV->hasInitializer() &&'), (122, 2, u'-  assert((GV || isa<ConstantPointerNull>(V)) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(109, 2, u'-  assert(DD == 0 && DE == 0 && "Debug/EH info didn\'t get finalized");'), (176, 2, u'-  assert(MI && "AsmPrinter didn\'t require GCModuleInfo?");'), (537, 2, u'-    assert(Op.isReg() && "KILL instruction must have only register operands");'), (584, 2, u'-    assert(MI->getOperand(0).isReg() && "Unknown operand type");'), (644, 2, u'-  assert(FoundOne);'), (918, 2, u'-        assert(I->hasLocalLinkage() && "Invalid alias linkage");'), (929, 2, u'-  assert(MI && "AsmPrinter didn\'t require GCModuleInfo?");'), (1144, 2, u'-  assert(MBB && MBB->getNumber() >= 0 && "Invalid basic block");'), (1202, 2, u'-  assert(Value && "Unknown entry kind!");'), (1226, 2, u'-  assert(GV->hasInitializer() && "Not a special LLVM global!");'), (1575, 2, u'-  assert(!Data.empty() && "Empty aggregates should be CAZ node");'), (1611, 2, u'-    assert(CA->getNumOperands() != 0 && "Should be a CAZ");'), (1658, 2, u'-    assert(CDS->getElementType()->isFloatTy());'), (1671, 2, u'-    assert(CDS->getElementType()->isDoubleTy());'), (1747, 2, u'-  assert(SizeSoFar == Layout->getSizeInBytes() &&'), (1821, 2, u'-  assert(CFP->getType()->isPPC_FP128Ty() &&'), (1840, 2, u'-  assert((BitWidth & 63) == 0 && "only support multiples of 64-bits");'), (2045, 2, u'-  assert(Header && "No header for loop");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(158, 2, u'-  assert((!Label->isInSection() || &Label->getSection() == &Section) &&'), (193, 2, u'-    assert(Dst.isReg() && "Machine move not supported yet.");'), (196, 2, u'-    assert(!Dst.isReg() && "Machine move not supported yet.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 2, u'-  assert(DiagInfo && "Diagnostic context not passed down?");'), (72, 2, u'-  assert(!Str.empty() && "Can\'t emit empty inline asm block");'), (142, 2, u'-  assert(MI->isInlineAsm() && "printInlineAsm only works on inline asms");'), (150, 2, u'-    assert(NumDefs != NumOperands-2 && "No asm string?");'), (152, 2, u'-  assert(MI->getOperand(NumDefs).isSymbol() && "No asm string?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-  assert(Data.empty() && "Already finalized!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(132, 2, u'-  assert(FileID && "Invalid file id");'), (148, 2, u'-  assert(FileID && "Invalid file id");'), (167, 2, u'-  assert(FileID && "Invalid file id");'), (184, 2, u'-  assert(FileID && "Invalid file id");'), (202, 2, u'-  assert(FileID && "Invalid file id");'), (220, 2, u'-  assert(FileID && "Invalid file id");'), (488, 2, u'-  assert(MO.isImm() && "Invalid machine operand!");'), (509, 2, u'-  assert (MO.isFPImm() && "Invalid machine operand!");'), (625, 2, u'-    assert(Ty.isDerivedType() && "Unknown kind of DIType");')]
===========================================
Class:    Class = In.slice(In.find('[') + 1, In.find(' '));
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(272, 2, u'-  assert(SPDie && "Unable to find subprogram DIE!");'), (365, 2, u'-  assert(Start->isDefined() && "Invalid starting label for an inlined scope!");'), (366, 2, u'-  assert(End->isDefined() && "Invalid end label for an inlined scope!");'), (380, 2, u'-  assert(Ranges.empty() == false &&'), (400, 2, u'-  assert(StartLabel->isDefined() &&'), (402, 2, u'-  assert(EndLabel->isDefined() &&'), (761, 2, u'-        assert(SPCU && "Unable to find Compile Unit!");'), (934, 2, u'-  assert(MI->isDebugValue() && "Invalid DBG_VALUE machine instruction!");'), (1009, 2, u'-    assert(MInsn->isDebugValue() && "History must begin with debug value");'), (1030, 2, u'-      assert(Begin->isDebugValue() && "Invalid History entry");'), (1054, 2, u'-          assert(SLabel && "Forgot label after clobber instruction");'), (1081, 2, u'-  assert(Label && "Didn\'t insert label before instruction");'), (1183, 2, u'-      assert(RI->first && "InsnRange does not have first instruction!");'), (1184, 2, u'-      assert(RI->second && "InsnRange does not have second instruction!");'), (1228, 2, u'-  assert(UserVariables.empty() && DbgValues.empty() && "Maps weren\'t cleaned");'), (1242, 2, u'-        assert(MI->getNumOperands() > 1 && "Invalid machine instruction!");'), (1410, 2, u'-  assert(TheCU && "Unable to find compile unit!");'), (1528, 2, u'-    assert(Abbrev->getChildrenFlag() == dwarf::DW_CHILDREN_yes &&'), (1609, 2, u'-    assert(Form && "Too many attributes for DIE (check abbreviation)");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 2, u'-        assert(Actions.size());'), (141, 2, u'-          assert(PrevAction != (unsigned)-1 && "PrevAction is invalid!");'), (152, 2, u'-        assert(-1 - TypeID < (int)FilterOffsets.size() && "Unknown filter id!");'), (188, 2, u'-  assert(MI->isCall() && "This should be a call instruction!");'), (265, 2, u'-      assert(BeginLabel == LandingPad->BeginLabels[P.RangeIndex] &&'), (279, 2, u'-      assert(BeginLabel && LastLabel && "Invalid landing pad!");'), (377, 2, u'-      assert(!PadMap.count(BeginLabel) && "Duplicate landing pad labels!");'), (552, 2, u'-    assert(Asm->MAI->isExceptionHandlingDwarf());')]
===========================================
Class:  class OcamlGCMetadataPrinter : public GCMetadataPrinter {   class OcamlGCMetadataPrinter : public GCMetadataPrinter 
Class:  class BranchFolderPass : public MachineFunctionPass {   class BranchFolderPass : public MachineFunctionPass 
Class:  class CodePlacementOpt : public MachineFunctionPass {   class CodePlacementOpt : public MachineFunctionPass 
Class:class DefaultVLIWScheduler : public ScheduleDAGInstrs { class DefaultVLIWScheduler : public ScheduleDAGInstrs 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(84, 2, u'-  assert(CachedTable.count(StateTrans) != 0);'), (184, 2, u'-  assert(MBB->end() == EndItr && "Bad EndIndex");'), (209, 2, u'-    assert(SUI && "Missing SUnit Info!");'), (219, 2, u'-        assert(SUJ && "Missing SUnit Info!");')]
===========================================
Class:  class DeadMachineInstructionElim : public MachineFunctionPass {   class DeadMachineInstructionElim : public MachineFunctionPass 
Class:  class DwarfEHPrepare : public FunctionPass {   class DwarfEHPrepare : public FunctionPass 
Class:class ExeDepsFix : public MachineFunctionPass { class ExeDepsFix : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(196, 2, u'-  assert(Reg < AliasMap.size() && "Invalid register");'), (206, 2, u'-  assert(dv->Refs == 0 && "Reference count wasn\'t cleared");'), (207, 2, u'-  assert(!dv->Next && "Chained DomainValue shouldn\'t have been recycled");'), (215, 2, u'-    assert(DV->Refs && "Bad DomainValue");'), (251, 2, u'-  assert(unsigned(rx) < NumRegs && "Invalid index");'), (252, 2, u'-  assert(LiveRegs && "Must enter basic block first.");'), (263, 2, u'-  assert(unsigned(rx) < NumRegs && "Invalid index");'), (264, 2, u'-  assert(LiveRegs && "Must enter basic block first.");'), (274, 2, u'-  assert(unsigned(rx) < NumRegs && "Invalid index");'), (275, 2, u'-  assert(LiveRegs && "Must enter basic block first.");'), (285, 2, u'-      assert(LiveRegs[rx].Value && "Not live after collapse?");'), (297, 2, u'-  assert(dv->hasDomain(domain) && "Cannot collapse");'), (314, 2, u'-  assert(!A->isCollapsed() && "Cannot merge into collapsed");'), (315, 2, u'-  assert(!B->isCollapsed() && "Cannot merge from collapsed");'), (378, 2, u'-    assert(fi->second && "Can\'t have NULL entries");'), (413, 2, u'-  assert(LiveRegs && "Must enter basic block first.");'), (454, 2, u'-  assert(!MI->isDebugValue() && "Won\'t process debug values");'), (605, 2, u'-      assert(dv->AvailableDomains && "Domain should have been filtered");'), (647, 2, u'-  assert(NumRegs == RC->getNumRegs() && "Bad regclass");')]
===========================================
Class:  class ExpandISelPseudos : public MachineFunctionPass {   class ExpandISelPseudos : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 2, u'-    assert(MII != MI->getParent()->begin() &&'), (98, 2, u'-  assert((MI->getOperand(0).isReg() && MI->getOperand(0).isDef()) &&'), (105, 2, u'-  assert(!MI->getOperand(2).getSubReg() && "SubIdx on physreg?");'), (108, 2, u'-  assert(SubIdx != 0 && "Invalid index for insert_subreg");'), (111, 2, u'-  assert(TargetRegisterInfo::isPhysicalRegister(DstReg) &&'), (113, 2, u'-  assert(TargetRegisterInfo::isPhysicalRegister(InsReg) &&')]
===========================================
Class:  class Printer : public FunctionPass {   class Printer : public FunctionPass 
Class:   class Deleter : public FunctionPass {   class Deleter : public FunctionPass 
Class:  class LowerIntrinsics : public FunctionPass {   class LowerIntrinsics : public FunctionPass 
Class:                class GCMachineCodeAnalysis : public MachineFunctionPass {   class GCMachineCodeAnalysis : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(166, 2, u'-  assert(MI && "LowerIntrinsics didn\'t require GCModuleInfo!?");'), (388, 2, u'-  assert(TFI && "TargetRegisterInfo not available!");')]
===========================================
Class:  class IfConverter : public MachineFunctionPass {   class IfConverter : public MachineFunctionPass 
Class:class InlineSpiller : public Spiller { class InlineSpiller : public Spiller 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 2, u'-  assert(!hasRefs() && "Cannot reset cache entry with references");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(167, 2, u'-  assert(V->getType()->isIntegerTy() && "Can\'t bswap a non-integer type!");'), (263, 2, u'-  assert(V->getType()->isIntegerTy() && "Can\'t ctpop a non-integer type!");'), (345, 2, u'-  assert(Callee && "Cannot lower an indirect call!");'), (539, 2, u'-  assert(CI->use_empty() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 2, u'-  assert(AsmInfo && "MCAsmInfo not initialized."')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 2, u'-  assert(!Queue.empty() && "Queue is empty!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(191, 2, u'-  assert(N && "Invalid Scope encoding!");'), (215, 2, u'-  assert (Scope && "Unable to calculate scop edominance graph!");'), (252, 2, u'-    assert (S && "Lost LexicalScope for a machine instruction!");')]
===========================================
Class:class UserValueScopes { class UserValueScopes 
Class:class LDVImpl;
Class:class UserValue { class UserValue 
Class:class LDVImpl { class LDVImpl 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 2, u'-  assert(!empty() && "empty interval");'), (92, 2, u'-  assert((StartPos->start <= i->start || StartPos == other.begin()) &&'), (101, 2, u'-      assert(StartPos < other.end() && i < end());'), (128, 2, u'-  assert(Start < End && "Invalid range");'), (156, 2, u'-    assert(!VNI->isUnused() && "Unused valno used by live range");'), (167, 2, u'-  assert(I != ranges.end() && "Not a valid interval!");'), (173, 2, u'-    assert(MergeTo->valno == ValNo && "Cannot merge with differing values!");'), (197, 2, u'-  assert(I != ranges.end() && "Not a valid interval!");'), (208, 2, u'-    assert(MergeTo->valno == ValNo && "Cannot merge with differing values!");'), (244, 2, u'-      assert(B->end <= Start &&'), (266, 2, u'-      assert(it->start >= End &&'), (299, 2, u'-  assert(I != ranges.end() && "Range is not in interval!");'), (300, 2, u'-  assert(I->containsRange(Start, End) && "Range is not entirely in interval!");'), (399, 2, u'-      assert(nextValNo != 0 && "Huh?");'), (448, 2, u'-    assert(I->valno && "Adding a dead range?");'), (498, 2, u'-  assert(V1 != V2 && "Identical value#\'s are always equivalent!");'), (594, 2, u'-    assert(0 && "Joining to spilled interval");'), (600, 2, u'-    assert(0 && "Joining from spilled interval");'), (624, 2, u'-      assert(I->valno == getValNumInfo(I->valno->id) && "Bad VNInfo");'), (680, 2, u'-      assert(MBB && "Phi-def has no defining MBB");'), (706, 2, u'-  assert(LIV[0] && "LIV[0] must be set");'), (721, 2, u'-    assert(VNI && "Interval not live at use.");'), (731, 2, u'-      assert((LIV[eq]->empty() || LIV[eq]->expiredAt(I->start)) &&')]
===========================================
Class:      class LiveIntervals::HMEditor { class LiveIntervals::HMEditor 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(146, 2, u'-      assert(MI.getOperand(MOIdx).getSubReg() != MO.getSubReg() &&'), (191, 2, u'-    assert(!MO.readsReg() && "First def cannot also read virtual register "'), (195, 2, u'-    assert(ValNo->id == 0 && "First value in interval is not 0?");'), (212, 2, u'-        assert(vi.AliveBlocks.empty() &&'), (234, 2, u'-      assert(vi.AliveBlocks.empty() && "Phi join can\'t pass through blocks");'), (260, 2, u'-        assert(getInstructionFromIndex(Start) == 0 &&'), (420, 2, u'-  assert(!isAllocatable(interval.reg) && "Physregs shouldn\'t be live out!");'), (428, 2, u'-    assert(isRegLiveIntoSuccessor(MBB, interval.reg) &&'), (433, 2, u'-  assert(start < end && "did not find end of interval?");'), (461, 2, u'-  assert(TargetRegisterInfo::isPhysicalRegister(interval.reg) &&'), (463, 2, u'-  assert((!isAllocatable(interval.reg) || MBB->getParent()->begin() ||'), (532, 2, u'-  assert(getInstructionFromIndex(defIdx) == 0 &&'), (582, 2, u'-      assert(indexes_->getInstructionFromIndex(MIIndex) == MI &&'), (643, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(li->reg)'), (675, 2, u'-      assert(VNI && "Early-clobber tied value not available");'), (704, 2, u'-      assert(ExtVNI == VNI && "Unexpected existing value number");'), (731, 2, u'-      assert(li->getVNInfoBefore(Stop) == VNI &&'), (745, 2, u'-    assert(LII != NewLI.end() && "Missing live range for PHI");'), (757, 2, u'-      assert(MI && "No instruction defining live value");'), (986, 2, u'-    assert(*SlotI >= LiveI->start);'), (1045, 2, u'-    assert(NewIdx != OldIdx && "No-op move? That\'s a bit strange.");'), (1074, 2, u'-    assert(validator.rangesOk() && "moveAllOperandsFrom broke liveness.");'), (1086, 2, u'-    assert(LIS.getSlotIndexes()->getInstructionFromIndex(OldIdx) == MI &&'), (1094, 2, u'-    assert(!hasRegMaskOp && "Can\'t have RegMask operand in bundle.");'), (1099, 2, u'-      assert(!hasRegMaskOp && "Can\'t have RegMask operand in bundle.");'), (1105, 2, u'-    assert(!hasRegMaskOp && "Can\'t have RegMask operand in bundle.");'), (1121, 2, u'-    assert(validator.rangesOk() && "moveAllOperandsInto broke liveness.");'), (1193, 2, u'-          assert(LR != 0 && "No EC range?");'), (1200, 2, u'-          assert(LR != 0 && "No dead-def range?");'), (1204, 2, u'-          assert(LR && LR->end > OldIdx.getDeadSlot() &&'), (1220, 2, u'-      assert(!MO.isRegMask() && "Can\'t have RegMasks in bundles.");'), (1241, 2, u'-        assert(!MO.isEarlyClobber() && "Early clobbers not allowed in bundles.");'), (1242, 2, u'-        assert(!MO.isDead() && "Dead-defs not allowed in bundles.");'), (1244, 2, u'-        assert(LR != 0 && "Internal ranges not allowed in bundles.");'), (1286, 2, u'-    assert(OldKillMI->killsRegister(reg) && "Old \'kill\' instr isn\'t a kill.");'), (1287, 2, u'-    assert(!NewKillMI->killsRegister(reg) && "New kill instr is already a kill.");'), (1296, 2, u'-    assert(*RI == OldIdx && "No RegMask at OldIdx.");'), (1298, 2, u'-    assert(*prior(RI) < *RI && *RI < *next(RI) &&'), (1337, 2, u'-        assert(LR->end > OldIdx && "LiveRange does not cover original slot");'), (1361, 2, u'-    assert(OldIdx < LR->start && LR->start < OldIdx.getDeadSlot() &&'), (1380, 2, u'-    assert(OldIdx < LR->start && LR->start < OldIdx.getDeadSlot() &&'), (1382, 2, u'-    assert(LR->end > OldIdx.getDeadSlot() && "Range should exit OldIdx.");'), (1400, 2, u'-      assert((LR->start < NewIdx || BR[LI->reg].Def == LR) &&'), (1402, 2, u'-      assert((BR[LI->reg].Use == 0 || BR[LI->reg].Use == LR) &&'), (1413, 2, u'-      assert(BR[LI->reg].Dead == 0 && BR[LI->reg].Def == 0 &&'), (1415, 2, u'-      assert((BR[LI->reg].Use == 0 || BR[LI->reg].Use == LR) &&'), (1421, 2, u'-      assert(LR->start == NewIdx.getRegSlot(LR->start.isEarlyClobber()) &&'), (1423, 2, u'-      assert(BR[LI->reg].Def == LR && "Reg should have def range.");'), (1424, 2, u'-      assert(BR[LI->reg].Dead == 0 &&'), (1439, 2, u'-      assert(BR[LI->reg].Use == 0 &&'), (1445, 2, u'-      assert(BR[LI->reg].Use != 0 &&'), (1482, 2, u'-    assert(LR->start.isRegister() &&'), (1492, 2, u'-      assert(BR[LI->reg].Def == 0 &&'), (1499, 2, u'-      assert(LR->end == NewIdx.getRegSlot() &&'), (1508, 2, u'-        assert(BR[LI->reg].Use == LR &&'), (1531, 2, u'-  assert(getMBBStartIdx(MI->getParent()) <= OldIndex &&'), (1534, 2, u'-  assert(!MI->isBundled() && "Can\'t handle bundled instructions yet.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 2, u'-    assert(SegPos.value() == &VirtReg && "Inconsistent LiveInterval");'), (146, 2, u'-    assert(VirtRegI != VirtRegEnd && "Reached end of VirtReg");'), (168, 2, u'-    assert(VirtRegI->end <= LiveUnionI.start() && "Expected non-overlap");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(38, 2, u'-    assert(VNI && "No live-in value found");'), (49, 2, u'-      assert(Seen.test(MBB->getNumber()));'), (62, 2, u'-  assert(LI && "Missing live range");'), (63, 2, u'-  assert(Kill.isValid() && "Invalid SlotIndex");'), (64, 2, u'-  assert(Indexes && "Missing SlotIndexes");'), (65, 2, u'-  assert(DomTree && "Missing dominator tree");'), (68, 2, u'-  assert(KillMBB && "No MBB at Kill");'), (94, 2, u'-  assert(Indexes && "Missing SlotIndexes");'), (95, 2, u'-  assert(DomTree && "Missing dominator tree");'), (116, 2, u'-    assert(!MBB->pred_empty() && "Value live-in to entry block?");'), (162, 2, u'-  assert(LiveIn.back().DomNode->getBlock() == KillMBB);'), (174, 2, u'-  assert(Indexes && "Missing SlotIndexes");'), (175, 2, u'-  assert(DomTree && "Missing dominator tree");'), (237, 2, u'-        assert(Alloc && "Need VNInfo allocator to create PHI-defs");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-  assert(DefMI && "Missing instruction");'), (104, 2, u'-  assert(scannedRemattable_ && "Call anyRematerializable first");'), (117, 2, u'-    assert(RM.OrigMI && "No defining instruction for remattable value");'), (137, 2, u'-  assert(RM.OrigMI && "Invalid remat");'), (205, 2, u'-      assert(MI->allDefsAreDead() && "Def isn\'t really dead");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 2, u'-  assert(Slot >= 0 && "Spill slot indice must be >= 0");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(84, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(RegIdx) &&'), (112, 2, u'-  assert(MBB != &MF->front() && "Can\'t find reaching def for virtreg");'), (131, 2, u'-  assert(MRI->getVRegDef(reg) && "Register use before def!");'), (147, 2, u'-    assert(VRInfo.Kills[i]->getParent() != MBB && "entry should be at end!");'), (379, 2, u'-          assert(!MO->isDead());'), (541, 2, u'-      assert(TargetRegisterInfo::isPhysicalRegister(*II) &&'), (637, 2, u'-        assert(TargetRegisterInfo::isPhysicalRegister(*I) &&'), (690, 2, u'-    assert(Visited.count(&*i) != 0 && "unreachable basic block found");'), (718, 2, u'-        assert(removed && "kill not in register\'s VarInfo?");')]
===========================================
Class:  class FrameRef {   class FrameRef 
Class:   class LocalStackSlotPass: public MachineFunctionPass {   class LocalStackSlotPass: public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(285, 2, u'-        assert(MFI->isObjectPreAllocated(FrameIdx) &&'), (342, 2, u'-          assert(BaseReg != 0 && "Unable to allocate virtual base register!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 2, u'-  assert(N->getParent() == 0 && "machine instruction already in a basic block");'), (109, 2, u'-  assert(N->getParent() != 0 && "machine instruction not in a basic block");'), (126, 2, u'-  assert(Parent->getParent() == fromList.Parent->getParent() &&'), (139, 2, u'-  assert(!MI->getParent() && "MI is still in a block!");'), (147, 2, u'-  assert(!I->isInsideBundle() && "First non-phi MI cannot be inside a bundle!");'), (158, 2, u'-  assert(!I->isInsideBundle() &&'), (352, 2, u'-  assert(!B && "UpdateTerminators requires analyzable predecessors!");'), (366, 2, u'-        assert(!TBB && "Found more than one non-landing-pad successor!");'), (402, 2, u'-        assert(!FallthroughBB && "Found more than one fallthrough successor.");'), (455, 2, u'-  assert(I != Successors.end() && "Not a current successor!");'), (468, 2, u'-  assert(I != Successors.end() && "Not a current successor!");'), (502, 2, u'-  assert(I != Predecessors.end() && "Pred is not a predecessor of this block!");'), (741, 2, u'-          assert(DestLoop->getHeader() == Succ &&'), (791, 2, u'-  assert(getParent() && "Not embedded in a function!");'), (800, 2, u'-  assert(getParent() && "Not embedded in a function!");'), (809, 2, u'-  assert(Old != New && "Cannot replace self with self!");'), (867, 2, u'-    assert(DestA && DestB && isCond &&'), (921, 2, u'-  assert(Weights.size() == Successors.size() && "Async weight list!");'), (923, 2, u'-  assert(index < Weights.size() && "Not a current successor!");'), (931, 2, u'-  assert(Weights.size() == Successors.size() && "Async weight list!");'), (933, 2, u'-  assert(index < Weights.size() && "Not a current successor!");')]
===========================================
Class:class BlockChain;
Class:class BlockChain { class BlockChain 
Class:class MachineBlockPlacement : public MachineFunctionPass { class MachineBlockPlacement : public MachineFunctionPass 
Class:class IsBlockPlaced { class IsBlockPlaced 
Class:class MachineBlockPlacementStats : public MachineFunctionPass { class MachineBlockPlacementStats : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-  assert(MBB->succ_size() < UINT32_MAX);'), (51, 2, u'-  assert((Sum / UINT32_MAX) < UINT32_MAX);'), (59, 2, u'-  assert(Sum <= UINT32_MAX);')]
===========================================
Class:  class MachineCSE : public MachineFunctionPass {   class MachineCSE : public MachineFunctionPass 
Class:  class MachineCopyPropagation : public MachineFunctionPass {   class MachineCopyPropagation : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(129, 2, u'-        assert(MBBNumbering[MBBI->getNumber()] == &*MBBI &&'), (145, 2, u'-  assert(BlockNo <= MBBNumbering.size() && "Mismatch!");'), (190, 2, u'-  assert(MBB->getParent() == this && "MBB parent mismatch!");'), (400, 2, u'-    assert(MRI.getRegClass(VReg) == RC && "Register class mismatch!");'), (413, 2, u'-  assert(JumpTableInfo && "No jump tables");'), (415, 2, u'-  assert(JTI < JumpTableInfo->getJumpTables().size() && "Invalid JTI!");'), (445, 2, u'-  assert(Size != 0 && "Cannot allocate zero size fixed stack objects!");'), (460, 2, u'-  assert(MBB && "MBB must be valid");'), (462, 2, u'-  assert(MF && "MBB must be part of a MachineFunction");'), (576, 2, u'-  assert(!DestBBs.empty() && "Cannot create an empty jump table!");'), (585, 2, u'-  assert(Old != New && "Not making a change?");'), (597, 2, u'-  assert(Old != New && "Not making a change?");'), (704, 2, u'-  assert(Alignment && "Alignment must be specified!");'), (724, 2, u'-  assert(Alignment && "Alignment must be specified!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 2, u'-  assert(!MF && "MachineFunctionAnalysis left initialized!");'), (39, 2, u'-  assert(MMI && "MMI not around yet??");'), (47, 2, u'-  assert(!MF && "MachineFunctionAnalysis already initialized!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 2, u'-  assert(isReg() && "Can only add reg operand to use lists");'), (75, 2, u'-    assert(getReg() == Contents.Reg.Next->getReg() &&'), (87, 2, u'-  assert(isOnRegUseList() && "Reg operand is not on a use list");'), (92, 2, u'-    assert(NextOp->getReg() == getReg() && "Corrupt reg use/def chain!");'), (120, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(Reg));'), (129, 2, u'-  assert(TargetRegisterInfo::isPhysicalRegister(Reg));'), (162, 2, u'-    assert(!isEarlyClobber());'), (389, 2, u'-  assert((PtrInfo.V == 0 || isa<PointerType>(PtrInfo.V->getType())) &&'), (391, 2, u'-  assert(getBaseAlignment() == a && "Alignment is not a power of 2!");'), (392, 2, u'-  assert((isLoad() || isStore()) && "Not a load/store!");'), (407, 2, u'-  assert(MMO->getFlags() == getFlags() && "Flags mismatch!");'), (408, 2, u'-  assert(MMO->getSize() == getSize() && "Size mismatch!");'), (427, 2, u'-  assert((MMO.isLoad() || MMO.isStore()) &&'), (538, 2, u'-  assert(MBB && "Cannot use inserting ctor with null basic block!");'), (554, 2, u'-  assert(MBB && "Cannot use inserting ctor with null basic block!");'), (589, 2, u'-    assert(Operands[i].ParentMI == this && "ParentMI mismatch!");'), (590, 2, u'-    assert((!Operands[i].isReg() || !Operands[i].isOnRegUseList()) &&'), (631, 2, u'-  assert(MCID && "Cannot add operands before providing an instr descriptor");'), (659, 2, u'-  assert((isImpReg || MCID->isVariadic() || OpNo < MCID->getNumOperands()) &&'), (694, 2, u'-      assert(Operands[i].isReg() && "Should only be an implicit reg!");'), (704, 2, u'-  assert(OpNo < Operands.size() && "Invalid operand number");'), (838, 2, u'-  assert(getParent() && "Not embedded in a basic block!");'), (859, 2, u'-  assert(getParent() && "Not embedded in a basic block!");'), (911, 2, u'-  assert(isInlineAsm() && "Expected an inline asm instruction");'), (912, 2, u'-  assert(OpIdx < getNumOperands() && "OpIdx out of range");'), (972, 2, u'-  assert(isBundle() && "Expecting a bundle");'), (979, 2, u'-  assert(Size > 1 && "Malformed bundle");'), (1091, 2, u'-    assert(DefOpIdx > InlineAsm::MIOp_FirstOperand);'), (1122, 2, u'-  assert(getOperand(DefOpIdx).isDef() && "DefOpIdx is not a def!");'), (1162, 2, u'-        assert(FMO.isImm());'), (1219, 2, u'-  assert(!isBundle() && "MachineInstr::copyPredicates() can\'t handle bundles");'), (1384, 2, u'-  assert(getNumOperands() >= 3 &&')]
===========================================
Class:  class UnpackMachineBundles : public MachineFunctionPass {   class UnpackMachineBundles : public MachineFunctionPass 
Class:  class FinalizeMachineBundles : public MachineFunctionPass {   class FinalizeMachineBundles : public MachineFunctionPass 
Class:  class MachineLICM : public MachineFunctionPass {   class MachineLICM : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(436, 2, u'-    assert(TargetRegisterInfo::isPhysicalRegister(Reg) &&'), (700, 2, u'-    assert(Node != 0 && "Null dominator tree node?");'), (879, 2, u'-  assert (MI.mayLoad() && "Expected MI that loads!");'), (955, 2, u'-    assert(MRI->getVRegDef(Reg) &&'), (1274, 2, u'-  assert(Success &&'), (1277, 2, u'-  assert(NewMIs.size() == 2 &&'), (1343, 2, u'-      assert((!MO.isReg() || MO.getReg() == 0 ||')]
===========================================
Class:class MMIAddrLabelMapCallbackPtr : CallbackVH { class MMIAddrLabelMapCallbackPtr : CallbackVH 
Class: class MMIAddrLabelMap { class MMIAddrLabelMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-    assert(!PhysRegUseDefLists[i] &&'), (99, 2, u'-  assert(RegClass && "Cannot create register without RegClass!");'), (100, 2, u'-  assert(RegClass->isAllocatable() &&'), (123, 2, u'-    assert(VRegInfo[TargetRegisterInfo::index2VirtReg(i)].second == 0 &&'), (148, 2, u'-  assert(FromReg != ToReg && "Cannot replace a reg with itself");'), (268, 2, u'-  assert(TargetRegisterInfo::isPhysicalRegister(PhysReg));')]
===========================================
Class:  class MachinePHIiter {   class MachinePHIiter 
Class:class SSAUpdaterTraits<MachineSSAUpdater> { class SSAUpdaterTraits<MachineSSAUpdater> 
Class:class MachineScheduler : public MachineSchedContext, class MachineScheduler : public MachineSchedContext,
Class:class ScheduleDAGMI;
Class:      class MachineSchedStrategy { class MachineSchedStrategy 
Class:class ScheduleDAGMI : public ScheduleDAGInstrs { class ScheduleDAGMI : public ScheduleDAGInstrs 
Class:class ConvergingScheduler : public MachineSchedStrategy { class ConvergingScheduler : public MachineSchedStrategy 
Class:class InstructionShuffler : public MachineSchedStrategy { class InstructionShuffler : public MachineSchedStrategy 
Class:  class MachineSinking : public MachineFunctionPass {   class MachineSinking : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(329, 2, u'-  assert(MF);'), (341, 2, u'-  assert(MBB);'), (353, 2, u'-  assert(MI);'), (363, 2, u'-  assert(MO);'), (563, 2, u'-  assert(MFI && "Function has no frame info");'), (848, 2, u'-          assert(VNI && "NULL valno is not allowed");'), (1044, 2, u'-  assert(LiveVars && "Don\'t call verifyLiveVariables without LiveVars");'), (1071, 2, u'-  assert(LiveInts && "Don\'t call verifyLiveIntervals without LiveInts");'), (1085, 2, u'-    assert(LVI->first == LI.reg && "Invalid reg to interval mapping");'), (1177, 2, u'-      assert(VNI && "Live range has no valno");'), (1301, 2, u'-        assert(LiveInts->isLiveInToMBB(LI, MFI));')]
===========================================
Class:  class OcamlGC : public GCStrategy {   class OcamlGC : public GCStrategy 
Class:  class OptimizePHIs : public MachineFunctionPass {   class OptimizePHIs : public MachineFunctionPass 
Class:  class PHIElimination : public MachineFunctionPass {   class PHIElimination : public MachineFunctionPass 
Class:class PassConfigImpl { class PassConfigImpl 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(243, 2, u'-  assert(!Initialized && "PassConfig is immutable");'), (262, 2, u'-  assert(!Initialized && "PassConfig is immutable");')]
===========================================
Class:  class PeepholeOptimizer : public MachineFunctionPass {   class PeepholeOptimizer : public MachineFunctionPass 
Class:  class PostRAScheduler : public MachineFunctionPass {   class PostRAScheduler : public MachineFunctionPass 
Class:   class SchedulePostRATDList : public ScheduleDAGInstrs {   class SchedulePostRATDList : public ScheduleDAGInstrs 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(72, 2, u'-  assert(!Fn.getRegInfo().getNumVirtRegs() && "Regalloc must assign all vregs");'), (175, 2, u'-        assert(I->getNumOperands() >= 1 && "Call Frame Setup/Destroy Pseudo"'), (347, 2, u'-          assert(I != MBB->begin() &&'), (378, 2, u'-    assert(blockCSI.size() > 0 &&'), (412, 2, u'-    assert(blockCSI.size() > 0 &&'), (446, 2, u'-      assert(I != MBB->begin() &&'), (506, 2, u'-  assert(LocalAreaOffset >= 0'), (715, 2, u'-  assert(TM.getRegisterInfo() && "TM::getRegisterInfo() must be implemented!");'), (803, 2, u'-    assert((SPAdjCount || SPAdj == 0) &&'), (844, 2, u'-            assert(MI->getOperand(i).isDef() &&'), (854, 2, u'-          assert (ScratchReg && "Missing scratch register!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(64, 2, u'-    assert(!VisitedVRegs.intersects(VRegs) && "vreg in multiple unions");'), (149, 2, u'-  assert(!VRM->hasPhys(VirtReg.reg) && "Duplicate VirtReg assignment");'), (159, 2, u'-  assert(VRM->getPhys(VirtReg.reg) == PhysReg && "Inconsistent unassign");'), (172, 2, u'-    assert(!VRM->hasPhys(VirtReg->reg) && "Register already assigned");'), (219, 2, u'-      assert(!VRM->hasPhys(SplitVirtReg->reg) && "Register already assigned");'), (226, 2, u'-      assert(TargetRegisterInfo::isVirtualRegister(SplitVirtReg->reg) &&')]
===========================================
Class:class RABasic : public MachineFunctionPass, public RegAllocBase class RABasic : public MachineFunctionPass, public RegAllocBase
Class:  class RAFast : public MachineFunctionPass {   class RAFast : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(235, 2, u'-  assert(PhysRegState[LRI->PhysReg] == LRI->VirtReg &&'), (245, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(VirtReg) &&'), (255, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(VirtReg) &&'), (258, 2, u'-  assert(LRI != LiveVirtRegs.end() && "Spilling unmapped virtual register");'), (266, 2, u'-  assert(PhysRegState[LR.PhysReg] == LRI->VirtReg && "Broken RegState mapping");'), (337, 2, u'-  assert(TargetRegisterInfo::isPhysicalRegister(PhysReg) &&'), (363, 2, u'-      assert(TRI->isSuperRegister(PhysReg, Alias) &&'), (451, 2, u'-    assert(I != LiveVirtRegs.end() && "Missing VirtReg entry");'), (473, 2, u'-      assert(I != LiveVirtRegs.end() && "Missing VirtReg entry");'), (491, 2, u'-  assert(!LR.PhysReg && "Already assigned a physreg");'), (498, 2, u'-  assert(LRI != LiveVirtRegs.end() && "VirtReg disappeared");'), (509, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(VirtReg) &&'), (578, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(VirtReg) &&'), (599, 2, u'-  assert(LRI->PhysReg && "Register not assigned");'), (611, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(VirtReg) &&'), (650, 2, u'-  assert(LRI->PhysReg && "Register not assigned");'), (797, 2, u'-    assert(TargetRegisterInfo::isPhysicalRegister(Reg) &&'), (834, 2, u'-  assert(LiveVirtRegs.empty() && "Mapping not cleared from last block?");'), (865, 2, u'-            assert(I != LiveVirtRegs.end() && "Missing VirtReg entry");'), (868, 2, u'-            assert(I->PhysReg == Reg && "Bad inverse map");'), (877, 2, u'-           assert(TargetRegisterInfo::isVirtualRegister(i->VirtReg) &&'), (879, 2, u'-           assert(TargetRegisterInfo::isPhysicalRegister(i->PhysReg) &&'), (881, 2, u'-           assert(PhysRegState[i->PhysReg] == i->VirtReg && "Bad inverse map");'), (1125, 2, u'-  assert(!MRI->isSSA() && "regalloc requires leaving SSA");')]
===========================================
Class:class RAGreedy : public MachineFunctionPass, class RAGreedy : public MachineFunctionPass,
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(409, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(Reg) &&'), (602, 2, u'-    assert(Q.seenAllInterferences() && "Didn\'t check all interfererences.");'), (606, 2, u'-      assert((ExtraRegInfo[Intf->reg].Cascade < Cascade ||'), (751, 2, u'-      assert(T < GroupSize && "Array overflow");'), (760, 2, u'-    assert(B < GroupSize && "Array overflow");'), (960, 2, u'-  assert(NumGlobalIntvs && "No global intervals configured");'), (1207, 2, u'-    assert(!Cand.PhysReg && "Compact region has no physreg");'), (1231, 2, u'-  assert(&SA->getParent() == &VirtReg && "Live range wasn\'t analyzed");'), (1280, 2, u'-  assert(SA->getUseBlocks().size() == 1 && "Not a local interval");'), (1333, 2, u'-  assert(SA->getUseBlocks().size() == 1 && "Not a local interval");'), (1368, 2, u'-      assert(!SlotIndex::isEarlierInstr(RMS[ri], Uses[i]));'), (1534, 2, u'-    assert(!ProgressRequired && "Didn\'t make progress when it was required.");'), (1623, 2, u'-  assert(NewVRegs.empty() && "Cannot append to existing NewVRegs");')]
===========================================
Class:class RegAllocPBQP : public MachineFunctionPass { class RegAllocPBQP : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(166, 2, u'-  assert(vregItr != node2VReg.end() && "No vreg for node.");'), (172, 2, u'-  assert(nodeItr != vreg2Node.end() && "No node for vreg.");'), (180, 2, u'-  assert(allowedSetItr != allowedSets.end() && "No pregs for vreg.");'), (186, 2, u'-  assert(isPRegOption(vreg, option) && "Not a preg option.");'), (189, 2, u'-  assert(option <= allowedSet.size() && "Option outside allowed set.");'), (270, 2, u'-        assert(regMask != 0 && "Couldn\'t find register mask.");'), (332, 2, u'-      assert(!l2.empty() && "Empty interval in vreg set?");'), (356, 2, u'-  assert(costMat.getRows() == vr1Allowed.size() + 1 && "Matrix height mismatch.");'), (357, 2, u'-  assert(costMat.getCols() == vr2Allowed.size() + 1 && "Matrix width mismatch.");'), (467, 2, u'-  assert(costMat.getRows() == vr1Allowed.size() + 1 && "Size mismatch.");'), (468, 2, u'-  assert(costMat.getCols() == vr2Allowed.size() + 1 && "Size mismatch.");'), (548, 2, u'-      assert(preg != 0 && "Invalid preg selected.");'), (563, 2, u'-        assert(!(*itr)->empty() && "Empty spill range.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 2, u'-  assert (RCI.NumRegs <= NumRegs && "Allocation order larger than regclass");')]
===========================================
Class:  class RegisterCoalescer : public MachineFunctionPass {   class RegisterCoalescer : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 2, u'-  assert((NumPhysRegs == 0 || NumPhysRegs == TRI->getNumRegs()) &&'), (88, 2, u'-  assert(MRI->tracksLiveness() &&'), (127, 2, u'-    assert(MBBI != MBB->end() && "Already past the end of the basic block!");'), (130, 2, u'-  assert(MBBI != MBB->end() && "Already at the end of the basic block!");'), (168, 2, u'-      assert(MO.isDef());'), (211, 2, u'-      assert(MO.isDef());'), (215, 2, u'-      assert((KillRegs.test(Reg) || isUnused(Reg) ||'), (270, 2, u'-  assert(Survivor > 0 && "No candidates for scavenging");'), (273, 2, u'-  assert(StartMI != ME && "MI already at terminator");'), (323, 2, u'-  assert (RestorePointMI != StartMI &&'), (365, 2, u'-  assert(ScavengedReg == 0 &&'), (375, 2, u'-    assert(ScavengingFrameIndex >= 0 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(344, 2, u'-    assert(!mapsPopulated && prWorst.empty() && vrWorst.empty() &&'), (413, 2, u'-      assert(prwItr != prWorst.end() && "Missing prWorst entry.");'), (418, 2, u'-      assert(vrwItr != vrWorst.end() && "Missing vrWorst entry.");'), (430, 2, u'-    assert(!mapsPopulated && capacityMap.empty() &&'), (447, 2, u'-    assert(cmItr != capacityMap.end() &&'), (729, 2, u'-    assert(ctsItr != cellTypeStrs.end() && "No string for given cell type.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 2, u'-    assert(NumPreds < UINT_MAX && "NumPreds will overflow!");'), (78, 2, u'-    assert(N->NumSuccs < UINT_MAX && "NumSuccs will overflow!");'), (83, 2, u'-    assert(NumPredsLeft < UINT_MAX && "NumPredsLeft will overflow!");'), (87, 2, u'-    assert(N->NumSuccsLeft < UINT_MAX && "NumSuccsLeft will overflow!");'), (119, 2, u'-      assert(FoundSucc && "Mismatching preds / succs lists!");'), (124, 2, u'-        assert(NumPreds > 0 && "NumPreds will underflow!");'), (125, 2, u'-        assert(N->NumSuccs > 0 && "NumSuccs will underflow!");'), (130, 2, u'-        assert(NumPredsLeft > 0 && "NumPredsLeft will underflow!");'), (134, 2, u'-        assert(N->NumSuccsLeft > 0 && "NumSuccsLeft will underflow!");'), (370, 2, u'-  assert(!AnyNotSched);'), (422, 2, u'-      assert(SU->Succs.empty() && "SUnit should have no successors");'), (451, 2, u'-      assert(Node2Index[SU->NodeNum] > Node2Index[I->getSUnit()->NodeNum] &&'), (470, 2, u'-    assert(!HasLoop && "Inserted edge creates a loop!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 2, u'-  assert((IsPostRA || LIS) && "PreRA scheduling requires LiveIntervals");'), (46, 2, u'-  assert(!(IsPostRA && MRI.getNumVirtRegs()) &&'), (73, 2, u'-    assert(V->getType()->isIntegerTy() && "Unexpected operand type!");'), (205, 2, u'-        assert(!IsPostRA && "Virtual register encountered after regalloc.");'), (212, 2, u'-    assert(Uses.empty() && "Uses in set before adding deps?");'), (228, 2, u'-  assert(MO.isDef() && "expect physreg def");'), (254, 2, u'-        assert(RegUseIndex >= 0 && "UseMI doesn\'t use register!");'), (438, 2, u'-  assert(LIS && "vreg dependencies requires LiveIntervals");'), (527, 2, u'-  assert(Defs.empty() && Uses.empty() &&'), (532, 2, u'-  assert(VRegDefs.empty() && "Only BuildSchedGraph may access VRegDefs");'), (557, 2, u'-    assert((!MI->isTerminator() || CanHandleTerminators) && !MI->isLabel() &&'), (561, 2, u'-    assert(SU && "No SUnit mapped to this MI");'), (573, 2, u'-        assert(!IsPostRA && "Virtual register encountered!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(135, 2, u'-        assert((StageCycle - Stalls) < (int)RequiredScoreboard.getDepth() &&'), (175, 2, u'-  assert(MCID && "The scheduler must filter non-machineinstrs");'), (190, 2, u'-      assert(((cycle + i) < RequiredScoreboard.getDepth()) &&')]
===========================================
Class:  class DAGCombiner {   class DAGCombiner 
Class:class WorkListRemover : public SelectionDAG::DAGUpdateListener { class WorkListRemover : public SelectionDAG::DAGUpdateListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(308, 2, u'-  assert (I && E && std::distance(I, E) > 0 && "Invalid iterator!");'), (1346, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(Op0) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 2, u'-    assert(isNew && "Node emitted out of order - early");'), (144, 2, u'-    assert(UseRC->hasType(VT) && "Incompatible phys register def and uses!");'), (166, 2, u'-  assert(isNew && "Node emitted out of order - early");'), (191, 2, u'-  assert(Node->getMachineOpcode() != TargetOpcode::IMPLICIT_DEF &&'), (204, 2, u'-      assert(TargetRegisterInfo::isPhysicalRegister(VRBase));'), (230, 2, u'-      assert(RC && "Isn\'t a register operand!");'), (240, 2, u'-    assert(isNew && "Node emitted out of order - early");'), (264, 2, u'-  assert(I != VRBaseMap.end() && "Node emitted out of order - late");'), (278, 2, u'-  assert(Op.getValueType() != MVT::Other &&'), (283, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(VReg) && "Not a vreg?");'), (297, 2, u'-    assert((DstRC || (MI->isVariadic() && IIOpNum >= MCID.getNumOperands())) &&'), (394, 2, u'-    assert(Op.getValueType() != MVT::Other &&'), (419, 2, u'-  assert(RC && "No legal register class for VT supports that SubIdx");'), (509, 2, u'-    assert(SRC && "No register class supports VT and SubIdx for INSERT_SUBREG");'), (537, 2, u'-  assert(isNew && "Node emitted out of order - early");'), (559, 2, u'-  assert(isNew && "Node emitted out of order - early");'), (573, 2, u'-  assert((NumOps & 1) == 1 &&'), (602, 2, u'-  assert(isNew && "Node emitted out of order - early");'), (699, 2, u'-    assert(NumMIOperands >= II.getNumOperands() &&'), (702, 2, u'-    assert(NumMIOperands >= II.getNumOperands() &&'), (718, 2, u'-  assert((!HasOptPRefs || !HasPhysRegOuts) &&')]
===========================================
Class:class SelectionDAGLegalize : public SelectionDAG::DAGUpdateListener { class SelectionDAGLegalize : public SelectionDAG::DAGUpdateListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(185, 2, u'-  assert(NumEltsGrowth && "Cannot promote to vector type with fewer elts!");'), (200, 2, u'-  assert(NewMask.size() == NumDestElts && "Non-integer NumEltsGrowth?");'), (201, 2, u'-  assert(TLI.isShuffleMaskLegal(NewMask, NVT) && "Shuffle not legal?");'), (254, 2, u'-    assert((VT == MVT::f64 || VT == MVT::f32) && "Invalid type expansion");'), (296, 2, u'-  assert(ST->getAddressingMode() == ISD::UNINDEXED &&'), (381, 2, u'-  assert(ST->getMemoryVT().isInteger() &&'), (418, 2, u'-  assert(LD->getAddressingMode() == ISD::UNINDEXED &&'), (504, 2, u'-  assert(LoadedVT.isInteger() && !LoadedVT.isVector() &&'), (700, 2, u'-    assert(TLI.getTypeAction(*DAG.getContext(), Node->getValueType(i)) =='), (705, 2, u'-    assert((TLI.getTypeAction(*DAG.getContext(),'), (940, 2, u'-        assert(VT.isVector() && "Cannot promote this load!");'), (953, 2, u'-        assert(Tmp3.getNode() != Node && "Load must be completely replaced");'), (1003, 2, u'-        Result = DAG.getNode(ISD::AssertZext, dl,'), (1011, 2, u'-      assert(!SrcVT.isVector() && "Unsupported extload!");'), (1013, 2, u'-      assert(RoundWidth < SrcWidth);'), (1015, 2, u'-      assert(ExtraWidth < RoundWidth);'), (1016, 2, u'-      assert(!(RoundWidth % 8) && !(ExtraWidth % 8) &&'), (1137, 2, u'-        assert(!SrcVT.isVector() &&'), (1144, 2, u'-        assert(ExtType != ISD::EXTLOAD &&'), (1168, 2, u'-      assert(Tmp1.getNode() != Node && "Load must be completely replaced");'), (1211, 2, u'-          assert(VT.isVector() && "Unknown legal promote case!");'), (1243, 2, u'-        assert(!StVT.isVector() && "Unsupported truncstore!");'), (1245, 2, u'-        assert(RoundWidth < StWidth);'), (1247, 2, u'-        assert(ExtraWidth < RoundWidth);'), (1248, 2, u'-        assert(!(RoundWidth % 8) && !(ExtraWidth % 8) &&'), (1314, 2, u'-          assert(!StVT.isVector() &&'), (1318, 2, u'-          assert(TLI.isTypeLegal(StVT) && "Do not know how to expand this store!");'), (1365, 2, u'-  assert(Op.getValueType().isVector() && "Non-vector insert subvector!");'), (1482, 2, u'-      assert(FloatVT.isByteSized() && "Unsupported floating point type!");'), (1500, 2, u'-      assert(BitShift < LoadTy.getSizeInBits() && "Pointer advanced wrong?");'), (1523, 2, u'-  assert(SPReg && "Target cannot require DYNAMIC_STACKALLOC expansion and"'), (1630, 2, u'-    assert(SrcSize == SlotSize && "Invalid store");'), (1640, 2, u'-  assert(SlotSize < DestSize && "Unknown extension!");'), (1725, 2, u'-        assert(Node->getOperand(i).getOpcode() == ISD::UNDEF);'), (2074, 2, u'-  assert(!isSigned && "Legalize cannot Expand SINT_TO_FP for i64 yet");'), (2223, 2, u'-    assert(NewInTy.isInteger() && "Ran out of possibilities!");'), (2265, 2, u'-    assert(NewOutTy.isInteger() && "Ran out of possibilities!");'), (2359, 2, u'-    assert(VT.isInteger() && Len <= 128 && Len % 8 == 0 &&'), (2642, 2, u'-      assert(VT.isFloatingPoint() && "Unknown value type!");'), (2742, 2, u'-      assert(((Align & (Align-1)) == 0) && "Expected Align to be a power of 2");'), (2830, 2, u'-        assert(NewVT.bitsEq(VT));'), (2840, 2, u'-        assert(factor > 0);'), (3031, 2, u'-    assert(Reg && "Can\'t expand to unknown register!");'), (3039, 2, u'-    assert(Reg && "Can\'t expand to unknown register!");'), (3047, 2, u'-    assert(TLI.isOperationLegalOrCustom(ISD::FADD, VT) &&'), (3057, 2, u'-    assert(TLI.isOperationLegalOrCustom(ISD::ADD, VT) &&'), (3127, 2, u'-    assert(TLI.isOperationLegalOrCustom(ExpandOpcode, VT) &&'), (3262, 2, u'-      assert(LC != RTLIB::UNKNOWN_LIBCALL && "Cannot expand this operation!");'), (3410, 2, u'-    assert(!Tmp2.getNode() && "Can\'t legalize SELECT_CC with legal condition!");'), (3427, 2, u'-    assert(!Tmp3.getNode() && "Can\'t legalize BR_CC with legal condition!");'), (3443, 2, u'-    assert(VT.isVector() && "Unable to legalize non-vector shift");'), (3444, 2, u'-    assert(TLI.isTypeLegal(VT.getScalarType())&& "Element type must be legal");'), (3549, 2, u'-      assert(OVT.isInteger()'), (3576, 2, u'-      assert(OVT.isInteger() && "Cannot promote logic operation");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(358, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_EXTEND!");'), (375, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_ROUND!");'), (392, 2, u'-  assert(N->getOperand(1).getValueType() == MVT::i32 &&'), (557, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported XINT_TO_FP!");'), (603, 2, u'-  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (618, 2, u'-  assert((VT == MVT::f32 || VT == MVT::f64) && "Unsupported setcc type!");'), (706, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_ROUND libcall");'), (734, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_TO_SINT!");'), (742, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_TO_UINT!");'), (780, 2, u'-    assert(NewLHS.getValueType() == N->getValueType(0) &&'), (792, 2, u'-  assert(ISD::isUNINDEXEDStore(N) && "Indexed store during type legalization!");'), (793, 2, u'-  assert(OpNo == 1 && "Can only soften the stored value!");'), (886, 2, u'-  assert(NVT.getSizeInBits() == integerPartWidth &&'), (897, 2, u'-  assert(N->getValueType(0) == MVT::ppcf128 &&'), (1140, 2, u'-  assert(ISD::isUNINDEXEDLoad(N) && "Indexed load during type legalization!");'), (1147, 2, u'-  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (1148, 2, u'-  assert(LD->getMemoryVT().bitsLE(NVT) && "Float type not round?");'), (1167, 2, u'-  assert(N->getValueType(0) == MVT::ppcf128 && "Unsupported XINT_TO_FP!");'), (1194, 2, u'-    assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported XINT_TO_FP!");'), (1284, 2, u'-  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (1301, 2, u'-  assert(NewLHS.getValueType() == MVT::ppcf128 && "Unsupported setcc type!");'), (1342, 2, u'-  assert(N->getOperand(0).getValueType() == MVT::ppcf128 &&'), (1358, 2, u'-    assert(N->getOperand(0).getValueType() == MVT::ppcf128 &&'), (1368, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_TO_SINT!");'), (1379, 2, u'-    assert(N->getOperand(0).getValueType() == MVT::ppcf128 &&'), (1400, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_TO_UINT!");'), (1429, 2, u'-    assert(NewLHS.getValueType() == N->getValueType(0) &&'), (1443, 2, u'-  assert(ISD::isUNINDEXEDStore(N) && "Indexed store during type legalization!");'), (1444, 2, u'-  assert(OpNo == 1 && "Can only expand the stored value so far");'), (1452, 2, u'-  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (1453, 2, u'-  assert(ST->getMemoryVT().bitsLE(NVT) && "Float type not round?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 2, u'-  case ISD::AssertSext:  Res = PromoteIntRes_AssertSext(N); break;'), (52, 2, u'-  case ISD::AssertZext:  Res = PromoteIntRes_AssertZext(N); break;'), (153, 2, u'-SDValue DAGTypeLegalizer::PromoteIntRes_AssertSext(SDNode *N) {'), (156, 2, u'-  return DAG.getNode(ISD::AssertSext, N->getDebugLoc(),'), (160, 2, u'-SDValue DAGTypeLegalizer::PromoteIntRes_AssertZext(SDNode *N) {'), (163, 2, u'-  return DAG.getNode(ISD::AssertZext, N->getDebugLoc(),'), (293, 2, u'-  assert(isa<ConstantSDNode>(Result) && "Didn\'t constant fold ext?");'), (299, 2, u'-  assert ((CvtCode == ISD::CVT_SS || CvtCode == ISD::CVT_SU ||'), (371, 2, u'-                     ISD::AssertZext : ISD::AssertSext, dl, NVT, Res,'), (381, 2, u'-  return DAG.getNode(ISD::AssertZext, dl,'), (392, 2, u'-    assert(Res.getValueType().bitsLE(NVT) && "Extension doesn\'t make sense!");'), (404, 2, u'-      assert(N->getOpcode() == ISD::ANY_EXTEND && "Unknown integer extension!");'), (414, 2, u'-  assert(ISD::isUNINDEXEDLoad(N) && "Indexed load during type legalization!");'), (521, 2, u'-  assert(SVT.isVector() == N->getOperand(0).getValueType().isVector() &&'), (528, 2, u'-  assert(NVT.bitsLE(SVT) && "Integer type overpromoted?");'), (587, 2, u'-    assert(InVT.isVector() && "Cannot split scalar types");'), (589, 2, u'-    assert(NumElts == NVT.getVectorNumElements() &&'), (592, 2, u'-    assert(isPowerOf2_32(NumElts) &&'), (805, 2, u'-  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (862, 2, u'-  assert(OpNo == 2 && "Don\'t know how to promote this operand!");'), (876, 2, u'-  assert(OpNo == 1 && "only know how to promote condition");'), (892, 2, u'-  assert(Lo.getValueType() == N->getValueType(0) && "Operand over promoted?");'), (906, 2, u'-  assert(!(NumElts & 1) && "Legal vector of one illegal element?");'), (911, 2, u'-  assert(N->getOperand(0).getValueType().getSizeInBits() >='), (924, 2, u'-  assert ((CvtCode == ISD::CVT_SS || CvtCode == ISD::CVT_SU ||'), (941, 2, u'-    assert(N->getOperand(1).getValueType().getSizeInBits() >='), (950, 2, u'-  assert(OpNo == 2 && "Different operand and result vector types?");'), (977, 2, u'-  assert(OpNo == 0 && "Only know how to promote the condition!");'), (991, 2, u'-  assert(OpNo == 0 && "Don\'t know how to promote this operand!");'), (1003, 2, u'-  assert(OpNo == 0 && "Don\'t know how to promote this operand!");'), (1032, 2, u'-  assert(ISD::isUNINDEXEDStore(N) && "Indexed store during type legalization!");'), (1103, 2, u'-  case ISD::AssertSext:  ExpandIntRes_AssertSext(N, Lo, Hi); break;'), (1104, 2, u'-  case ISD::AssertZext:  ExpandIntRes_AssertZext(N, Lo, Hi); break;'), (1325, 2, u'-  assert(N->getOpcode() == ISD::SRA && "Unknown shift!");'), (1359, 2, u'-  assert(isPowerOf2_32(NVTBits) &&'), (1446, 2, u'-  assert(isPowerOf2_32(NVTBits) &&'), (1641, 2, u'-    assert(getTypeAction(Op.getValueType()) =='), (1645, 2, u'-    assert(Res.getValueType() == N->getValueType(0) &&'), (1652, 2, u'-void DAGTypeLegalizer::ExpandIntRes_AssertSext(SDNode *N,'), (1662, 2, u'-    Hi = DAG.getNode(ISD::AssertSext, dl, NVT, Hi,'), (1666, 2, u'-    Lo = DAG.getNode(ISD::AssertSext, dl, NVT, Lo, DAG.getValueType(EVT));'), (1673, 2, u'-void DAGTypeLegalizer::ExpandIntRes_AssertZext(SDNode *N,'), (1683, 2, u'-    Hi = DAG.getNode(ISD::AssertZext, dl, NVT, Hi,'), (1687, 2, u'-    Lo = DAG.getNode(ISD::AssertZext, dl, NVT, Lo, DAG.getValueType(EVT));'), (1765, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unexpected fp-to-sint conversion!");'), (1775, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unexpected fp-to-uint conversion!");'), (1786, 2, u'-  assert(ISD::isUNINDEXEDLoad(N) && "Indexed load during type legalization!");'), (1799, 2, u'-  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (1820, 2, u'-      assert(ExtType == ISD::EXTLOAD && "Unknown extload!");'), (1988, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported MUL!");'), (2050, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported SDIV!");'), (2078, 2, u'-    assert(N->getOpcode() == ISD::SRA && "Unknown shift!");'), (2123, 2, u'-    assert(N->getOpcode() == ISD::SRA && "Unknown shift!");'), (2160, 2, u'-    assert(getTypeAction(Op.getValueType()) =='), (2164, 2, u'-    assert(Res.getValueType() == N->getValueType(0) &&'), (2217, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported SREM!");'), (2294, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported XMULO!");'), (2353, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported UDIV!");'), (2373, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported UREM!");'), (2391, 2, u'-    assert(getTypeAction(Op.getValueType()) =='), (2395, 2, u'-    assert(Res.getValueType() == N->getValueType(0) &&'), (2477, 2, u'-  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (2629, 2, u'-    assert(NewLHS.getValueType() == N->getValueType(0) &&'), (2661, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL &&'), (2670, 2, u'-  assert(ISD::isUNINDEXEDStore(N) && "Indexed store during type legalization!");'), (2671, 2, u'-  assert(OpNo == 1 && "Can only expand the stored value so far");'), (2683, 2, u'-  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (2839, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL &&'), (2863, 2, u'-  assert(NOutVT.isVector() && "This type must be promoted to a vector type");'), (2911, 2, u'-  assert(NOutVT.isVector() && "This type must be promoted to a vector type");'), (2931, 2, u'-  assert(!N->getOperand(0).getValueType().isVector() &&'), (2936, 2, u'-  assert(NOutVT.isVector() && "This type must be promoted to a vector type");'), (2949, 2, u'-  assert(NOutVT.isVector() && "This type must be promoted to a vector type");'), (2957, 2, u'-  assert(NumElem * NumOperands == NumOutElem &&'), (2977, 2, u'-  assert(NOutVT.isVector() && "This type must be promoted to a vector type");')]
===========================================
Class:  class NodeUpdateListener : public SelectionDAG::DAGUpdateListener {   class NodeUpdateListener : public SelectionDAG::DAGUpdateListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 2, u'-            assert(UI->getNodeId() == NewNode &&'), (102, 2, u'-        assert(NewVal.getNode()->getNodeId() != NewNode &&'), (172, 2, u'-      assert(UI->getNodeId() == NewNode && "NewNode used by non-NewNode!");'), (214, 2, u'-    assert(N->getNodeId() == ReadyToProcess &&'), (317, 2, u'-      assert(N->getNodeId() == ReadyToProcess && "Node ID recalculated?");'), (328, 2, u'-      assert(N->getNumValues() == M->getNumValues() &&'), (333, 2, u'-      assert(N->getNodeId() == NewNode && "Unexpected node state!");'), (348, 2, u'-    assert(N->getNodeId() == ReadyToProcess && "Node ID recalculated?");'), (376, 2, u'-      assert(NodeId == Unanalyzed && "Unknown node ID!");'), (558, 2, u'-    assert(I->first.getNode() != N);'), (564, 2, u'-    assert(I->first.getNode() != N);'), (570, 2, u'-    assert(I->first.getNode() != N);'), (576, 2, u'-    assert(I->first.getNode() != N);'), (582, 2, u'-    assert(I->first.getNode() != N);'), (589, 2, u'-    assert(I->first.getNode() != N);'), (596, 2, u'-    assert(I->first.getNode() != N);'), (618, 2, u'-    assert(N.getNode()->getNodeId() != NewNode && "Mapped to new node!");'), (634, 2, u'-      assert(N->getNodeId() != DAGTypeLegalizer::ReadyToProcess &&'), (639, 2, u'-      assert(E && "Node not replaced?");'), (658, 2, u'-      assert(N->getNodeId() != DAGTypeLegalizer::ReadyToProcess &&'), (672, 2, u'-  assert(From.getNode() != To.getNode() && "Potential legalization loop!");'), (704, 2, u'-        assert(M->getNodeId() != NewNode && "Analysis resulted in NewNode!");'), (705, 2, u'-        assert(N->getNumValues() == M->getNumValues() &&'), (729, 2, u'-  assert(Result.getValueType() =='), (735, 2, u'-  assert(OpEntry.getNode() == 0 && "Node is already promoted!");'), (740, 2, u'-  assert(Result.getValueType() =='), (746, 2, u'-  assert(OpEntry.getNode() == 0 && "Node is already converted to integer!");'), (754, 2, u'-  assert(Result.getValueType().getSizeInBits() >='), (760, 2, u'-  assert(OpEntry.getNode() == 0 && "Node is already scalarized!");'), (769, 2, u'-  assert(Entry.first.getNode() && "Operand isn\'t expanded");'), (776, 2, u'-  assert(Lo.getValueType() =='), (786, 2, u'-  assert(Entry.first.getNode() == 0 && "Node already expanded");'), (796, 2, u'-  assert(Entry.first.getNode() && "Operand isn\'t expanded");'), (803, 2, u'-  assert(Lo.getValueType() =='), (813, 2, u'-  assert(Entry.first.getNode() == 0 && "Node already expanded");'), (823, 2, u'-  assert(Entry.first.getNode() && "Operand isn\'t split");'), (830, 2, u'-  assert(Lo.getValueType().getVectorElementType() =='), (842, 2, u'-  assert(Entry.first.getNode() == 0 && "Node already split");'), (848, 2, u'-  assert(Result.getValueType() =='), (854, 2, u'-  assert(OpEntry.getNode() == 0 && "Node already widened!");'), (873, 2, u'-  assert(Op.getValueType().isVector() && "Only applies to vectors!");'), (919, 2, u'-  assert(Results.size() == N->getNumValues() &&'), (942, 2, u'-  assert(Results.size() == N->getNumValues() &&'), (964, 2, u'-    assert(!(NumElements & 1) && "Splitting vector, but not in half!");'), (1114, 2, u'-  assert(LoVT.getSizeInBits() + HiVT.getSizeInBits() ==')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(78, 2, u'-      assert(!(InVT.getVectorNumElements() & 1) && "Unsupported BITCAST");'), (114, 2, u'-  assert(NOutVT.isByteSized() && "Expanded type not byte sized!");'), (161, 2, u'-  assert(Part.getValueType() == N->getValueType(0) &&'), (203, 2, u'-  assert(ISD::isNormalLoad(N) && "This routine only for normal loads!");'), (215, 2, u'-  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (305, 2, u'-  assert(OldVT == VecVT.getVectorElementType() &&'), (347, 2, u'-  assert(OldEVT == VecVT.getVectorElementType() &&'), (375, 2, u'-  assert(VT.getVectorElementType() == N->getOperand(0).getValueType() &&'), (387, 2, u'-  assert(ISD::isNormalStore(N) && "This routine only for normal stores!");'), (388, 2, u'-  assert(OpNo == 1 && "Can only expand the stored value so far");'), (400, 2, u'-  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (414, 2, u'-  assert(isTypeLegal(Ptr.getValueType()) && "Pointers must be legal!");'), (449, 2, u'-    assert(Cond.getValueType().getVectorElementType() == MVT::i1 &&')]
===========================================
Class:class VectorLegalizer { class VectorLegalizer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(95, 2, u'-  assert(LegalizedNodes.count(OldRoot) && "Root didn\'t get legalized?");'), (278, 2, u'-  assert(Op.getNode()->getNumValues() == 1 &&'), (406, 2, u'-  assert(VT.getSizeInBits() == Op.getOperand(1).getValueType().getSizeInBits()'), (434, 2, u'-  assert((SVT.getSizeInBits() == 64 || SVT.getSizeInBits() == 32) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(186, 2, u'-  assert(N->isUnindexed() && "Indexed vector load?");'), (241, 2, u'-        assert(VecBool == TargetLowering::UndefinedBooleanContent ||'), (248, 2, u'-        assert(VecBool == TargetLowering::UndefinedBooleanContent ||'), (277, 2, u'-  assert(N->getValueType(0).isVector() =='), (305, 2, u'-  assert(N->getValueType(0).isVector() &&'), (367, 2, u'-  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (406, 2, u'-  assert(N->isUnindexed() && "Indexed store of one-element vector?");'), (407, 2, u'-  assert(OpNo == 1 && "Do not know how to scalarize this operand!");'), (622, 2, u'-  assert(!(N->getNumOperands() & 1) && "Unsupported CONCAT_VECTORS");'), (740, 2, u'-  assert(ISD::isUNINDEXEDLoad(LD) && "Indexed load during type legalization!");'), (780, 2, u'-  assert(N->getValueType(0).isVector() &&'), (1017, 2, u'-  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (1069, 2, u'-    assert(IdxVal + SubVT.getVectorNumElements() <= LoElts &&'), (1085, 2, u'-    assert(IdxVal < VecVT.getVectorNumElements() && "Invalid vector index!");'), (1113, 2, u'-  assert(N->isUnindexed() && "Indexed store of vector?");'), (1114, 2, u'-  assert(OpNo == 1 && "Can only split the stored value");'), (1180, 2, u'-  assert(N->getValueType(0).isVector() &&'), (1944, 2, u'-  assert(InOp1.getValueType() == WidenVT && InOp2.getValueType() == WidenVT);'), (1958, 2, u'-  assert(N->getValueType(0).isVector() =='), (2001, 2, u'-  assert(N->getValueType(0).isVector() &&'), (2009, 2, u'-  assert(InVT.isVector() && "can not widen non vector type");'), (2017, 2, u'-  assert(InOp1.getValueType() == WidenInVT &&'), (2073, 2, u'-  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (2311, 2, u'-  assert(LdVT.isVector() && WidenVT.isVector());'), (2312, 2, u'-  assert(LdVT.getVectorElementType() == WidenVT.getVectorElementType());'), (2344, 2, u'-    assert(WidenWidth % NewVTWidth == 0);'), (2465, 2, u'-  assert(LdVT.isVector() && WidenVT.isVector());'), (2524, 2, u'-  assert(StVT.getVectorElementType() == ValEltVT);'), (2591, 2, u'-  assert(StVT.isVector() && ValOp.getValueType().isVector());'), (2592, 2, u'-  assert(StVT.bitsLT(ValOp.getValueType()));'), (2625, 2, u'-  assert(InVT.getVectorElementType() == NVT.getVectorElementType() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 2, u'-   assert (ResourcesModel && "Unimplemented CreateTargetScheduleState.");'), (637, 2, u'-  assert(!Queue.empty() && "Queue is empty!");')]
===========================================
Class:class ScheduleDAGFast : public ScheduleDAGSDNodes { class ScheduleDAGFast : public ScheduleDAGSDNodes 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(181, 2, u'-  assert(CurCycle >= SU->getHeight() && "Node scheduled below its height!");'), (192, 2, u'-        assert(NumLiveRegs > 0 && "NumLiveRegs is already zero!");'), (193, 2, u'-        assert(LiveRegDefs[I->getReg()] == SU &&'), (237, 2, u'-    assert(NewNodes.size() == 2 && "Expected a load folding node!");'), (249, 2, u'-    assert(N->getNodeId() == -1 && "Node already inserted!");'), (426, 2, u'-  assert(MCID.ImplicitDefs && "Physical reg def must be in implicit def list!");'), (530, 2, u'-    assert(RootSU->Succs.empty() && "Graph root shouldn\'t have successors!");'), (566, 2, u'-        assert(LRegs.size() == 1 && "Can\'t handle this yet!");')]
===========================================
Class:class ScheduleDAGRRList : public ScheduleDAGSDNodes { class ScheduleDAGRRList : public ScheduleDAGSDNodes 
Class:class RegReductionPQBase;
Class: class RegReductionPQBase : public SchedulingPriorityQueue { class RegReductionPQBase : public SchedulingPriorityQueue 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 2, u'-  assert((Addr == 0 || Addr == &SUnits[0]) &&'), (191, 2, u'-  assert((N->getValueType(N->getNumValues() - 1) == MVT::Glue &&'), (356, 2, u'-      assert(N->getNodeId() == -1 && "Node already inserted!");'), (373, 2, u'-          assert(N->getNodeId() == -1 && "Node already inserted!");'), (396, 2, u'-    assert(N->getNodeId() == -1 && "Node already inserted!");'), (461, 2, u'-        assert(OpSU && "Node has no SUnit!");'), (465, 2, u'-        assert(OpVT != MVT::Glue && "Glued nodes should be in same sunit!");'), (472, 2, u'-        assert((PhysReg == 0 || !isChain) &&'), (577, 2, u'-  assert(SU->NumRegDefsLeft == 0 && "expect a new node");'), (579, 2, u'-    assert(SU->NumRegDefsLeft < USHRT_MAX && "overflow is ok but unexpected");'), (683, 2, u'-  assert(Sequence.size() - Noops == ScheduledNodes &&'), (762, 2, u'-      assert(VRI != VRBaseMap.end() && "Node emitted out of order - late");'), (777, 2, u'-      assert(I->getReg() && "Unknown physical register!");'), (781, 2, u'-      assert(isNew && "Node emitted out of order - early");')]
===========================================
Class:class ScheduleDAGVLIW : public ScheduleDAGSDNodes { class ScheduleDAGVLIW : public ScheduleDAGSDNodes 
Class:class RAUWUpdateListener : public SelectionDAG::DAGUpdateListener { class RAUWUpdateListener : public SelectionDAG::DAGUpdateListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 2, u'-  assert(VT.isFloatingPoint() && "Can only convert between FP types");'), (490, 2, u'-  assert((ConvType & 3) == ConvType &&'), (492, 2, u'-  assert((AM & 7) == AM &&'), (598, 2, u'-  assert(N != AllNodes.begin() && "Cannot delete the entry node!");'), (599, 2, u'-  assert(N->use_empty() && "Cannot delete a node that is not dead!");'), (635, 2, u'-    assert(CondCodeNodes[cast<CondCodeSDNode>(N)->get()] &&'), (662, 2, u'-    assert(N->getOpcode() != ISD::DELETED_NODE && "DELETED_NODE in CSEMap!");'), (663, 2, u'-    assert(N->getOpcode() != ISD::EntryToken && "EntryToken in CSEMap!");'), (774, 2, u'-    assert(N->getNumValues() == 1 && "Too many results!");'), (775, 2, u'-    assert(!VT.isVector() && (VT.isInteger() || VT.isFloatingPoint()) &&'), (777, 2, u'-    assert(N->getNumOperands() == 2 && "Wrong number of operands!");'), (778, 2, u'-    assert(N->getOperand(0).getValueType() == N->getOperand(1).getValueType() &&'), (780, 2, u'-    assert(N->getOperand(0).getValueType().isInteger() == VT.isInteger() &&'), (782, 2, u'-    assert(VT.getSizeInBits() == 2 * N->getOperand(0).getValueSizeInBits() &&'), (787, 2, u'-    assert(N->getNumValues() == 1 && "Too many results!");'), (788, 2, u'-    assert(N->getValueType(0).isVector() && "Wrong return type!");'), (789, 2, u'-    assert(N->getNumOperands() == N->getValueType(0).getVectorNumElements() &&'), (793, 2, u'-      assert((I->getValueType() == EltVT ||'), (797, 2, u'-      assert(I->getValueType() == N->getOperand(0).getValueType() &&'), (809, 2, u'-  assert(!isa<MemSDNode>(N) && "Bad MemSDNode!");'), (810, 2, u'-  assert(!isa<ShuffleVectorSDNode>(N) && "Bad ShuffleVectorSDNode!");'), (811, 2, u'-  assert(!isa<ConstantSDNode>(N) && "Bad ConstantSDNode!");'), (812, 2, u'-  assert(!isa<ConstantFPSDNode>(N) && "Bad ConstantFPSDNode!");'), (813, 2, u'-  assert(!isa<GlobalAddressSDNode>(N) && "Bad GlobalAddressSDNode!");'), (814, 2, u'-  assert(!isa<FrameIndexSDNode>(N) && "Bad FrameIndexSDNode!");'), (815, 2, u'-  assert(!isa<JumpTableSDNode>(N) && "Bad JumpTableSDNode!");'), (816, 2, u'-  assert(!isa<ConstantPoolSDNode>(N) && "Bad ConstantPoolSDNode!");'), (817, 2, u'-  assert(!isa<BasicBlockSDNode>(N) && "Bad BasicBlockSDNode!");'), (818, 2, u'-  assert(!isa<SrcValueSDNode>(N) && "Bad SrcValueSDNode!");'), (819, 2, u'-  assert(!isa<MDNodeSDNode>(N) && "Bad MDNodeSDNode!");'), (820, 2, u'-  assert(!isa<RegisterSDNode>(N) && "Bad RegisterSDNode!");'), (821, 2, u'-  assert(!isa<BlockAddressSDNode>(N) && "Bad BlockAddressSDNode!");'), (822, 2, u'-  assert(!isa<EHLabelSDNode>(N) && "Bad EHLabelSDNode!");'), (823, 2, u'-  assert(!isa<ExternalSymbolSDNode>(N) && "Bad ExternalSymbolSDNode!");'), (824, 2, u'-  assert(!isa<CondCodeSDNode>(N) && "Bad CondCodeSDNode!");'), (825, 2, u'-  assert(!isa<CvtRndSatSDNode>(N) && "Bad CvtRndSatSDNode!");'), (826, 2, u'-  assert(!isa<VTSDNode>(N) && "Bad VTSDNode!");'), (827, 2, u'-  assert(!isa<MachineSDNode>(N) && "Bad MachineSDNode!");'), (876, 2, u'-  assert(&*AllNodes.begin() == &EntryNode);'), (921, 2, u'-  assert(!VT.isVector() &&'), (943, 2, u'-  assert((EltVT.getSizeInBits() >= 64 ||'), (954, 2, u'-  assert(VT.isInteger() && "Cannot create FP integer constant!");'), (970, 2, u'-  assert(Elt->getBitWidth() == EltVT.getSizeInBits() &&'), (1007, 2, u'-  assert(VT.isFloatingPoint() && "Cannot create integer FP constant!");'), (1060, 2, u'-  assert((TargetFlags == 0 || isTargetGA) &&'), (1115, 2, u'-  assert((TargetFlags == 0 || isTarget) &&'), (1137, 2, u'-  assert((TargetFlags == 0 || isTarget) &&'), (1164, 2, u'-  assert((TargetFlags == 0 || isTarget) &&'), (1262, 2, u'-  assert(N1.getValueType() == N2.getValueType() && "Invalid VECTOR_SHUFFLE");'), (1263, 2, u'-  assert(VT.isVector() && N1.getValueType().isVector() &&'), (1265, 2, u'-  assert(VT.getVectorElementType() == N1.getValueType().getVectorElementType()'), (1277, 2, u'-    assert(Mask[i] < (int)(NElts * 2) && "Index out of range");'), (1438, 2, u'-  assert((!V || V->getType()->isPointerTy()) &&'), (1532, 2, u'-    assert(!N1.getValueType().isInteger() && "Illegal setcc for integer!");'), (1632, 2, u'-  assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1660, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1661, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1671, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1672, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1682, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1683, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1695, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1696, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1736, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1737, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1746, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1747, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1778, 2, u'-      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1795, 2, u'-      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1816, 2, u'-      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1851, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1913, 2, u'-    assert(!(SignBitKnownZero && SignBitKnownOne) &&'), (1942, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1947, 2, u'-  case ISD::AssertZext: {'), (1988, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1992, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (2030, 2, u'-        assert((KnownZero & KnownOne) == 0&&"Bits known to be one AND zero?");'), (2041, 2, u'-        assert((KnownZero & KnownOne) == 0&&"Bits known to be one AND zero?");'), (2086, 2, u'-  assert(VT.isInteger() && "Invalid VT!");'), (2096, 2, u'-  case ISD::AssertSext:'), (2099, 2, u'-  case ISD::AssertZext:'), (2443, 2, u'-        assert(integerPartWidth >= 64);'), (2471, 2, u'-    assert(VT.isFloatingPoint() &&'), (2474, 2, u'-    assert((!VT.isVector() ||'), (2482, 2, u'-    assert(VT.isInteger() && Operand.getValueType().isInteger() &&'), (2485, 2, u'-    assert(Operand.getValueType().getScalarType().bitsLT(VT.getScalarType()) &&'), (2487, 2, u'-    assert((!VT.isVector() ||'), (2498, 2, u'-    assert(VT.isInteger() && Operand.getValueType().isInteger() &&'), (2501, 2, u'-    assert(Operand.getValueType().getScalarType().bitsLT(VT.getScalarType()) &&'), (2503, 2, u'-    assert((!VT.isVector() ||'), (2515, 2, u'-    assert(VT.isInteger() && Operand.getValueType().isInteger() &&'), (2518, 2, u'-    assert(Operand.getValueType().getScalarType().bitsLT(VT.getScalarType()) &&'), (2520, 2, u'-    assert((!VT.isVector() ||'), (2540, 2, u'-    assert(VT.isInteger() && Operand.getValueType().isInteger() &&'), (2543, 2, u'-    assert(Operand.getValueType().getScalarType().bitsGT(VT.getScalarType()) &&'), (2545, 2, u'-    assert((!VT.isVector() ||'), (2566, 2, u'-    assert(VT.getSizeInBits() == Operand.getValueType().getSizeInBits()'), (2575, 2, u'-    assert(VT.isVector() && !Operand.getValueType().isVector() &&'), (2670, 2, u'-    assert(VT == MVT::Other && N1.getValueType() == MVT::Other &&'), (2689, 2, u'-    assert(VT.isInteger() && "This operator does not apply to FP types!");'), (2690, 2, u'-    assert(N1.getValueType() == N2.getValueType() &&'), (2703, 2, u'-    assert(VT.isInteger() && "This operator does not apply to FP types!");'), (2704, 2, u'-    assert(N1.getValueType() == N2.getValueType() &&'), (2718, 2, u'-    assert(VT.isInteger() && "This operator does not apply to FP types!");'), (2719, 2, u'-    assert(N1.getValueType() == N2.getValueType() &&'), (2744, 2, u'-    assert(VT.isFloatingPoint() && "This operator only applies to FP types!");'), (2745, 2, u'-    assert(N1.getValueType() == N2.getValueType() &&'), (2749, 2, u'-    assert(N1.getValueType() == VT &&'), (2759, 2, u'-    assert(VT == N1.getValueType() &&'), (2761, 2, u'-    assert(VT.isInteger() && N2.getValueType().isInteger() &&'), (2767, 2, u'-    assert(N2.getValueType().getSizeInBits() >='), (2781, 2, u'-    assert(VT == N1.getValueType() && "Not an inreg round!");'), (2782, 2, u'-    assert(VT.isFloatingPoint() && EVT.isFloatingPoint() &&'), (2784, 2, u'-    assert(EVT.isVector() == VT.isVector() &&'), (2787, 2, u'-    assert((!EVT.isVector() ||'), (2790, 2, u'-    assert(EVT.bitsLE(VT) && "Not rounding down!");'), (2796, 2, u'-    assert(VT.isFloatingPoint() &&'), (2802, 2, u'-  case ISD::AssertSext:'), (2803, 2, u'-  case ISD::AssertZext: {'), (2805, 2, u'-    assert(VT == N1.getValueType() && "Not an inreg extend!");'), (2806, 2, u'-    assert(VT.isInteger() && EVT.isInteger() &&'), (2808, 2, u'-    assert(!EVT.isVector() &&'), (2811, 2, u'-    assert(EVT.bitsLE(VT) && "Not extending!");'), (2817, 2, u'-    assert(VT == N1.getValueType() && "Not an inreg extend!");'), (2818, 2, u'-    assert(VT.isInteger() && EVT.isInteger() &&'), (2820, 2, u'-    assert(EVT.isVector() == VT.isVector() &&'), (2823, 2, u'-    assert((!EVT.isVector() ||'), (2826, 2, u'-    assert(EVT.bitsLE(VT) && "Not extending!");'), (2896, 2, u'-    assert(N2C && (unsigned)N2C->getZExtValue() < 2 && "Bad EXTRACT_ELEMENT!");'), (2897, 2, u'-    assert(!N1.getValueType().isVector() && !VT.isVector() &&'), (2919, 2, u'-      assert(VT.isVector() && N1.getValueType().isVector() &&'), (2921, 2, u'-      assert(VT.getVectorElementType() == N1.getValueType().getVectorElementType() &&'), (2923, 2, u'-      assert(VT.getSimpleVT() <= N1.getValueType().getSimpleVT() &&'), (2927, 2, u'-        assert((VT.getVectorNumElements() +'), (3146, 2, u'-      assert(VT.isVector() && N1.getValueType().isVector() &&'), (3149, 2, u'-      assert(VT == N1.getValueType() &&'), (3151, 2, u'-      assert(N2.getValueType().getSimpleVT() <= N1.getValueType().getSimpleVT() &&'), (3154, 2, u'-        assert((N2.getValueType().getVectorNumElements() +'), (3249, 2, u'-  assert(Value.getOpcode() != ISD::UNDEF);'), (3291, 2, u'-  assert(!VT.isVector() && "Can\'t handle vector type here!");'), (3346, 2, u'-  assert((SrcAlign == 0 || SrcAlign >= DstAlign) &&'), (3375, 2, u'-    assert(LVT.isInteger());'), (3484, 2, u'-      assert(NVT.bitsGE(VT));'), (3645, 2, u'-    assert(Value.getValueType() == VT && "Value with wrong type.");'), (3691, 2, u'-    assert(ConstantSize && "AlwaysInline requires a constant size!");'), (3867, 2, u'-  assert(Opcode == ISD::ATOMIC_CMP_SWAP && "Invalid Atomic Op");'), (3868, 2, u'-  assert(Cmp.getValueType() == Swp.getValueType() && "Invalid Atomic Op Types");'), (3927, 2, u'-  assert((Opcode == ISD::ATOMIC_LOAD_ADD ||'), (3998, 2, u'-  assert(Opcode == ISD::ATOMIC_LOAD && "Invalid Atomic Op");'), (4070, 2, u'-  assert((Opcode == ISD::INTRINSIC_VOID ||'), (4141, 2, u'-  assert(Chain.getValueType() == MVT::Other &&'), (4174, 2, u'-    assert(VT == MemVT && "Non-extending load from different memory type!");'), (4177, 2, u'-    assert(MemVT.getScalarType().bitsLT(VT.getScalarType()) &&'), (4179, 2, u'-    assert(VT.isInteger() == MemVT.isInteger() &&'), (4181, 2, u'-    assert(VT.isVector() == MemVT.isVector() &&'), (4183, 2, u'-    assert((!VT.isVector() ||'), (4189, 2, u'-  assert((Indexed || Offset.getOpcode() == ISD::UNDEF) &&'), (4242, 2, u'-  assert(LD->getOffset().getOpcode() == ISD::UNDEF &&'), (4254, 2, u'-  assert(Chain.getValueType() == MVT::Other &&'), (4279, 2, u'-  assert(Chain.getValueType() == MVT::Other &&'), (4307, 2, u'-  assert(Chain.getValueType() == MVT::Other &&'), (4334, 2, u'-  assert(Chain.getValueType() == MVT::Other &&'), (4339, 2, u'-  assert(SVT.getScalarType().bitsLT(VT.getScalarType()) &&'), (4341, 2, u'-  assert(VT.isInteger() == SVT.isInteger() &&'), (4343, 2, u'-  assert(VT.isVector() == SVT.isVector() &&'), (4345, 2, u'-  assert((!VT.isVector() ||'), (4373, 2, u'-  assert(ST->getOffset().getOpcode() == ISD::UNDEF &&'), (4431, 2, u'-    assert(NumOps == 5 && "SELECT_CC takes 5 operands!");'), (4432, 2, u'-    assert(Ops[0].getValueType() == Ops[1].getValueType() &&'), (4434, 2, u'-    assert(Ops[2].getValueType() == Ops[3].getValueType() &&'), (4436, 2, u'-    assert(Ops[2].getValueType() == VT &&'), (4441, 2, u'-    assert(NumOps == 5 && "BR_CC takes 5 operands!");'), (4442, 2, u'-    assert(Ops[2].getValueType() == Ops[3].getValueType() &&'), (4682, 2, u'-  assert(N->getNumOperands() == 1 && "Update with wrong number of operands");'), (4706, 2, u'-  assert(N->getNumOperands() == 2 && "Update with wrong number of operands");'), (4755, 2, u'-  assert(N->getNumOperands() == NumOps &&'), (5279, 2, u'-  assert(From->getNumValues() == 1 && FromN.getResNo() == 0 &&'), (5281, 2, u'-  assert(From != To.getNode() && "Cannot replace uses of with self");'), (5328, 2, u'-    assert((!From->hasAnyUseOfValue(i) ||'), (5574, 2, u'-      assert(SortedPos != AllNodes.end() && "Overran node list");'), (5593, 2, u'-      assert(Degree != 0 && "Invalid node degree");'), (5600, 2, u'-        assert(SortedPos != AllNodes.end() && "Overran node list");'), (5617, 2, u'-  assert(SortedPos == AllNodes.end() &&'), (5619, 2, u'-  assert(AllNodes.front().getOpcode() == ISD::EntryToken &&'), (5621, 2, u'-  assert(AllNodes.front().getNodeId() == 0 &&'), (5623, 2, u'-  assert(AllNodes.front().getNumOperands() == 0 &&'), (5625, 2, u'-  assert(AllNodes.back().getNodeId() == (int)DAGSize-1 &&'), (5627, 2, u'-  assert(AllNodes.back().use_empty() &&'), (5629, 2, u'-  assert(DAGSize == allnodes_size() && "Node count mismatch!");'), (5635, 2, u'-  assert(SD && "Trying to assign an order to a null node!");'), (5641, 2, u'-  assert(SD && "Trying to get the order of a null node!");'), (5696, 2, u'-  assert(isVolatile() == MMO->isVolatile() && "Volatile encoding error!");'), (5697, 2, u'-  assert(isNonTemporal() == MMO->isNonTemporal() &&'), (5699, 2, u'-  assert(memvt.getStoreSize() == MMO->getSize() && "Size mismatch!");'), (5709, 2, u'-  assert(isVolatile() == MMO->isVolatile() && "Volatile encoding error!");'), (5710, 2, u'-  assert(memvt.getStoreSize() == MMO->getSize() && "Size mismatch!");'), (5742, 2, u'-    assert(VT.getSimpleVT() < MVT::LAST_VALUETYPE &&'), (5752, 2, u'-  assert(Value < getNumValues() && "Bad value!");'), (5771, 2, u'-  assert(Value < getNumValues() && "Bad value!");'), (5880, 2, u'-  assert(Num < NumOperands && "Invalid child # of SDNode!");'), (5885, 2, u'-  assert(N->getNumValues() == 1 &&'), (6058, 2, u'-  assert(VT.isVector() && "Expected a vector type");'), (6071, 2, u'-  assert(nOps > 0 && "isConstantSplat has 0-size build vector");'), (6123, 2, u'-  assert(i != e && "VECTOR_SHUFFLE node with all undef indices!");'), (6160, 2, u'-  assert(N && "Checking nonexistant SDNode");')]
===========================================
Class:class SDISelAsmOperandInfo : public TargetLowering::AsmOperandInfo { class SDISelAsmOperandInfo : public TargetLowering::AsmOperandInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 2, u'-                                ISD::NodeType AssertOp = ISD::DELETED_NODE) {'), (104, 2, u'-  assert(NumParts > 0 && "No parts to assemble!");'), (160, 2, u'-      assert(ValueVT == EVT(MVT::ppcf128) && PartVT == EVT(MVT::f64) &&'), (170, 2, u'-      assert(ValueVT.isFloatingPoint() && PartVT.isInteger() &&'), (188, 2, u'-      if (AssertOp != ISD::DELETED_NODE)'), (189, 2, u'-        Val = DAG.getNode(AssertOp, DL, PartVT, Val,'), (219, 2, u'-  assert(ValueVT.isVector() && "Not a vector value");'), (220, 2, u'-  assert(NumParts > 0 && "No parts to assemble!");'), (231, 2, u'-    assert(NumRegs == NumParts && "Part count doesn\'t match vector breakdown!");'), (233, 2, u'-    assert(RegisterVT == PartVT && "Part type doesn\'t match vector breakdown!");'), (234, 2, u'-    assert(RegisterVT == Parts[0].getValueType() &&'), (248, 2, u'-      assert(NumParts % NumIntermediates == 0 &&'), (275, 2, u'-      assert(PartVT.getVectorNumElements() > ValueVT.getVectorNumElements() &&'), (285, 2, u'-    assert(PartVT.getVectorNumElements() == ValueVT.getVectorNumElements() &&'), (301, 2, u'-  assert(ValueVT.getVectorNumElements() == 1 &&'), (337, 2, u'-  assert(TLI.isTypeLegal(PartVT) && "Copying to an illegal type!");'), (342, 2, u'-  assert(!ValueVT.isVector() && "Vector case handled elsewhere");'), (344, 2, u'-    assert(NumParts == 1 && "No-op copy with multiple parts!");'), (352, 2, u'-      assert(NumParts == 1 && "Do not know what to promote to!");'), (355, 2, u'-      assert((PartVT.isInteger() || PartVT == MVT::x86mmx) &&'), (365, 2, u'-    assert(NumParts == 1 && PartVT != ValueVT);'), (369, 2, u'-    assert((PartVT.isInteger() || PartVT == MVT::x86mmx) &&'), (380, 2, u'-  assert(NumParts * PartBits == ValueVT.getSizeInBits() &&'), (384, 2, u'-    assert(PartVT == ValueVT && "Type conversion failed!");'), (392, 2, u'-    assert(PartVT.isInteger() && ValueVT.isInteger() &&'), (447, 2, u'-  assert(ValueVT.isVector() && "Not a vector");'), (488, 2, u'-      assert(ValueVT.getVectorNumElements() == 1 &&'), (510, 2, u'-  assert(NumRegs == NumParts && "Part count doesn\'t match vector breakdown!");'), (512, 2, u'-  assert(RegisterVT == PartVT && "Part type doesn\'t match vector breakdown!");'), (535, 2, u'-    assert(NumParts % NumIntermediates == 0 &&'), (717, 2, u'-      assert(FromVT != MVT::Other);'), (718, 2, u'-      Parts[i] = DAG.getNode(isSExt ? ISD::AssertSext : ISD::AssertZext, dl,'), (815, 2, u'-      assert(Reg < Regs.size() && "Mismatch in # registers expected");'), (893, 2, u'-      assert(PendingExports[i].getNode()->getNumOperands() > 1);'), (1044, 2, u'-      assert(N1.getNode() && "visit didn\'t populate the NodeMap!");'), (1083, 2, u'-      assert((isa<ConstantAggregateZero>(C) || isa<UndefValue>(C)) &&'), (1119, 2, u'-      assert(isa<ConstantAggregateZero>(C) && "Unknown vector constant!");'), (1247, 2, u'-  assert(Chain.getNode() && Chain.getValueType() == MVT::Other &&'), (1264, 2, u'-    assert(!V->use_empty() && "Unused value assigned virtual registers!");'), (1421, 2, u'-    assert(Opc == Instruction::And && "Unknown merge op!");'), (1526, 2, u'-      assert(SwitchCases[0].ThisBB == BrMBB && "Unexpected lowering!");'), (1581, 2, u'-    assert(CB.CC == ISD::SETLE && "Can handle only LE ranges now");'), (1635, 2, u'-  assert(JT.Reg != -1U && "Should lower JT Header first!");'), (1853, 2, u'-  assert(FuncInfo.MBB->isLandingPad() &&'), (1870, 2, u'-  assert(FuncInfo.MBB->isLandingPad() &&'), (1941, 2, u'-        assert((SmallValue | CommonBit) == BigValue &&'), (2186, 2, u'-    assert((Range - 2ULL).isNonNegative() &&'), (2214, 2, u'-    assert((FMetric > 0) && "Should handle dense range earlier!");'), (2352, 2, u'-      assert((count < 3) && "Too much destinations to test!");'), (3249, 2, u'-      assert(PendingLoads.empty() && "PendingLoads must be serialized first");'), (4387, 2, u'-  if (Ext.getOpcode() == ISD::AssertZext || Ext.getOpcode() == ISD::AssertSext){'), (4502, 2, u'-    assert(cast<PointerType>(I.getArgOperand(0)->getType())->getAddressSpace()'), (4520, 2, u'-    assert(cast<PointerType>(I.getArgOperand(0)->getType())->getAddressSpace()'), (4535, 2, u'-    assert(cast<PointerType>(I.getArgOperand(0)->getType())->getAddressSpace()'), (4739, 2, u'-    assert(CI && "Non-constant call site value in eh.sjlj.callsite!");'), (4740, 2, u'-    assert(MMI.getCurrentCallSite() == 0 && "Overlapping call sites!");'), (5012, 2, u'-    assert(CI && "Non-constant type in __builtin_object_size?");'), (5260, 2, u'-  assert((isTailCall || Result.second.getNode()) &&'), (5262, 2, u'-  assert((Result.second.getNode() || !Result.first.getNode()) &&'), (5273, 2, u'-    assert(PVTs.size() == 1 && "Pointers should fit in one register");'), (5300, 2, u'-    ISD::NodeType AssertOp = ISD::DELETED_NODE;'), (5310, 2, u'-                         RegisterVT, VT, AssertOp);'), (5822, 2, u'-        assert(I != RC->end() && "Didn\'t find reg!");'), (5827, 2, u'-        assert(I != RC->end() && "Ran out of registers to allocate!");'), (5887, 2, u'-      assert(!CS.getType()->isVoidTy() && "Bad inline asm!");'), (5891, 2, u'-        assert(ResNo == 0 && "Asm only has one result!");'), (5979, 2, u'-      assert((OpInfo.isMultipleAlternative ||'), (6075, 2, u'-        assert(OpInfo.isIndirect && "Memory output must be indirect operand");'), (6104, 2, u'-        assert(!CS.getType()->isVoidTy() && "Bad inline asm!");'), (6135, 2, u'-          assert((InlineAsm::isRegDefKind(OpFlag) ||'), (6173, 2, u'-        assert(InlineAsm::isMemKind(OpFlag) && "Unknown matching constraint!");'), (6174, 2, u'-        assert(InlineAsm::getNumOperandRegisters(OpFlag) == 1 &&'), (6213, 2, u'-        assert(OpInfo.isIndirect && "Operand must be indirect to be a mem!");'), (6214, 2, u'-        assert(InOperandVal.getValueType() == TLI.getPointerTy() &&'), (6225, 2, u'-      assert((OpInfo.ConstraintType == TargetLowering::C_RegisterClass ||'), (6228, 2, u'-      assert(!OpInfo.isIndirect &&'), (6295, 2, u'-      assert(ResultType == Val.getValueType() && "Asm result value mismatch!");'), (6477, 2, u'-  assert(Chain.getNode() && Chain.getValueType() == MVT::Other &&'), (6479, 2, u'-  assert((!isTailCall || InVals.empty()) &&'), (6481, 2, u'-  assert((isTailCall || InVals.size() == Ins.size()) &&'), (6494, 2, u'-          assert(InVals[i].getNode() &&'), (6496, 2, u'-          assert(EVT(Ins[i].VT) == InVals[i].getValueType() &&'), (6502, 2, u'-  ISD::NodeType AssertOp = ISD::DELETED_NODE;'), (6504, 2, u'-    AssertOp = ISD::AssertSext;'), (6506, 2, u'-    AssertOp = ISD::AssertZext;'), (6516, 2, u'-                                            AssertOp));'), (6547, 2, u'-  assert((Op.getOpcode() != ISD::CopyFromReg ||'), (6550, 2, u'-  assert(!TargetRegisterInfo::isPhysicalRegister(Reg) && "Is a physreg");'), (6668, 2, u'-  assert(NewRoot.getNode() && NewRoot.getValueType() == MVT::Other &&'), (6670, 2, u'-  assert(InVals.size() == Ins.size() &&'), (6674, 2, u'-        assert(InVals[i].getNode() &&'), (6676, 2, u'-        assert(EVT(Ins[i].VT) == InVals[i].getValueType() &&'), (6694, 2, u'-    ISD::NodeType AssertOp = ISD::DELETED_NODE;'), (6696, 2, u'-                                        RegVT, VT, AssertOp);'), (6729, 2, u'-        ISD::NodeType AssertOp = ISD::DELETED_NODE;'), (6731, 2, u'-          AssertOp = ISD::AssertSext;'), (6733, 2, u'-          AssertOp = ISD::AssertZext;'), (6737, 2, u'-                                             AssertOp));'), (6783, 2, u'-  assert(i == InVals.size() && "Argument register count mismatch!");'), (6844, 2, u'-          assert(isa<AllocaInst>(PHIOp) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(79, 2, u'-  case ISD::AssertSext:                 return "AssertSext";'), (80, 2, u'-  case ISD::AssertZext:                 return "AssertZext";')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(229, 2, u'-    assert(TLI.getSchedulingPreference() == Sched::ILP &&'), (257, 2, u'-  assert(!MI->hasPostISelHook() &&'), (340, 2, u'-  assert((!EnableFastISelVerbose || TM.Options.EnableFastISel) &&'), (342, 2, u'-  assert((!EnableFastISelAbort || TM.Options.EnableFastISel) &&'), (853, 2, u'-  assert(RI.getOperand().isUse() &&'), (887, 2, u'-  default: assert (0 && "<Invalid operator> ");'), (1170, 2, u'-      assert(PHI->isPHI() &&'), (1223, 2, u'-      assert(PHI->isPHI() &&'), (1284, 2, u'-      assert(PHI->isPHI() &&'), (1309, 2, u'-    assert(PHI->isPHI() &&'), (1356, 2, u'-            assert(pn != FuncInfo->PHINodesToUpdate.size() &&'), (1482, 2, u'-      assert(InlineAsm::getNumOperandRegisters(Flags) == 1 &&'), (1548, 2, u'-      assert(N != Root);'), (1658, 2, u'-  assert(Val >= 128 && "Not a VBR");'), (1688, 2, u'-    assert(InputChain.getNode() != 0 &&'), (1707, 2, u'-      assert(ChainVal.getValueType() == MVT::Other && "Not a chain?");'), (1728, 2, u'-      assert(FRN->getValueType(FRN->getNumValues()-1) == MVT::Glue &&'), (1902, 2, u'-      assert(InChain.getValueType() == MVT::Other && "Not a chain");'), (1988, 2, u'-  assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2201, 2, u'-  case ISD::AssertSext:'), (2202, 2, u'-  case ISD::AssertZext:'), (2210, 2, u'-  assert(!NodeToMatch->isMachineOpcode() && "Node already selected!");'), (2285, 2, u'-    assert(MatcherIndex < TableSize && "Invalid index");'), (2394, 2, u'-      assert(!NodeStack.empty() && "Node stack imbalance!");'), (2412, 2, u'-      assert(RecNo < RecordedNodes.size() && "Invalid CheckComplexPat");'), (2514, 2, u'-      assert(NodeStack.size() != 1 && "No parent node");'), (2570, 2, u'-      assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2588, 2, u'-      assert(InputChain.getNode() == 0 &&'), (2590, 2, u'-      assert(ChainNodesMatched.empty() &&'), (2595, 2, u'-      assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2615, 2, u'-      assert(InputChain.getNode() == 0 &&'), (2624, 2, u'-      assert(NumChains != 0 && "Can\'t TF zero chains");'), (2626, 2, u'-      assert(ChainNodesMatched.empty() &&'), (2632, 2, u'-        assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2659, 2, u'-      assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2676, 2, u'-      assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2720, 2, u'-        assert(RecNo < RecordedNodes.size() && "Invalid EmitNode");'), (2729, 2, u'-        assert(NodeToMatch->getNumOperands() >= FirstOpToCopy &&'), (2848, 2, u'-        assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2865, 2, u'-        assert(ResSlot < RecordedNodes.size() && "Invalid CheckSame");'), (2868, 2, u'-        assert(i < NodeToMatch->getNumValues() &&'), (2872, 2, u'-        assert((NodeToMatch->getValueType(i) == Res.getValueType() ||'), (2889, 2, u'-      assert(NodeToMatch->use_empty() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(638, 2, u'-  assert(isTypeLegal(VT));'), (750, 2, u'-  assert(MVT::LAST_VALUETYPE <= MVT::MAX_ALLOWED_VALUETYPE &&'), (764, 2, u'-    assert(LargestIntReg != MVT::i1 && "No integer registers defined!");'), (919, 2, u'-  assert(!VT.isVector() && "No default SetCC type for vectors!");'), (1169, 2, u'-  assert(Op.getNumOperands() == 2 &&'), (1171, 2, u'-  assert(Op.getNode()->getNumValues() == 1 &&'), (1216, 2, u'-  assert(Op.getValueType().getScalarType().getSizeInBits() == BitWidth &&'), (1272, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1276, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1303, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1307, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1337, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1341, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1410, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1411, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1428, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1429, 2, u'-    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1537, 2, u'-      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1574, 2, u'-      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1636, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1671, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1711, 2, u'-      assert((KnownZero & NewBits) == 0);'), (1713, 2, u'-      assert((KnownOne & NewBits) == 0);'), (1714, 2, u'-      assert((KnownZero & NewBits) == 0);'), (1725, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1785, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1788, 2, u'-  case ISD::AssertZext: {'), (1797, 2, u'-    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1868, 2, u'-  assert((Op.getOpcode() >= ISD::BUILTIN_OP_END ||'), (1882, 2, u'-  assert((Op.getOpcode() >= ISD::BUILTIN_OP_END ||'), (2202, 2, u'-            assert(N0.getOpcode() == ISD::AND &&'), (2514, 2, u'-            assert(N0.getOpcode() == ISD::SUB && "Unexpected operation!");'), (2537, 2, u'-          assert(N1.getOpcode() == ISD::SUB && "Unexpected operation!");'), (2788, 2, u'-  assert(*(Constraint.end()-1) == \'}\' && "Not a brace enclosed constraint?");'), (2820, 2, u'-  assert(!ConstraintCode.empty() && "No known constraint!");'), (2827, 2, u'-  assert(!ConstraintCode.empty() && "No known constraint!");'), (2873, 2, u'-      assert(!CS.getType()->isVoidTy() &&'), (2878, 2, u'-        assert(ResNo == 0 && "Asm only has one result!");'), (3134, 2, u'-  assert(OpInfo.Codes.size() > 1 && "Doesn\'t have multiple constraint options");'), (3149, 2, u'-      assert(OpInfo.Codes[i].size() == 1 &&'), (3185, 2, u'-  assert(!OpInfo.Codes.empty() && "Must have at least one constraint");'), (3259, 2, u'-  assert(d != 0 && "Division by zero!");'), (3372, 2, u'-    assert(magics.a == 0 && "Should use cheap fixup now");'), (3390, 2, u'-    assert(magics.s < N1C.getBitWidth() &&')]
===========================================
Class:  class ShadowStackGC : public GCStrategy {   class ShadowStackGC : public GCStrategy 
Class:  class EscapeEnumerator {   class EscapeEnumerator 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(326, 2, u'-  assert(Roots.empty() && "Not cleaned up?");'), (356, 2, u'-  assert(isa<GetElementPtrInst>(Val) && "Unexpected folded constant");'), (368, 2, u'-  assert(isa<GetElementPtrInst>(Val) && "Unexpected folded constant");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 2, u'-  assert(LP && "Machine loop is NULL.");'), (449, 2, u'-        assert(HDR->pred_size() > 0 && "Loop header has no predecessors?");'), (648, 2, u'-      assert(!loopSpills.empty() && "No CSRs used in loop?");'), (653, 2, u'-    assert(exitBlocks.size() > 0 && "Loop has no top level exit blocks?");')]
===========================================
Class:  class SjLjEHPrepare : public FunctionPass {   class SjLjEHPrepare : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(57, 2, u'-  assert(indexList.empty() && "Index list non-empty at initial numbering?");'), (58, 2, u'-  assert(idx2MBBMap.empty() &&'), (60, 2, u'-  assert(MBBRanges.empty() &&'), (62, 2, u'-  assert(mi2iMap.empty() &&'), (133, 2, u'-  assert((Space & 3) == 0 && "InstrDist must be a multiple of 2*NUM");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(175, 2, u'-  assert(!nodes && "Leaking node array");'), (358, 2, u'-  assert(ActiveNodes && "Call prepare() first");')]
===========================================
Class:class SpillerBase : public Spiller { class SpillerBase : public Spiller 
Class:class TrivialSpiller : public SpillerBase { class TrivialSpiller : public SpillerBase 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 2, u'-    assert(li->weight != HUGE_VALF &&'), (83, 2, u'-    assert(!TargetRegisterInfo::isStackSlot(li->reg) &&'), (131, 2, u'-      assert(hasUse || hasDef);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(123, 2, u'-  assert(UseSlots.empty() && "Call clear first");'), (161, 2, u'-    assert(fixed && "Couldn\'t fix broken live interval");'), (206, 2, u'-      assert(BI.FirstInstr >= Start);'), (210, 2, u'-      assert(BI.LastInstr < Stop);'), (217, 2, u'-        assert(LVI->start == LVI->valno->def && "Dangling LiveRange start");'), (218, 2, u'-        assert(LVI->start == BI.FirstInstr && "First instr should be a def");'), (249, 2, u'-        assert(LVI->start == LVI->valno->def && "Dangling LiveRange start");'), (272, 2, u'-  assert(getNumLiveBlocks() == countLiveBlocks(CurLI) && "Bad block count");'), (302, 2, u'-  assert(!Orig.empty() && "Splitting empty interval?");'), (371, 2, u'-  assert(ParentVNI && "Mapping  NULL value");'), (372, 2, u'-  assert(Idx.isValid() && "Invalid SlotIndex");'), (373, 2, u'-  assert(Edit->getParent().getVNInfoAt(Idx) == ParentVNI && "Bad Parent VNI");'), (405, 2, u'-  assert(ParentVNI && "Mapping  NULL value");'), (468, 2, u'-  assert(Idx != 0 && "Cannot select the complement interval");'), (469, 2, u'-  assert(Idx < Edit->size() && "Can only select previously opened interval");'), (475, 2, u'-  assert(OpenIdx && "openIntv not called before enterIntvBefore");'), (485, 2, u'-  assert(MI && "enterIntvBefore called with invalid index");'), (492, 2, u'-  assert(OpenIdx && "openIntv not called before enterIntvAfter");'), (502, 2, u'-  assert(MI && "enterIntvAfter called with invalid index");'), (510, 2, u'-  assert(OpenIdx && "openIntv not called before enterIntvAtEnd");'), (533, 2, u'-  assert(OpenIdx && "openIntv not called before useIntv");'), (540, 2, u'-  assert(OpenIdx && "openIntv not called before leaveIntvAfter");'), (552, 2, u'-  assert(MI && "No instruction at index");'), (571, 2, u'-  assert(OpenIdx && "openIntv not called before leaveIntvBefore");'), (584, 2, u'-  assert(MI && "No instruction at index");'), (590, 2, u'-  assert(OpenIdx && "openIntv not called before leaveIntvAtTop");'), (608, 2, u'-  assert(OpenIdx && "openIntv not called before overlapIntv");'), (610, 2, u'-  assert(ParentVNI == Edit->getParent().getVNInfoBefore(End) &&'), (612, 2, u'-  assert(LIS.getMBBFromIndex(Start) == LIS.getMBBFromIndex(End) &&'), (637, 2, u'-    assert(MI && "No instruction for back-copy");'), (676, 2, u'-  assert(MDT.dominates(DefMBB, MBB) && "MBB must be dominated by the def.");'), (741, 2, u'-    assert(ParentVNI && "Parent not live at complement def");'), (885, 2, u'-        assert(VNI && "Missing def for complex mapped value");'), (897, 2, u'-      assert(Start <= BlockStart && "Expected live-in block");'), (903, 2, u'-          assert(ParentVNI->isPHIDef() && "Non-phi defined at block start?");'), (905, 2, u'-          assert(VNI && "Missing def for complex mapped parent PHI");'), (954, 2, u'-        assert(RegAssign.lookup(LastUse) == RegIdx &&'), (1022, 2, u'-      assert(MI && "Missing instruction for dead def");'), (1121, 2, u'-  assert(!LRMap || LRMap->size() == Edit->size());'), (1184, 2, u'-  assert((IntvIn || IntvOut) && "Use splitSingleBlock for isolated blocks");'), (1186, 2, u'-  assert((!LeaveBefore || LeaveBefore < Stop) && "Interference after block");'), (1187, 2, u'-  assert((!IntvIn || !LeaveBefore || LeaveBefore > Start) && "Impossible intf");'), (1188, 2, u'-  assert((!EnterAfter || EnterAfter >= Start) && "Interference before block");'), (1201, 2, u'-    assert((!LeaveBefore || Idx <= LeaveBefore) && "Interference");'), (1215, 2, u'-    assert((!EnterAfter || Idx >= EnterAfter) && "Interference");'), (1233, 2, u'-  assert((!IntvOut || !EnterAfter || EnterAfter < LSP) && "Impossible intf");'), (1253, 2, u'-    assert((!LeaveBefore || Idx <= LeaveBefore) && "Interference");'), (1254, 2, u'-    assert((!EnterAfter || Idx >= EnterAfter) && "Interference");'), (1264, 2, u'-  assert(LeaveBefore <= EnterAfter && "Missed case");'), (1269, 2, u'-  assert((!EnterAfter || Idx >= EnterAfter) && "Interference");'), (1274, 2, u'-  assert((!LeaveBefore || Idx <= LeaveBefore) && "Interference");'), (1288, 2, u'-  assert(IntvIn && "Must have register in");'), (1289, 2, u'-  assert(BI.LiveIn && "Must be live-in");'), (1290, 2, u'-  assert((!LeaveBefore || LeaveBefore > Start) && "Bad interference");'), (1322, 2, u'-      assert((!LeaveBefore || Idx <= LeaveBefore) && "Interference");'), (1329, 2, u'-      assert((!LeaveBefore || Idx <= LeaveBefore) && "Interference");'), (1352, 2, u'-    assert((!LeaveBefore || From <= LeaveBefore) && "Interference");'), (1367, 2, u'-  assert((!LeaveBefore || From <= LeaveBefore) && "Interference");'), (1382, 2, u'-  assert(IntvOut && "Must have register out");'), (1383, 2, u'-  assert(BI.LiveOut && "Must be live-out");'), (1384, 2, u'-  assert((!EnterAfter || EnterAfter < LSP) && "Bad interference");'), (1408, 2, u'-    assert((!EnterAfter || Idx >= EnterAfter) && "Interference");'), (1424, 2, u'-  assert((!EnterAfter || Idx >= EnterAfter) && "Interference");')]
===========================================
Class:  class StackProtector : public FunctionPass {   class StackProtector : public FunctionPass 
Class:  class StackSlotColoring : public MachineFunctionPass {   class StackSlotColoring : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(232, 2, u'-    assert(NextColor != -1 && "No more spill slots?");'), (270, 2, u'-    assert(NewSS >= 0 && "Stack coloring failed?");')]
===========================================
Class:  class StrongPHIElimination : public MachineFunctionPass {   class StrongPHIElimination : public MachineFunctionPass 
Class:  class TailDuplicatePass : public MachineFunctionPass {   class TailDuplicatePass : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(385, 2, u'-  assert(SrcOpIdx && "Unable to find matching PHI source?");'), (462, 2, u'-      assert(Idx != 0);'), (719, 2, u'-    assert(NumSuccessors <= 1);'), (754, 2, u'-    assert(TailBB != PredBB &&'), (811, 2, u'-    assert(PredBB->succ_empty() &&'), (854, 2, u'-        assert(!MI->isBundle() && "Not expecting bundles before regalloc!");'), (870, 2, u'-    assert(PrevBB->succ_empty());'), (933, 2, u'-  assert(MBB->pred_empty() && "MBB must be dead!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 2, u'-  assert(MI->getOperand(Idx1).isReg() && MI->getOperand(Idx2).isReg() &&'), (134, 2, u'-  assert(!MI->isBundle() &&'), (169, 2, u'-  assert(!MI->isBundle() &&'), (251, 2, u'-  assert(!Orig->isNotDuplicable() &&'), (260, 2, u'-  assert(MI->isCopy() && "MI must be a COPY instruction");'), (263, 2, u'-  assert(FoldIdx<2 && "FoldIdx refers no nonexistent operand");'), (274, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(FoldReg) &&'), (314, 2, u'-  assert(MBB && "foldMemoryOperand needs an inserted instruction");'), (320, 2, u'-    assert((!(Flags & MachineMemOperand::MOStore) ||'), (323, 2, u'-    assert((!(Flags & MachineMemOperand::MOLoad) ||'), (327, 2, u'-    assert(MFI.getObjectOffset(FI) != -1);'), (364, 2, u'-  assert(LoadMI->canFoldAsLoad() && "LoadMI isn\'t foldable!");'), (367, 2, u'-    assert(MI->getOperand(Ops[i]).isUse() && "Folding load into def!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(201, 2, u'-  assert(Kind.isReadOnlyWithRel() && "Unknown section kind");'), (257, 2, u'-      assert(Kind.isMergeable1ByteCString() && "unknown string width");'), (293, 2, u'-  assert(Kind.isReadOnlyWithRel() && "Unknown section kind");'), (312, 2, u'-  assert(Kind.isReadOnlyWithRel() && "Unknown section kind");')]
===========================================
Class:  class TwoAddressInstructionPass : public MachineFunctionPass {   class TwoAddressInstructionPass : public MachineFunctionPass 
Class:  class UnreachableBlockElim : public FunctionPass {   class UnreachableBlockElim : public FunctionPass 
Class:  class UnreachableMachineBlockElim : public MachineFunctionPass {   class UnreachableMachineBlockElim : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(virtReg));'), (91, 2, u'-  assert(Virt2StackSlotMap[virtReg] == NO_STACK_SLOT &&'), (98, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(virtReg));'), (99, 2, u'-  assert(Virt2StackSlotMap[virtReg] == NO_STACK_SLOT &&'), (101, 2, u'-  assert((SS >= 0 ||'), (139, 2, u'-        assert(PhysReg != NO_PHYS_REG && "Instruction uses unmapped VirtReg");'), (140, 2, u'-        assert(!Reserved.test(PhysReg) && "Reserved register assignment");'), (166, 2, u'-          assert(PhysReg && "Invalid SubReg for physical register");')]
===========================================
Class:  class DescriptorContainsAddress {   class DescriptorContainsAddress 
Class:  class CountArangeDescriptors {   class CountArangeDescriptors 
Class:   class AddArangeDescriptors {   class AddArangeDescriptors 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(104, 2, u'-  assert (fixed_form_sizes); // For best performance this should be specified!')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(381, 2, u'-          assert(opcode - 1U < prologue->StandardOpcodeLengths.size());')]
===========================================
Class:class GVMemoryBlock : public CallbackVH { class GVMemoryBlock : public CallbackVH 
Class:class ArgvArray { class ArgvArray 
Class:class IntelJITEventListener : public JITEventListener { class IntelJITEventListener : public JITEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(694, 2, u'-    assert(i != -1 && "PHINode doesn\'t contain entry for predecessor??");'), (735, 2, u'-  assert(Result.PointerVal != 0 && "Null pointer returned by malloc!");'), (747, 2, u'-  assert(Ptr->getType()->isPointerTy() &&'), (771, 2, u'-        assert(BitWidth == 64 && "Invalid index type for getelementptr");'), (945, 2, u'-  assert(SrcVal->getType()->isDoubleTy() && DstTy->isFloatTy() &&'), (954, 2, u'-  assert(SrcVal->getType()->isFloatTy() && DstTy->isDoubleTy() &&'), (965, 2, u'-  assert(SrcTy->isFloatingPointTy() && "Invalid FPToUI instruction");'), (979, 2, u'-  assert(SrcTy->isFloatingPointTy() && "Invalid FPToSI instruction");'), (991, 2, u'-  assert(DstTy->isFloatingPointTy() && "Invalid UIToFP instruction");'), (1003, 2, u'-  assert(DstTy->isFloatingPointTy() && "Invalid SIToFP instruction");'), (1017, 2, u'-  assert(SrcVal->getType()->isPointerTy() && "Invalid PtrToInt instruction");'), (1026, 2, u'-  assert(DstTy->isPointerTy() && "Invalid PtrToInt instruction");'), (1042, 2, u'-    assert(SrcTy->isPointerTy() && "Invalid BitCast");'), (1262, 2, u'-  assert((ECStack.empty() || ECStack.back().Caller.getInstruction() == 0 ||'), (1283, 2, u'-  assert((ArgVals.size() == F->arg_size() ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(304, 2, u'-  assert(Args.size() == 1);'), (429, 2, u'-  assert(args.size() < 10 && "Only handle up to 10 args to sscanf right now!");'), (445, 2, u'-  assert(args.size() < 10 && "Only handle up to 10 args to scanf right now!");'), (462, 2, u'-  assert(Args.size() >= 2);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 2, u'-  assert (F && "Function *F was null at entry to run()");')]
===========================================
Class:class JitPool { class JitPool 
Class:  class MCIListener : public JITEventListener {   class MCIListener : public JITEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 2, u'-  assert(MMI && "MachineModuleInfo not registered!");'), (200, 2, u'-  assert(MMI && "MachineModuleInfo not registered!");'), (257, 2, u'-        assert(Actions.size());'), (271, 2, u'-        assert(-1-TypeID < (int)FilterOffsets.size() && "Unknown filter id!");'), (303, 2, u'-      assert(!PadMap.count(BeginLabel) && "Duplicate landing pad labels!");'), (321, 2, u'-      assert(BeginLabel && "Invalid label!");'), (334, 2, u'-      assert(BeginLabel == LandingPad->BeginLabels[P.RangeIndex] &&'), (349, 2, u'-      assert(Site.BeginLabel && Site.EndLabel && Site.PadLabel &&')]
===========================================
Class:  class JITEmitter;
Class:   class JITResolverState {   class JITResolverState 
Class:         class JITResolver {   class JITResolver 
Class:   class StubToResolverMapTy {   class StubToResolverMapTy 
Class:         class JITEmitter : public JITCodeEmitter {   class JITEmitter : public JITCodeEmitter 
Class:  class DefaultJITMemoryManager;
Class:   class JITSlabAllocator : public SlabAllocator {   class JITSlabAllocator : public SlabAllocator 
Class:                     class DefaultJITMemoryManager : public JITMemoryManager {   class DefaultJITMemoryManager : public JITMemoryManager 
Class:class StatSymbols { class StatSymbols 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(121, 2, u'-  assert(F && "Function *F was null at entry to run()");'), (124, 2, u'-  assert(FPtr && "Pointer to fn\'s code was null after getPointerToFunction");'), (128, 2, u'-  assert((FTy->getNumParams() == ArgValues.size() ||'), (131, 2, u'-  assert(FTy->getNumParams() == ArgValues.size() &&')]
===========================================
Class:class OProfileJITEventListener : public JITEventListener { class OProfileJITEventListener : public JITEventListener 
Class:class GDBJITRegistrar : public JITRegistrar { class GDBJITRegistrar : public JITRegistrar 
Class:class DyldELFObject : public ELFObjectFile<target_endianness, is64Bits> { class DyldELFObject : public ELFObjectFile<target_endianness, is64Bits> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(248, 2, u'-    assert(si != se && "No section containing relocation!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 2, u'-  assert(Target && "Could not allocate target machine!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(52, 2, u'-        assert(!I->hasDLLImportLinkage()'), (64, 2, u'-        assert(!I->hasDLLImportLinkage()')]
===========================================
Class:class TypeMapTy : public ValueMapTypeRemapper { class TypeMapTy : public ValueMapTypeRemapper 
Class:  class ModuleLinker {   class ModuleLinker 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(215, 2, u'-    assert(!SrcSTy->isOpaque() && "Not resolving a definition?");'), (459, 2, u'-    assert(ConflictGV->getName() != Name && "forceRenaming didn\'t work");'), (498, 2, u'-  assert(Dest && "Must have two globals being queried");'), (499, 2, u'-  assert(!Src->hasLocalLinkage() &&'), (549, 2, u'-    assert((Dest->hasExternalLinkage()  || Dest->hasDLLImportLinkage() ||'), (922, 2, u'-  assert(Src && Dst && Dst->isDeclaration() && !Src->isDeclaration());'), (1002, 2, u'-    assert(Op->getNumOperands() == 3 && "Invalid module flag metadata!");'), (1003, 2, u'-    assert(isa<ConstantInt>(Op->getOperand(0)) &&'), (1005, 2, u'-    assert(isa<MDString>(Op->getOperand(1)) &&'), (1013, 2, u'-      assert(false && "Invalid behavior in module flag metadata!");'), (1127, 2, u'-      assert(isa<MDNode>(Node->getOperand(2)) &&'), (1155, 2, u'-  assert(DstM && "Null destination module");'), (1156, 2, u'-  assert(SrcM && "Null source module");')]
===========================================
Class:class ELFObjectWriter : public MCObjectWriter { class ELFObjectWriter : public MCObjectWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(555, 2, u'-  assert(!(Data.isCommon() && !Data.isExternal()));'), (577, 2, u'-  assert(StringTable.size() && "Missing string table");'), (611, 2, u'-    assert(((Data.getFlags() & ELF_STB_Global) ||'), (758, 2, u'-    assert(isInt<64>(Addend));'), (760, 2, u'-    assert(isInt<32>(Addend));'), (906, 2, u'-      assert(!Local);'), (921, 2, u'-      assert(MSD.SectionIndex && "Invalid section index!");'), (1274, 2, u'-    assert(sh_link && ".symtab not found");'), (1316, 2, u'-    assert(0 && "FIXME: sh_type value not supported!");'), (1335, 2, u'-    assert(F.getKind() == MCFragment::FT_Data);'), (1367, 2, u'-      assert(F.getKind() == MCFragment::FT_Data);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 2, u'-  assert((size_t)Kind <= sizeof(Builtins) / sizeof(Builtins[0]) &&')]
===========================================
Class:class MCAsmStreamer : public MCStreamer { class MCAsmStreamer : public MCStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 2, u'-  assert(LastValid->getParent() == F->getParent());'), (100, 2, u'-  assert(F->Offset != ~UINT64_C(0) && "Address not set!");'), (132, 2, u'-  assert(SD->getFragment() && "Invalid getOffset() on undefined symbol!");'), (290, 2, u'-  assert((ShouldAlignPC ? IsPCRel : true) &&'), (360, 2, u'-  assert(!isFragmentUpToDate(F) && "Attempt to recompute up-to-date fragment!");'), (363, 2, u'-  assert((!Prev || isFragmentUpToDate(Prev)) &&'), (393, 2, u'-    assert(AF.getValueSize() && "Invalid virtual align in concrete fragment!");'), (430, 2, u'-    assert(FragmentSize == DF.getContents().size() && "Invalid size!");'), (438, 2, u'-    assert(FF.getValueSize() && "Invalid virtual align in concrete fragment!");'), (485, 2, u'-  assert(OW->getStream().tell() - Start == FragmentSize);'), (492, 2, u'-    assert(Layout.getSectionFileSize(SD) == 0 && "Invalid size for section!");'), (504, 2, u'-        assert(DF.fixup_begin() == DF.fixup_end() &&'), (507, 2, u'-          assert(DF.getContents()[i] == 0 &&'), (514, 2, u'-        assert((!cast<MCAlignFragment>(it)->getValueSize() ||'), (519, 2, u'-        assert(!cast<MCFillFragment>(it)->getValueSize() &&'), (535, 2, u'-  assert(getWriter().getStream().tell() - Start =='), (711, 2, u'-  assert(IsAbs);'), (729, 2, u'-  assert(IsAbs);'), (746, 2, u'-  assert(IsAbs);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(17, 2, u'-  assert(Type == TextAtom && "Trying to add MCInst to a non-text atom!");'), (19, 2, u'-  assert(Address < End+Size &&'), (28, 2, u'-  assert(Type == DataAtom && "Trying to add MCData to a non-data atom!");'), (35, 2, u'-  assert((SplitPt > Begin && SplitPt <= End) &&'), (55, 2, u'-    assert(I != Data.end() && "Split point not found in range!");'), (64, 2, u'-    assert(I != Text.end() && "Split point not found in disassembly!");'), (65, 2, u'-    assert(I->first == SplitPt &&'), (77, 2, u'-  assert((TruncPt >= Begin && TruncPt < End) &&'), (89, 2, u'-    assert(I != Text.end() && "Truncation point not found in disassembly!");'), (90, 2, u'-    assert(I->first == TruncPt+1 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 2, u'-  assert(!Name.empty() && "Normal symbols cannot be unnamed!");'), (94, 2, u'-    assert(isTemporary && "Cannot rename non temporary symbols");')]
===========================================
Class:class Target;
Class:class DisasmMemoryObject : public MemoryObject { class DisasmMemoryObject : public MemoryObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 2, u'-  assert(TheTarget && "Unable to create target!");'), (60, 2, u'-  assert(MAI && "Unable to create target asm info!");'), (63, 2, u'-  assert(MII && "Unable to create target instruction info!");'), (66, 2, u'-  assert(MRI && "Unable to create target register info!");'), (74, 2, u'-  assert(STI && "Unable to create subtarget info!");'), (78, 2, u'-  assert(Ctx && "Unable to create MCContext!");'), (82, 2, u'-  assert(DisAsm && "Unable to create disassembler!");'), (89, 2, u'-  assert(IP && "Unable to create instruction printer!");'), (95, 2, u'-  assert(DC && "Allocation failure!");'), (177, 2, u'-    assert(OutStringSize != 0 && "Output buffer cannot be zero size");')]
===========================================
Class:  class EDMemoryObject : public llvm::MemoryObject {   class EDMemoryObject : public llvm::MemoryObject 
Class:  class FrameEmitterImpl {   class FrameEmitterImpl 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(958, 2, u'-      assert(Dst.isReg() && "Machine move not supported yet.");'), (1454, 2, u'-    assert(isUInt<32>(AddrDelta));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(23, 2, u'-  assert(Binding == ELF::STB_LOCAL || Binding == ELF::STB_GLOBAL ||'), (31, 2, u'-  assert(Binding == ELF::STB_LOCAL || Binding == ELF::STB_GLOBAL ||'), (37, 2, u'-  assert(Type == ELF::STT_NOTYPE || Type == ELF::STT_OBJECT ||'), (48, 2, u'-  assert(Type == ELF::STT_NOTYPE || Type == ELF::STT_OBJECT ||'), (56, 2, u'-  assert(Visibility == ELF::STV_DEFAULT || Visibility == ELF::STV_INTERNAL ||'), (66, 2, u'-  assert(Visibility == ELF::STV_DEFAULT || Visibility == ELF::STV_INTERNAL ||')]
===========================================
Class:class MCELFStreamer : public MCObjectStreamer { class MCELFStreamer : public MCObjectStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(406, 2, u'-  assert((!Layout || Asm) &&')]
===========================================
Class:class MCMachOStreamer : public MCObjectStreamer { class MCMachOStreamer : public MCObjectStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(119, 2, u'-  assert(Symbol->isUndefined() && "Cannot define a symbol twice!");'), (270, 2, u'-  assert(DescValue == (DescValue & SF_DescFlagsMask) &&'), (279, 2, u'-  assert(Symbol->isUndefined() && "Cannot define a symbol twice!");'), (296, 2, u'-  assert(Symbol->isUndefined() && "Cannot define a symbol twice!");'), (389, 2, u'-      assert(it->getOffset() == 0 && "Invalid offset in atom defining symbol!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(17, 2, u'-  assert(Begin < End && "Creating MCAtom with endpoints reversed?");'), (21, 2, u'-  assert((!I.valid() || I.start() < End) && "Offset range already occupied!");'), (34, 2, u'-  assert(I.valid() && "Atom offset not found in module!");'), (35, 2, u'-  assert(*I == Atom && "Previous atom mapping was invalid!");')]
===========================================
Class:  class MCNullStreamer : public MCStreamer {   class MCNullStreamer : public MCStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-  assert(getCurrentSectionData() && "No current section!");'), (93, 2, u'-  assert(AddrSpace == 0 && "Address space must be 0!");'), (126, 2, u'-  assert(!SD.getFragment() && "Unexpected fragment on symbol data!");'), (157, 2, u'-  assert(Section && "Cannot switch to a null section!");')]
===========================================
Class:class AsmParser : public MCAsmParser { class AsmParser : public MCAsmParser 
Class:   class GenericAsmParser : public MCAsmParserExtension { class GenericAsmParser : public MCAsmParserExtension 
Class:class COFFAsmParser : public MCAsmParserExtension { class COFFAsmParser : public MCAsmParserExtension 
Class:class DarwinAsmParser : public MCAsmParserExtension { class DarwinAsmParser : public MCAsmParserExtension 
Class:class ELFAsmParser : public MCAsmParserExtension { class ELFAsmParser : public MCAsmParserExtension 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 2, u'-  assert(!TargetParser && "Target parser is already initialized!");')]
===========================================
Class:class MCPureStreamer : public MCObjectStreamer { class MCPureStreamer : public MCObjectStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(115, 2, u'-  assert(Symbol->isUndefined() && "Cannot define a symbol twice!");'), (116, 2, u'-  assert(!Symbol->isVariable() && "Cannot emit a variable symbol!");'), (117, 2, u'-  assert(getCurrentSection() && "Cannot emit before setting section!");'), (133, 2, u'-  assert(!SD.getFragment() && "Unexpected fragment on symbol data!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(72, 2, u'-        assert (0 && "unsupported COFF selection type");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(125, 2, u'-    assert(Flags & ELF::SHF_MERGE);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(78, 2, u'-  assert(Segment.size() <= 16 && Section.size() <= 16 &&'), (105, 2, u'-  assert(SectionType <= MCSectionMachO::LAST_KNOWN_SECTION_TYPE &&'), (148, 2, u'-  assert(SectionAttrs == 0 && "Unknown section attributes!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 2, u'-  assert(Size <= 8 && "Invalid size");'), (83, 2, u'-  assert((isUIntN(8 * Size, Value) || isIntN(8 * Size, Value)) &&'), (180, 2, u'-  assert(!Symbol->isVariable() && "Cannot emit a variable symbol!");'), (181, 2, u'-  assert(getCurrentSection() && "Cannot emit before setting section!");'), (272, 2, u'-  assert(EH || Debug);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 2, u'-  assert(ProcItins && "Instruction itineraries information not available!");'), (77, 2, u'-    assert(strcmp(ProcItins[i - 1].Key, ProcItins[i].Key) < 0 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 2, u'-  assert(!Str.empty() && "Cannot create an empty MCSymbol");'), (55, 2, u'-  assert(!IsUsed && "Cannot set a variable that has already been used.");'), (56, 2, u'-  assert(Value && "Invalid variable value!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(174, 2, u'-    assert(frameInst.getOperation() == Win64EH::UOP_SetFPReg);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(136, 2, u'-  assert(OS.tell() - Start =='), (179, 2, u'-  assert(OS.tell() - Start == SegmentLoadCommandSize);'), (192, 2, u'-    assert(Layout.getSectionFileSize(&SD) == 0 && "Invalid file size!");'), (218, 2, u'-  assert(isPowerOf2_32(SD.getAlignment()) && "Invalid alignment!");'), (228, 2, u'-  assert(OS.tell() - Start == (is64Bit() ? macho::Section64Size :'), (248, 2, u'-  assert(OS.tell() - Start == macho::SymtabLoadCommandSize);'), (285, 2, u'-  assert(OS.tell() - Start == macho::DysymtabLoadCommandSize);'), (330, 2, u'-      assert((1U << Log2Size) == Align && "Invalid \'common\' alignment!");'), (430, 2, u'-  assert(Index <= 256 && "Too many sections!");'), (473, 2, u'-      assert(MSD.SectionIndex && "Invalid section index!");'), (506, 2, u'-      assert(MSD.SectionIndex && "Invalid section index!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 2, u'-  assert(!Feature.empty() && "Empty string");'), (47, 2, u'-  assert(!Feature.empty() && "Empty string");'), (58, 2, u'-  assert(!Feature.empty() && "Empty string");'), (269, 2, u'-    assert(strcmp(CPUTable[i - 1].Key, CPUTable[i].Key) < 0 &&'), (273, 2, u'-    assert(strcmp(FeatureTable[i - 1].Key, FeatureTable[i].Key) < 0 &&'), (343, 2, u'-  assert(Table && "missing table");'), (346, 2, u'-    assert(strcmp(Table[i - 1].Key, Table[i].Key) < 0 && "Table is not sorted");')]
===========================================
Class:class COFFSymbol;
Class: class COFFSymbol { class COFFSymbol 
Class: class COFFSection { class COFFSection 
Class:  class StringTable { class StringTable 
Class: class WinCOFFObjectWriter : public MCObjectWriter { class WinCOFFObjectWriter : public MCObjectWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(238, 2, u'-    assert(Section->Number != -1 && "Sections with relocations must be real!");'), (367, 2, u'-  assert(SectionData.getSection().getVariant() == MCSection::SV_COFF'), (430, 2, u'-      assert(Value->getKind() == MCExpr::SymbolRef &&'), (637, 2, u'-  assert(Target.getSymA() != NULL && "Relocation must reference a symbol!");'), (645, 2, u'-  assert(SectionMap.find(&SectionData->getSection()) != SectionMap.end() &&'), (647, 2, u'-  assert(SymbolMap.find(&A_SD.getSymbol()) != SymbolMap.end() &&'), (732, 2, u'-      assert(coff_symbol->Section != NULL);'), (753, 2, u'-      assert(coff_symbol->Index != -1);'), (754, 2, u'-      assert(coff_symbol->Aux.size() == 1 &&'), (756, 2, u'-      assert(coff_symbol->Aux[0].AuxType == ATWeakExternal &&'), (807, 2, u'-        assert((*cr).Symb->Index != -1);'), (812, 2, u'-    assert(Sec->Symbol->Aux.size() == 1'), (815, 2, u'-    assert(Aux.AuxType == ATSectionDefinition &&'), (851, 2, u'-        assert(OS.tell() == (*i)->Header.PointerToRawData &&'), (858, 2, u'-        assert(OS.tell() == (*i)->Header.PointerToRelocations &&'), (877, 2, u'-        assert((*i)->Header.PointerToRelocations == 0 &&'), (882, 2, u'-  assert(OS.tell() == Header.PointerToSymbolTable &&')]
===========================================
Class:class WinCOFFStreamer : public MCObjectStreamer { class WinCOFFStreamer : public MCObjectStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 2, u'-    assert(end <= sizeof(Name) && end > 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(66, 2, u'-  assert((offset - Header->PointerToSymbolTable) % sizeof(coff_symbol)'), (83, 2, u'-  assert(offset % sizeof(coff_section) == 0 &&')]
===========================================
Class:class _object_error_category : public _do_message { class _object_error_category : public _do_message 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(144, 2, u'-  assert(Index < getHeader().NumLoadCommands && "Invalid index!");'), (289, 2, u'-  assert(LCI.Command.Type == macho::LCT_Segment &&'), (312, 2, u'-  assert(LCI.Command.Type == macho::LCT_Segment64 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(448, 2, u'-  assert(loc != Sections.end() && "Sec is not a valid section!");'), (465, 2, u'-  assert(LCI.Command.Type == macho::LCT_Segment && "Unexpected Type.");'), (754, 2, u'-      assert(Sym.d.a < MachOObj->getHeader().NumLoadCommands &&'), (1257, 2, u'-      assert((MachOObj->getHeader().CPUType & llvm::MachO::CPUArchABI64) == 0 &&'), (1269, 2, u'-    assert((MachOObj->getHeader().CPUType & llvm::MachO::CPUArchABI64) == 1 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-  assert(Alignment && (Alignment & (Alignment - 1)) == 0 &&'), (119, 2, u'-    assert((uintptr_t)Ptr + Size <= (uintptr_t)NewSlab + NewSlab->Size);'), (127, 2, u'-  assert(CurPtr <= End && "Unable to allocate memory!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 2, u'-  assert(n <= d && "Probability must be less or equal to 1.");')]
===========================================
Class:class HelpPrinter { class HelpPrinter 
Class:class VersionPrinter { class VersionPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 2, u'-  assert(L.getBitWidth() == U.getBitWidth() &&'), (47, 2, u'-  assert((L != U || (L.isMaxValue() || L.isMinValue())) &&'), (244, 2, u'-  assert(Val.getBitWidth() == getBitWidth() && "Wrong bit width");'), (257, 2, u'-  assert(getBitWidth() == CR.getBitWidth() &&'), (338, 2, u'-  assert(getBitWidth() == CR.getBitWidth() &&'), (395, 2, u'-    assert(CR.Lower.ult(Upper) && CR.Upper.ult(Lower) &&'), (422, 2, u'-  assert(SrcTySize < DstTySize && "Not a value extension");'), (438, 2, u'-  assert(SrcTySize < DstTySize && "Not a value extension");'), (452, 2, u'-  assert(getBitWidth() > DstTySize && "Not a value truncation");')]
===========================================
Class:class DAGDeltaAlgorithmImpl { class DAGDeltaAlgorithmImpl 
Class:  class DeltaActiveSetHelper : public DeltaAlgorithm { class DeltaActiveSetHelper : public DeltaAlgorithm 
Class:class DataFileStreamer : public DataStreamer { class DataFileStreamer : public DataStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 2, u'-  assert(!llvm_is_multithreaded() &&'), (43, 2, u'-  assert(!ErrorHandler && "Error handler already registered!\\n");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(107, 2, u'-      assert(sys::isLittleEndianHost() && "Unexpected host endianness");'), (186, 2, u'-  assert((Ptr & 1) && "Not a bucket pointer");'), (210, 2, u'-  assert(5 < Log2InitSize && Log2InitSize < 32 &&'), (292, 2, u'-  assert(N->getNextInBucket() == 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(26, 2, u'-  assert(NumClasses == 0 && "grow() called after compress().");'), (33, 2, u'-  assert(NumClasses == 0 && "join() called after compress().");'), (47, 2, u'-  assert(NumClasses == 0 && "findLeader() called after compress().");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(20, 2, u'-  assert(!path.empty() && "Can\'t replace missing root");'), (49, 2, u'-  assert(Level != 0 && "Cannot move the root node");'), (56, 2, u'-      assert(l != 0 && "Cannot move beyond begin()");'), (99, 2, u'-  assert(Level != 0 && "Cannot move the root node");'), (123, 2, u'-  assert(Elements + Grow <= Nodes * Capacity && "Not enough room for elements");'), (124, 2, u'-  assert(Position <= Elements && "Invalid position");'), (138, 2, u'-  assert(Sum == Elements + Grow && "Bad distribution sum");'), (142, 2, u'-    assert(PosPair.first < Nodes && "Bad algebra");'), (143, 2, u'-    assert(NewSize[PosPair.first] && "Too few elements to need Grow");'), (150, 2, u'-    assert(NewSize[n] <= Capacity && "Overallocated node");'), (153, 2, u'-  assert(Sum == Elements && "Bad distribution sum");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-    assert(Ptr == 0 && DeleterFn == 0 && Next == 0 &&'), (60, 2, u'-  assert(DeleterFn && "ManagedStatic not initialized correctly!");'), (61, 2, u'-  assert(StaticList == this &&')]
===========================================
Class:class MemoryBufferMem : public MemoryBuffer { class MemoryBufferMem : public MemoryBuffer 
Class:class MemoryBufferMMapFile : public MemoryBufferMem { class MemoryBufferMMapFile : public MemoryBufferMem 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 2, u'-  assert(errorcode == 0); (void)errorcode;'), (60, 2, u'-  assert(errorcode == 0);'), (65, 2, u'-  assert(errorcode == 0);'), (70, 2, u'-  assert(errorcode == 0);'), (74, 2, u'-  assert(errorcode == 0);'), (84, 2, u'-  assert(mutex != 0);'), (93, 2, u'-  assert(mutex != 0);'), (103, 2, u'-  assert(mutex != 0);'), (113, 2, u'-  assert(mutex != 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 2, u'-  assert(magic && "Invalid magic number string");'), (44, 2, u'-  assert(length >=4 && "Invalid magic number length");'), (248, 2, u"-  assert(Sep[0] != '\\0' && Sep[1] == '\\0' &&")]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(169, 2, u'-  assert(Position < Path.size() && "Tried to increment past end!");'), (881, 2, u'-    assert(obviously_this_exists);'), (886, 2, u'-    assert(obviously_this_exists);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 2, u'-  assert(Plugins.isConstructed() && num < Plugins->size() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(118, 2, u'-  assert(PrettyStackTraceHead.get() == this &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 2, u'-  assert(errorcode == 0);'), (71, 2, u'-  assert(rwlock != 0);'), (80, 2, u'-  assert(rwlock != 0);'), (90, 2, u'-  assert(rwlock != 0);'), (100, 2, u'-  assert(rwlock != 0);'), (110, 2, u'-  assert(rwlock != 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(85, 2, u'-      assert(pm[i].rm_eo >= pm[i].rm_so);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(24, 2, u'-  assert(!isSmall() && "Can\'t shrink a small set!");'), (33, 2, u'-  assert(CurArray && "Failed to allocate memory?");'), (143, 2, u'-  assert(CurArray && "Failed to allocate memory?");'), (184, 2, u'-    assert(CurArray && "Failed to allocate memory?");'), (201, 2, u'-    assert(CurArraySize == RHS.CurArraySize &&'), (215, 2, u'-    assert(CurArray && "Failed to allocate memory?");'), (271, 2, u'-  assert(this->isSmall() && RHS.isSmall());'), (272, 2, u'-  assert(this->CurArraySize == RHS.CurArraySize);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 2, u'-  assert(BufferID != -1 && "Invalid Location!");'), (128, 2, u'-  assert(CurBuf != -1 && "Invalid or unspecified location!");'), (150, 2, u'-  assert(CurBuf != -1 && "Invalid or unspecified location!");'), (209, 2, u'-  assert(CurBuf != -1 && "Invalid or unspecified location!");')]
===========================================
Class:class StatisticInfo { class StatisticInfo 
Class:class RawMemoryObject : public StreamableMemoryObject { class RawMemoryObject : public StreamableMemoryObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(23, 2, u'-    assert(LastChar > FirstChar && "Invalid start/end range");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-  assert((InitSize & (InitSize-1)) == 0 &&'), (161, 2, u'-  assert(V == V2 && "Didn\'t find key?");'), (174, 2, u'-  assert(NumItems + NumTombstones <= NumBuckets);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(22, 2, u'-  assert(InternTable.empty() && "PooledStringPtr leaked!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(362, 2, u'-  assert(Radix > 1 && Radix <= 36);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 2, u'-  assert(Name && ShortDesc && TQualityFn &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(46, 2, u'-  assert(errorcode == 0);'), (54, 2, u'-  assert(errorcode == 0);'), (62, 2, u'-  assert(errorcode == 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 2, u'-  assert(!multithreaded_mode && "Already multithreaded!");'), (43, 2, u'-  assert(multithreaded_mode && "Not currently multithreaded!");')]
===========================================
Class:class Name2PairMap { class Name2PairMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(461, 2, u'-      assert(Pos < Components.size() && Components[Pos] == Comp &&'), (507, 2, u'-  assert(!Str.empty() && Str[0] >= \'0\' && Str[0] <= \'9\' && "Not a number");')]
===========================================
Class:class Scanner { class Scanner 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(727, 2, u'-    assert(!TokenQueue.empty() &&'), (1164, 2, u'-    assert(i != e && "SimpleKey not in token queue!");'), (1194, 2, u'-  assert(Position - 1 >= First);'), (1257, 2, u'-  assert(Indent >= -1 && "Indent must be >= -1 !");'), (1646, 2, u'-    assert(!UnquotedValue.empty() && "Can\'t be empty!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(63, 2, u'-  assert(OutBufCur == OutBufStart &&'), (89, 2, u'-  assert(((Mode == Unbuffered && BufferStart == 0 && Size == 0) ||'), (94, 2, u'-  assert(GetNumBytesInBuffer() == 0 && "Current buffer is non-empty!");'), (103, 2, u'-  assert(OutBufStart <= OutBufEnd && "Invalid size!");'), (261, 2, u'-  assert(OutBufCur > OutBufStart && "Invalid call to flush_nonempty.");'), (325, 2, u'-  assert(Size <= size_t(OutBufEnd - OutBufCur) && "Buffer overrun!");'), (379, 2, u'-    assert(BytesUsed > NextBufferSize && "Didn\'t grow buffer!?");'), (424, 2, u'-  assert(Filename != 0 && "Filename is null");'), (426, 2, u'-  assert((!(Flags & F_Excl) || !(Flags & F_Append)) &&'), (519, 2, u'-  assert(FD >= 0 && "File already closed.");'), (568, 2, u'-  assert(ShouldClose);'), (590, 2, u'-  assert(FD >= 0 && "File not yet open!");'), (722, 2, u'-  assert(GetNumBytesInBuffer() == 0 && "Didn\'t flush before mutating vector");'), (734, 2, u'-    assert(OS.size() + Size <= OS.capacity() && "Invalid write_impl() call!");'), (737, 2, u'-    assert(GetNumBytesInBuffer() == 0 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(244, 2, u'-\t\tSETERROR(REG_ASSERT);'), (293, 2, u'-\tassert(!MORE() || SEE(stop));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(153, 2, u'-\tassert(!(g->iflags&REGEX_BAD));')]
===========================================
Class:class _generic_error_category : public _do_message { class _generic_error_category : public _do_message 
Class: class _system_error_category : public _do_message { class _system_error_category : public _do_message 
Class:class TableGenStringKey { class TableGenStringKey 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(119, 2, u'-    assert(BInit != 0);'), (769, 2, u'-  assert(Lex.getCode() == tgtok::Id && "Expected ID in ParseIDValue");'), (793, 2, u'-      assert(RV && "Template arg doesn\'t exist??");'), (804, 2, u'-      assert(RV && "Template arg doesn\'t exist??");'), (928, 2, u'-          assert(LHSt && "expected list type argument in unary operator");'), (1640, 2, u'-    assert(RV && "Template argument record not found??");'), (1657, 2, u'-      assert(RV && "Template argument record not found??");'), (1701, 2, u'-      assert(CurMultiClass);'), (1777, 2, u'-  assert(Lex.getCode() == tgtok::less && "Not a template arg list!");'), (1929, 2, u'-  assert(Lex.getCode() == tgtok::Def && "Unknown tok");'), (1967, 2, u'-  assert(CurRec->getTemplateArgs().empty() && "How\'d this get template args?");'), (1976, 2, u'-      assert(RV && "Template arg doesn\'t exist?");'), (1997, 2, u'-  assert(Lex.getCode() == tgtok::Foreach && "Unknown tok");'), (2046, 2, u'-  assert(Lex.getCode() == tgtok::Class && "Unexpected token!");'), (2125, 2, u'-  assert(Lex.getCode() == tgtok::Let && "Unexpected token");'), (2169, 2, u'-  assert(Lex.getCode() == tgtok::MultiClass && "Unexpected token");'), (2382, 2, u'-      assert(RV && "Template arg doesn\'t exist?");'), (2395, 2, u'-  assert(Lex.getCode() == tgtok::Defm && "Unexpected token!");'), (2426, 2, u'-    assert(MC && "Didn\'t lookup multiclass correctly?");')]
===========================================
Class:  class AttributeEmitter {   class AttributeEmitter 
Class:   class AsmAttributeEmitter : public AttributeEmitter {   class AsmAttributeEmitter : public AttributeEmitter 
Class:   class ObjectAttributeEmitter : public AttributeEmitter {   class ObjectAttributeEmitter : public AttributeEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(89, 2, u'-      assert(false && "Duplicated entries?");'), (407, 2, u'-  assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (408, 2, u'-  assert((Cond.size() == 2 || Cond.size() == 0) &&'), (540, 2, u'-  assert(JTI < JT.size());'), (610, 2, u'-    assert(MJTI != 0);'), (612, 2, u'-    assert(JTI < JT.size());'), (640, 2, u'-    assert(!I->isBundle() && "No nested bundle!");'), (714, 2, u'-      assert(Dst && Src && "Bad sub-register");'), (1126, 2, u'-  assert(MCPE.isMachineConstantPoolEntry() &&'), (1378, 2, u'-  assert(Offset2 > Offset1);'), (1588, 2, u'-    assert(ThisVal && "Didn\'t extract field correctly");'), (1593, 2, u'-    assert(ARM_AM::getSOImmVal(ThisVal) != -1 && "Bit extraction didn\'t work?");'), (1650, 2, u'-    assert(ARM_AM::getSOImmVal(ThisImmVal) != -1 &&'), (1699, 2, u'-    assert((Offset & (Scale-1)) == 0 && "Can\'t encode this offset!");'), (2436, 2, u'-  assert(II->isInsideBundle() && "Empty bundle?");'), (2447, 2, u'-  assert(Idx != -1 && "Cannot find bundled definition!");'), (2458, 2, u'-  assert(II->isInsideBundle() && "Empty bundle?");'), (3056, 2, u'-  assert(MI->getOpcode() == ARM::VMOVD && "Can only swizzle VMOVD");'), (3061, 2, u'-  assert(!isPredicated(MI) && "Cannot predicate a VORRd");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 2, u'-    assert(ARM::D31 == ARM::D16 + 15);'), (758, 2, u'-      assert(!AFI->isThumb1OnlyFunction() &&'), (774, 2, u'-        assert(Opc == ARM::ADJCALLSTACKUP || Opc == ARM::tADJCALLSTACKUP);'), (839, 2, u'-    assert(i < MI->getNumOperands() &&"Instr doesn\'t have FrameIndex operand!");'), (954, 2, u'-  assert(!AFI->isThumb1OnlyFunction() &&'), (959, 2, u'-    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (965, 2, u'-    assert(AFI->isThumb2Function());'), (968, 2, u'-  assert (Done && "Unable to resolve frame index!");'), (980, 2, u'-    assert(i < MI->getNumOperands() &&"Instr doesn\'t have FrameIndex operand!");'), (1050, 2, u'-  assert(!AFI->isThumb1OnlyFunction() &&'), (1055, 2, u'-    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (1069, 2, u'-    assert(TFI->hasReservedCallFrame(MF) &&'), (1072, 2, u'-    assert(!MF.getFrameInfo()->hasVarSizedObjects() &&'), (1090, 2, u'-    assert(AFI->isThumb2Function());'), (1099, 2, u'-  assert((Offset ||'), (1118, 2, u'-      assert(AFI->isThumb2Function());')]
===========================================
Class:  class ARMCodeEmitter : public MachineFunctionPass {   class ARMCodeEmitter : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(368, 2, u'-  assert((MF.getTarget().getRelocationModel() != Reloc::Default ||'), (418, 2, u'-  assert(((Reloc == ARM::reloc_arm_movt) || (Reloc == ARM::reloc_arm_movw))'), (637, 2, u'-    assert(ACPV->isGlobalValue() && "unsupported constant pool value");'), (722, 2, u'-  assert(MO1.isImm() && ARM_AM::isSOImmTwoPartVal(MO1.getImm()) &&'), (965, 2, u'-    assert(ARM_AM::getSORegOffset(MO2.getImm()) == 0);'), (975, 2, u'-  assert(SoImmVal != -1 && "Not a valid so_imm value!");'), (1159, 2, u'-  assert(TargetRegisterInfo::isPhysicalRegister(MO2.getReg()));'), (1291, 2, u'-    assert(TargetRegisterInfo::isPhysicalRegister(MO.getReg()) &&'), (1412, 2, u'-    assert(ShiftAmt != 0 && "PKHTB shift_imm is 0!");'), (1416, 2, u'-  assert(ShiftAmt < 32 && "shift_imm range is 0 to 31!");'), (1438, 2, u'-  assert((Pos < 16 || (Pos < 32 &&'), (1456, 2, u'-    assert(ShiftAmt < 32 && "shift_imm range is 0 to 31!");'), (1593, 2, u'-  assert((Binary & ARMII::D_BitShift) == 0 &&'), (1790, 2, u'-  assert((Binary & 0xfe000000) == 0xf2000000 &&'), (1830, 2, u'-  assert((Opc1 & 3) == 0 && "out-of-range lane number operand");')]
===========================================
Class:  class ARMConstantIslands : public MachineFunctionPass {   class ARMConstantIslands : public MachineFunctionPass 
Class:  class ARMExpandPseudo : public MachineFunctionPass {   class ARMExpandPseudo : public MachineFunctionPass 
Class:class ARMFastISel : public FastISel { class ARMFastISel : public FastISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(475, 2, u'-  assert(TargetRegisterInfo::isVirtualRegister(Op0) &&'), (881, 2, u'-  assert(VT.isSimple() && "Non-simple types are invalid here!");'), (985, 2, u'-  assert(VT.isSimple() && "Non-simple types are invalid here!");'), (1063, 2, u'-  assert (ResultReg > 255 && "Expected an allocated virtual register.");'), (1641, 2, u'-    assert (VT == MVT::i32 && "Expecting an i32.");'), (1705, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported SDIV!");'), (1727, 2, u'-  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported SREM!");'), (1911, 2, u'-    assert((!ArgVT.isVector() && ArgVT.getSizeInBits() <= 64) &&'), (1920, 2, u'-        assert (Arg != 0 && "Failed to emit a sext");'), (1929, 2, u'-        assert (Arg != 0 && "Failed to emit a sext");'), (1936, 2, u'-        assert(BC != 0 && "Failed to emit a bitcast!");'), (1952, 2, u'-      assert(VA.getLocVT() == MVT::f64 &&'), (1957, 2, u'-      assert(VA.isRegLoc() && NextVA.isRegLoc() &&'), (1967, 2, u'-      assert(VA.isMemLoc());'), (1975, 2, u'-      assert(EmitRet && "Could not emit a store for argument!");'), (2015, 2, u'-      assert(RVLocs.size() == 1 &&"Can\'t handle non-double multi-reg retvals!");'), (2084, 2, u'-      assert(DestVT == MVT::i32 && "ARM should always ext to i32");'), (2361, 2, u'-      assert(Len == 1);'), (2368, 2, u'-    assert (RV == true && "Should be able to handle this load.");'), (2370, 2, u'-    assert (RV == true && "Should be able to handle this store.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(139, 2, u'-  assert(!AFI->isThumb1OnlyFunction() &&'), (287, 2, u'-    assert (!AFI->isThumb1OnlyFunction());'), (341, 2, u'-  assert(MBBI->isReturn() && "Can only insert epilog into returning blocks");'), (349, 2, u'-  assert(!AFI->isThumb1OnlyFunction() &&'), (392, 2, u'-          assert(MF.getRegInfo().isPhysRegUsed(ARM::R4) &&'), (440, 2, u'-        assert(JumpTarget.isSymbol());'), (504, 2, u'-    assert (hasFP(MF) && "dynamic stack realignment without a FP!");'), (509, 2, u'-      assert(RegInfo->hasBasePointer(MF) &&'), (524, 2, u'-      assert(RegInfo->hasBasePointer(MF) && "missing base pointer!");'), (757, 2, u'-  assert(!AFI->isThumb1OnlyFunction() && "Can\'t realign stack for thumb1");'), (853, 2, u'-  assert(MI->mayStore() && "Expecting spill instruction");'), (859, 2, u'-    assert(MI->mayStore() && "Expecting spill instruction");'), (862, 2, u'-    assert(MI->mayStore() && "Expecting spill instruction");'), (866, 2, u'-    assert(MI->killsRegister(ARM::R4) && "Missed kill flag");'), (899, 2, u'-  assert(!AFI->isThumb1OnlyFunction() && "Can\'t realign stack for thumb1");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-  assert(Stalls == 0 && "ARM hazards don\'t support scoreboard lookahead");')]
===========================================
Class:class ARMDAGToDAGISel : public SelectionDAGISel { class ARMDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(320, 2, u'-  assert(Scale > 0 && "Invalid scale!");'), (1602, 2, u'-  assert(NumVecs >= 1 && NumVecs <= 4 && "VLD NumVecs out-of-range");'), (1630, 2, u'-    assert(NumVecs == 1 && "v2i64 type only supported for VLD1");'), (1696, 2, u'-      assert(isa<ConstantSDNode>(Inc.getNode()) &&'), (1719, 2, u'-  assert(ARM::dsub_7 == ARM::dsub_0+7 &&'), (1734, 2, u'-  assert(NumVecs >= 1 && NumVecs <= 4 && "VST NumVecs out-of-range");'), (1766, 2, u'-    assert(NumVecs == 1 && "v2i64 type only supported for VST1");'), (1861, 2, u'-    assert(isa<ConstantSDNode>(Inc.getNode()) &&'), (1880, 2, u'-  assert(NumVecs >=2 && NumVecs <= 4 && "VLDSTLane NumVecs out-of-range");'), (1984, 2, u'-  assert(ARM::dsub_7 == ARM::dsub_0+7 &&'), (1998, 2, u'-  assert(NumVecs >=2 && NumVecs <= 4 && "VLDDup NumVecs out-of-range");'), (2068, 2, u'-  assert(ARM::dsub_7 == ARM::dsub_0+7 && "Unexpected subreg numbering");'), (2081, 2, u'-  assert(NumVecs >= 2 && NumVecs <= 4 && "VTBL NumVecs out-of-range");'), (2133, 2, u'-        assert(Srl_imm > 0 && Srl_imm < 32 && "bad amount in shift node!");'), (2152, 2, u'-    assert(Shl_imm > 0 && Shl_imm < 32 && "bad amount in shift node!");'), (2155, 2, u'-      assert(Srl_imm > 0 && Srl_imm < 32 && "bad amount in shift node!");'), (2289, 2, u'-  assert(CC.getOpcode() == ISD::Constant);'), (2290, 2, u'-  assert(CCR.getOpcode() == ISD::Register);'), (2376, 2, u'-  assert(CCR.getOpcode() == ISD::Register);'), (2795, 2, u'-    assert(N1.getOpcode() == ISD::BasicBlock);'), (2796, 2, u'-    assert(N2.getOpcode() == ISD::Constant);'), (2797, 2, u'-    assert(N3.getOpcode() == ISD::Register);'), (2884, 2, u'-      assert(NumElts == 2 && "unexpected type for BUILD_VECTOR");'), (2887, 2, u'-    assert(EltVT == MVT::f32 && "unexpected type for BUILD_VECTOR");'), (2890, 2, u'-    assert(NumElts == 4 && "unexpected type for BUILD_VECTOR");'), (3385, 2, u'-  assert(ConstraintCode == \'m\' && "unexpected asm memory constraint");')]
===========================================
Class:  class ARMCCState : public CCState {   class ARMCCState : public CCState 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(255, 2, u'-    assert((!ACPV->hasModifier() && !ACPV->mustAddCurrentAddress()) &&'), (312, 2, u'-      assert(ResultPtr >= -33554432 && ResultPtr <= 33554428);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(428, 2, u'-        assert(Idx >= 0 && "Cannot find killing operand");'), (1174, 2, u'-        assert(!TRI->regsOverlap(OddReg, BaseReg));'), (1411, 2, u'-      assert(((isThumb2 && Opcode == ARM::t2LDMIA_UPD) ||'), (1550, 2, u'-  assert(MI->memoperands_empty() && "expected a new machineinstr");'), (1640, 2, u'-      assert(LHS == RHS || LOffset != ROffset);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 2, u'-    assert(!MO.getSubReg() && "Subregs should be eliminated!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(208, 2, u'-  assert(InstrItins.IssueWidth <= 2 && "itinerary bug, too many stage 1 units");')]
===========================================
Class:class ARMPassConfig : public TargetPassConfig { class ARMPassConfig : public TargetPassConfig 
Class:class ARMBaseAsmLexer : public MCTargetAsmLexer { class ARMBaseAsmLexer : public MCTargetAsmLexer 
Class: class ARMAsmLexer : public ARMBaseAsmLexer { class ARMAsmLexer : public ARMBaseAsmLexer 
Class: class ThumbAsmLexer : public ARMBaseAsmLexer { class ThumbAsmLexer : public ARMBaseAsmLexer 
Class:class ARMOperand;
Class: class ARMAsmParser : public MCTargetAsmParser { class ARMAsmParser : public MCTargetAsmParser 
Class:class ARMOperand : public MCParsedAsmOperand { class ARMOperand : public MCParsedAsmOperand 
Class:class ARMDisassembler : public MCDisassembler { class ARMDisassembler : public MCDisassembler 
Class:  class ThumbDisassembler : public MCDisassembler { class ThumbDisassembler : public MCDisassembler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 2, u'-    assert(ARM_AM::getSORegOffset(MO3.getImm()) == 0);'), (210, 2, u'-    assert(Op.isExpr() && "unknown operand kind in printOperand");'), (257, 2, u'-  assert(ARM_AM::getSORegOffset(MO3.getImm()) == 0);'), (562, 2, u'-  assert(MO.isImm() && "Not a valid bf_inv_mask_imm value!");'), (588, 2, u'-  assert(Imm > 0 && Imm < 32 && "Invalid PKH shift immediate value!");'), (598, 2, u'-  assert(Imm > 0 && Imm <= 32 && "Invalid PKH shift immediate value!");'), (711, 2, u'-    assert(MI->getOperand(OpNum).getReg() == ARM::CPSR &&'), (759, 2, u'-  assert(NumTZ <= 3 && "Invalid IT mask!");'), (839, 2, u'-  assert(MO2.isImm() && "Not a valid t2_so_reg value!");'), (959, 2, u'-  assert(MO2.getReg() && "Invalid so_reg load / store address!");'), (964, 2, u'-    assert(ShAmt <= 3 && "Not a valid Thumb2 addressing mode!");'), (998, 2, u'-  default: assert (0 && "illegal ror immediate!");')]
===========================================
Class:class ARMELFObjectWriter : public MCELFObjectTargetWriter { class ARMELFObjectWriter : public MCELFObjectTargetWriter 
Class: class ARMAsmBackend : public MCAsmBackend { class ARMAsmBackend : public MCAsmBackend 
Class:class ELFARMAsmBackend : public ARMAsmBackend { class ELFARMAsmBackend : public ARMAsmBackend 
Class:  class DarwinARMAsmBackend : public ARMAsmBackend { class DarwinARMAsmBackend : public ARMAsmBackend 
Class:  class ARMELFObjectWriter : public MCELFObjectTargetWriter {   class ARMELFObjectWriter : public MCELFObjectTargetWriter 
Class:class ARMMCCodeEmitter : public MCCodeEmitter { class ARMMCCodeEmitter : public MCCodeEmitter 
Class:class ARMMCInstrAnalysis : public MCInstrAnalysis { class ARMMCInstrAnalysis : public MCInstrAnalysis 
Class:class ARMMachObjectWriter : public MCMachObjectTargetWriter { class ARMMachObjectWriter : public MCMachObjectTargetWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(203, 2, u'-  assert((MBBI->getOpcode() == ARM::tBX_RET ||'), (243, 2, u'-        assert(MF.getRegInfo().isPhysRegUsed(ARM::R4) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 2, u'-  assert(ARM::GPRRegClass.contains(DestReg, SrcReg) &&'), (56, 2, u'-  assert((RC == ARM::tGPRRegisterClass ||'), (84, 2, u'-  assert((RC == ARM::tGPRRegisterClass ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(111, 2, u'-      assert(BaseReg == ARM::SP && "Unexpected!");'), (186, 2, u'-    assert(isMul4 && "Thumb sp inc / dec size must be multiple of 4!");'), (212, 2, u'-      assert(isMul4 && "Thumb sp inc / dec size must be multiple of 4!");'), (331, 2, u'-        assert(Opc == ARM::ADJCALLSTACKUP || Opc == ARM::tADJCALLSTACKUP);'), (408, 2, u'-      assert((Offset & 3) == 0 &&'), (490, 2, u'-    assert((Offset & (Scale - 1)) == 0 && "Can\'t encode this offset!");'), (538, 2, u'-    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (541, 2, u'-  assert (Done && "Unable to resolve frame index!");'), (608, 2, u'-    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (621, 2, u'-    assert(SPAdj == 0 && MF.getTarget().getFrameLowering()->hasFP(MF) &&'), (638, 2, u'-    assert(MF.getTarget().getFrameLowering()->hasReservedCallFrame(MF) &&'), (641, 2, u'-    assert(!MF.getFrameInfo()->hasVarSizedObjects() &&'), (655, 2, u'-  assert(AFI->isThumbFunction() &&'), (663, 2, u'-  assert(Offset && "This code isn\'t needed if offset already handled!");')]
===========================================
Class:  class Thumb2ITBlockPass : public MachineFunctionPass {   class Thumb2ITBlockPass : public MachineFunctionPass 
Class:  class Thumb2SizeReduce : public MachineFunctionPass {   class Thumb2SizeReduce : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(187, 2, u'-      assert(false && "Duplicated entries?");'), (463, 2, u'-    assert((!HasShift || OffsetReg) && "Invalid so_reg load / store address!");'), (833, 2, u'-    assert(LiveCPSR && "CPSR liveness tracking is wrong!");')]
===========================================
Class:  class SPUAsmPrinter : public AsmPrinter {   class SPUAsmPrinter : public AsmPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 2, u'-      assert(value < (1 << 8) && "Invalid u7 argument");'), (126, 2, u'-      assert(value <= (1 << 19) - 1 && "Invalid u18 argument");'), (135, 2, u'-      assert((value >= -(1 << 9) && value <= (1 << 9) - 1)'), (145, 2, u'-      assert((value <= (1 << 10) - 1) && "Invalid u10 argument");'), (152, 2, u'-      assert(MI->getOperand(OpNo).isImm() &&'), (156, 2, u'-      assert((value16 >= -(1 << (9+4)) && value16 <= (1 << (9+4)) - 1)'), (225, 2, u'-        assert((value >= 0 && value < 16)'), (234, 2, u'-      assert(MI->getOperand(OpNo).isImm() &&'), (237, 2, u'-      assert((value >= 0 && value <= 32)')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 2, u'-  assert(isPowerOf2_32(Align) && "Alignment is not power of 2");'), (111, 2, u'-  assert((FrameSize & 0xf) == 0'), (198, 2, u'-  assert(MBBI->getOpcode() == SPU::RET &&'), (200, 2, u'-  assert((FrameSize & 0xf) == 0 && "FrameSize not aligned");')]
===========================================
Class:  class SPUDAGToDAGISel :   class SPUDAGToDAGISel :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(597, 2, u'-    assert( false && "add a new case here" );')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 2, u'-  assert( isEvenPlace && "basic block start from odd address");'), (149, 2, u'-             assert( false && "got unknown FuncUnit\\n");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(266, 2, u'-    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (286, 2, u'-  assert((Offset & 0xf) == 0'), (335, 2, u'-    default: assert( false && "Unhandled D to X-form conversion");'), (350, 2, u'-  assert(RS && "Register scavenging must be on");'), (354, 2, u'-  assert( Reg && "Register scavenger failed");')]
===========================================
Class:class SPUPassConfig : public TargetPassConfig { class SPUPassConfig : public TargetPassConfig 
Class:  class CppWriter : public ModulePass {   class CppWriter : public ModulePass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(493, 2, u'-      assert(attrs == 0 && "Unhandled attribute!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 2, u'-    assert(0 && "<unknown operand type>");'), (231, 2, u'-  assert( (MO.getType() == MachineOperand::MO_GlobalAddress) &&'), (244, 2, u'-  assert( (MO.getType() == MachineOperand::MO_JumpTableIndex) &&'), (254, 2, u'-  assert( (MO.getType() == MachineOperand::MO_ConstantPoolIndex) &&')]
===========================================
Class:class HexagonCFGOptimizer : public MachineFunctionPass { class HexagonCFGOptimizer : public MachineFunctionPass 
Class:class HexagonExpandPredSpillCode : public MachineFunctionPass { class HexagonExpandPredSpillCode : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 2, u'-        assert(FP == QTM.getRegisterInfo()->getFrameRegister() &&'), (82, 2, u'-        assert(MI->getOperand(1).isImm() && "Not an offset");'), (85, 2, u'-        assert(Hexagon::PredRegsRegClass.contains(SrcReg) &&'), (122, 2, u'-        assert(Hexagon::PredRegsRegClass.contains(DstReg) &&'), (125, 2, u'-        assert(FP == QTM.getRegisterInfo()->getFrameRegister() &&'), (127, 2, u'-        assert(MI->getOperand(2).isImm() && "Not an offset");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(108, 2, u'-    assert((MI->getOpcode() == Hexagon::ADJDYNALLOC) &&'), (112, 2, u'-    assert(MO.isImm() && "Expected immediate");'), (241, 2, u'-    assert(SuperReg[0] && !SuperReg[1] && "Expected exactly one superreg");'), (247, 2, u'-      assert(SuperRegNext[0] && !SuperRegNext[1] &&'), (302, 2, u'-    assert(SuperReg[0] && !SuperReg[1] && "Expected exactly one superreg");'), (306, 2, u'-      assert(SuperRegNext[0] && !SuperRegNext[1] &&')]
===========================================
Class:  class CountValue;
Class:             class CountValue {   class CountValue 
Class:class HexagonDAGToDAGISel : public SelectionDAGISel { class HexagonDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 2, u'-  assert ( (NumNamedVarArgParams > 0) &&'), (100, 2, u'-    assert ((ArgFlags.getByValSize() > 8) &&'), (127, 2, u'-    assert ((ArgFlags.getByValSize() > 8) &&'), (853, 2, u'-        assert (0);'), (856, 2, u'-      assert (0 && "ByValSize must be bigger than 8 bytes");'), (859, 2, u'-      assert(VA.isMemLoc());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(129, 2, u'-    assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (1258, 2, u'-  assert (isPredicable(MI) && "Expected predicable instruction");'), (1400, 2, u'-    assert((Offset % 4 == 0) && "Offset has incorrect alignment");'), (1406, 2, u'-    assert((Offset % 8 == 0) && "Offset has incorrect alignment");'), (1414, 2, u'-    assert((Offset % 2 == 0) && "Offset has incorrect alignment");'), (1446, 2, u'-    assert ((Offset % 4) == 0 && "MEMOPw offset is not aligned correctly." );'), (1463, 2, u'-    assert ((Offset % 2) == 0 && "MEMOPh offset is not aligned correctly." );')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(52, 2, u'-      assert(0 && "unknown operand type");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(128, 2, u'-        assert (MI->getNumOperands() == 2);'), (146, 2, u'-        assert (MI->getNumOperands() == 2);'), (164, 2, u'-        assert (MI->getNumOperands() == 2);'), (256, 2, u'-  assert (&Dst != &Src && "Cannot duplicate into itself");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(138, 2, u'-  assert(SPAdj == 0 && "Unexpected");'), (145, 2, u'-    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 2, u'-            assert (EVT::getEVT(SI->getType()) ==')]
===========================================
Class:class HexagonSplitTFRCondSets : public MachineFunctionPass { class HexagonSplitTFRCondSets : public MachineFunctionPass 
Class:class HexagonPassConfig : public TargetPassConfig { class HexagonPassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 2, u'-    assert(false && "Unknown operand");'), (116, 2, u'-  assert(MI->getOperand(OpNo).isExpr() && "Expecting expression");'), (123, 2, u'-  assert(MI->getOperand(OpNo).isExpr() && "Expecting expression");'), (130, 2, u'-  assert(MI->getOperand(OpNo).isExpr() && "Expecting expression");'), (139, 2, u'-  assert("Unknown branch operand.");'), (163, 2, u'-    assert("Unknown symbol operand");')]
===========================================
Class:  class MBlazeBaseAsmLexer : public MCTargetAsmLexer {   class MBlazeBaseAsmLexer : public MCTargetAsmLexer 
Class:   class MBlazeAsmLexer : public MBlazeBaseAsmLexer {   class MBlazeAsmLexer : public MBlazeBaseAsmLexer 
Class:class MBlazeAsmParser : public MCTargetAsmParser { class MBlazeAsmParser : public MCTargetAsmParser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(140, 2, u'-    assert(Kind == Register && "Invalid access!");'), (145, 2, u'-    assert(Kind == Immediate && "Invalid access!");'), (150, 2, u'-    assert(Kind == Fsl && "Invalid access!");'), (155, 2, u'-    assert(Kind == Memory && "Invalid access!");'), (160, 2, u'-    assert(Kind == Memory && "Invalid access!");'), (165, 2, u'-    assert(Kind == Memory && "Invalid access!");'), (186, 2, u'-    assert(N == 1 && "Invalid number of operands!");'), (191, 2, u'-    assert(N == 1 && "Invalid number of operands!");'), (196, 2, u'-    assert(N == 1 && "Invalid number of operands!");'), (201, 2, u'-    assert(N == 2 && "Invalid number of operands!");'), (213, 2, u'-    assert(Kind == Token && "Invalid access!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-  assert((Modifier == 0 || Modifier[0] == 0) && "No modifiers supported");'), (43, 2, u'-    assert(Op.isExpr() && "unknown operand kind in printOperand");')]
===========================================
Class:  class MBlazeAsmPrinter : public AsmPrinter {   class MBlazeAsmPrinter : public AsmPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 2, u'-  assert((RelTy == ELF::R_MICROBLAZE_32_PCREL ||')]
===========================================
Class:class MBlazeDAGToDAGISel : public SelectionDAGISel { class MBlazeDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(746, 2, u'-      assert(VA.isMemLoc());'), (920, 2, u'-          Opcode = ISD::AssertSext;'), (922, 2, u'-          Opcode = ISD::AssertZext;'), (932, 2, u'-      assert(VA.isMemLoc());'), (1037, 2, u'-    assert(VA.isRegLoc() && "Can only return in registers!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(192, 2, u'-  assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (193, 2, u'-  assert((Cond.size() == 2 || Cond.size() == 0) &&'), (244, 2, u'-  assert(Cond.size() == 2 && "Invalid MBlaze branch opcode!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 2, u'-  assert(!isOverloaded(IntrID) && "MBlaze intrinsics are not overloaded");'), (52, 2, u'-  assert(IntrID < mblazeIntrinsic::num_mblaze_intrinsics &&'), (106, 2, u'-  assert(!isOverloaded(IntrID) && "MBlaze intrinsics are not overloaded");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(110, 2, u'-        assert(Old->getOpcode() == MBlaze::ADJCALLSTACKUP);'), (137, 2, u'-    assert(i < MI.getNumOperands() &&')]
===========================================
Class:class MBlazePassConfig : public TargetPassConfig { class MBlazePassConfig : public TargetPassConfig 
Class:class MBlazeAsmBackend : public MCAsmBackend { class MBlazeAsmBackend : public MCAsmBackend 
Class:class ELFMBlazeAsmBackend : public MBlazeAsmBackend { class ELFMBlazeAsmBackend : public MBlazeAsmBackend 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(136, 2, u'-  assert(Fixup.getOffset() + Size <= DataSize &&'), (163, 2, u'-    assert(0 && "Mac not supported on MBlaze");'), (166, 2, u'-    assert(0 && "Windows not supported on MBlaze");')]
===========================================
Class:  class MBlazeELFObjectWriter : public MCELFObjectTargetWriter {   class MBlazeELFObjectWriter : public MCELFObjectTargetWriter 
Class:class MBlazeMCCodeEmitter : public MCCodeEmitter { class MBlazeMCCodeEmitter : public MCCodeEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 2, u'-    assert(Op.isExpr() && "unknown pcrel immediate operand");'), (47, 2, u'-  assert((Modifier == 0 || Modifier[0] == 0) && "No modifiers supported");'), (54, 2, u'-    assert(Op.isExpr() && "unknown operand kind in printOperand");'), (79, 2, u'-    assert(Disp.isImm() && "Expected immediate in displacement field");')]
===========================================
Class:  class MSP430AsmPrinter : public AsmPrinter {   class MSP430AsmPrinter : public AsmPrinter 
Class:  class MSP430DAGToDAGISel : public SelectionDAGISel {   class MSP430DAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(404, 2, u'-    assert(Node->getValueType(0) == MVT::i16);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(316, 2, u'-  assert(!isVarArg && "Varargs not supported yet");'), (342, 2, u'-          ArgValue = DAG.getNode(ISD::AssertSext, dl, RegVT, ArgValue,'), (345, 2, u'-          ArgValue = DAG.getNode(ISD::AssertZext, dl, RegVT, ArgValue,'), (355, 2, u'-      assert(VA.isMemLoc());'), (412, 2, u'-    assert(VA.isRegLoc() && "Can only return in registers!");'), (488, 2, u'-      assert(VA.isMemLoc());'), (663, 2, u'-  assert(!LHS.getValueType().isFloatingPoint() && "We don\'t handle FP yet");'), (865, 2, u'-  assert(VT == MVT::i16 && "Only support i16 for now!");'), (1134, 2, u'-  assert((Opc == MSP430::Select16 || Opc == MSP430::Select8) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(128, 2, u'-  assert(Cond.size() == 1 && "Invalid Xbranch condition!");'), (224, 2, u'-    assert(I->getOpcode() == MSP430::JCC && "Invalid conditional branch");'), (240, 2, u'-    assert(Cond.size() == 1);'), (241, 2, u'-    assert(TBB);'), (265, 2, u'-  assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (266, 2, u'-  assert((Cond.size() == 1 || Cond.size() == 0) &&'), (271, 2, u'-    assert(!FBB && "Unconditional branch with multiple successors!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(127, 2, u'-        assert(Old->getOpcode() == TII.getCallFrameDestroyOpcode());'), (166, 2, u'-  assert(SPAdj == 0 && "Unexpected");'), (176, 2, u'-    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (231, 2, u'-    assert(FrameIdx == MF.getFrameInfo()->getObjectIndexBegin() &&')]
===========================================
Class:class MSP430PassConfig : public TargetPassConfig { class MSP430PassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-  assert(!Str.empty() && "Cannot create an empty MCSymbol");'), (110, 2, u'-  assert(!Name.empty() && "getNameWithPrefix requires non-empty name");'), (152, 2, u'-  assert(Name.find_first_of("\\n\\"") != StringRef::npos);')]
===========================================
Class:class MipsAsmParser : public MCTargetAsmParser { class MipsAsmParser : public MCTargetAsmParser 
Class:  class MipsDisassembler : public MCDisassembler { class MipsDisassembler : public MCDisassembler 
Class:   class Mips64Disassembler : public MCDisassembler { class Mips64Disassembler : public MCDisassembler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 2, u'-    assert(SRE && CE && "Binary expression must be sym+const.");'), (86, 2, u'-    assert(false && "Unexpected MCExpr type.");'), (141, 2, u'-  assert(Op.isExpr() && "unknown operand kind in printOperand");')]
===========================================
Class:class MipsAsmBackend : public MCAsmBackend { class MipsAsmBackend : public MCAsmBackend 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(165, 2, u'-    assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&'), (188, 2, u'-    assert(0 && "RelaxInstruction() unimplemented");')]
===========================================
Class:  class MipsELFObjectWriter : public MCELFObjectTargetWriter {   class MipsELFObjectWriter : public MCELFObjectTargetWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(79, 2, u'-  assert(Target.getSymA() && "SymA cannot be 0.");'), (236, 2, u'-  assert(Relocs.size() == RelocLs.size());')]
===========================================
Class:class MipsMCCodeEmitter : public MCCodeEmitter { class MipsMCCodeEmitter : public MCCodeEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(112, 2, u'-    assert(S->size() <= 7);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 2, u'-    assert(MO.isImm() && "CPRESTORE\'s operand must be an immediate.");'), (404, 2, u'-  assert(MO.isReg() && "unexpected inline asm memory operand");'), (544, 2, u'-  assert(MI->getNumOperands() == 4 && "Invalid no. of machine operands!");'), (545, 2, u'-  assert(MI->getOperand(0).isReg() && MI->getOperand(1).isImm() &&')]
===========================================
Class:class MipsCodeEmitter : public MachineFunctionPass { class MipsCodeEmitter : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(196, 2, u'-  assert(MI.getOperand(OpNo).isReg());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(191, 2, u'-  assert((!candidate->isCall() && !candidate->isReturn()) &&')]
===========================================
Class:class MipsDAGToDAGISel : public SelectionDAGISel { class MipsDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(180, 2, u'-      assert(Subtarget.isABI_O32());'), (264, 2, u'-      assert(TLI.allowsUnalignedMemoryAccesses(VT) &&'), (390, 2, u'-    assert(((Opc == ISD::ADDC || Opc == ISD::ADDE) ||'), (558, 2, u'-  assert(ConstraintCode == \'m\' && "unexpected asm memory constraint");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 2, u'-  assert(Offset > 0);'), (146, 2, u'-  assert(isInt<32>(Offset) && (Offset >= 0) &&'), (216, 2, u'-  assert(MI->getNumOperands() == 3);'), (217, 2, u'-  assert(MI->getOperand(0).isReg());'), (218, 2, u'-  assert(MI->getOperand(1).isReg());'), (281, 2, u'-    assert (Base.getReg() != Target.getReg());'), (328, 2, u'-  assert(MO.isReg());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(66, 2, u'-  assert(Subtarget.isABI_N64());'), (80, 2, u'-  assert(Subtarget.isABI_N64());'), (163, 2, u'-    assert(i < MI.getNumOperands() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-  assert(((!hasMips64() && (isABI_O32() || isABI_EABI())) ||')]
===========================================
Class:class MipsPassConfig : public TargetPassConfig { class MipsPassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(187, 2, u'-    assert(Op.isExpr() && "unknown operand kind in printOperand");'), (211, 2, u'-  assert (Op.isImm() && "Rounding modes must be immediate values");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 2, u'-  assert(SyntaxVariant == 0 && "We only have one syntax variant");')]
===========================================
Class:  class PTXFPRoundingModePass : public MachineFunctionPass {   class PTXFPRoundingModePass : public MachineFunctionPass 
Class:class PTXDAGToDAGISel : public SelectionDAGISel { class PTXDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 2, u'-  assert(Node->getNumOperands() >= 3);'), (98, 2, u'-  assert(Target.getOpcode()  == ISD::BasicBlock);'), (99, 2, u'-  assert(Pred.getValueType() == MVT::i1);'), (114, 2, u'-  assert(VT.isSimple() && "READ_PARAM only implemented for MVT types");'), (129, 2, u'-    assert(Type == MVT::f64 && "Unexpected type!");'), (152, 2, u'-  assert(VT.isSimple() && "WRITE_PARAM only implemented for MVT types");'), (203, 2, u'-  assert(Addr.getValueType().isSimple() && "Type must be simple");'), (297, 2, u'-    assert(Addr.getValueType().isSimple() && "Type must be simple");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(155, 2, u'-  assert(Op.getValueType() == MVT::i1 && "SetCC type must be 1-bit integer");'), (191, 2, u'-  assert(PtrVT.isSimple() && "Pointer must be to primitive type.");'), (238, 2, u'-      assert((!MFI->isKernel() || Ins[i].VT != MVT::i1) &&'), (303, 2, u'-      assert(Outs.size() == 0 && "Kernel must return void.");'), (306, 2, u'-      assert(Outs.size() <= 1 && "Can at most return one value.");'), (318, 2, u'-    assert(Outs.size() < 2 && "Device functions can return at most one value");'), (398, 2, u'-  assert(getTargetMachine().getSubtarget<PTXSubtarget>().callsAreHandled() &&'), (408, 2, u'-  assert((isPrintf || function->getCallingConv() == CallingConv::PTX_Device) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 2, u'-      assert(MI.getNumOperands() >= 2 &&'), (278, 2, u'-  assert(TBB && "TBB is NULL");'), (357, 2, u'-  assert(target.isMBB() && "FIXME: detect branch target operand");')]
===========================================
Class:class PTXMCAsmStreamer : public MCStreamer { class PTXMCAsmStreamer : public MCStreamer 
Class:  class PTXMFInfoExtract : public MachineFunctionPass {   class PTXMFInfoExtract : public MachineFunctionPass 
Class:  class PTXRegAlloc : public MachineFunctionPass {   class PTXRegAlloc : public MachineFunctionPass 
Class:class PTXPassConfig : public TargetPassConfig { class PTXPassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(89, 2, u'-  assert(Modifier && "Must specify \'cc\' or \'reg\' as predicate op modifier!");'), (105, 2, u'-  assert(StringRef(Modifier) == "reg" &&'), (122, 2, u'-  assert(Value <= 31 && "Invalid u5imm argument!");'), (129, 2, u'-  assert(Value <= 63 && "Invalid u6imm argument!");'), (259, 2, u'-  assert(Op.isExpr() && "unknown operand kind in printOperand");')]
===========================================
Class:class PPCMachObjectWriter : public MCMachObjectTargetWriter { class PPCMachObjectWriter : public MCMachObjectTargetWriter 
Class: class PPCAsmBackend : public MCAsmBackend { class PPCAsmBackend : public MCAsmBackend 
Class:  class DarwinPPCAsmBackend : public PPCAsmBackend {   class DarwinPPCAsmBackend : public PPCAsmBackend 
Class:   class ELFPPCAsmBackend : public PPCAsmBackend {   class ELFPPCAsmBackend : public PPCAsmBackend 
Class:  class PPCELFObjectWriter : public MCELFObjectTargetWriter {   class PPCELFObjectWriter : public MCELFObjectTargetWriter 
Class:class PPCMCCodeEmitter : public MCCodeEmitter { class PPCMCCodeEmitter : public MCCodeEmitter 
Class:  class PPCAsmPrinter : public AsmPrinter {   class PPCAsmPrinter : public AsmPrinter 
Class:      class PPCLinuxAsmPrinter : public PPCAsmPrinter {   class PPCLinuxAsmPrinter : public PPCAsmPrinter 
Class:         class PPCDarwinAsmPrinter : public PPCAsmPrinter {   class PPCDarwinAsmPrinter : public PPCAsmPrinter 
Class:  class PPCCodeEmitter : public MachineFunctionPass {   class PPCCodeEmitter : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 2, u'-  assert((MF.getTarget().getRelocationModel() != Reloc::Default ||'), (129, 2, u'-      assert(TM.getRelocationModel() == Reloc::PIC_);'), (141, 2, u'-  assert((MI.getOpcode() == PPC::MTCRF || MI.getOpcode() == PPC::MTCRF8 ||'), (156, 2, u'-    assert(MovePCtoLROffset && "MovePCtoLR not seen yet?");'), (175, 2, u'-  assert(MO.isJTI());'), (218, 2, u'-  assert(MI.getOperand(OpNo+1).isReg());'), (234, 2, u'-  assert(MI.getOperand(OpNo+1).isReg());'), (252, 2, u'-    assert((MI.getOpcode() != PPC::MTCRF && MI.getOpcode() != PPC::MTCRF8 &&'), (258, 2, u'-  assert(MO.isImm() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 2, u'-  assert(MBBI != Entry->end() && MBBI->getOpcode() == PPC::MTVRSAVE);'), (85, 2, u'-    assert(MBBI != Entry->begin() && "UPDATE_VRSAVE is first instr in block?");'), (87, 2, u'-    assert(MBBI->getOpcode() == PPC::MFVRSAVE && "VRSAVE instrs wandered?");'), (306, 2, u'-      assert(FPIndex && "No Frame Pointer Save Slot!");'), (357, 2, u'-      assert(isPowerOf2_32(MaxAlign) && isInt<16>(MaxAlign) &&'), (359, 2, u'-      assert(isInt<16>(NegFrameSize) && "Unhandled stack size and alignment!");'), (391, 2, u'-      assert(isPowerOf2_32(MaxAlign) && isInt<16>(MaxAlign) &&'), (393, 2, u'-      assert(isInt<16>(NegFrameSize) && "Unhandled stack size and alignment!");'), (508, 2, u'-  assert(MBBI != MBB.end() && "Returning block has no terminator");'), (515, 2, u'-  assert((RetOpcode == PPC::BLR ||'), (549, 2, u'-      assert(FPIndex && "No Frame Pointer Save Slot!");'), (566, 2, u'-    assert(StackAdjust.isImm() && "Expecting immediate value.");'), (570, 2, u'-    assert((Delta >= 0) && "Delta must be positive");'), (586, 2, u'-        assert(hasFP(MF) && "Expecting a valid the frame pointer.");'), (610, 2, u'-        assert(hasFP(MF) && "Expecting a valid the frame pointer.");'), (693, 2, u'-    assert(MBBI->getOperand(0).isReg() && "Expecting register operand.");'), (706, 2, u'-    assert(MBBI->getOperand(0).isReg() && "Expecting register operand.");'), (892, 2, u'-    assert(FI && "No Frame Pointer Save Slot!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(138, 2, u'-  assert(Stalls == 0 && "PPC hazards don\'t support scoreboard lookahead");'), (236, 2, u'-  assert(NumIssued < 5 && "Illegal dispatch group!");')]
===========================================
Class:  class PPCDAGToDAGISel : public SelectionDAGISel {   class PPCDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(537, 2, u'-    assert(LHS.getValueType() == MVT::f64 && "Unknown vt!");'), (716, 2, u'-    assert(OtherCondIdx == -1 && "Can\'t have split plus negation");'), (892, 2, u'-        assert((!isSExt || LoadedVT == MVT::i16) && "Invalid sext update load");'), (903, 2, u'-        assert(LD->getValueType(0) == MVT::i64 && "Unknown load result type!");'), (904, 2, u'-        assert((!isSExt || LoadedVT == MVT::i16) && "Invalid sext update load");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(577, 2, u'-  assert(N->getValueType(0) == MVT::v16i8 &&'), (579, 2, u'-  assert((UnitSize == 1 || UnitSize == 2 || UnitSize == 4) &&'), (615, 2, u'-  assert(N->getValueType(0) == MVT::v16i8 &&'), (651, 2, u'-  assert(N->getValueType(0) == MVT::v16i8 &&'), (697, 2, u'-  assert(isSplatShuffleMask(SVOp, EltSize));'), (716, 2, u'-    assert(Multiple > 1 && Multiple <= 4 && "How can this happen?");'), (780, 2, u'-    assert(CN->getValueType(0) == MVT::f32 && "Only one legal FP vector type!");'), (905, 2, u'-     assert(!cast<ConstantSDNode>(N.getOperand(1).getOperand(1))->getZExtValue()'), (908, 2, u'-      assert(Disp.getOpcode() == ISD::TargetGlobalAddress ||'), (1018, 2, u'-     assert(!cast<ConstantSDNode>(N.getOperand(1).getOperand(1))->getZExtValue()'), (1021, 2, u'-      assert(Disp.getOpcode() == ISD::TargetGlobalAddress ||'), (1311, 2, u'-  assert(!Subtarget.isPPC64() && "LowerVAARG is PPC32 only");'), (1747, 2, u'-      assert(VA.isMemLoc());'), (2087, 2, u'-            ArgVal = DAG.getNode(ISD::AssertSext, dl, MVT::i64, ArgVal,'), (2090, 2, u'-            ArgVal = DAG.getNode(ISD::AssertZext, dl, MVT::i64, ArgVal,'), (2753, 2, u'-    assert(VA.isRegLoc() && "Can only return in registers!");'), (2790, 2, u'-  assert(Mask && "Missing call preserved mask for calling convention");'), (2809, 2, u'-    assert(((Callee.getOpcode() == ISD::Register &&'), (2901, 2, u'-  assert((CallConv == CallingConv::C ||'), (3014, 2, u'-      assert((j < ByValArgLocs.size()) && "Index out of bounds!");'), (3016, 2, u'-      assert((VA.getValNo() == ByValVA.getValNo()) && "ValNo mismatch!");'), (3050, 2, u'-      assert(VA.isMemLoc());'), (3503, 2, u'-    assert(VA.isRegLoc() && "Can only return in registers!");'), (3695, 2, u'-  assert(Op.getOperand(0).getValueType().isFloatingPoint());'), (3745, 2, u'-  assert(Op.getOperand(0).getValueType() == MVT::i32 &&'), (3847, 2, u'-  assert(Op.getNumOperands() == 3 &&'), (3876, 2, u'-  assert(Op.getNumOperands() == 3 &&'), (3905, 2, u'-  assert(Op.getNumOperands() == 3 &&'), (3938, 2, u'-  assert(Val >= -16 && Val <= 15 && "vsplti is out of range!");'), (4006, 2, u'-  assert(BVN != 0 && "Expected a BuildVectorSDNode in LowerBUILD_VECTOR");'), (4187, 2, u'-    assert(LHSID == ((4*9+5)*9+6)*9+7 && "Illegal OP_COPY!");'), (4626, 2, u'-    assert(N->getValueType(0) == MVT::ppcf128);'), (4627, 2, u'-    assert(N->getOperand(0).getValueType() == MVT::ppcf128);'), (5419, 2, u'-        assert(UI != VCMPoNode->use_end() && "Didn\'t find user!");'), (5449, 2, u'-      assert(isDot && "Can\'t compare against a vector result!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 2, u'-    assert(TII && "No InstrInfo?");'), (146, 2, u'-    assert(MI->getDesc().getOperandConstraint(0, MCOI::TIED_TO) &&'), (300, 2, u'-  assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (301, 2, u'-  assert((Cond.size() == 2 || Cond.size() == 0) &&'), (667, 2, u'-  assert(Cond.size() == 2 && "Invalid PPC branch opcode!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(327, 2, u'-  assert((*StubCallAddr >> 26) == 19 && "Call in stub is not indirect!");'), (422, 2, u'-      assert(ResultPtr >= -(1 << 23) && ResultPtr < (1 << 23) &&'), (430, 2, u'-      assert(ResultPtr >= -(1 << 13) && ResultPtr < (1 << 13) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-    assert(MO.isSymbol() && "Isn\'t a symbol reference");'), (86, 2, u'-      assert(MO.isGlobal() && "Extern symbol not handled yet");'), (145, 2, u'-      assert(!MO.getSubReg() && "Subregs should be eliminated!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(243, 2, u'-  assert(RS && "Register scavenging must be on");'), (436, 2, u'-  assert(MI.definesRegister(DestReg) &&'), (462, 2, u'-  assert(SPAdj == 0 && "Unexpected");'), (479, 2, u'-    assert(FIOperandNo != MI.getNumOperands() &&'), (590, 2, u'-    assert(ImmToIdxMap.count(OpC) &&')]
===========================================
Class:class PPCPassConfig : public TargetPassConfig { class PPCPassConfig : public TargetPassConfig 
Class:  class SparcAsmPrinter : public AsmPrinter {   class SparcAsmPrinter : public AsmPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(147, 2, u'-    assert(TargetRegisterInfo::isPhysicalRegister(MO.getReg()) &&'), (149, 2, u'-    assert(MO.getReg() != SP::O7 &&'), (248, 2, u'-  assert(MI->getNumOperands() == 4 && "Invalid number of operands!");'), (249, 2, u'-  assert(MI->getOperand(0).isReg() && MI->getOperand(1).isImm() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 2, u'-  assert(MBBI->getOpcode() == SP::RETL &&')]
===========================================
Class:class SparcDAGToDAGISel : public SelectionDAGISel { class SparcDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 2, u'-  assert(SPAdj == 0 && "Unexpected");'), (82, 2, u'-    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");')]
===========================================
Class:class SparcPassConfig : public TargetPassConfig { class SparcPassConfig : public TargetPassConfig 
Class:class StructLayoutMap { class StructLayoutMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 2, u'-    assert(NumElts != 0 && "Can\'t have an empty CDS");'), (119, 2, u'-  assert(!GV->isDeclaration() && !GV->hasAvailableExternallyLinkage() &&'), (178, 2, u'-            assert(ITy->getBitWidth() == 32 && "Unknown width");'), (263, 2, u'-  assert(!Kind.isThreadLocal() && "Doesn\'t support TLS");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 2, u'-  assert(isPhysicalRegister(reg) && "reg must be a physical register");'), (66, 2, u'-  assert(BestRC && "Couldn\'t find the register class");')]
===========================================
Class:class X86AsmLexer : public MCTargetAsmLexer { class X86AsmLexer : public MCTargetAsmLexer 
Class:class X86AsmParser : public MCTargetAsmParser { class X86AsmParser : public MCTargetAsmParser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(196, 2, u'-    assert(Kind == Token && "Invalid access!");'), (200, 2, u'-    assert(Kind == Token && "Invalid access!");'), (206, 2, u'-    assert(Kind == Register && "Invalid access!");'), (211, 2, u'-    assert(Kind == Immediate && "Invalid access!");'), (216, 2, u'-    assert(Kind == Memory && "Invalid access!");'), (220, 2, u'-    assert(Kind == Memory && "Invalid access!");'), (224, 2, u'-    assert(Kind == Memory && "Invalid access!");'), (228, 2, u'-    assert(Kind == Memory && "Invalid access!");'), (232, 2, u'-    assert(Kind == Memory && "Invalid access!");'), (350, 2, u'-    assert(N == 1 && "Invalid number of operands!");'), (355, 2, u'-    assert(N == 1 && "Invalid number of operands!");'), (382, 2, u'-    assert((N == 5) && "Invalid number of operands!");'), (391, 2, u'-    assert((N == 1) && "Invalid number of operands!");'), (439, 2, u'-    assert((SegReg || BaseReg || IndexReg) && "Invalid memory operand!");'), (442, 2, u'-    assert(((Scale == 1 || Scale == 2 || Scale == 4 || Scale == 8)) &&'), (482, 2, u'-    assert(TokPercent.is(AsmToken::Percent) && "Invalid token kind!");'), (701, 2, u'-    assert (Tok.getString() == "PTR" && "Unexpected token!");'), (1001, 2, u'-        assert(PatchedName.endswith("pd") && "Unexpected mnemonic!");'), (1479, 2, u'-  assert(!Operands.empty() && "Unexpect empty operand list!");'), (1481, 2, u'-  assert(Op->isToken() && "Leading operand should always be a mnemonic!");'), (1507, 2, u'-    assert(Repl && "Unknown wait-prefixed instruction");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 2, u'-    assert(Op.isExpr() && "unknown pcrel immediate operand");'), (131, 2, u'-    assert(Op.isExpr() && "unknown operand kind in printOperand");'), (154, 2, u'-    assert(DispSpec.isExpr() && "non-immediate displacement for LEA?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(93, 2, u'-    assert(Op.isExpr() && "unknown pcrel immediate operand");'), (122, 2, u'-    assert(Op.isExpr() && "unknown operand kind in printOperand");'), (160, 2, u'-    assert(DispSpec.isExpr() && "non-immediate displacement for LEA?");')]
===========================================
Class:class X86ELFObjectWriter : public MCELFObjectTargetWriter { class X86ELFObjectWriter : public MCELFObjectTargetWriter 
Class: class X86AsmBackend : public MCAsmBackend { class X86AsmBackend : public MCAsmBackend 
Class:class ELFX86AsmBackend : public X86AsmBackend { class ELFX86AsmBackend : public X86AsmBackend 
Class: class ELFX86_32AsmBackend : public ELFX86AsmBackend { class ELFX86_32AsmBackend : public ELFX86AsmBackend 
Class: class ELFX86_64AsmBackend : public ELFX86AsmBackend { class ELFX86_64AsmBackend : public ELFX86AsmBackend 
Class: class WindowsX86AsmBackend : public X86AsmBackend { class WindowsX86AsmBackend : public X86AsmBackend 
Class: class DarwinX86AsmBackend : public X86AsmBackend { class DarwinX86AsmBackend : public X86AsmBackend 
Class: class DarwinX86_32AsmBackend : public DarwinX86AsmBackend { class DarwinX86_32AsmBackend : public DarwinX86AsmBackend 
Class: class DarwinX86_64AsmBackend : public DarwinX86AsmBackend { class DarwinX86_64AsmBackend : public DarwinX86AsmBackend 
Class:  class X86ELFObjectWriter : public MCELFObjectTargetWriter {   class X86ELFObjectWriter : public MCELFObjectTargetWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 2, u'-        assert(Modifier == MCSymbolRefExpr::VK_None);'), (92, 2, u'-        assert(Modifier == MCSymbolRefExpr::VK_None);'), (96, 2, u'-        assert(Modifier == MCSymbolRefExpr::VK_None);')]
===========================================
Class:class X86MCCodeEmitter : public MCCodeEmitter { class X86MCCodeEmitter : public MCCodeEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(298, 2, u'-    assert((int(RegNo) > 0) && "Unknown physical register!");')]
===========================================
Class:class X86MachObjectWriter : public MCMachObjectTargetWriter { class X86MachObjectWriter : public MCMachObjectTargetWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(411, 2, u'-  assert(Target.getSymA()->getKind() == MCSymbolRefExpr::VK_TLVP &&')]
===========================================
Class:  class MCObjectWriter;
Class:  class X86WinCOFFObjectWriter : public MCWinCOFFObjectTargetWriter {   class X86WinCOFFObjectWriter : public MCWinCOFFObjectTargetWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(324, 2, u'-    assert(DispSpec.isGlobal() || DispSpec.isCPI() ||'), (333, 2, u'-    assert(IndexReg.getReg() != X86::ESP &&'), (353, 2, u'-  assert(isMem(MI, Op) && "Invalid memory reference!");'), (692, 2, u'-  assert (MI->getNumOperands() == 7 && "Invalid no. of machine operands!");'), (709, 2, u'-  assert(NOps==7);')]
===========================================
Class:  class Emitter : public MachineFunctionPass {   class Emitter : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(349, 2, u'-  assert(Mod < 4 && RegOpcode < 8 && RM < 8 && "ModRM Fields out of range!");'), (432, 2, u'-    assert(RelocOp->isJTI() && "Unexpected machine operand!");'), (476, 2, u'-    assert(IndexReg.getReg() == 0 && Is64BitMode &&'), (535, 2, u'-  assert(IndexReg.getReg() != X86::ESP &&'), (808, 2, u'-    assert(MO.isImm() && "Unknown RawFrm operand!");')]
===========================================
Class:class X86FastISel : public FastISel { class X86FastISel : public FastISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(178, 2, u'-        assert(RegMap[Stack[i]] == i && "Stack[] doesn\'t match RegMap[]!");'), (188, 2, u'-      assert(RegNo < NumFPRegs && "Regno out of range!");'), (226, 2, u'-      assert(Reg < NumFPRegs && "Register number out of range!");'), (328, 2, u'-  assert(MO.isReg() && "Expected an FP register!");'), (330, 2, u'-  assert(Reg >= X86::FP0 && Reg <= X86::FP6 && "Expected FP register!");'), (342, 2, u'-  assert(X86::FP6 == X86::FP0+6 && "Register enums aren\'t sorted right!");'), (388, 2, u'-  assert(LiveBundles.empty() && "Stale data in LiveBundles");'), (508, 2, u'-  assert(Bundle.isFixed() && "Reached block before any predecessors");'), (601, 2, u'-#define ASSERT_SORTED(TABLE)'), (603, 2, u'-#define ASSERT_SORTED(TABLE)                                              \\'), (606, 2, u'-       assert(TableIsSorted(TABLE, array_lengthof(TABLE)) &&              \\'), (784, 2, u'-  ASSERT_SORTED(OpcodeTable);'), (786, 2, u'-  assert(Opc != -1 && "FP Stack instruction not in OpcodeTable!");'), (830, 2, u'-  ASSERT_SORTED(PopTable);'), (890, 2, u'-  assert((Kills & Defs) == 0 && "Register needs killing and def\'ing?");'), (935, 2, u'-  assert(StackTop == CountPopulation_32(Mask) && "Live count mismatch");'), (984, 2, u'-  assert((NumOps == X86::AddrNumOperands + 1 || NumOps == 1) &&'), (1049, 2, u'-  assert(NumOps >= 2 && "FPRW instructions must have 2 ops!!");'), (1156, 2, u'-  ASSERT_SORTED(ForwardST0Table); ASSERT_SORTED(ReverseST0Table);'), (1157, 2, u'-  ASSERT_SORTED(ForwardSTiTable); ASSERT_SORTED(ReverseSTiTable);'), (1161, 2, u'-  assert(NumOperands == 3 && "Illegal TwoArgFP instruction!");'), (1204, 2, u'-  assert((TOS == Op0 || TOS == Op1) && (KillsOp0 || KillsOp1) &&'), (1226, 2, u'-  assert(Opcode != -1 && "Unknown TwoArgFP pseudo instruction!");'), (1238, 2, u'-    assert(!updateST0 && "Should have updated other operand!");'), (1245, 2, u'-  assert(UpdatedSlot < StackTop && Dest < 7);'), (1255, 2, u'-  ASSERT_SORTED(ForwardST0Table); ASSERT_SORTED(ReverseST0Table);'), (1256, 2, u'-  ASSERT_SORTED(ForwardSTiTable); ASSERT_SORTED(ReverseSTiTable);'), (1260, 2, u'-  assert(NumOperands == 2 && "Illegal FUCOM* instruction!");'), (1328, 2, u'-      assert(isLive(SrcFP) && "Cannot copy dead register");'), (1329, 2, u'-      assert(!MO0.isDead() && "Cannot copy to dead ST register");'), (1360, 2, u'-      assert(!isLive(DstFP) && "Cannot copy ST to live FP register");'), (1361, 2, u'-      assert(NumPendingSTs > SrcST && "Cannot copy from dead ST register");'), (1363, 2, u'-      assert(isScratchReg(SrcFP) && "Expected ST in a scratch register");'), (1364, 2, u'-      assert(isLive(SrcFP) && "Scratch holding ST is dead");'), (1381, 2, u'-    assert(isLive(SrcFP) && "Cannot copy dead register");'), (1419, 2, u'-    assert(StackTop < 8 && "Stack overflowed before FpPOP_RETVAL");'), (1587, 2, u'-    assert(NumPendingSTs >= NumSTUses && "Fixed registers should be assigned");'), (1650, 2, u'-    assert(Op.isUse() && Op.isReg() &&'), (1685, 2, u'-      assert(Op.isUse() &&'), (1694, 2, u'-        assert(SecondFPRegOp == ~0U && "More than two fp operands!");'), (1715, 2, u'-      assert(StackTop == 1 && FirstFPRegOp == getStackEntry(0) &&'), (1729, 2, u'-      assert(FirstFPRegOp == SecondFPRegOp && FirstFPRegOp == getStackEntry(0)&&'), (1740, 2, u'-    assert(StackTop == 2 && "Must have two values live!");'), (1745, 2, u'-      assert(getStackEntry(1) == FirstFPRegOp && "Unknown regs live");'), (1751, 2, u'-    assert(getStackEntry(0) == FirstFPRegOp && "Unknown regs live");'), (1752, 2, u'-    assert(getStackEntry(1) == SecondFPRegOp && "Unknown regs live");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(459, 2, u'-  assert((permutationEncoding & 0x3FF) == permutationEncoding &&'), (492, 2, u'-  assert((RegEnc & 0x3FFFF) == RegEnc && "Invalid compact register encoding!");'), (869, 2, u'-      assert(!Is64Bit && "EAX is livein in x64 case!");'), (954, 2, u'-  assert(MBBI != MBB.end() && "Returning block has no instructions");'), (1068, 2, u'-    assert(DestAddr.isReg() && "Offset should be in register!");'), (1081, 2, u'-    assert(StackAdjust.isImm() && "Expecting immediate value.");'), (1087, 2, u'-    assert(MaxTCDelta <= 0 && "MaxTCDelta should never be positive");'), (1091, 2, u'-    assert(Offset >= 0 && "Offset should never be negative");'), (1108, 2, u'-        assert(JumpTarget.isSymbol());'), (1156, 2, u'-      assert((-(Offset + StackSize)) % MFI->getObjectAlignment(FI) == 0);'), (1296, 2, u'-    assert((TailCallReturnAddrDelta <= 0) &&'), (1306, 2, u'-    assert(FrameIdx == MFI->getObjectIndexBegin() &&'), (1364, 2, u'-  assert(!MF.getRegInfo().isLiveIn(ScratchReg) &&'), (1472, 2, u'-      assert((!MF.getRegInfo().isLiveIn(ScratchReg2) || SaveScratch2) &&')]
===========================================
Class:  class X86DAGToDAGISel : public SelectionDAGISel {   class X86DAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(367, 2, u'-    assert(Chain.getOpcode() == ISD::TokenFactor &&'), (669, 2, u'-    assert(N.getOpcode() != X86ISD::WrapperRIP &&'), (907, 2, u'-    assert(X.getValueType() != VT);'), (1370, 2, u'-  assert (T == AM.Segment);'), (1422, 2, u'-  assert(N.getOpcode() == ISD::TargetGlobalTLSAddress);'), (1775, 2, u'-  assert(Opc != 0 && "Invalid arith lock transform!");'), (1932, 2, u'-    assert(Opc == X86ISD::INC && "unrecognized opcode");'), (2035, 2, u'-      assert(CstVT == MVT::i8);'), (2045, 2, u'-      assert(CstVT == MVT::i8 || CstVT == MVT::i32);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(70, 2, u'-  assert(VT.getSizeInBits() == 256 && "Unexpected vector size!");'), (114, 2, u'-    assert(VT.getSizeInBits() == 128 && "Unexpected vector size!");'), (1372, 2, u'-  assert(getTargetMachine().getRelocationModel() == Reloc::PIC_ &&'), (1500, 2, u'-    assert(VA.isRegLoc() && "Can only return in registers!");'), (1560, 2, u'-    assert(Reg &&'), (1823, 2, u'-  assert(!(isVarArg && IsTailCallConvention(CallConv)) &&'), (1844, 2, u'-    assert(VA.getValNo() != LastVal &&'), (1876, 2, u'-        ArgValue = DAG.getNode(ISD::AssertSext, dl, RegVT, ArgValue,'), (1879, 2, u'-        ArgValue = DAG.getNode(ISD::AssertZext, dl, RegVT, ArgValue,'), (1893, 2, u'-      assert(VA.isMemLoc());'), (1966, 2, u'-      assert(!(NumXMMRegs && !Subtarget->hasSSE1()) &&'), (1968, 2, u'-      assert(!(NumXMMRegs && MF.getTarget().Options.UseSoftFloat &&'), (2163, 2, u'-  assert(!(isVarArg && IsTailCallConvention(CallConv)) &&'), (2273, 2, u'-      assert(VA.isMemLoc());'), (2340, 2, u'-    assert((Subtarget->hasSSE1() || !NumXMMRegs)'), (2369, 2, u'-        assert(VA.isMemLoc());'), (2417, 2, u'-    assert(Is64Bit && "Large code model is only legal in 64-bit mode.");'), (2528, 2, u'-  assert(Mask && "Missing call preserved mask for calling convention");'), (2682, 2, u'-  assert(FI != INT_MAX);'), (3458, 2, u'-  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (3497, 2, u'-  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (3535, 2, u'-  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (3577, 2, u'-  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (3866, 2, u'-  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (3875, 2, u'-  assert((NumLaneElts == 2 || NumLaneElts == 4) &&'), (3942, 2, u'-  assert(Val - i > 0 && "PALIGNR imm should be positive");'), (3988, 2, u'-  assert((VT.is256BitVector() && NumElts == 4) &&'), (4161, 2, u'-  assert(VT.isVector() && "Expected a vector type");'), (4196, 2, u'-  assert(VT.isVector() && "Expected a vector type");'), (4197, 2, u'-  assert((VT.is128BitVector() || VT.is256BitVector())'), (4292, 2, u'-  assert((VT.getSizeInBits() == 128 || VT.getSizeInBits() == 256)'), (4325, 2, u'-  assert(((Size == 128 && NumElems > 4) || Size == 256) &&'), (4729, 2, u'-  assert(VT.getSizeInBits() == 128 && "Unknown type for VShift");'), (4957, 2, u'-    assert(!CVT.isVector() && "Must not broadcast a vector type");'), (4969, 2, u'-      assert(C && "Invalid constant type");'), (5088, 2, u'-        assert(VT == MVT::v2i64 && "Expected an SSE value type!");'), (5128, 2, u'-        assert(VT.getSizeInBits() == 128 && "Expected an SSE value type!");'), (5142, 2, u'-          assert(VT.getSizeInBits() == 128 && "Expected an SSE value type!");'), (5353, 2, u'-  assert(ResVT == MVT::v2i64 || ResVT == MVT::v4i32 ||'), (5379, 2, u'-  assert(ResVT.getSizeInBits() == 256 && "Value type must be 256-bit wide");'), (5395, 2, u'-  assert(Op.getNumOperands() == 2);'), (5396, 2, u'-  assert((ResVT.getSizeInBits() == 128 || ResVT.getSizeInBits() == 256) &&'), (5468, 2, u'-  assert(ISDNo && "Invalid Op Number");'), (6066, 2, u'-  assert(VT.getSizeInBits() == 128 && "Unsupported vector size");'), (6079, 2, u'-      assert(Idx < 8 && "Invalid VECTOR_SHUFFLE index!");'), (6246, 2, u'-  assert(VT != MVT::v2i64 && "unsupported shuffle type");'), (6264, 2, u'-  assert((VT == MVT::v4i32 || VT == MVT::v4f32) &&'), (6324, 2, u'-  assert(VT != MVT::v4i32 && "unsupported shuffle type");'), (6411, 2, u'-  assert(VT.getSizeInBits() != 64 && "Can\'t lower MMX shuffles");'), (6416, 2, u'-  assert(!V1IsUndef && "Op 1 of shuffle should not be undef");'), (6714, 2, u'-    SDValue Assert  = DAG.getNode(ISD::AssertZext, dl, MVT::i32, Extract,'), (6716, 2, u'-    return DAG.getNode(ISD::TRUNCATE, dl, VT, Assert);'), (6729, 2, u'-    SDValue Assert  = DAG.getNode(ISD::AssertZext, dl, MVT::i32, Extract,'), (6731, 2, u'-    return DAG.getNode(ISD::TRUNCATE, dl, VT, Assert);'), (6787, 2, u'-  assert(Vec.getValueSizeInBits() <= 128 && "Unexpected vector length");'), (6811, 2, u'-    SDValue Assert  = DAG.getNode(ISD::AssertZext, dl, EltVT, Extract,'), (6813, 2, u'-    return DAG.getNode(ISD::TRUNCATE, dl, VT, Assert);'), (6976, 2, u'-  assert(Op.getValueType().getSimpleVT().getSizeInBits() == 128 &&'), (7290, 2, u'-    assert(model == TLSModel::InitialExec);'), (7294, 2, u'-    assert(model == TLSModel::InitialExec);'), (7457, 2, u'-  assert(Op.getNumOperands() == 3 && "Not a double-shift!");'), (7507, 2, u'-  assert(SrcVT.getSimpleVT() <= MVT::i64 && SrcVT.getSimpleVT() >= MVT::i16 &&'), (7744, 2, u'-  assert(SrcVT == MVT::i64 && "Unexpected type in UINT_TO_FP");'), (7800, 2, u'-    assert(DstTy == MVT::i32 && "Unexpected FP_TO_UINT");'), (7804, 2, u'-  assert(DstTy.getSimpleVT() <= MVT::i64 &&'), (7841, 2, u'-    assert(DstTy == MVT::i64 && "Invalid FP_TO_SINT to lower!");'), (7912, 2, u'-  assert(FIST.getNode() && "Unexpected failure");'), (8298, 2, u'-  assert(Op.getValueType() == MVT::i8 && "SetCC type must be 8-bit integer");'), (8353, 2, u'-  assert(VT.getSizeInBits() == 256 && Op.getOpcode() == ISD::SETCC &&'), (8394, 2, u'-    assert(EltVT == MVT::f32 || EltVT == MVT::f64); (void)EltVT;'), (8874, 2, u'-            assert(NewBR == User);'), (8915, 2, u'-          assert(NewBR == User);'), (8945, 2, u'-          assert(NewBR == User);'), (8996, 2, u'-  assert((Subtarget->isTargetCygMing() || Subtarget->isTargetWindows() ||'), (9000, 2, u'-  assert(!Subtarget->isTargetEnvMacho() && "Not implemented");'), (9115, 2, u'-  assert(Subtarget->is64Bit() &&'), (9117, 2, u'-  assert((Subtarget->isTargetLinux() ||'), (9120, 2, u'-  assert(Op.getNode()->getNumOperands() == 4);'), (9147, 2, u'-    assert(!getTargetMachine().Options.UseSoftFloat &&'), (9182, 2, u'-  assert(Subtarget->is64Bit() && "This code only handles 64-bit va_copy!");'), (9201, 2, u'-  assert(ShAmt.getValueType() == MVT::i32 && "ShAmt is not i32");'), (9333, 2, u'-    assert(X86CC != X86::COND_INVALID && "Unexpected illegal condition!");'), (10152, 2, u'-  assert(VT.getSizeInBits() == 256 && VT.isInteger() &&'), (10179, 2, u'-  assert(Op.getValueType().getSizeInBits() == 256 &&'), (10186, 2, u'-  assert(Op.getValueType().getSizeInBits() == 256 &&'), (10199, 2, u'-  assert((VT == MVT::v2i64 || VT == MVT::v4i64) &&'), (10378, 2, u'-    assert(Subtarget->hasSSE2() && "Need SSE2 for pslli/pcmpeq.");'), (10692, 2, u'-    assert(Subtarget->is64Bit() && "Node not type legal!");'), (10714, 2, u'-  assert(Subtarget->is64Bit() && "Result not type legalized?");'), (10735, 2, u'-  assert(Subtarget->is64Bit() && !Subtarget->hasSSE2() &&'), (10737, 2, u'-  assert((DstVT == MVT::i64 ||'), (10920, 2, u'-  assert (Node->getValueType(0) == MVT::i64 &&'), (10993, 2, u'-    assert((T == MVT::i64 || T == MVT::i128) && "can only expand cmpxchg pair");'), (11381, 2, u'-  assert(bInstr->getNumOperands() < X86::AddrNumOperands + 4 &&'), (11400, 2, u'-  assert((argOpers[valArgIndx]->isReg() ||'), (11424, 2, u'-  assert(bInstr->hasOneMemOperand() && "Unexpected number of memoperand");'), (11495, 2, u'-  assert(bInstr->getNumOperands() < X86::AddrNumOperands + 14 &&'), (11543, 2, u'-  assert((argOpers[valArgIndx]->isReg() ||'), (11555, 2, u'-  assert(argOpers[valArgIndx + 1]->isReg() =='), (11557, 2, u'-  assert(argOpers[valArgIndx + 1]->isImm() =='), (11592, 2, u'-  assert(bInstr->hasOneMemOperand() && "Unexpected number of memoperand");'), (11653, 2, u'-  assert(mInstr->getNumOperands() < X86::AddrNumOperands + 4 &&'), (11671, 2, u'-  assert((argOpers[valArgIndx]->isReg() ||'), (11700, 2, u'-  assert(mInstr->hasOneMemOperand() && "Unexpected number of memoperand");'), (11720, 2, u'-  assert(Subtarget->hasSSE42() &&'), (11810, 2, u'-  assert(MI->getNumOperands() == 10 && "VAARG_64 should have 10 operands!");'), (11811, 2, u'-  assert(X86::AddrNumOperands == 5 && "VAARG_64 assumes 5 address operands");'), (11824, 2, u'-  assert(MI->hasOneMemOperand() && "Expected VAARG_64 to have one memoperand");'), (11941, 2, u'-    assert(OffsetReg != 0);'), (12004, 2, u'-    assert((Align & (Align-1)) == 0 && "Alignment must be a power of 2");'), (12237, 2, u'-  assert(getTargetMachine().Options.EnableSegmentedStacks);'), (12355, 2, u'-  assert(!Subtarget->isTargetEnvMacho());'), (12414, 2, u'-  assert(Subtarget->isTargetDarwin() && "Darwin only instr emitted?");'), (12415, 2, u'-  assert(MI->getOperand(3).isGlobal() && "This should be a global");'), (12783, 2, u'-  assert((Opc >= ISD::BUILTIN_OP_END ||'), (13565, 2, u'-    assert(BitWidth >= 8 && BitWidth <= 64 && "Invalid mask size");'), (13793, 2, u'-    assert(N0.getValueType().isVector() && "Invalid vector shift type");'), (14186, 2, u'-        assert((EltBits == 8 || EltBits == 16 || EltBits == 32) &&'), (14275, 2, u'-  assert(Subtarget->hasBMI() && "Creating BLSMSK requires BMI instructions");'), (14310, 2, u'-    assert(MemVT != RegVT && "Cannot extend to the same type");'), (14311, 2, u'-    assert(MemVT.isVector() && "Must load a vector from memory");'), (14316, 2, u'-    assert(RegSz > MemSz && "Register size must be greater than the mem size");'), (14419, 2, u'-    assert(StVT != VT && "Cannot truncate to the same type");'), (14431, 2, u'-    assert(SizeRatio * NumElems * ToSz == VT.getSizeInBits());'), (14437, 2, u'-    assert(WideVecVT.getSizeInBits() == VT.getSizeInBits());'), (14464, 2, u'-    assert(StoreVecVT.getSizeInBits() == VT.getSizeInBits());'), (14632, 2, u'-  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (14640, 2, u'-  assert((NumLaneElts % 2 == 0) &&'), (14758, 2, u'-  assert(N->getOpcode() == X86ISD::FOR || N->getOpcode() == X86ISD::FXOR);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(1132, 2, u'-      assert(!R2MTable.count(RegOp) && "Duplicate entry!");'), (1136, 2, u'-      assert(!M2RTable.count(MemOp) &&'), (1321, 2, u'-    assert(!isPICBase && "More than one PIC base?");'), (1378, 2, u'-          assert(!isPICBase && "More than one PIC base?");'), (1685, 2, u'-    assert(MI->getNumOperands() == 4 && "Unknown shufps instruction!");'), (1699, 2, u'-    assert(MI->getNumOperands() == 4 && "Unknown shufpd instruction!");'), (1717, 2, u'-    assert(MI->getNumOperands() >= 3 && "Unknown shift instruction!");'), (1736, 2, u'-    assert(MI->getNumOperands() >= 3 && "Unknown shift instruction!");'), (1755, 2, u'-    assert(MI->getNumOperands() >= 3 && "Unknown shift instruction!");'), (1782, 2, u'-      assert(MI->getNumOperands() >= 2 && "Unknown inc instruction!");'), (1803, 2, u'-      assert(MI->getNumOperands() >= 2 && "Unknown inc instruction!");'), (1812, 2, u'-      assert(MI->getNumOperands() >= 2 && "Unknown dec instruction!");'), (1832, 2, u'-      assert(MI->getNumOperands() >= 2 && "Unknown dec instruction!");'), (1842, 2, u'-      assert(MI->getNumOperands() >= 3 && "Unknown add instruction!");'), (1874, 2, u'-      assert(MI->getNumOperands() >= 3 && "Unknown add instruction!");'), (1889, 2, u'-      assert(MI->getNumOperands() >= 3 && "Unknown add instruction!");'), (1899, 2, u'-      assert(MI->getNumOperands() >= 3 && "Unknown add instruction!");'), (1913, 2, u'-      assert(MI->getNumOperands() >= 3 && "Unknown add instruction!");'), (2269, 2, u'-    assert(Cond.size() == 1);'), (2270, 2, u'-    assert(TBB);'), (2331, 2, u'-  assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (2332, 2, u'-  assert((Cond.size() == 1 || Cond.size() == 0) &&'), (2337, 2, u'-    assert(!FBB && "Unconditional branch with multiple successors!");'), (2438, 2, u'-      assert(X86::GR8_NOREXRegClass.contains(SrcReg, DestReg) &&'), (2498, 2, u'-    assert(X86::GR8RegClass.hasSubClassEq(RC) && "Unknown 1-byte regclass");'), (2506, 2, u'-    assert(X86::GR16RegClass.hasSubClassEq(RC) && "Unknown 2-byte regclass");'), (2531, 2, u'-    assert(X86::RFP80RegClass.hasSubClassEq(RC) && "Unknown 10-byte regclass");'), (2534, 2, u'-    assert(X86::VR128RegClass.hasSubClassEq(RC) && "Unknown 16-byte regclass");'), (2546, 2, u'-    assert(X86::VR256RegClass.hasSubClassEq(RC) && "Unknown 32-byte regclass");'), (2576, 2, u'-  assert(MF.getFrameInfo()->getObjectSize(FrameIdx) >= RC->getSize() &&'), (2648, 2, u'-  assert(Desc.getNumOperands() == 3 && "Expected two-addr instruction.");'), (2657, 2, u'-  assert(MI->getOperand(1).getReg() == Reg &&'), (2727, 2, u'-      assert(MO.isReg() && "Expected to fold into reg operand!");'), (3546, 2, u'-  assert(Offset2 > Offset1);'), (3594, 2, u'-  assert(Cond.size() == 1 && "Invalid X86 branch condition!");'), (3617, 2, u'-  assert(!TM.getSubtarget<X86Subtarget>().is64Bit() &&'), (3724, 2, u'-  assert(Domain>0 && Domain<4 && "Invalid execution domain");'), (3726, 2, u'-  assert(dom && "Not an SSE instruction");'), (3729, 2, u'-    assert((TM.getSubtarget<X86Subtarget>().hasAVX2() || Domain < 3) &&'), (3733, 2, u'-  assert(table && "Cannot change domain");'), (3815, 2, u'-      assert(!TM->getSubtarget<X86Subtarget>().is64Bit() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(354, 2, u'-  assert(*RetAddrLoc == RetAddr &&'), (376, 2, u'-  assert(((unsigned char*)RetAddr)[-2] == 0x41 &&"Not a call instr!");'), (377, 2, u'-  assert(((unsigned char*)RetAddr)[-1] == 0xFF &&"Not a call instr!");'), (379, 2, u'-  assert(((unsigned char*)RetAddr)[-1] == 0xE8 &&"Not a call instr!");'), (387, 2, u'-  assert(isStub &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(46, 2, u'-  assert((MO.isGlobal() || MO.isSymbol()) && "Isn\'t a symbol reference");'), (51, 2, u'-    assert(MO.isSymbol());'), (84, 2, u'-      assert(MO.isGlobal() && "Extern symbol not handled yet");'), (98, 2, u'-      assert(MO.isGlobal() && "Extern symbol not handled yet");'), (234, 2, u'-  assert(Inst.getOperand(0).isReg() &&'), (264, 2, u'-  assert(Inst.getNumOperands() == 6 && Inst.getOperand(RegOp).isReg() &&'), (358, 2, u'-    assert(OutMI.getNumOperands() == 1+X86::AddrNumOperands &&'), (360, 2, u'-    assert(OutMI.getOperand(1+X86::AddrSegmentReg).getReg() == 0 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(315, 2, u'-      assert(X86::XMM15 == X86::XMM8+7);'), (424, 2, u'-      assert(Opcode == TII.getCallFrameDestroyOpcode());'), (471, 2, u'-  assert(SPAdj == 0 && "Unexpected");'), (480, 2, u'-    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (512, 2, u'-    assert((!Is64Bit || isInt<32>((long long)FIOffset + Imm)) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 2, u'-      assert(isTargetELF() && "Unknown rip-relative target");'), (411, 2, u'-  assert((!In64BitMode || HasX86_64) &&')]
===========================================
Class:class X86PassConfig : public TargetPassConfig { class X86PassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(96, 2, u'-      assert(getRelocationModel() == Reloc::DynamicNoPIC);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(162, 2, u'-  assert(BBState.empty());')]
===========================================
Class:  class XCoreAsmPrinter : public AsmPrinter {   class XCoreAsmPrinter : public AsmPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 2, u'-  assert(((GV->hasExternalLinkage() ||'), (270, 2, u'-  assert(NOps == 4);'), (277, 2, u'-  assert(MI->getOperand(0).isReg() && MI->getOperand(1).isImm());'), (287, 2, u'-  assert(MI->getNumOperands() == 4 && "Invalid no. of machine operands!");'), (288, 2, u'-  assert(MI->getOperand(0).isReg() && MI->getOperand(1).isImm() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 2, u'-  assert(Offset%4 == 0 && "Misaligned stack offset");'), (64, 2, u'-  assert(Offset%4 == 0 && "Misaligned stack offset");'), (111, 2, u'-  assert(FrameSize%4 == 0 && "Misaligned frame size");'), (232, 2, u'-  assert(FrameSize%4 == 0 && "Misaligned frame size");'), (261, 2, u'-      assert(MBBI->getOpcode() == XCore::RETSP_u6'), (324, 2, u'-    assert(MI != MBB.begin() &&')]
===========================================
Class:  class XCoreDAGToDAGISel : public SelectionDAGISel {   class XCoreDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(118, 2, u'-      assert(Amount%4 == 0);'), (137, 2, u'-        assert(Old->getOpcode() == XCore::ADJCALLSTACKUP);'), (154, 2, u'-  assert(SPAdj == 0 && "Unexpected");'), (161, 2, u'-    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (197, 2, u'-  assert(Offset%4 == 0 && "Misaligned stack offset");'), (208, 2, u'-  assert(XCore::GRRegsRegisterClass->contains(Reg) &&')]
===========================================
Class:class XCorePassConfig : public TargetPassConfig { class XCorePassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(231, 2, u'-    assert(CS && "Should only have direct calls!");'), (555, 2, u'-        assert(isa<LoadInst>(User) || isa<GetElementPtrInst>(User));'), (582, 2, u'-        assert(Params.back());'), (643, 2, u'-    assert(CS.getCalledFunction() == F);'), (829, 2, u'-        assert(ArgIndices.begin()->empty() &&'), (852, 2, u'-          assert(It != ArgIndices.end() && "GEP not handled??");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(221, 2, u'-      assert(Replacements[i].first->hasLocalLinkage() &&')]
===========================================
Class:  class DAE : public ModulePass {   class DAE : public ModulePass 
Class:  class GVExtractorPass : public ModulePass {   class GVExtractorPass : public ModulePass 
Class:  class ArgumentGraph {   class ArgumentGraph 
Class:class Evaluator { class Evaluator 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(132, 2, u'-  assert(NumNonconstant != ArgumentConstants.size());')]
===========================================
Class:  class AlwaysInliner : public Inliner {   class AlwaysInliner : public Inliner 
Class:  class SimpleInliner : public Inliner {   class SimpleInliner : public Inliner 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(327, 2, u'-    assert(unsigned(InlineHistoryID) < InlineHistory.size() &&')]
===========================================
Class:  class InternalizePass : public ModulePass {   class InternalizePass : public ModulePass 
Class:  class BlockExtractorPass : public ModulePass {   class BlockExtractorPass : public ModulePass 
Class:class ComparableFunction { class ComparableFunction 
Class:class FunctionComparator { class FunctionComparator 
Class:class MergeFunctions : public ModulePass { class MergeFunctions : public ModulePass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(112, 2, u'-    assert(Func &&'), (121, 2, u'-  AssertingVH<Function> Func;'), (440, 2, u'-      assert(F1I->getNumOperands() == F2I->getNumOperands());'), (491, 2, u'-  assert(F1->arg_size() == F2->arg_size() &&'), (523, 2, u'-    assert(F1TI->getNumSuccessors() == F2TI->getNumSuccessors());'), (675, 2, u'-  assert(LHS.getTD() == RHS.getTD() &&'), (777, 2, u'-    assert(G->mayBeOverridden());'), (821, 2, u'-  assert(!OldF.getFunc()->mayBeOverridden() ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(234, 2, u'-  assert(pred_begin(BB) == pred_end(BB) && "BB is not dead!");')]
===========================================
Class:class StripDeadPrototypesPass : public ModulePass { class StripDeadPrototypesPass : public ModulePass 
Class:  class StripSymbols : public ModulePass {   class StripSymbols : public ModulePass 
Class:   class StripNonDebugSymbols : public ModulePass {   class StripNonDebugSymbols : public ModulePass 
Class:   class StripDebugDeclare : public ModulePass {   class StripDebugDeclare : public ModulePass 
Class:   class StripDeadDebugInfo : public ModulePass {   class StripDeadDebugInfo : public ModulePass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(475, 2, u'-  assert(TD && "Must have target data info for this");')]
===========================================
Class:class InstCombineFortifiedLibCalls : public SimplifyFortifiedLibCalls { class InstCombineFortifiedLibCalls : public SimplifyFortifiedLibCalls 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(451, 2, u'-    assert(Res->getType() == DestTy);'), (765, 2, u'-    assert(BitsToClear < SrcTy->getScalarSizeInBits() &&'), (772, 2, u'-    assert(Res->getType() == DestTy);'), (986, 2, u'-  assert(V->getType()->getScalarSizeInBits() < Ty->getScalarSizeInBits() &&'), (1072, 2, u'-    assert(Res->getType() == DestTy);'), (1364, 2, u'-        assert(isa<PtrToIntInst>(CI));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(154, 2, u'-  assert(KnownZero.getBitWidth() == KnownOne.getBitWidth() &&'), (178, 2, u'-  assert(KnownZero.getBitWidth() == KnownOne.getBitWidth() &&'), (417, 2, u'-    assert(TrueRangeEnd != FirstTrueElement && "Should emit single compare");'), (432, 2, u'-    assert(FalseRangeEnd != FirstFalseElement && "Should emit single compare");'), (765, 2, u'-  assert(Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SGE);'), (973, 2, u'-    assert(TheDiv->getOpcode() == Instruction::SDiv ||'), (977, 2, u'-    assert(Res && "This div/cst should have folded!");'), (1649, 2, u'-  assert(ICI.getPredicate() == ICmpInst::ICMP_UGT && "ICmp should be folded!");'), (1932, 2, u'-      assert(!CI->isMaxValue(false));                 // A <=u MAX -> TRUE'), (1936, 2, u'-      assert(!CI->isMaxValue(true));                  // A <=s MAX -> TRUE'), (1940, 2, u'-      assert(!CI->isMinValue(false));                 // A >=u MIN -> TRUE'), (1944, 2, u'-      assert(!CI->isMinValue(true));                  // A >=s MIN -> TRUE'), (2140, 2, u'-      assert(!isa<ConstantInt>(Op1) && "ICMP_SGE with ConstantInt not folded!");'), (2147, 2, u'-      assert(!isa<ConstantInt>(Op1) && "ICMP_SLE with ConstantInt not folded!");'), (2154, 2, u'-      assert(!isa<ConstantInt>(Op1) && "ICMP_UGE with ConstantInt not folded!");'), (2161, 2, u'-      assert(!isa<ConstantInt>(Op1) && "ICMP_ULE with ConstantInt not folded!");'), (2658, 2, u'-  assert(!RHS.isNaN() && "NaN comparison not already folded!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(109, 2, u'-      assert(isa<AllocaInst>(AI) && "Unknown type of allocation inst!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(26, 2, u'-  assert(isa<BinaryOperator>(FirstInst) || isa<CmpInst>(FirstInst));'), (719, 2, u'-      assert(EltPHI->getType() != PN->getType() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(23, 2, u'-  assert(I.getOperand(1)->getType() == I.getOperand(0)->getType());'), (246, 2, u'-    assert(CI->getZExtValue() > NumBits);'), (286, 2, u'-    assert(CI->getZExtValue() > NumBits);'), (389, 2, u'-        assert(I.getOpcode() == Instruction::LShr && "Unknown logical shift");'), (535, 2, u'-    assert(ShiftAmt2 != 0 && "Should have been simplified earlier");'), (577, 2, u'-        assert(ShiftOp->getOpcode() == Instruction::LShr ||'), (627, 2, u'-      assert(ShiftAmt2 < ShiftAmt1);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 2, u'-  assert(I && "No instruction?");'), (30, 2, u'-  assert(OpNo < I->getNumOperands() && "Operand index too large");'), (103, 2, u'-  assert(V != 0 && "Null pointer of Value???");'), (104, 2, u'-  assert(Depth <= 6 && "Limit Search Depth");'), (107, 2, u'-  assert((TD || !VTy->isPointerTy()) &&'), (109, 2, u'-  assert((!TD || TD->getTypeSizeInBits(VTy->getScalarType()) == BitWidth) &&'), (227, 2, u'-    assert(!(RHSKnownZero & RHSKnownOne) && "Bits known to be one AND zero?");'), (228, 2, u'-    assert(!(LHSKnownZero & LHSKnownOne) && "Bits known to be one AND zero?");'), (259, 2, u'-    assert(!(RHSKnownZero & RHSKnownOne) && "Bits known to be one AND zero?");'), (260, 2, u'-    assert(!(LHSKnownZero & LHSKnownOne) && "Bits known to be one AND zero?");'), (295, 2, u'-    assert(!(RHSKnownZero & RHSKnownOne) && "Bits known to be one AND zero?");'), (296, 2, u'-    assert(!(LHSKnownZero & LHSKnownOne) && "Bits known to be one AND zero?");'), (370, 2, u'-    assert(!(RHSKnownZero & RHSKnownOne) && "Bits known to be one AND zero?");'), (371, 2, u'-    assert(!(LHSKnownZero & LHSKnownOne) && "Bits known to be one AND zero?");'), (393, 2, u'-    assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (416, 2, u'-    assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (431, 2, u'-    assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (458, 2, u'-    assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (596, 2, u'-      assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (620, 2, u'-      assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (665, 2, u'-      assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (721, 2, u'-        assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (817, 2, u'-  assert((DemandedElts & ~EltMask) == 0 && "Invalid DemandedElts!");'), (936, 2, u'-          assert(MaskVal < LHSVWidth * 2 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 2, u'-  assert(V->getType()->isVectorTy() && "Not looking at a vector?");'), (211, 2, u'-  assert(V->getType() == LHS->getType() && V->getType() == RHS->getType() &&'), (268, 2, u'-              assert(EI->getOperand(0) == RHS);'), (289, 2, u'-  assert(V->getType()->isVectorTy() &&'), (629, 2, u'-          assert(isa<UndefValue>(RHSShuffle->getOperand(1))')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 2, u'-  assert(From->isIntegerTy() && To->isIntegerTy());'), (755, 2, u'-      assert(Offset >= 0);'), (757, 2, u'-    assert((uint64_t)Offset < (uint64_t)TySize && "Out of range offset");'), (770, 2, u'-      assert(Offset < (int64_t)SL->getSizeInBytes() &&'), (781, 2, u'-      assert(EltSize && "Cannot index into a zero-sized array");'), (1255, 2, u'-          assert(isa<ConstantInt>(NewCaseVal) &&'), (1507, 2, u'-      assert(LI.isFilter(i) && "Unsupported landingpad clause!");'), (1527, 2, u'-        assert(NumTypeInfos > 0 && "Should have handled empty filter already!");'), (1593, 2, u'-        assert(MakeNewInstruction && "New filter but not a new instruction!");'), (1677, 2, u'-          assert(FElts <= LElts && "Should have handled this case earlier!");'), (1689, 2, u'-        assert(FElts > 0 && "Should have eliminated the empty filter earlier!");'), (1748, 2, u'-    assert(!CleanupFlag && "Adding a cleanup, not removing one?!");'), (1764, 2, u'-  assert(I->hasOneUse() && "Invariants didn\'t hold!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(307, 2, u'-  assert(OrigTy->isSized());'), (734, 2, u'-  assert(ShadowRZSize >= 1 && ShadowRZSize <= 4);'), (754, 2, u'-    assert(AlignedSize - SizeInBytes < RedzoneSize);'), (759, 2, u'-    assert(ShadowBase->getType() == IntptrTy);'), (857, 2, u'-  assert(MyAlloca->isStaticAlloca());'), (882, 2, u'-    assert((AlignedSize % RedzoneSize) == 0);'), (889, 2, u'-  assert(Pos == LocalStackSize);')]
===========================================
Class:  class EdgeProfiler : public ModulePass {   class EdgeProfiler : public ModulePass 
Class:  class GCOVProfiler : public ModulePass {   class GCOVProfiler : public ModulePass 
Class:  class GCOVRecord {   class GCOVRecord 
Class:            class GCOVLines : public GCOVRecord {   class GCOVLines : public GCOVRecord 
Class:            class GCOVBlock : public GCOVRecord {   class GCOVBlock : public GCOVRecord 
Class:            class GCOVFunction : public GCOVRecord {   class GCOVFunction : public GCOVRecord 
Class:  class OptimalEdgeProfiler : public ModulePass {   class OptimalEdgeProfiler : public ModulePass 
Class:class BLInstrumentationNode;
Class:     class BLInstrumentationNode : public BallLarusNode { class BLInstrumentationNode : public BallLarusNode 
Class:     class BLInstrumentationEdge : public BallLarusEdge { class BLInstrumentationEdge : public BallLarusEdge 
Class:     class BLInstrumentationDag : public BallLarusDag { class BLInstrumentationDag : public BallLarusDag 
Class:    class PathProfiler : public ModulePass { class PathProfiler : public ModulePass 
Class:  class PathProfilingFunctionTable 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(288, 2, u'-  assert(OrigTy->isSized());'), (305, 2, u'-  assert(Idx < kNumberOfAccessSizes);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(105, 2, u'-  assert(!PlacedBlocks.count(BB) && "Already placed this block!");')]
===========================================
Class:  class CodeGenPrepare : public FunctionPass {   class CodeGenPrepare : public FunctionPass 
Class:class CodeGenPrepareFortifiedLibCalls : public SimplifyFortifiedLibCalls { class CodeGenPrepareFortifiedLibCalls : public SimplifyFortifiedLibCalls 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(1006, 2, u'-    assert(isa<SExtInst>(I) && "Unexpected ext type!");')]
===========================================
Class:  class CorrelatedValuePropagation : public FunctionPass {   class CorrelatedValuePropagation : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(208, 2, u'-  assert(hasMemoryWrite(Inst) && "Unknown instruction case");')]
===========================================
Class:class EarlyCSE : public FunctionPass { class EarlyCSE : public FunctionPass 
Class:  class ValueTable {   class ValueTable 
Class:  class GVN : public FunctionPass {   class GVN : public FunctionPass 
Class:  class GlobalMerge : public FunctionPass {   class GlobalMerge : public FunctionPass 
Class:  class IndVarSimplify : public LoopPass {   class IndVarSimplify : public LoopPass 
Class:  class WideIVVisitor : public IVVisitor {   class WideIVVisitor : public IVVisitor 
Class:class WidenIV { class WidenIV 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(207, 2, u'-  assert(InsertPt && "Missing phi operand");'), (208, 2, u'-  assert((!isa<Instruction>(Def) ||'), (290, 2, u'-  assert(TheBr->isConditional() && "Can\'t use fcmp if not conditional");'), (479, 2, u'-  assert(L->isLCSSAForm(*DT));'), (696, 2, u'-    assert(L->getHeader() == OrigPhi->getParent() && "Phi must be an IV");'), (799, 2, u'-  assert(DU.NarrowUse->getOperand(1-ExtendOperIdx) == DU.NarrowDef && "bad DU");'), (915, 2, u'-  assert(DU.NarrowUse != DU.NarrowUse->getParent()->getTerminator() &&'), (981, 2, u'-  assert(SE->getEffectiveSCEVType(WideIVExpr->getType()) == WideType &&'), (992, 2, u'-  assert(SE->properlyDominates(AddRec->getStart(), L->getHeader()) &&'), (1017, 2, u'-  assert(Widened.empty() && NarrowIVUsers.empty() && "expect initial state" );'), (1221, 2, u'-  assert(L->getExitingBlock() && "expected loop exit");'), (1229, 2, u'-  assert(BI && "expected exit branch");'), (1303, 2, u'-  assert(LatchBlock && "needsLFTR should guarantee a loop latch");'), (1364, 2, u'-  assert(AR && AR->getLoop() == L && AR->isAffine() && "bad loop counter");'), (1378, 2, u'-    assert(SE->isLoopInvariant(IVOffset, L) &&'), (1384, 2, u'-    assert(AR->getStart() == SE->getSCEV(GEPBase) && "bad loop counter");'), (1387, 2, u'-    assert(SE->getSizeOfExpr('), (1411, 2, u'-      assert(AR->getStepRecurrence(*SE)->isOne() && "only handles unit stride");'), (1424, 2, u'-    assert(SE->isLoopInvariant(IVLimit, L) &&'), (1445, 2, u'-  assert(canExpandBackedgeTakenCount(L, SE) && "precondition");'), (1488, 2, u'-  assert(ExitCnt->getType()->isPointerTy() == IndVar->getType()->isPointerTy()'), (1715, 2, u'-  assert(L->isLCSSAForm(*DT) &&'), (1731, 2, u'-    assert(BackedgeTakenCount == NewBECount && "indvars must preserve SCEV");')]
===========================================
Class:  class JumpThreading : public FunctionPass {   class JumpThreading : public FunctionPass 
Class:  class LoopPromoter : public LoadAndStorePromoter {   class LoopPromoter : public LoadAndStorePromoter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 2, u'-      assert(LoopToAliasSetMap.empty() && "Didn\'t free loop alias sets");'), (140, 2, u'-      assert(CurLoop->contains(BB) && "Only valid if BB is IN the loop");'), (214, 2, u'-    assert(InnerAST && "Where is my AST?");'), (285, 2, u'-  assert(N != 0 && "Null dominator tree node?");'), (332, 2, u'-  assert(N != 0 && "Null dominator tree node?");'), (690, 2, u'-  assert(!AS.empty() &&'), (739, 2, u'-        assert(!load->isVolatile() && "AST broken");'), (747, 2, u'-        assert(!store->isVolatile() && "AST broken");')]
===========================================
Class:  class LoopDeletion : public LoopPass {   class LoopDeletion : public LoopPass 
Class:  class LoopIdiomRecognize : public LoopPass {   class LoopIdiomRecognize : public LoopPass 
Class:  class LoopInstSimplify : public LoopPass {   class LoopInstSimplify : public LoopPass 
Class:  class LoopRotate : public LoopPass {   class LoopRotate : public LoopPass 
Class:class RegSortData { class RegSortData 
Class:class RegUseTracker { class RegUseTracker 
Class:class Cost { class Cost 
Class:class LSRUse { class LSRUse 
Class:class LSRInstance { class LSRInstance 
Class:class LoopStrengthReduce : public LoopPass { class LoopStrengthReduce : public LoopPass 
Class:  class LoopUnroll : public LoopPass {   class LoopUnroll : public LoopPass 
Class:  class LUAnalysisCache {   class LUAnalysisCache 
Class:   class LoopUnswitch : public LoopPass {   class LoopUnswitch : public LoopPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(321, 2, u'-    assert(NewInst && "All instructions that are in SrcBB must be in VMap.");'), (384, 2, u'-    assert(currentLoop->isLCSSAForm(*DT));'), (720, 2, u'-  assert(!L->contains(ExitBlock) && "Exit block is in the loop?");'), (839, 2, u'-    assert(NewExit->getTerminator()->getNumSuccessors() == 1 &&'), (876, 2, u'-  assert(OldBR->isUnconditional() && OldBR->getSuccessor(0) == LoopBlocks[0] &&'), (1069, 2, u'-  assert(!isa<Constant>(LIC) && "Why are we unswitching on a constant?");'), (1233, 2, u'-        assert(SinglePred == Pred && "CFG broken");')]
===========================================
Class:class MemsetRanges { class MemsetRanges 
Class:  class MemCpyOpt : public FunctionPass {   class MemCpyOpt : public FunctionPass 
Class:  class MapVector {   class MapVector 
Class:         Class == IC_RetainRV;
Class:         Class == IC_AutoreleaseRV;
Class:         Class == IC_RetainRV ||          Class == IC_RetainRV ||
Class:         Class == IC_RetainRV ||          Class == IC_RetainRV ||
Class:         Class == IC_RetainRV ||          Class == IC_RetainRV ||
Class:         Class == IC_RetainRV ||          Class == IC_RetainRV ||
Class:  class ObjCARCAliasAnalysis : public ImmutablePass,   class ObjCARCAliasAnalysis : public ImmutablePass,
Class:  class ObjCARCExpand : public FunctionPass {   class ObjCARCExpand : public FunctionPass 
Class:  class ObjCARCAPElim : public ModulePass {   class ObjCARCAPElim : public ModulePass 
Class:  class ProvenanceAnalysis {   class ProvenanceAnalysis 
Class:  class PtrState {   class PtrState 
Class:  class BBState {   class BBState 
Class:  class ObjCARCOpt : public FunctionPass {   class ObjCARCOpt : public FunctionPass 
Class:        Class = IC_Release;
Class:  class ObjCARCContract : public FunctionPass {   class ObjCARCContract : public FunctionPass 
Class:  class Reassociate : public FunctionPass {   class Reassociate : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 2, u'-  assert(pred_begin(BBEntry) == pred_end(BBEntry) &&')]
===========================================
Class:class LatticeVal { class LatticeVal 
Class:class SCCPSolver : public InstVisitor<SCCPSolver> { class SCCPSolver : public InstVisitor<SCCPSolver> 
Class:class ConvertToScalarInfo { class ConvertToScalarInfo 
Class:class AllocaPromoter : public LoadAndStorePromoter { class AllocaPromoter : public LoadAndStorePromoter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(312, 2, u'-    assert(VectorTy && "Missing type for vector scalar.");'), (559, 2, u'-      assert(SI->getOperand(0) != Ptr && "Consistency error!");'), (576, 2, u'-      assert(MSI->getRawDest() == Ptr && "Consistency error!");'), (608, 2, u'-      assert(Offset == 0 && "must be store to start of alloca");'), (618, 2, u'-        assert(MTI->getRawDest() == Ptr && "Neither use is of pointer?");'), (634, 2, u'-        assert(MTI->getRawSource() == Ptr && "Neither use is of pointer?");'), (700, 2, u'-      assert(EltSize*Elt == Offset && "Invalid modulus in validity checking");'), (781, 2, u'-  assert(FromVal->getType() == ToType && "Didn\'t convert right?");'), (893, 2, u'-    assert(DestWidth > SrcWidth);'), (1856, 2, u'-      assert(Offset == 0 && NewElts[0] &&'), (2036, 2, u'-      assert(Inst == MTI->getRawSource());'), (2126, 2, u'-      assert(isa<MemSetInst>(MI));'), (2154, 2, u'-          assert(StoreVal->getType() == ValTy && "Type mismatch!");'), (2180, 2, u'-      assert(isa<MemTransferInst>(MI));'), (2551, 2, u'-        assert(II->use_empty() && "Lifetime markers have no result to use!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(184, 2, u'-  assert(Reachable.size() < F.size());')]
===========================================
Class:class LibCallOptimization { class LibCallOptimization 
Class:  class SimplifyLibCalls : public FunctionPass {   class SimplifyLibCalls : public FunctionPass 
Class:  class Sinking : public FunctionPass {   class Sinking : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(335, 2, u'-  assert(I->getNumOperands() == 2 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(564, 2, u'-    (void)Success; assert(Success && "Couldn\'t select *anything*?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-  assert((pred_begin(BB) == pred_end(BB) ||'), (217, 2, u'-  assert(I->getParent() == 0 &&'), (248, 2, u'-    assert(i != e && "Didn\'t find edge?");'), (270, 2, u'-    assert(SP == BB && "CFG broken");'), (277, 2, u'-  assert(BB->getTerminator()->getNumSuccessors() == 1 &&'), (469, 2, u'-    assert(!isa<IndirectBrInst>(Preds[i]->getTerminator()) &&'), (512, 2, u'-  assert(OrigBB->isLandingPad() && "Trying to split a non-landing pad!");'), (529, 2, u'-    assert(!isa<IndirectBrInst>(Preds[i]->getTerminator()) &&'), (547, 2, u'-    assert(!isa<IndirectBrInst>(Pred->getTerminator()) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(93, 2, u'-  assert(SuccNum < TI->getNumSuccessors() && "Illegal edge specification!");'), (100, 2, u'-  assert(I != E && "No preds, but we have an edge to the block?");'), (129, 2, u'-  assert((SplitBB->getFirstNonPHI() == SplitBB->getTerminator() ||'), (180, 2, u'-  assert(!isa<IndirectBrInst>(TI) &&'), (329, 2, u'-          assert(DestLoop->getHeader() == DestBB &&'), (340, 2, u'-        assert(!TIL->contains(NewBB) &&'), (400, 2, u'-      assert((!P->mustPreserveAnalysisID(LCSSAID) ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 2, u'-  assert(NameSuffix && "NameSuffix cannot be null!");'), (87, 2, u'-    assert(VMap.count(I) && "No mapping from source argument specified!");'), (370, 2, u'-  assert(NameSuffix && "NameSuffix cannot be null!");'), (375, 2, u'-    assert(VMap.count(II) && "No mapping from source argument specified!");'), (439, 2, u'-          assert(InVal && "Unknown input value?");'), (457, 2, u'-      assert(NumPreds < PN->getNumIncomingValues());'), (492, 2, u'-        assert(VMap[OldI] == PN && "VMap mismatch");'), (545, 2, u'-    assert(!isa<PHINode>(Dest->begin()));')]
===========================================
Class:  class CodeExtractor {   class CodeExtractor 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(679, 2, u'-      assert(BlocksToExtract.count(*PI) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(84, 2, u'-    assert(II.getNormalDest()->getSinglePredecessor() &&'), (119, 2, u'-      assert(II->getParent() != P->getIncomingBlock(i) &&')]
===========================================
Class:  class InvokeInliningInfo {   class InvokeInliningInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(492, 2, u'-  assert(TheCall->getParent() && TheCall->getParent()->getParent() &&'), (571, 2, u'-    assert(CalledFunc->arg_size() == CS.arg_size() &&'), (784, 2, u'-  assert(Br && Br->getOpcode() == Instruction::Br &&'), (816, 2, u'-        assert(RI->getReturnValue()->getType() == PHI->getType() &&'), (862, 2, u'-  assert(cast<BranchInst>(Br)->isUnconditional() && "splitBasicBlock broken!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 2, u'-      assert(L->isLCSSAForm(*DT) && "LCSSA form not preserved!");'), (160, 2, u'-  assert(L->isLCSSAForm(*DT));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 2, u'-      assert(BI->getParent() && "Terminator not inserted in block!");'), (364, 2, u'-  AssertingVH<Instruction> TerminatorVH(--BB->end());'), (368, 2, u'-    assert(!BI->isTerminator());'), (445, 2, u'-  assert(PredBB && "Block doesn\'t have a single predecessor!");'), (488, 2, u'-  assert(*succ_begin(BB) == Succ && "Succ is not successor of BB!");'), (546, 2, u'-  assert(BB != &BB->getParent()->getEntryBlock() &&'), (597, 2, u'-      assert(OldVal && "No entry in PHI for Pred BB!");'), (629, 2, u'-      assert(PN->use_empty() && "There shouldn\'t be any uses here!");'), (762, 2, u'-  assert(V->getType()->isPointerTy() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(337, 2, u'-      assert(pred_begin(ExitingBlock) == pred_end(ExitingBlock));'), (421, 2, u'-  assert(!LoopBlocks.empty() && "No edges coming in from outside the loop?");'), (546, 2, u'-  assert(!L->getHeader()->isLandingPad() &&'), (647, 2, u'-  assert(L->getNumBackEdges() > 1 && "Must have > 1 backedge!");'), (658, 2, u'-  assert(!Header->isLandingPad() && "Can\'t insert backedge to landing pad");'), (714, 2, u'-    assert(PreheaderIdx != ~0U && "PHI has no preheader entry??");'), (772, 2, u'-    assert(HasIndBrPred &&'), (789, 2, u'-    assert(HasIndBrExiting &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(190, 2, u'-  assert(Count > 0);'), (191, 2, u'-  assert(TripMultiple > 0);'), (192, 2, u'-  assert(TripCount == 0 || TripCount % TripMultiple == 0);'), (341, 2, u'-      assert(Latches.back() == LastValueMap[LatchBlock] && "bad last latch");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 2, u'-  assert(Latch != 0 && "Loop must have a latch");'), (113, 2, u'-  assert(Exit != 0 && "Loop must have a single exit block only");'), (294, 2, u'-  assert(PreHeaderBR->isUnconditional() &&')]
===========================================
Class:  class LowerExpectIntrinsic : public FunctionPass {   class LowerExpectIntrinsic : public FunctionPass 
Class:  class LowerInvoke : public FunctionPass {   class LowerInvoke : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(277, 2, u'-    assert(!isa<PHINode>(II->getNormalDest()) &&')]
===========================================
Class:  class LowerSwitch : public FunctionPass {   class LowerSwitch : public FunctionPass 
Class:  class RenamePassData {   class RenamePassData 
Class:                  class LargeBlockInfo {   class LargeBlockInfo 
Class:  class PHIiter {   class PHIiter 
Class:class SSAUpdaterTraits<SSAUpdater> { class SSAUpdaterTraits<SSAUpdater> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(65, 2, u'-  assert(ProtoType != 0 && "Need to initialize SSAUpdater");'), (66, 2, u'-  assert(ProtoType == V->getType() &&'), (470, 2, u'-    assert(StoredValue && "Already checked that there is a store in block");'), (502, 2, u'-      assert(NewVal && "not a replaced load?");')]
===========================================
Class:class SimplifyCFGOpt { class SimplifyCFGOpt 
Class:  class SimplifyIndvar {   class SimplifyIndvar 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(64, 2, u'-      assert(LI && "IV simplification requires LoopInfo");'), (114, 2, u'-    assert(SE->isSCEVable(IVSrc->getType()) && "Expect SCEVable IV operand");'), (140, 2, u'-  assert(SE->getSCEV(UseInst) == FoldedExpr && "bad SCEV with folded oper");'), (156, 2, u'-    assert(IVOperand == ICmp->getOperand(1) && "Can\'t find IVOperand");'), (344, 2, u'-      assert(N <= Simplified.size() && "runaway iteration");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(153, 2, u'-  assert(isa<ConstantPointerNull>(C));'), (169, 2, u'-      assert((Flags & RF_IgnoreMissingEntries) &&'), (181, 2, u'-        assert((Flags & RF_IgnoreMissingEntries) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(421, 2, u'-        assert(VTy == cast<PointerType>(JPtr->getType())->getElementType());'), (1703, 2, u'-    assert(cast<Instruction>(L) == J &&'), (1833, 2, u'-      assert(FP != ChosenPairs.end() && "Flipped pair not found in list");')]
===========================================
Class:class TypePrinting { class TypePrinting 
Class:class SlotTracker { class SlotTracker 
Class:class AssemblyWriter { class AssemblyWriter 
Class:  class AttributeListImpl;
Class:class AttributeListImpl : public FoldingSetNode { class AttributeListImpl : public FoldingSetNode 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(92, 2, u'-  assert(!Result.empty() && "Unknown attribute!");'), (178, 2, u'-    assert(Attrs[i].Attrs != Attribute::None &&'), (180, 2, u'-    assert((!i || Attrs[i-1].Index < Attrs[i].Index) &&'), (242, 2, u'-  assert(AttrList && Slot < AttrList->Attrs.size() && "Slot # out of range!");'), (280, 2, u'-  assert((!OldAlign || !NewAlign || OldAlign == NewAlign) &&'), (318, 2, u'-  assert(!(Attrs & Attribute::Alignment) && "Attempt to exclude alignment!");'), (336, 2, u'-  assert(OldAttrList[i].Index == Idx && "Attribute isn\'t set?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 2, u'-  assert(F && "Illegal to upgrade a non-existent Function.");'), (101, 2, u'-  assert(F && "Intrinsic call is not direct?");'), (171, 2, u'-    assert(CI->getNumArgOperands() == 1 &&'), (186, 2, u'-  assert(F && "Illegal attempt to upgrade a non-existent intrinsic.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-    assert(NewParent &&'), (69, 2, u'-    assert(!use_empty() && "There should be at least one blockaddress!");'), (80, 2, u'-  assert(getParent() == 0 && "BasicBlock still linked into the program!");'), (218, 2, u'-  assert((hasNUsesOrMore(16)||// Reduce cost of this assertion for complex CFGs.'), (239, 2, u'-  assert(max_idx != 0 && "PHI Node in block with 0 predecessors!?!?!");'), (299, 2, u'-  assert(getTerminator() && "Can\'t use splitBasicBlock on degenerate BB!");'), (300, 2, u'-  assert(I != InstList.end() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 2, u'-  assert(Op && Op->isCast() && "Can\'t fold cast of cast without a cast!");'), (82, 2, u'-  assert(DstTy && DstTy->isFirstClassType() && "Invalid cast destination type");'), (83, 2, u'-  assert(CastInst::isCast(opc) && "Invalid cast opcode");'), (136, 2, u'-      assert(DestPTy->getBitWidth() == SrcTy->getBitWidth() &&'), (195, 2, u'-  assert(C->getType()->isIntegerTy() &&'), (199, 2, u'-  assert(ByteSize && "Must be accessing some piece");'), (200, 2, u'-  assert(ByteStart+ByteSize <= CSize && "Extracting invalid piece from input");'), (201, 2, u'-  assert(ByteSize != CSize && "Should not extract everything");'), (313, 2, u'-      assert((SrcBitSize&7) && "Shouldn\'t get byte sized case here");'), (1011, 2, u'-          assert(CI2->equalsInt(1));'), (1047, 2, u'-        assert(!CI2->isNullValue() && "Div by zero handled above");'), (1050, 2, u'-        assert(!CI2->isNullValue() && "Div by zero handled above");'), (1055, 2, u'-        assert(!CI2->isNullValue() && "Div by zero handled above");'), (1058, 2, u'-        assert(!CI2->isNullValue() && "Div by zero handled above");'), (1265, 2, u'-  assert(V1->getType() == V2->getType() &&'), (1334, 2, u'-  assert(V1->getType() == V2->getType() &&'), (1388, 2, u'-      assert(isa<ConstantPointerNull>(V2) && "Canonicalization guarantee!");'), (1414, 2, u'-      assert((isa<ConstantPointerNull>(V2) || isa<GlobalValue>(V2)) &&'), (1491, 2, u'-            assert(CE1->getNumOperands() == 2 &&'), (1913, 2, u'-    assert(Ty != 0 && "Invalid indices for GEP!");'), (1927, 2, u'-      assert(Ty != 0 && "Invalid indices for GEP!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(183, 2, u'-  assert(isa<IntegerType>(Elt->getType()) && "Index must be an integer");'), (207, 2, u'-    assert(isa<Constant>(V) && "References remain to Constant being destroyed");'), (211, 2, u'-    assert((use_empty() || use_back() != V) && "Constant not removed!");'), (221, 2, u'-  assert(getType()->isFirstClassType() && "Cannot evaluate aggregate vals!");'), (376, 2, u'-  assert(V.getBitWidth() == Ty->getBitWidth() && "Invalid constant for type");'), (396, 2, u'-    assert(Ty->isIntegerTy(1) && "True must be i1 or vector of i1.");'), (399, 2, u'-  assert(VTy->getElementType()->isIntegerTy(1) &&'), (408, 2, u'-    assert(Ty->isIntegerTy(1) && "False must be i1 or vector of i1.");'), (411, 2, u'-  assert(VTy->getElementType()->isIntegerTy(1) &&'), (458, 2, u'-  assert(C->getType() == Ty->getScalarType() &&'), (489, 2, u'-  assert(Ty->isPPC_FP128Ty() && "Unknown FP format");'), (571, 2, u'-      assert(&V.getSemantics() == &APFloat::PPCDoubleDouble &&'), (589, 2, u'-  assert(&V.getSemantics() == TypeToFloatSemantics(Ty) &&'), (680, 2, u'-  assert(V.size() == T->getNumElements() &&'), (683, 2, u'-    assert(V[i]->getType() == T->getElementType() &&'), (694, 2, u'-    assert(V[i]->getType() == Ty->getElementType() &&'), (798, 2, u'-  assert(!V.empty() &&'), (808, 2, u'-  assert(V.size() == T->getNumElements() &&'), (811, 2, u'-    assert((T->isOpaque() || V[i]->getType() == T->getElementType(i)) &&'), (818, 2, u'-  assert((ST->isOpaque() || ST->getNumElements() == V.size()) &&'), (860, 2, u'-    assert(V[i]->getType() == T->getElementType() &&'), (867, 2, u'-  assert(!V.empty() && "Vectors can\'t be empty");'), (1026, 2, u'-  assert(isCompare());'), (1034, 2, u'-  assert(Op->getType() == getOperand(OpNo)->getType() &&'), (1051, 2, u'-  assert(Ops.size() == getNumOperands() && "Operand count mismatch!");'), (1092, 2, u'-    assert(getNumOperands() == 2 && "Must be binary operator?");'), (1174, 2, u'-  assert((Ty->isStructTy() || Ty->isArrayTy() || Ty->isVectorTy()) &&'), (1271, 2, u'-  assert(BB->getParent() != 0 && "Block must have a parent");'), (1281, 2, u'-  assert(BA->getFunction() == F && "Basic block moved between functions");'), (1333, 2, u'-  assert(NewBA != this && "I didn\'t contain From!");'), (1348, 2, u'-  assert(Ty->isFirstClassType() && "Cannot cast to an aggregate type!");'), (1364, 2, u'-  assert(Instruction::isCast(opc) && "opcode out of range");'), (1365, 2, u'-  assert(C && Ty && "Null arguments to getCast");'), (1366, 2, u'-  assert(CastInst::castIsValid(opc, C, Ty) && "Invalid constantexpr cast!");'), (1405, 2, u'-  assert(S->getType()->isPointerTy() && "Invalid cast");'), (1406, 2, u'-  assert((Ty->isIntegerTy() || Ty->isPointerTy()) && "Invalid cast");'), (1415, 2, u'-  assert(C->getType()->isIntOrIntVectorTy() &&'), (1427, 2, u'-  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&'), (1443, 2, u'-  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1444, 2, u'-  assert(C->getType()->isIntOrIntVectorTy() && "Trunc operand must be integer");'), (1445, 2, u'-  assert(Ty->isIntOrIntVectorTy() && "Trunc produces only integral");'), (1446, 2, u'-  assert(C->getType()->getScalarSizeInBits() > Ty->getScalarSizeInBits()&&'), (1457, 2, u'-  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1458, 2, u'-  assert(C->getType()->isIntOrIntVectorTy() && "SExt operand must be integral");'), (1459, 2, u'-  assert(Ty->isIntOrIntVectorTy() && "SExt produces only integer");'), (1460, 2, u'-  assert(C->getType()->getScalarSizeInBits() < Ty->getScalarSizeInBits()&&'), (1471, 2, u'-  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1472, 2, u'-  assert(C->getType()->isIntOrIntVectorTy() && "ZEXt operand must be integral");'), (1473, 2, u'-  assert(Ty->isIntOrIntVectorTy() && "ZExt produces only integer");'), (1474, 2, u'-  assert(C->getType()->getScalarSizeInBits() < Ty->getScalarSizeInBits()&&'), (1485, 2, u'-  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1486, 2, u'-  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&'), (1497, 2, u'-  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1498, 2, u'-  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&'), (1509, 2, u'-  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1510, 2, u'-  assert(C->getType()->isIntOrIntVectorTy() && Ty->isFPOrFPVectorTy() &&'), (1520, 2, u'-  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1521, 2, u'-  assert(C->getType()->isIntOrIntVectorTy() && Ty->isFPOrFPVectorTy() &&'), (1531, 2, u'-  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1532, 2, u'-  assert(C->getType()->isFPOrFPVectorTy() && Ty->isIntOrIntVectorTy() &&'), (1542, 2, u'-  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1543, 2, u'-  assert(C->getType()->isFPOrFPVectorTy() && Ty->isIntOrIntVectorTy() &&'), (1549, 2, u'-  assert(C->getType()->getScalarType()->isPointerTy() &&'), (1551, 2, u'-  assert(DstTy->getScalarType()->isIntegerTy() &&'), (1553, 2, u'-  assert(isa<VectorType>(C->getType()) == isa<VectorType>(DstTy));'), (1555, 2, u'-    assert(C->getType()->getVectorNumElements()==DstTy->getVectorNumElements()&&'), (1561, 2, u'-  assert(C->getType()->getScalarType()->isIntegerTy() &&'), (1563, 2, u'-  assert(DstTy->getScalarType()->isPointerTy() &&'), (1565, 2, u'-  assert(isa<VectorType>(C->getType()) == isa<VectorType>(DstTy));'), (1567, 2, u'-    assert(C->getType()->getVectorNumElements()==DstTy->getVectorNumElements()&&'), (1573, 2, u'-  assert(CastInst::castIsValid(Instruction::BitCast, C, DstTy) &&'), (1586, 2, u'-  assert(Opcode >= Instruction::BinaryOpsBegin &&'), (1589, 2, u'-  assert(C1->getType() == C2->getType() &&'), (1597, 2, u'-    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1598, 2, u'-    assert(C1->getType()->isIntOrIntVectorTy() &&'), (1604, 2, u'-    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1605, 2, u'-    assert(C1->getType()->isFPOrFPVectorTy() &&'), (1611, 2, u'-    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1612, 2, u'-    assert(C1->getType()->isIntOrIntVectorTy() &&'), (1616, 2, u'-    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1617, 2, u'-    assert(C1->getType()->isFPOrFPVectorTy() &&'), (1622, 2, u'-    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1623, 2, u'-    assert(C1->getType()->isIntOrIntVectorTy() &&'), (1627, 2, u'-    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1628, 2, u'-    assert(C1->getType()->isFPOrFPVectorTy() &&'), (1634, 2, u'-    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1635, 2, u'-    assert(C1->getType()->isIntOrIntVectorTy() &&'), (1641, 2, u'-    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1642, 2, u'-    assert(C1->getType()->isIntOrIntVectorTy() &&'), (1705, 2, u'-  assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1726, 2, u'-  assert(!SelectInst::areInvalidOperands(C, V1, V2)&&"Invalid select operands");'), (1747, 2, u'-  assert(Ty && "GEP indices invalid!");'), (1751, 2, u'-  assert(C->getType()->isPointerTy() &&'), (1768, 2, u'-  assert(LHS->getType() == RHS->getType());'), (1769, 2, u'-  assert(pred >= ICmpInst::FIRST_ICMP_PREDICATE &&'), (1792, 2, u'-  assert(LHS->getType() == RHS->getType());'), (1793, 2, u'-  assert(pred <= FCmpInst::LAST_FCMP_PREDICATE && "Invalid FCmp Predicate");'), (1814, 2, u'-  assert(Val->getType()->isVectorTy() &&'), (1816, 2, u'-  assert(Idx->getType()->isIntegerTy(32) &&'), (1834, 2, u'-  assert(Val->getType()->isVectorTy() &&'), (1836, 2, u'-  assert(Elt->getType() == Val->getType()->getVectorElementType() &&'), (1838, 2, u'-  assert(Idx->getType()->isIntegerTy(32) &&'), (1855, 2, u'-  assert(ShuffleVectorInst::isValidOperands(V1, V2, Mask) &&'), (1877, 2, u'-  assert(ExtractValueInst::getIndexedType(Agg->getType(),'), (1880, 2, u'-  assert(Agg->getType()->isFirstClassType() &&'), (1883, 2, u'-  assert(FC && "insertvalue constant expr couldn\'t be folded!");'), (1889, 2, u'-  assert(Agg->getType()->isFirstClassType() &&'), (1894, 2, u'-  assert(ReqTy && "extractvalue indices invalid!");'), (1896, 2, u'-  assert(Agg->getType()->isFirstClassType() &&'), (1899, 2, u'-  assert(FC && "ExtractValue constant expr couldn\'t be folded!");'), (1904, 2, u'-  assert(C->getType()->isIntOrIntVectorTy() &&'), (1911, 2, u'-  assert(C->getType()->isFPOrFPVectorTy() &&'), (1917, 2, u'-  assert(C->getType()->isIntOrIntVectorTy() &&'), (2083, 2, u'-  assert(Elt < getNumElements() && "Invalid Elt");'), (2101, 2, u'-  assert(isElementTypeCompatible(Ty->getSequentialElementType()));'), (2126, 2, u'-  assert(isa<VectorType>(Ty));'), (2138, 2, u'-  assert(Slot != CDSConstants.end() && "CDS not found in uniquing table");'), (2146, 2, u'-    assert((*Entry) == this && "Hash mismatch in ConstantDataSequential");'), (2153, 2, u'-      assert(Node && "Didn\'t find entry in its uniquing hash table!");'), (2243, 2, u'-  assert(isElementTypeCompatible(V->getType()) &&'), (2258, 2, u'-    assert(CI->getType()->isIntegerTy(64) && "Unsupported ConstantData type");'), (2281, 2, u'-  assert(isa<IntegerType>(getElementType()) &&'), (2312, 2, u'-  assert(getElementType()->isFloatTy() &&'), (2320, 2, u'-  assert(getElementType()->isDoubleTy() &&'), (2386, 2, u'-  assert(isa<Constant>(To) && "Cannot make Constant refer to non-constant!");'), (2436, 2, u'-        assert(getOperand(OperandToUpdate) == From &&'), (2450, 2, u'-  assert(Replacement != this && "I didn\'t contain From!");'), (2461, 2, u'-  assert(isa<Constant>(To) && "Cannot make Constant refer to non-constant!");'), (2465, 2, u'-  assert(getOperand(OperandToUpdate) == From && "ReplaceAllUsesWith broken!");'), (2525, 2, u'-  assert(Replacement != this && "I didn\'t contain From!");'), (2536, 2, u'-  assert(isa<Constant>(To) && "Cannot make Constant refer to non-constant!");'), (2547, 2, u'-  assert(Replacement != this && "I didn\'t contain From!");'), (2558, 2, u'-  assert(isa<Constant>(ToV) && "Cannot make Constant refer to non-constant!");'), (2568, 2, u'-  assert(Replacement != this && "I didn\'t contain From!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 2, u'-    assert(unsigned(ScopeIdx) <= Ctx.pImpl->ScopeRecords.size() &&'), (31, 2, u'-  assert(unsigned(-ScopeIdx) <= Ctx.pImpl->ScopeInlinedAtRecords.size() &&'), (42, 2, u'-  assert(unsigned(-ScopeIdx) <= Ctx.pImpl->ScopeInlinedAtRecords.size() &&'), (58, 2, u'-    assert(unsigned(ScopeIdx) <= Ctx.pImpl->ScopeRecords.size() &&'), (66, 2, u'-  assert(unsigned(-ScopeIdx) <= Ctx.pImpl->ScopeInlinedAtRecords.size() &&'), (104, 2, u'-  assert(Scope && "If scope is null, this should be isUnknown()");'), (251, 2, u'-    assert(Ctx->ScopeRecordIdx[Cur] == Idx && "Mapping out of date!");'), (261, 2, u'-  assert(unsigned(-Idx-1) < Ctx->ScopeInlinedAtRecords.size());'), (263, 2, u'-  assert((this == &Entry.first || this == &Entry.second) &&'), (268, 2, u'-  assert(OldScope != 0 && OldInlinedAt != 0 &&'), (272, 2, u'-  assert(Ctx->ScopeInlinedAtIdx[std::make_pair(OldScope, OldInlinedAt)] == Idx&&'), (296, 2, u'-  assert(OldVal != NewVa && "Node replaced with self?");'), (300, 2, u'-    assert(Ctx->ScopeRecordIdx[OldVal] == Idx && "Mapping out of date!");'), (315, 2, u'-  assert(unsigned(-Idx-1) < Ctx->ScopeInlinedAtRecords.size());'), (317, 2, u'-  assert((this == &Entry.first || this == &Entry.second) &&'), (322, 2, u'-  assert(OldScope != 0 && OldInlinedAt != 0 &&'), (326, 2, u'-  assert(Ctx->ScopeInlinedAtIdx[std::make_pair(OldScope, OldInlinedAt)] == Idx&&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 2, u'-  assert(F && "Argument is not in a function");'), (86, 2, u'-  assert(getType()->isPointerTy() && "Only pointers have alignments");'), (168, 2, u'-  assert(FunctionType::isValidReturnType(getReturnType()) &&'), (203, 2, u'-    assert(!FT->getParamType(i)->isVoidTy() &&'), (272, 2, u'-  assert(hasGC() && "Function has no collector");'), (304, 2, u'-  assert(isa<Function>(Src) && "Expected a Function!");'), (340, 2, u'-  assert(id < num_intrinsics && "Invalid intrinsic ID!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 2, u'-      assert (i < Functions.size() && ".gcda data does not match .gcno data");'), (116, 2, u'-  assert (Buff.readBlockTag() && "Block Tag not found!");'), (127, 2, u'-    assert (BlockNo < BlockCount && "Unexpected Block number!");'), (139, 2, u'-    assert (BlockNo < BlockCount && "Unexpected Block number!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(58, 2, u'-  assert((Align & (Align-1)) == 0 && "Alignment is not a power of 2!");'), (59, 2, u'-  assert(Align <= MaximumAlignment &&'), (62, 2, u'-  assert(getAlignment() == Align && "Alignment representation error!");'), (75, 2, u'-  assert(isa<GlobalAlias>(this));'), (92, 2, u'-    assert(InitVal->getType() == Ty &&'), (111, 2, u'-    assert(InitVal->getType() == Ty &&'), (144, 2, u'-  assert(getNumOperands() == 1 &&'), (149, 2, u'-  assert(getOperand(0) == From &&'), (153, 2, u'-  assert(isa<Constant>(To) &&'), (167, 2, u'-    assert(InitVal->getType() == getType()->getElementType() &&'), (178, 2, u'-  assert(isa<GlobalVariable>(Src) && "Expected a GlobalVariable!");'), (196, 2, u'-    assert(aliasee->getType() == Ty && "Alias and aliasee types should match!");'), (220, 2, u'-  assert((!Aliasee || Aliasee->getType() == getType()) &&'), (234, 2, u'-  assert((CE->getOpcode() == Instruction::BitCast ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(38, 2, u'-  assert(BB && BB->getParent() && "No current function!");'), (122, 2, u'-  assert(isa<PointerType>(Ptr->getType()) &&'), (128, 2, u'-    assert(Size->getType() == getInt64Ty() &&'), (137, 2, u'-  assert(isa<PointerType>(Ptr->getType()) &&'), (143, 2, u'-    assert(Size->getType() == getInt64Ty() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 2, u'-  assert(Verify(getFunctionType(), constraints) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 2, u'-    assert(InsertBefore->getParent() &&'), (44, 2, u'-  assert(InsertAtEnd && "Basic block to append to may not be NULL!");'), (51, 2, u'-  assert(Parent == 0 && "Instruction still linked in the program!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(247, 2, u'-  assert(OpNo < ReservedSpace && "Growing didn\'t work!");'), (260, 2, u'-  assert(NumOperands == Args.size() + 1 && "NumOperands not set up?");'), (267, 2, u'-  assert((Args.size() == FTy->getNumParams() ||'), (272, 2, u'-    assert((i >= FTy->getNumParams() ||'), (282, 2, u'-  assert(NumOperands == 1 && "NumOperands not set up?");'), (289, 2, u'-  assert(FTy->getNumParams() == 0 && "Calling a function with bad signature");'), (349, 2, u'-  assert(val && "IsConstantOne does not work with NULL val");'), (358, 2, u'-  assert(((!InsertBefore && InsertAtEnd) || (InsertBefore && !InsertAtEnd)) &&'), (395, 2, u'-  assert(AllocSize->getType() == IntPtrTy && "malloc arg is wrong size");'), (427, 2, u'-  assert(!MCall->getType()->isVoidTy() && "Malloc has void return type");'), (465, 2, u'-  assert(((!InsertBefore && InsertAtEnd) || (InsertBefore && !InsertAtEnd)) &&'), (467, 2, u'-  assert(Source->getType()->isPointerTy() &&'), (505, 2, u'-  assert(FreeCall && "CreateFree did not create a CallInst");'), (515, 2, u'-  assert(NumOperands == 3 + Args.size() && "NumOperands not set up?");'), (524, 2, u'-  assert(((Args.size() == FTy->getNumParams()) ||'), (529, 2, u'-    assert((i >= FTy->getNumParams() ||'), (697, 2, u'-void BranchInst::AssertOK() {'), (699, 2, u'-    assert(getCondition()->getType()->isIntegerTy(1) &&'), (707, 2, u'-  assert(IfTrue != 0 && "Branch destination may not be null!");'), (719, 2, u'-  AssertOK();'), (727, 2, u'-  assert(IfTrue != 0 && "Branch destination may not be null!");'), (740, 2, u'-  AssertOK();'), (751, 2, u'-    assert(BI.getNumOperands() == 3 && "BR can have 1 or 3 operands!");'), (759, 2, u'-  assert(isConditional() &&'), (798, 2, u'-    assert(!isa<BasicBlock>(Amt) &&'), (800, 2, u'-    assert(Amt->getType()->isIntegerTy() &&'), (811, 2, u'-  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (820, 2, u'-  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (829, 2, u'-  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (838, 2, u'-  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (847, 2, u'-  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (856, 2, u'-  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (865, 2, u'-  assert((Align & (Align-1)) == 0 && "Alignment is not a power of 2!");'), (866, 2, u'-  assert(Align <= MaximumAlignment &&'), (869, 2, u'-  assert(getAlignment() == Align && "Alignment representation error!");'), (898, 2, u'-void LoadInst::AssertOK() {'), (899, 2, u'-  assert(getOperand(0)->getType()->isPointerTy() &&'), (901, 2, u'-  assert(!(isAtomic() && getAlignment() == 0) &&'), (911, 2, u'-  AssertOK();'), (921, 2, u'-  AssertOK();'), (932, 2, u'-  AssertOK();'), (943, 2, u'-  AssertOK();'), (954, 2, u'-  AssertOK();'), (965, 2, u'-  AssertOK();'), (978, 2, u'-  AssertOK();'), (991, 2, u'-  AssertOK();'), (1001, 2, u'-  AssertOK();'), (1011, 2, u'-  AssertOK();'), (1022, 2, u'-  AssertOK();'), (1033, 2, u'-  AssertOK();'), (1038, 2, u'-  assert((Align & (Align-1)) == 0 && "Alignment is not a power of 2!");'), (1039, 2, u'-  assert(Align <= MaximumAlignment &&'), (1043, 2, u'-  assert(getAlignment() == Align && "Alignment representation error!");'), (1050, 2, u'-void StoreInst::AssertOK() {'), (1051, 2, u'-  assert(getOperand(0) && getOperand(1) && "Both operands must be non-null!");'), (1052, 2, u'-  assert(getOperand(1)->getType()->isPointerTy() &&'), (1054, 2, u'-  assert(getOperand(0)->getType() =='), (1057, 2, u'-  assert(!(isAtomic() && getAlignment() == 0) &&'), (1072, 2, u'-  AssertOK();'), (1085, 2, u'-  AssertOK();'), (1099, 2, u'-  AssertOK();'), (1113, 2, u'-  AssertOK();'), (1129, 2, u'-  AssertOK();'), (1143, 2, u'-  AssertOK();'), (1157, 2, u'-  AssertOK();'), (1173, 2, u'-  AssertOK();'), (1177, 2, u'-  assert((Align & (Align-1)) == 0 && "Alignment is not a power of 2!");'), (1178, 2, u'-  assert(Align <= MaximumAlignment &&'), (1182, 2, u'-  assert(getAlignment() == Align && "Alignment representation error!");'), (1198, 2, u'-  assert(getOperand(0) && getOperand(1) && getOperand(2) &&'), (1200, 2, u'-  assert(getOperand(0)->getType()->isPointerTy() &&'), (1202, 2, u'-  assert(getOperand(1)->getType() =='), (1205, 2, u'-  assert(getOperand(2)->getType() =='), (1208, 2, u'-  assert(Ordering != NotAtomic &&'), (1247, 2, u'-  assert(getOperand(0) && getOperand(1) &&'), (1249, 2, u'-  assert(getOperand(0)->getType()->isPointerTy() &&'), (1251, 2, u'-  assert(getOperand(1)->getType() =='), (1254, 2, u'-  assert(Ordering != NotAtomic &&'), (1306, 2, u'-  assert(NumOperands == 1 + IdxList.size() && "NumOperands not initialized?");'), (1333, 2, u'-    assert(IdxList.size() == 1 &&'), (1337, 2, u'-    assert(PTy && "Gep with invalid vector pointer found");'), (1434, 2, u'-  assert(isValidOperands(Val, Index) &&'), (1448, 2, u'-  assert(isValidOperands(Val, Index) &&'), (1474, 2, u'-  assert(isValidOperands(Vec, Elt, Index) &&'), (1488, 2, u'-  assert(isValidOperands(Vec, Elt, Index) &&'), (1524, 2, u'-  assert(isValidOperands(V1, V2, Mask) &&'), (1541, 2, u'-  assert(isValidOperands(V1, V2, Mask) &&'), (1602, 2, u'-  assert(i < Mask->getType()->getVectorNumElements() && "Index out of range");'), (1636, 2, u'-  assert(NumOperands == 2 && "NumOperands not initialized?");'), (1642, 2, u'-  assert(Idxs.size() > 0 && "InsertValueInst must have at least one index");'), (1644, 2, u'-  assert(ExtractValueInst::getIndexedType(Agg->getType(), Idxs) =='), (1667, 2, u'-  assert(NumOperands == 1 && "NumOperands not initialized?");'), (1671, 2, u'-  assert(Idxs.size() > 0 && "ExtractValueInst must have at least one index");'), (1749, 2, u'-  assert(LHS->getType() == RHS->getType() &&'), (1755, 2, u'-    assert(getType() == LHS->getType() &&'), (1757, 2, u'-    assert(getType()->isIntOrIntVectorTy() &&'), (1762, 2, u'-    assert(getType() == LHS->getType() &&'), (1764, 2, u'-    assert(getType()->isFPOrFPVectorTy() &&'), (1770, 2, u'-    assert(getType() == LHS->getType() &&'), (1772, 2, u'-    assert((getType()->isIntegerTy() || (getType()->isVectorTy() &&'), (1777, 2, u'-    assert(getType() == LHS->getType() &&'), (1779, 2, u'-    assert(getType()->isFPOrFPVectorTy() &&'), (1784, 2, u'-    assert(getType() == LHS->getType() &&'), (1786, 2, u'-    assert((getType()->isIntegerTy() || (getType()->isVectorTy() &&'), (1791, 2, u'-    assert(getType() == LHS->getType() &&'), (1793, 2, u'-    assert(getType()->isFPOrFPVectorTy() &&'), (1799, 2, u'-    assert(getType() == LHS->getType() &&'), (1801, 2, u'-    assert((getType()->isIntegerTy() ||'), (1808, 2, u'-    assert(getType() == LHS->getType() &&'), (1810, 2, u'-    assert((getType()->isIntegerTy() ||'), (1824, 2, u'-  assert(S1->getType() == S2->getType() &&'), (1954, 2, u'-  assert(isNot(BinOp) && "getNotArgument on non-\'not\' instruction!");'), (1960, 2, u'-  assert(isConstantAllOnes(Op1));'), (2273, 2, u'-  assert(castIsValid(op, S, Ty) && "Invalid cast!");'), (2294, 2, u'-  assert(castIsValid(op, S, Ty) && "Invalid cast!");'), (2364, 2, u'-  assert(S->getType()->isPointerTy() && "Invalid cast");'), (2365, 2, u'-  assert((Ty->isIntegerTy() || Ty->isPointerTy()) &&'), (2377, 2, u'-  assert(S->getType()->isPointerTy() && "Invalid cast");'), (2378, 2, u'-  assert((Ty->isIntegerTy() || Ty->isPointerTy()) &&'), (2389, 2, u'-  assert(C->getType()->isIntOrIntVectorTy() && Ty->isIntOrIntVectorTy() &&'), (2403, 2, u'-  assert(C->getType()->isIntOrIntVectorTy() && Ty->isIntOrIntVectorTy() &&'), (2417, 2, u'-  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&'), (2430, 2, u'-  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&'), (2515, 2, u'-  assert(SrcTy->isFirstClassType() && DestTy->isFirstClassType() &&'), (2553, 2, u'-      assert(DestBits == SrcBits &&'), (2557, 2, u'-      assert(SrcTy->isPointerTy() &&'), (2576, 2, u'-      assert(DestBits == SrcBits &&'), (2582, 2, u'-    assert(DestBits == SrcBits &&'), (2594, 2, u'-      assert(DestBits == SrcBits && "Casting vector of wrong width to X86_MMX");'), (2689, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal Trunc");'), (2695, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal Trunc");'), (2701, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal ZExt");'), (2707, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal ZExt");'), (2712, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal SExt");'), (2718, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal SExt");'), (2724, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPTrunc");'), (2730, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPTrunc");'), (2736, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPExt");'), (2742, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPExt");'), (2748, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal UIToFP");'), (2754, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal UIToFP");'), (2760, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal SIToFP");'), (2766, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal SIToFP");'), (2772, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPToUI");'), (2778, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPToUI");'), (2784, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPToSI");'), (2790, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPToSI");'), (2796, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal PtrToInt");'), (2802, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal PtrToInt");'), (2808, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal IntToPtr");'), (2814, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal IntToPtr");'), (2820, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal BitCast");'), (2826, 2, u'-  assert(castIsValid(getOpcode(), S, Ty) && "Illegal BitCast");'), (3121, 2, u'-  assert(Value && Default && NumReserved);'), (3177, 2, u'-  assert(OpNo+1 < ReservedSpace && "Growing didn\'t work!");'), (3189, 2, u'-  assert(2 + idx*2 < getNumOperands() && "Case index out of range!!!");'), (3239, 2, u'-  assert(Address && Address->getType()->isPointerTy() &&'), (3300, 2, u'-  assert(OpNo < ReservedSpace && "Growing didn\'t work!");'), (3308, 2, u'-  assert(idx < getNumOperands()-1 && "Successor index out of range!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 2, u'-  assert(DbgID == MD_dbg && "dbg kind id drifted"); (void)DbgID;'), (41, 2, u'-  assert(TBAAID == MD_tbaa && "tbaa kind id drifted"); (void)TBAAID;'), (45, 2, u'-  assert(ProfID == MD_prof && "prof kind id drifted"); (void)ProfID;'), (49, 2, u'-  assert(FPAccuracyID == MD_fpmath && "fpmath kind id drifted");'), (54, 2, u'-  assert(RangeID == MD_range && "range kind id drifted");'), (142, 2, u'-  assert(isValidName(Name) && "Invalid MDNode name");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(108, 2, u'-  assert(MDNodeSet.empty() && NonUniquedMDNodes.empty() &&')]
===========================================
Class:class MDNodeOperand : public CallbackVH { class MDNodeOperand : public CallbackVH 
Class:  class TypeFinder {   class TypeFinder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(378, 2, u'-  assert(Node->getNumOperands() == 3 &&'), (380, 2, u'-  assert(isa<ConstantInt>(Node->getOperand(0)) &&'), (390, 2, u'-  assert(!Materializer &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 2, u'-  assert(!Resolver && "Resolver is already set");'), (200, 2, u'-  assert((!isAnalysisGroup() || NormalCtor) &&'), (202, 2, u'-  assert(NormalCtor &&')]
===========================================
Class:class BBPassManager : public PMDataManager, public FunctionPass { class BBPassManager : public PMDataManager, public FunctionPass 
Class:class FunctionPassManagerImpl : public Pass, class FunctionPassManagerImpl : public Pass,
Class:       class MPPassManager : public Pass, public PMDataManager { class MPPassManager : public Pass, public PMDataManager 
Class:     class PassManagerImpl : public Pass,                         public PMDataManager,                         public PMTopLevelManager {                         public PMTopLevelManager 
Class:class TimingInfo { class TimingInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(110, 2, u'-  assert(Inserted && "Pass registered multiple times!");'), (127, 2, u'-  assert(I != Impl->PassInfoMap.end() && "Pass registered but not in map!");'), (155, 2, u'-  assert(Registeree.isAnalysisGroup() &&'), (160, 2, u'-    assert(ImplementationInfo &&'), (172, 2, u'-    assert(AGI.Implementations.count(ImplementationInfo) == 0 &&'), (176, 2, u'-      assert(InterfaceInfo->getNormalCtor() == 0 &&'), (178, 2, u'-      assert(ImplementationInfo->getNormalCtor() &&'), (206, 2, u'-  assert(I != Impl->Listeners.end() &&')]
===========================================
Class:  class PrintModulePass : public ModulePass {   class PrintModulePass : public ModulePass 
Class:   class PrintFunctionPass : public FunctionPass {   class PrintFunctionPass : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(162, 2, u'-  assert(isFloatingPointTy() && "Not a floating point type!");'), (168, 2, u'-  assert(getTypeID() == PPC_FP128TyID && "unknown fp type");'), (327, 2, u'-  assert(NumBits >= MIN_INT_BITS && "bitwidth too small");'), (328, 2, u'-  assert(NumBits <= MAX_INT_BITS && "bitwidth too large");'), (366, 2, u'-  assert(isValidReturnType(Result) && "invalid return type for function");'), (372, 2, u'-    assert(isValidArgumentType(Params[i]) &&'), (450, 2, u'-  assert(isOpaque() && "Struct body already set!");'), (519, 2, u'-  assert(type != 0 && "Cannot create a struct type with no elements with this");'), (549, 2, u'-  assert(!Elements.empty() &&'), (555, 2, u'-  assert(!Elements.empty() &&'), (561, 2, u'-  assert(type != 0 && "Cannot create a struct type with no elements with this");'), (595, 2, u'-  assert(!isLiteral() && "Literal structs never have names");'), (602, 2, u'-  assert(type != 0 && "Cannot create a struct type with no elements with this");'), (649, 2, u'-    assert(indexValid(Idx) && "Invalid structure index!");'), (657, 2, u'-    assert(indexValid(Idx) && "Invalid structure index!");'), (696, 2, u'-  assert(isValidElementType(ElementType) && "Invalid type for array element!");'), (723, 2, u'-  assert(NumElements > 0 && "#Elements of a VectorType must be greater than 0");'), (724, 2, u'-  assert(isValidElementType(ElementType) &&'), (747, 2, u'-  assert(EltTy && "Can\'t get a pointer to <null> type!");'), (748, 2, u'-  assert(isValidElementType(EltTy) && "Invalid type for pointer element!");'), (769, 2, u'-  assert(oldNCT == NumContainedTys && "bitfield written out of bounds?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 2, u'-  assert((!isa<Constant>(this) || isa<GlobalValue>(this)) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(39, 2, u'-  assert(Ty && "Value defined with a null type: Error!");'), (49, 2, u'-    assert((VTy->isFirstClassType() || VTy->isVoidTy() || VTy->isStructTy()) &&'), (52, 2, u'-    assert((VTy->isFirstClassType() || VTy->isVoidTy()) &&'), (75, 2, u'-  assert(use_empty() && "Uses remain when a value is destroyed!");'), (158, 2, u'-    assert(isa<Constant>(V) && "Unknown value type!");'), (173, 2, u'-  assert(SubclassID != MDStringVal &&'), (187, 2, u'-  assert(!getType()->isVoidTy() && "Cannot assign a name to void values!");'), (234, 2, u'-  assert(SubclassID != MDStringVal && "Cannot take the name of an MDString!");'), (271, 2, u'-  assert(!Failure && "V has a name, so it should have a ST!"); (void)Failure;'), (298, 2, u'-  assert(New && "Value::replaceAllUsesWith(<null>) is invalid!");'), (299, 2, u'-  assert(New != this && "this->replaceAllUsesWith(this) is NOT valid!");'), (300, 2, u'-  assert(New->getType() == getType() &&'), (369, 2, u'-    assert(V->getType()->isPointerTy() && "Unexpected operand type!");'), (477, 2, u'-  assert(List && "Handle list is null?");'), (485, 2, u'-    assert(VP.getPointer() == Next->VP.getPointer() && "Added to wrong list?");'), (490, 2, u'-  assert(List && "Must insert after existing node");'), (501, 2, u'-  assert(VP.getPointer() && "Null pointer doesn\'t have a use list!");'), (509, 2, u'-    assert(Entry != 0 && "Value doesn\'t have any handles?");'), (523, 2, u'-  assert(Entry == 0 && "Value really did already have handles?");'), (537, 2, u'-    assert(I->second && I->first == I->second->VP.getPointer() &&'), (545, 2, u'-  assert(VP.getPointer() && VP.getPointer()->HasValueHandle &&'), (550, 2, u'-  assert(*PrevPtr == this && "List invariant broken");'), (554, 2, u'-    assert(Next->getPrevPtr() == &Next && "List invariant broken");'), (572, 2, u'-  assert(V->HasValueHandle && "Should only be called if ValueHandles present");'), (578, 2, u'-  assert(Entry && "Value bit set but no entries exist");'), (589, 2, u'-  for (ValueHandleBase Iterator(Assert, *Entry); Entry; Entry = Iterator.Next) {'), (592, 2, u'-    assert(Entry->Next == &Iterator && "Loop invariant broken.");'), (595, 2, u'-    case Assert:'), (618, 2, u'-    if (pImpl->ValueHandles[V]->getKind() == Assert)'), (629, 2, u'-  assert(Old->HasValueHandle &&"Should only be called if ValueHandles present");'), (630, 2, u'-  assert(Old != New && "Changing value into itself!");'), (637, 2, u'-  assert(Entry && "Value bit set but no entries exist");'), (643, 2, u'-  for (ValueHandleBase Iterator(Assert, *Entry); Entry; Entry = Iterator.Next) {'), (646, 2, u'-    assert(Entry->Next == &Iterator && "Loop invariant broken.");'), (649, 2, u'-    case Assert:')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 2, u'-  assert(vmap.empty() && "Values remain in symbol table!");'), (37, 2, u'-  assert(V->hasName() && "Can\'t insert nameless Value into symbol table");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 2, u'-  assert(VT.isExtended() && "Type is not extended!");'), (39, 2, u'-  assert(ResultVT.isExtended() && "Type is not extended!");'), (44, 2, u'-  assert(isExtended() && "Type is not extended!");'), (49, 2, u'-  assert(isExtended() && "Type is not extended!");'), (54, 2, u'-  assert(isExtended() && "Type is not extended!");'), (75, 2, u'-  assert(isExtended() && "Type is not extended!");'), (80, 2, u'-  assert(isExtended() && "Type is not extended!");'), (85, 2, u'-  assert(isExtended() && "Type is not extended!");'), (152, 2, u'-    assert(isExtended() && "Type is not extended!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(360, 2, u'-#define Assert(C, M) \\'), (362, 2, u'-#define Assert1(C, M, V1) \\'), (364, 2, u'-#define Assert2(C, M, V1, V2) \\'), (366, 2, u'-#define Assert3(C, M, V1, V2, V3) \\'), (368, 2, u'-#define Assert4(C, M, V1, V2, V3, V4) \\'), (373, 2, u'-    Assert1(I.getOperand(i) != 0, "Operand is null", &I);'), (379, 2, u'-  Assert1(!GV.isDeclaration() ||'), (389, 2, u'-  Assert1(!GV.hasDLLImportLinkage() || GV.isDeclaration(),'), (392, 2, u'-  Assert1(!GV.hasAppendingLinkage() || isa<GlobalVariable>(GV),'), (397, 2, u'-    Assert1(GVar && GVar->getType()->getElementType()->isArrayTy(),'), (401, 2, u'-  Assert1(!GV.hasLinkerPrivateWeakDefAutoLinkage() || GV.hasDefaultVisibility(),'), (408, 2, u'-    Assert1(GV.getInitializer()->getType() == GV.getType()->getElementType(),'), (415, 2, u'-      Assert1(GV.getInitializer()->isNullValue(),'), (417, 2, u'-      Assert1(!GV.isConstant(), "\'common\' global may not be marked constant!",'), (421, 2, u'-    Assert1(GV.hasExternalLinkage() || GV.hasDLLImportLinkage() ||'), (428, 2, u'-    Assert1(!GV.hasInitializer() || GV.hasAppendingLinkage(),'), (436, 2, u'-      Assert1(STy && STy->getNumElements() == 2 &&'), (447, 2, u'-  Assert1(!GA.getName().empty(),'), (449, 2, u'-  Assert1(GA.hasExternalLinkage() || GA.hasLocalLinkage() ||'), (452, 2, u'-  Assert1(GA.getAliasee(),'), (454, 2, u'-  Assert1(GA.getType() == GA.getAliasee()->getType(),'), (456, 2, u'-  Assert1(!GA.hasUnnamedAddr(), "Alias cannot have unnamed_addr!", &GA);'), (460, 2, u'-    Assert1(CE &&'), (469, 2, u'-  Assert1(Aliasee,'), (481, 2, u'-    Assert1(!MD->isFunctionLocal(),'), (500, 2, u'-      Assert2(MD.isFunctionLocal() || !N->isFunctionLocal(),'), (505, 2, u'-    Assert2(MD.isFunctionLocal(), "Invalid operand for global metadata!", &MD, Op);'), (516, 2, u'-    assert(ActualF && "Unimplemented function local metadata case!");'), (518, 2, u'-    Assert2(ActualF == F, "function-local metadata used in wrong function",'), (531, 2, u'-  Assert1(!FnCheckAttr, "Attribute " + Attribute::getAsString(FnCheckAttr) +'), (536, 2, u'-    Assert1(!RetI, "Attribute " + Attribute::getAsString(RetI) +'), (543, 2, u'-    Assert1(MutI.isEmptyOrSingleton(), "Attributes " +'), (548, 2, u'-  Assert1(!TypeI, "Wrong type for attribute " +'), (553, 2, u'-    Assert1(!ByValI || PTy->getElementType()->isSized(),'), (557, 2, u'-    Assert1(!ByValI,'), (587, 2, u'-      Assert1(!SawNest, "More than one parameter has attribute nest!", V);'), (592, 2, u'-      Assert1(Attr.Index == 1, "Attribute sret not on first parameter!", V);'), (597, 2, u'-  Assert1(!NotFn, "Attribute " + Attribute::getAsString(NotFn) +'), (603, 2, u'-    Assert1(MutI.isEmptyOrSingleton(), "Attributes " +'), (629, 2, u'-  Assert1(Context == &F.getContext(),'), (632, 2, u'-  Assert1(!F.hasCommonLinkage(), "Functions may not have common linkage", &F);'), (633, 2, u'-  Assert2(FT->getNumParams() == NumArgs,'), (636, 2, u'-  Assert1(F.getReturnType()->isFirstClassType() ||'), (641, 2, u'-  Assert1(!F.hasStructRetAttr() || F.getReturnType()->isVoidTy(),'), (646, 2, u'-  Assert1(VerifyAttributeCount(Attrs, FT->getNumParams()),'), (664, 2, u'-    Assert1(!F.isVarArg(),'), (676, 2, u'-    Assert2(I->getType() == FT->getParamType(i),'), (679, 2, u'-    Assert1(I->getType()->isFirstClassType(),'), (682, 2, u'-      Assert2(!I->getType()->isMetadataTy(),'), (689, 2, u'-    Assert1(F.hasExternalLinkage() || F.hasDLLImportLinkage() ||'), (695, 2, u'-    Assert1(!isLLVMdotName, "llvm intrinsics cannot be defined!", &F);'), (699, 2, u'-    Assert1(pred_begin(Entry) == pred_end(Entry),'), (704, 2, u'-      Assert1(!BlockAddress::get(Entry)->isConstantUsed(),'), (714, 2, u'-      Assert1(0, "Invalid user of intrinsic instruction!", U);'), (724, 2, u'-  Assert1(BB.getTerminator(), "Basic Block does not have terminator!", &BB);'), (735, 2, u'-      Assert1(PN->getNumIncomingValues() != 0,'), (738, 2, u'-      Assert1(PN->getNumIncomingValues() == Preds.size(),'), (755, 2, u'-        Assert4(i == 0 || Values[i].first  != Values[i-1].first ||'), (763, 2, u'-        Assert3(Values[i].first == Preds[i],'), (773, 2, u'-  Assert1(&I == I.getParent()->getTerminator(),'), (780, 2, u'-    Assert2(BI.getCondition()->getType()->isIntegerTy(1),'), (790, 2, u'-    Assert2(N == 0,'), (794, 2, u'-    Assert2(N == 1 && F->getReturnType() == RI.getOperand(0)->getType(),'), (809, 2, u'-    Assert1(i.getCaseValue()->getType() == SwitchTy,'), (811, 2, u'-    Assert2(Constants.insert(i.getCaseValue()),'), (819, 2, u'-  Assert1(BI.getAddress()->getType()->isPointerTy(),'), (822, 2, u'-    Assert1(BI.getDestination(i)->getType()->isLabelTy(),'), (829, 2, u'-  Assert1(!SelectInst::areInvalidOperands(SI.getOperand(0), SI.getOperand(1),'), (833, 2, u'-  Assert1(SI.getTrueValue()->getType() == SI.getType(),'), (842, 2, u'-  Assert1(0, "User-defined operators should not live outside of a pass!", &I);'), (854, 2, u'-  Assert1(SrcTy->isIntOrIntVectorTy(), "Trunc only operates on integer", &I);'), (855, 2, u'-  Assert1(DestTy->isIntOrIntVectorTy(), "Trunc only produces integer", &I);'), (856, 2, u'-  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (858, 2, u'-  Assert1(SrcBitSize > DestBitSize,"DestTy too big for Trunc", &I);'), (869, 2, u'-  Assert1(SrcTy->isIntOrIntVectorTy(), "ZExt only operates on integer", &I);'), (870, 2, u'-  Assert1(DestTy->isIntOrIntVectorTy(), "ZExt only produces an integer", &I);'), (871, 2, u'-  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (876, 2, u'-  Assert1(SrcBitSize < DestBitSize,"Type too small for ZExt", &I);'), (890, 2, u'-  Assert1(SrcTy->isIntOrIntVectorTy(), "SExt only operates on integer", &I);'), (891, 2, u'-  Assert1(DestTy->isIntOrIntVectorTy(), "SExt only produces an integer", &I);'), (892, 2, u'-  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (894, 2, u'-  Assert1(SrcBitSize < DestBitSize,"Type too small for SExt", &I);'), (907, 2, u'-  Assert1(SrcTy->isFPOrFPVectorTy(),"FPTrunc only operates on FP", &I);'), (908, 2, u'-  Assert1(DestTy->isFPOrFPVectorTy(),"FPTrunc only produces an FP", &I);'), (909, 2, u'-  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (911, 2, u'-  Assert1(SrcBitSize > DestBitSize,"DestTy too big for FPTrunc", &I);'), (925, 2, u'-  Assert1(SrcTy->isFPOrFPVectorTy(),"FPExt only operates on FP", &I);'), (926, 2, u'-  Assert1(DestTy->isFPOrFPVectorTy(),"FPExt only produces an FP", &I);'), (927, 2, u'-  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (929, 2, u'-  Assert1(SrcBitSize < DestBitSize,"DestTy too small for FPExt", &I);'), (942, 2, u'-  Assert1(SrcVec == DstVec,'), (944, 2, u'-  Assert1(SrcTy->isIntOrIntVectorTy(),'), (946, 2, u'-  Assert1(DestTy->isFPOrFPVectorTy(),'), (950, 2, u'-    Assert1(cast<VectorType>(SrcTy)->getNumElements() =='), (965, 2, u'-  Assert1(SrcVec == DstVec,'), (967, 2, u'-  Assert1(SrcTy->isIntOrIntVectorTy(),'), (969, 2, u'-  Assert1(DestTy->isFPOrFPVectorTy(),'), (973, 2, u'-    Assert1(cast<VectorType>(SrcTy)->getNumElements() =='), (988, 2, u'-  Assert1(SrcVec == DstVec,'), (990, 2, u'-  Assert1(SrcTy->isFPOrFPVectorTy(), "FPToUI source must be FP or FP vector",'), (992, 2, u'-  Assert1(DestTy->isIntOrIntVectorTy(),'), (996, 2, u'-    Assert1(cast<VectorType>(SrcTy)->getNumElements() =='), (1011, 2, u'-  Assert1(SrcVec == DstVec,'), (1013, 2, u'-  Assert1(SrcTy->isFPOrFPVectorTy(),'), (1015, 2, u'-  Assert1(DestTy->isIntOrIntVectorTy(),'), (1019, 2, u'-    Assert1(cast<VectorType>(SrcTy)->getNumElements() =='), (1031, 2, u'-  Assert1(SrcTy->getScalarType()->isPointerTy(),'), (1033, 2, u'-  Assert1(DestTy->getScalarType()->isIntegerTy(),'), (1035, 2, u'-  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (1041, 2, u'-    Assert1(VSrc->getNumElements() == VDest->getNumElements(),'), (1053, 2, u'-  Assert1(SrcTy->getScalarType()->isIntegerTy(),'), (1055, 2, u'-  Assert1(DestTy->getScalarType()->isPointerTy(),'), (1057, 2, u'-  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (1062, 2, u'-    Assert1(VSrc->getNumElements() == VDest->getNumElements(),'), (1079, 2, u'-  Assert1(DestTy->isPointerTy() == DestTy->isPointerTy(),'), (1081, 2, u'-  Assert1(SrcBitSize == DestBitSize, "Bitcast requires types of same width",&I);'), (1084, 2, u'-  Assert1(!SrcTy->isAggregateType(),'), (1086, 2, u'-  Assert1(!DestTy->isAggregateType(),'), (1099, 2, u'-  Assert2(&PN == &PN.getParent()->front() ||'), (1107, 2, u'-    Assert1(PN.getType() == PN.getIncomingValue(i)->getType(),'), (1119, 2, u'-  Assert1(CS.getCalledValue()->getType()->isPointerTy(),'), (1123, 2, u'-  Assert1(FPTy->getElementType()->isFunctionTy(),'), (1129, 2, u'-    Assert1(CS.arg_size() >= FTy->getNumParams(),'), (1132, 2, u'-    Assert1(CS.arg_size() == FTy->getNumParams(),'), (1137, 2, u'-    Assert3(CS.getArgument(i)->getType() == FTy->getParamType(i),'), (1143, 2, u'-  Assert1(VerifyAttributeCount(Attrs, CS.arg_size()),'), (1157, 2, u'-      Assert1(!VArgI, "Attribute " + Attribute::getAsString(VArgI) +'), (1166, 2, u'-      Assert1(!(*PI)->isMetadataTy(),'), (1186, 2, u'-  Assert1(II.getUnwindDest()->isLandingPad(),'), (1196, 2, u'-  Assert1(B.getOperand(0)->getType() == B.getOperand(1)->getType(),'), (1209, 2, u'-    Assert1(B.getType()->isIntOrIntVectorTy(),'), (1211, 2, u'-    Assert1(B.getType() == B.getOperand(0)->getType(),'), (1222, 2, u'-    Assert1(B.getType()->isFPOrFPVectorTy(),'), (1225, 2, u'-    Assert1(B.getType() == B.getOperand(0)->getType(),'), (1233, 2, u'-    Assert1(B.getType()->isIntOrIntVectorTy(),'), (1235, 2, u'-    Assert1(B.getType() == B.getOperand(0)->getType(),'), (1242, 2, u'-    Assert1(B.getType()->isIntOrIntVectorTy(),'), (1244, 2, u'-    Assert1(B.getType() == B.getOperand(0)->getType(),'), (1258, 2, u'-  Assert1(Op0Ty == Op1Ty,'), (1261, 2, u'-  Assert1(Op0Ty->isIntOrIntVectorTy() || Op0Ty->getScalarType()->isPointerTy(),'), (1264, 2, u'-  Assert1(IC.getPredicate() >= CmpInst::FIRST_ICMP_PREDICATE &&'), (1275, 2, u'-  Assert1(Op0Ty == Op1Ty,'), (1278, 2, u'-  Assert1(Op0Ty->isFPOrFPVectorTy(),'), (1281, 2, u'-  Assert1(FC.getPredicate() >= CmpInst::FIRST_FCMP_PREDICATE &&'), (1289, 2, u'-  Assert1(ExtractElementInst::isValidOperands(EI.getOperand(0),'), (1296, 2, u'-  Assert1(InsertElementInst::isValidOperands(IE.getOperand(0),'), (1304, 2, u'-  Assert1(ShuffleVectorInst::isValidOperands(SV.getOperand(0), SV.getOperand(1),'), (1313, 2, u'-  Assert1(isa<PointerType>(TargetTy),'), (1315, 2, u'-  Assert1(cast<PointerType>(TargetTy)->getElementType()->isSized(),'), (1321, 2, u'-  Assert1(ElTy, "Invalid indices for GEP pointer type!", &GEP);'), (1325, 2, u'-    Assert2(GEP.getType()->isPointerTy() &&'), (1330, 2, u'-    Assert1(Idxs.size() == 1, "Invalid number of indices!", &GEP);'), (1333, 2, u'-    Assert1(IndexTy->isVectorTy(),'), (1335, 2, u'-    Assert1(GEP.getType()->isVectorTy(),'), (1338, 2, u'-    Assert1(ElemPtr->isPointerTy(),'), (1342, 2, u'-    Assert1(IndexWidth == GepWidth, "Invalid GEP index vector width", &GEP);'), (1343, 2, u'-    Assert1(ElTy == cast<PointerType>(ElemPtr)->getElementType(),'), (1351, 2, u'-  Assert1(PTy, "Load operand must be a pointer.", &LI);'), (1353, 2, u'-  Assert2(ElTy == LI.getType(),'), (1356, 2, u'-    Assert1(LI.getOrdering() != Release && LI.getOrdering() != AcquireRelease,'), (1358, 2, u'-    Assert1(LI.getAlignment() != 0,'), (1361, 2, u'-    Assert1(LI.getSynchScope() == CrossThread,'), (1367, 2, u'-    Assert1(NumOperands % 2 == 0, "Unfinished range!", Range);'), (1369, 2, u'-    Assert1(NumRanges >= 1, "It should have at least one range!", Range);'), (1372, 2, u'-      Assert1(Low, "The lower limit must be an integer!", Low);'), (1374, 2, u'-      Assert1(High, "The upper limit must be an integer!", High);'), (1375, 2, u'-      Assert1(High->getType() == Low->getType() &&'), (1378, 2, u'-      Assert1(High->getValue() != Low->getValue(), "Range must not be empty!",'), (1388, 2, u'-  Assert1(PTy, "Store operand must be a pointer.", &SI);'), (1390, 2, u'-  Assert2(ElTy == SI.getOperand(0)->getType(),'), (1394, 2, u'-    Assert1(SI.getOrdering() != Acquire && SI.getOrdering() != AcquireRelease,'), (1396, 2, u'-    Assert1(SI.getAlignment() != 0,'), (1399, 2, u'-    Assert1(SI.getSynchScope() == CrossThread,'), (1407, 2, u'-  Assert1(PTy->getAddressSpace() == 0,'), (1410, 2, u'-  Assert1(PTy->getElementType()->isSized(), "Cannot allocate unsized type",'), (1412, 2, u'-  Assert1(AI.getArraySize()->getType()->isIntegerTy(),'), (1418, 2, u'-  Assert1(CXI.getOrdering() != NotAtomic,'), (1420, 2, u'-  Assert1(CXI.getOrdering() != Unordered,'), (1423, 2, u'-  Assert1(PTy, "First cmpxchg operand must be a pointer.", &CXI);'), (1425, 2, u'-  Assert2(ElTy == CXI.getOperand(1)->getType(),'), (1428, 2, u'-  Assert2(ElTy == CXI.getOperand(2)->getType(),'), (1435, 2, u'-  Assert1(RMWI.getOrdering() != NotAtomic,'), (1437, 2, u'-  Assert1(RMWI.getOrdering() != Unordered,'), (1440, 2, u'-  Assert1(PTy, "First atomicrmw operand must be a pointer.", &RMWI);'), (1442, 2, u'-  Assert2(ElTy == RMWI.getOperand(1)->getType(),'), (1445, 2, u'-  Assert1(AtomicRMWInst::FIRST_BINOP <= RMWI.getOperation() &&'), (1453, 2, u'-  Assert1(Ordering == Acquire || Ordering == Release ||'), (1461, 2, u'-  Assert1(ExtractValueInst::getIndexedType(EVI.getAggregateOperand()->getType(),'), (1470, 2, u'-  Assert1(ExtractValueInst::getIndexedType(IVI.getAggregateOperand()->getType(),'), (1483, 2, u'-  Assert1(LPI.getNumClauses() > 0 || LPI.isCleanup(),'), (1490, 2, u'-    Assert1(II && II->getUnwindDest() == BB,'), (1497, 2, u'-  Assert1(LPI.getParent()->getLandingPadInst() == &LPI,'), (1504, 2, u'-    Assert1(LPI.getPersonalityFn() == PersonalityFn,'), (1509, 2, u'-  Assert1(isa<Constant>(PersonalityFn), "Personality function is not constant!",'), (1513, 2, u'-    Assert1(isa<Constant>(Clause), "Clause is not constant!", &LPI);'), (1515, 2, u'-      Assert1(isa<PointerType>(Clause->getType()),'), (1518, 2, u'-      Assert1(LPI.isFilter(i), "Clause is neither catch nor filter!", &LPI);'), (1519, 2, u'-      Assert1(isa<ConstantArray>(Clause) || isa<ConstantAggregateZero>(Clause),'), (1536, 2, u'-    Assert2(InstsInThisBlock.count(Op) || !DT->isReachableFromEntry(BB) ||'), (1554, 2, u'-    Assert2(UseBlock, "Invoke operand is PHI node with bad incoming-BB",'), (1560, 2, u'-      Assert2(BB == NormalDest || !DT->isReachableFromEntry(UseBlock),'), (1564, 2, u'-      Assert2(DT->dominates(II, UseBlock) ||'), (1574, 2, u'-  Assert2(PredBB && (DT->dominates(OpBlock, PredBB) ||'), (1583, 2, u'-  Assert1(BB, "Instruction not embedded in basic block!", &I);'), (1588, 2, u'-      Assert1(*UI != (User*)&I || !DT->isReachableFromEntry(BB),'), (1593, 2, u'-  Assert1(!I.getType()->isVoidTy() || !I.hasName(),'), (1598, 2, u'-  Assert1(I.getType()->isVoidTy() ||'), (1604, 2, u'-  Assert1(!I.getType()->isMetadataTy() ||'), (1614, 2, u'-      Assert2(Used->getParent() != 0, "Instruction referencing instruction not"'), (1623, 2, u'-    Assert1(I.getOperand(i) != 0, "Instruction has null operand!", &I);'), (1628, 2, u'-      Assert1(0, "Instruction operands must be first-class values!", &I);'), (1634, 2, u'-      Assert1(!F->isIntrinsic() || (i + 1 == e && isa<CallInst>(I)),'), (1636, 2, u'-      Assert1(F->getParent() == Mod, "Referencing function in another module!",'), (1639, 2, u'-      Assert1(OpBB->getParent() == BB->getParent(),'), (1642, 2, u'-      Assert1(OpArg->getParent() == BB->getParent(),'), (1645, 2, u'-      Assert1(GV->getParent() == Mod, "Referencing global in another module!",'), (1650, 2, u'-      Assert1((i + 1 == e && isa<CallInst>(I)) ||'), (1657, 2, u'-    Assert1(I.getType()->isFPOrFPVectorTy(),'), (1659, 2, u'-    Assert1(MD->getNumOperands() == 1, "fpmath takes one operand!", &I);'), (1663, 2, u'-      Assert1(Accuracy.isNormal() && !Accuracy.isNegative(),'), (1666, 2, u'-      Assert1(false, "invalid fpmath accuracy!", &I);'), (1671, 2, u'-  Assert1(!MD || isa<LoadInst>(I), "Ranges are only for loads!", &I);'), (1685, 2, u'-  Assert1(IF->isDeclaration(), "Intrinsic functions should never be defined!",'), (1703, 2, u'-    Assert1(isa<ConstantInt>(CI.getArgOperand(1)),'), (1708, 2, u'-    Assert1(CI.getArgOperand(0) && isa<MDNode>(CI.getArgOperand(0)),'), (1711, 2, u'-    Assert1(MD->getNumOperands() == 1,'), (1717, 2, u'-    Assert1(isa<ConstantInt>(CI.getArgOperand(3)),'), (1720, 2, u'-    Assert1(isa<ConstantInt>(CI.getArgOperand(4)),'), (1730, 2, u'-      Assert1(AI, "llvm.gcroot parameter #1 must be an alloca.", &CI);'), (1731, 2, u'-      Assert1(isa<Constant>(CI.getArgOperand(1)),'), (1734, 2, u'-        Assert1(!isa<ConstantPointerNull>(CI.getArgOperand(1)),'), (1740, 2, u'-    Assert1(CI.getParent()->getParent()->hasGC(),'), (1744, 2, u'-    Assert1(isa<Function>(CI.getArgOperand(1)->stripPointerCasts()),'), (1749, 2, u'-    Assert1(isa<ConstantInt>(CI.getArgOperand(1)) &&'), (1757, 2, u'-    Assert1(isa<AllocaInst>(CI.getArgOperand(1)->stripPointerCasts()),'), (1764, 2, u'-    Assert1(isa<ConstantInt>(CI.getArgOperand(0)),'), (1769, 2, u'-    Assert1(isa<ConstantInt>(CI.getArgOperand(1)),'), (2025, 2, u'-  Assert1(F->getAttributes() == Intrinsic::getAttributes(ID),'), (2044, 2, u'-  assert(!F.isDeclaration() && "Cannot verify external functions");')]
===========================================
Class:  class CrashOnCalls : public BasicBlockPass {   class CrashOnCalls : public BasicBlockPass 
Class:  class DeleteCalls : public BasicBlockPass {   class DeleteCalls : public BasicBlockPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(115, 2, u'-  assert(Program == 0 && "Cannot call addSources multiple times!");'), (116, 2, u'-  assert(!Filenames.empty() && "Must specify at least on input filename!");')]
===========================================
Class:  class ReducePassList : public ListReducer<std::string> {   class ReducePassList : public ListReducer<std::string> 
Class:  class ReduceCrashingGlobalVariables : public ListReducer<GlobalVariable*> {   class ReduceCrashingGlobalVariables : public ListReducer<GlobalVariable*> 
Class:  class ReduceCrashingFunctions : public ListReducer<Function*> {   class ReduceCrashingFunctions : public ListReducer<Function*> 
Class:  class ReduceCrashingBlocks : public ListReducer<const BasicBlock*> {   class ReduceCrashingBlocks : public ListReducer<const BasicBlock*> 
Class:  class ReduceCrashingInstructions : public ListReducer<const Instruction*> {   class ReduceCrashingInstructions : public ListReducer<const Instruction*> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(300, 2, u'-  assert(AI && "Interpreter should have been created already!");'), (382, 2, u'-  assert(Interpreter && "Interpreter should have been created already!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(184, 2, u'-    assert(M->size() < NewM->size() && "Loop extract removed functions?");'), (200, 2, u'-  assert(F->isDeclaration() && "This didn\'t make the function external!");'), (206, 2, u'-  assert(!TorList.empty() && "Don\'t create empty tor list!");'), (273, 2, u'-  assert(GV && "Not a clone of M1?");'), (274, 2, u'-  assert(GV->use_empty() && "llvm.ctors shouldn\'t have uses!");')]
===========================================
Class:  class ReduceMiscompilingPasses : public ListReducer<std::string> {   class ReduceMiscompilingPasses : public ListReducer<std::string> 
Class:  class ReduceMiscompilingFunctions : public ListReducer<Function*> {   class ReduceMiscompilingFunctions : public ListReducer<Function*> 
Class:  class ReduceMiscompiledBlocks : public ListReducer<BasicBlock*> {   class ReduceMiscompiledBlocks : public ListReducer<BasicBlock*> 
Class:  class LLI : public AbstractInterpreter {   class LLI : public AbstractInterpreter 
Class:  class CustomCompiler : public AbstractInterpreter {   class CustomCompiler : public AbstractInterpreter 
Class:  class CustomExecutor : public AbstractInterpreter {   class CustomExecutor : public AbstractInterpreter 
Class:  class JIT : public AbstractInterpreter {   class JIT : public AbstractInterpreter 
Class:  class AddToDriver : public FunctionPassManager {   class AddToDriver : public FunctionPassManager 
Class:class PrintFunctionsConsumer : public ASTConsumer { class PrintFunctionsConsumer : public ASTConsumer 
Class: class PrintFunctionNamesAction : public PluginASTAction { class PrintFunctionNamesAction : public PluginASTAction 
Class:class MainCallChecker : public Checker < check::PreStmt<CallExpr> > { class MainCallChecker : public Checker < check::PreStmt<CallExpr> > 
Class:class CaptureDiagnosticConsumer : public DiagnosticConsumer { class CaptureDiagnosticConsumer : public DiagnosticConsumer 
Class:class ARCMTMacroTrackerPPCallbacks : public PPCallbacks { class ARCMTMacroTrackerPPCallbacks : public PPCallbacks 
Class: class ARCMTMacroTrackerAction : public ASTFrontendAction { class ARCMTMacroTrackerAction : public ASTFrontendAction 
Class: class RewritesApplicator : public TransformActions::RewriteReceiver { class RewritesApplicator : public TransformActions::RewriteReceiver 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-  assert(ToFromMappings.empty());'), (45, 2, u'-  assert(!outputDir.empty());'), (60, 2, u'-  assert(FromToMappings.empty() &&'), (247, 2, u'-  assert(file);'), (254, 2, u'-  assert(file && newfile);'), (269, 2, u'-    assert(FromToMappings.find(file) != FromToMappings.end() &&')]
===========================================
Class:class ObjCMigrateASTConsumer : public ASTConsumer { class ObjCMigrateASTConsumer : public ASTConsumer 
Class:class ObjCMigrator : public RecursiveASTVisitor<ObjCMigrator> { class ObjCMigrator : public RecursiveASTVisitor<ObjCMigrator> 
Class:class RewritesReceiver : public edit::EditsReceiver { class RewritesReceiver : public edit::EditsReceiver 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-  assert(I != FIDs.end());')]
===========================================
Class:class APIChecker : public RecursiveASTVisitor<APIChecker> { class APIChecker : public RecursiveASTVisitor<APIChecker> 
Class:class ARCAssignChecker : public RecursiveASTVisitor<ARCAssignChecker> { class ARCAssignChecker : public RecursiveASTVisitor<ARCAssignChecker> 
Class:class ReleaseCollector : public RecursiveASTVisitor<ReleaseCollector> { class ReleaseCollector : public RecursiveASTVisitor<ReleaseCollector> 
Class:class AutoreleasePoolRewriter class AutoreleasePoolRewriter
Class:class RootBlockObjCVarRewriter : class RootBlockObjCVarRewriter :
Class:  class BlockVarChecker : public RecursiveASTVisitor<BlockVarChecker> {   class BlockVarChecker : public RecursiveASTVisitor<BlockVarChecker> 
Class: class BlockObjCVarRewriter : public RecursiveASTVisitor<BlockObjCVarRewriter> { class BlockObjCVarRewriter : public RecursiveASTVisitor<BlockObjCVarRewriter> 
Class:class EmptyChecker : public StmtVisitor<EmptyChecker, bool> { class EmptyChecker : public StmtVisitor<EmptyChecker, bool> 
Class: class EmptyStatementsRemover :                             public RecursiveASTVisitor<EmptyStatementsRemover> {                             public RecursiveASTVisitor<EmptyStatementsRemover> 
Class:class GCAttrsCollector : public RecursiveASTVisitor<GCAttrsCollector> { class GCAttrsCollector : public RecursiveASTVisitor<GCAttrsCollector> 
Class:class GCCollectableCallsChecker : class GCCollectableCallsChecker :
Class:class PropertiesRewriter { class PropertiesRewriter 
Class:  class PlusOneAssign : public RecursiveASTVisitor<PlusOneAssign> {   class PlusOneAssign : public RecursiveASTVisitor<PlusOneAssign> 
Class:class RetainReleaseDeallocRemover : class RetainReleaseDeallocRemover :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(255, 2, u'-    assert(E);')]
===========================================
Class:class UnbridgedCastRewriter : public RecursiveASTVisitor<UnbridgedCastRewriter>{ class UnbridgedCastRewriter : public RecursiveASTVisitor<UnbridgedCastRewriter>
Class:class UnusedInitRewriter : public RecursiveASTVisitor<UnusedInitRewriter> { class UnusedInitRewriter : public RecursiveASTVisitor<UnusedInitRewriter> 
Class:class ZeroOutInDeallocRemover : class ZeroOutInDeallocRemover :
Class:class TransformActionsImpl { class TransformActionsImpl 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(69, 2, u'-      assert(beginLoc.isValid() && endLoc.isValid());'), (77, 2, u'-      assert(Begin.isValid() && End.isValid());'), (184, 2, u'-  assert(!IsInTransaction &&'), (190, 2, u'-  assert(IsInTransaction && "No transaction started");'), (215, 2, u'-      assert(act.S);'), (279, 2, u'-  assert(IsInTransaction && "No transaction started");'), (285, 2, u'-  assert(IsInTransaction && "Actions only allowed during a transaction");'), (295, 2, u'-  assert(IsInTransaction && "Actions only allowed during a transaction");'), (305, 2, u'-  assert(IsInTransaction && "Actions only allowed during a transaction");'), (313, 2, u'-  assert(IsInTransaction && "Actions only allowed during a transaction");'), (321, 2, u'-  assert(IsInTransaction && "Actions only allowed during a transaction");'), (329, 2, u'-  assert(IsInTransaction && "Actions only allowed during a transaction");'), (350, 2, u'-  assert(IsInTransaction && "Actions only allowed during a transaction");'), (359, 2, u'-  assert(IsInTransaction && "Actions only allowed during a transaction");'), (369, 2, u'-  assert(IsInTransaction && "Actions only allowed during a transaction");'), (449, 2, u'-  assert(S);'), (466, 2, u'-  assert(comp == Range_Contained);'), (677, 2, u'-  assert(!static_cast<TransformActionsImpl*>(Impl)->isInTransaction() &&'), (697, 2, u'-  assert(!static_cast<TransformActionsImpl*>(Impl)->isInTransaction() &&'), (716, 2, u'-  assert(!static_cast<TransformActionsImpl*>(Impl)->isInTransaction() &&')]
===========================================
Class:class ReferenceClear : public RecursiveASTVisitor<ReferenceClear> { class ReferenceClear : public RecursiveASTVisitor<ReferenceClear> 
Class: class ReferenceCollector : public RecursiveASTVisitor<ReferenceCollector> { class ReferenceCollector : public RecursiveASTVisitor<ReferenceCollector> 
Class: class RemovablesCollector : public RecursiveASTVisitor<RemovablesCollector> { class RemovablesCollector : public RecursiveASTVisitor<RemovablesCollector> 
Class:class ASTTransform : public RecursiveASTVisitor<ASTTransform> { class ASTTransform : public RecursiveASTVisitor<ASTTransform> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(459, 2, u'-        assert(BI != CD->bases_end());'), (513, 2, u'-  assert(isLValue() && "Invalid accessor");'), (518, 2, u'-  assert(isLValue() && "Invalid accessor");'), (523, 2, u'-  assert(isLValue() && "Invalid accessor");'), (528, 2, u'-  assert(isLValue() && "Invalid accessor");'), (533, 2, u'-  assert(isLValue() && hasLValuePath() && "Invalid accessor");'), (539, 2, u'-  assert(isLValue() && "Invalid accessor");'), (545, 2, u'-  assert(isLValue() && "Invalid accessor");'), (557, 2, u'-  assert(isLValue() && "Invalid accessor");'), (568, 2, u'-  assert(isMemberPointer() && "Invalid accessor");'), (574, 2, u'-  assert(isMemberPointer() && "Invalid accessor");'), (580, 2, u'-  assert(isMemberPointer() && "Invalid accessor");'), (586, 2, u'-  assert(isUninit() && "Bad state change");'), (587, 2, u'-  assert(sizeof(LV) <= MaxSize && "LV too big");'), (593, 2, u'-  assert(isUninit() && "Bad state change");'), (600, 2, u'-  assert(isUninit() && "Bad state change");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(178, 2, u'-  assert(Canonical == 0 && "Shouldn\'t be in the map!");'), (250, 2, u'-    assert(t && "No target supplied for ASTContext initialization");'), (389, 2, u'-  assert((!this->Target || this->Target == &Target) &&'), (391, 2, u'-  assert(VoidTy.isNull() && "Context reinitialized?");'), (524, 2, u'-  assert(Var->isStaticDataMember() && "Not a static data member");'), (537, 2, u'-  assert(Inst->isStaticDataMember() && "Not a static data member");'), (538, 2, u'-  assert(Tmpl->isStaticDataMember() && "Not a static data member");'), (539, 2, u'-  assert(!InstantiatedFromStaticDataMember[Inst] &&'), (547, 2, u'-  assert(FD && "Specialization is 0");'), (558, 2, u'-  assert(FD && "Specialization is 0");'), (559, 2, u'-  assert(Pattern && "Class scope specialization pattern is 0");'), (575, 2, u'-  assert((isa<UsingDecl>(Pattern) ||'), (579, 2, u'-  assert(!InstantiatedFromUsingDecl[Inst] && "pattern already exists");'), (596, 2, u'-  assert(!InstantiatedFromUsingShadowDecl[Inst] && "pattern already exists");'), (611, 2, u'-  assert(!Inst->getDeclName() && "Instantiated field decl is not unnamed");'), (612, 2, u'-  assert(!Tmpl->getDeclName() && "Template field decl is not unnamed");'), (613, 2, u'-  assert(!InstantiatedFromUnnamedFieldDecl[Inst] &&'), (687, 2, u'-  assert(!Import->NextLocalImport && "Import declaration already in the chain");'), (688, 2, u'-  assert(!Import->isFromASTFile() && "Non-local import declaration");'), (707, 2, u'-  assert(BT && "Not a floating point type!");'), (865, 2, u'-    assert((Size == 0 || EltInfo.first <= (uint64_t)(-1)/Size) &&'), (1052, 2, u'-    assert(A->isDeduced() && "Cannot request the size of a dependent type");'), (1096, 2, u'-    assert(getCanonicalType(T) != T &&'), (1126, 2, u'-  assert(llvm::isPowerOf2_32(Align) && "Alignment must be power of 2");'), (1300, 2, u'-  assert(IFaceD && ImplD && "Passed null params");'), (1306, 2, u'-  assert(CatD && ImplD && "Passed null params");'), (1324, 2, u'-  assert(VD && "Passed null params");'), (1325, 2, u'-  assert(VD->hasAttr<BlocksAttr>() &&'), (1334, 2, u'-  assert(VD && Init && "Passed null params");'), (1335, 2, u'-  assert(VD->hasAttr<BlocksAttr>() &&'), (1353, 2, u'-    assert(DataSize == TypeLoc::getFullDataSizeForType(T) &&'), (1394, 2, u'-    assert(eq->getQualifiers() == quals);'), (1427, 2, u'-  assert(!Quals.hasAddressSpace() &&'), (1455, 2, u'-  assert(!Quals.hasObjCGCAttr() &&'), (1501, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1529, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1540, 2, u'-  assert(T->isFunctionType() && "block of function types only");'), (1560, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1573, 2, u'-  assert(getCanonicalType(T) != OverloadTy &&'), (1598, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1635, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1667, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1682, 2, u'-  assert((EltTy->isDependentType() ||'), (1712, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1889, 2, u'-  assert((!numElements || numElements->isTypeDependent() ||'), (1976, 2, u'-    assert(!existing && "Shouldn\'t be in the map!"); (void) existing;'), (1991, 2, u'-  assert(vecType->isBuiltinType());'), (2009, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (2022, 2, u'-  assert(vecType->isBuiltinType() || vecType->isDependentType());'), (2040, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (2076, 2, u'-      assert(!CanonCheck && "Dependent-sized ext_vector canonical type broken");'), (2119, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (2181, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (2229, 2, u'-  assert(NeedsInjectedClassNameType(Decl));'), (2231, 2, u'-    assert(isa<InjectedClassNameType>(Decl->TypeForDecl));'), (2233, 2, u'-    assert(PrevDecl->TypeForDecl && "previous declaration has no type");'), (2235, 2, u'-    assert(isa<InjectedClassNameType>(Decl->TypeForDecl));'), (2248, 2, u'-  assert(Decl && "Passed null for Decl param");'), (2249, 2, u'-  assert(!Decl->TypeForDecl && "TypeForDecl present in slow case");'), (2254, 2, u'-  assert(!isa<TemplateTypeParmDecl>(Decl) &&'), (2258, 2, u'-    assert(!Record->getPreviousDecl() &&'), (2260, 2, u'-    assert(!NeedsInjectedClassNameType(Record));'), (2263, 2, u'-    assert(!Enum->getPreviousDecl() &&'), (2344, 2, u'-  assert(Replacement.isCanonical()'), (2371, 2, u'-    assert(P->getKind() == TemplateArgument::Type &&"Pack contains a non-type");'), (2372, 2, u'-    assert(P->getAsType().isCanonical() && "Pack contains non-canonical type");'), (2420, 2, u'-    assert(!TypeCheck && "Template type parameter canonical type broken");'), (2437, 2, u'-  assert(!Name.getAsDependentTemplateName() &&'), (2457, 2, u'-  assert(!Template.getAsDependentTemplateName() &&'), (2487, 2, u'-  assert(!Template.getAsDependentTemplateName() &&'), (2502, 2, u'-    assert((!IsTypeAlias || hasAnyPackExpansions(Args, NumArgs)) &&'), (2528, 2, u'-  assert(!Template.getAsDependentTemplateName() &&'), (2564, 2, u'-  assert(Spec->isDependentType() &&'), (2585, 2, u'-    assert(!CheckT && "Elaborated canonical type broken");'), (2609, 2, u'-    assert(!CheckT && "Paren canonical type broken");'), (2623, 2, u'-  assert(NNS->isDependent() && "nested-name-specifier must be dependent");'), (2672, 2, u'-  assert((!NNS || NNS->isDependent()) &&'), (2723, 2, u'-  assert(Pattern->containsUnexpandedParameterPack() &&'), (2868, 2, u'-    assert(PrevDecl->TypeForDecl && "previous decl has no TypeForDecl");'), (3022, 2, u'-    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (3034, 2, u'-  assert(!AutoDeductTy.isNull() && "can\'t build \'auto\' pattern");'), (3042, 2, u'-  assert(!AutoRRefDeductTy.isNull() && "can\'t build \'auto &&\' pattern");'), (3049, 2, u'-  assert (Decl);'), (3138, 2, u'-    assert(quals.empty()); // from the recursive call'), (3280, 2, u'-    assert(DTN && "Non-dependent template names must refer to template decls.");'), (3511, 2, u'-  assert(PrettyArrayType && "Not an array type!");'), (3554, 2, u'-  assert(T->getAs<BuiltinType>() && "getFloatingRank(): not a floating type");'), (3580, 2, u'-  assert(Domain->isRealFloatingType() && "Unknown domain!");'), (3609, 2, u'-  assert(T->isCanonicalUnqualified() && "T should be canonicalized");'), (3675, 2, u'-  assert(!Promotable.isNull());'), (3676, 2, u'-  assert(Promotable->isPromotableIntegerType());'), (3711, 2, u'-  assert(Promotable->isUnsignedIntegerType() && PromotableSize <= IntSize);'), (3825, 2, u'-  assert(Rec && "Invalid CFConstantStringType");'), (3946, 2, u'-  assert(getIntWidth(IntTy) == 32 && "non-32bit int not supported");'), (4048, 2, u'-    assert (sz.isPositive() && "BlockExpr - Incomplete param type");'), (4091, 2, u'-    assert (sz.isPositive() &&'), (4160, 2, u'-    assert (sz.isPositive() &&'), (4373, 2, u'-  assert(FD->isBitField() && "not a bitfield - getObjCEncodingForTypeImpl");'), (4512, 2, u'-        assert((isa<VariableArrayType>(AT) || isa<IncompleteArrayType>(AT)) &&'), (4732, 2, u'-  assert(RDecl && "Expected non-null RecordDecl");'), (4733, 2, u'-  assert(!RDecl->isUnion() && "Should not be called for unions");'), (4793, 2, u'-    assert(CXXRec && CXXRec->isDynamicClass() &&'), (4814, 2, u'-    assert(CurOffs <= CurLayObj->first);'), (4838, 2, u'-      assert(!base->isEmpty());'), (4881, 2, u'-  assert(BuiltinVaListType.isNull() && "__builtin_va_list type already set!");'), (4940, 2, u'-  assert(ObjCConstantStringType.isNull() &&'), (4952, 2, u'-  assert(size > 1 && "set is not overloaded!");'), (4961, 2, u'-    assert(isa<FunctionTemplateDecl>(D) ||'), (4976, 2, u'-  assert(NNS && "Missing nested-name-specifier in qualified template name");'), (4998, 2, u'-  assert((!NNS || NNS->isDependent()) &&'), (5019, 2, u'-    assert(!CheckQTN && "Dependent type name canonicalization broken");'), (5032, 2, u'-  assert((!NNS || NNS->isDependent()) &&'), (5054, 2, u'-    assert(!CheckQTN && "Dependent template name canonicalization broken");'), (5131, 2, u'-  assert(getLangOpts().ObjC1);'), (5149, 2, u'-    assert(CT->isAnyPointerType() || CT->isBlockPointerType());'), (5163, 2, u'-  assert(LHS->isCanonicalUnqualified() && RHS->isCanonicalUnqualified());'), (5170, 2, u'-  assert(FirstVec->isVectorType() && "FirstVec should be a vector type");'), (5171, 2, u'-  assert(SecondVec->isVectorType() && "SecondVec should be a vector type");'), (5224, 2, u'-  assert ((lhsQID && rhsOPT) && "ObjCQualifiedClassTypesAreCompatible");'), (5317, 2, u'-  assert(rhsQID && "One of the LHS/RHS should be id<x>");'), (5456, 2, u'-  assert(LHS->getInterface() && "LHS must have an interface base");'), (5457, 2, u'-  assert(RHS->getInterface() && "RHS must have an interface base");'), (5523, 2, u'-  assert(LHS->getInterface() && "LHS is not an interface type");'), (5524, 2, u'-  assert(RHS->getInterface() && "RHS is not an interface type");'), (5753, 2, u'-    assert(!lproto->hasExceptionSpec() && !rproto->hasExceptionSpec() &&'), (5811, 2, u'-    assert(!proto->hasExceptionSpec() && "C++ shouldn\'t be here");'), (5854, 2, u'-  assert(!LHS->getAs<ReferenceType>() && "LHS is a reference type?");'), (5855, 2, u'-  assert(!RHS->getAs<ReferenceType>() && "RHS is a reference type?");'), (5887, 2, u'-    assert((GC_L != GC_R) && "unequal qualifier sets had only equal elements");'), (6195, 2, u'-    assert((GC_L != GC_R) && "unequal qualifier sets had only equal elements");'), (6233, 2, u'-  assert(T->hasSignedIntegerRepresentation() && "Unexpected type");'), (6245, 2, u'-  assert(BTy && "Unexpected signed integer type");'), (6298, 2, u'-      assert(!Unsigned && "Can\'t use both \'S\' and \'U\' modifiers!");'), (6299, 2, u'-      assert(!Signed && "Can\'t use \'S\' modifier multiple times!");'), (6303, 2, u'-      assert(!Signed && "Can\'t use both \'S\' and \'U\' modifiers!");'), (6304, 2, u'-      assert(!Unsigned && "Can\'t use \'S\' modifier multiple times!");'), (6308, 2, u'-      assert(HowLong <= 2 && "Can\'t have LLLL modifier");'), (6320, 2, u'-    assert(HowLong == 0 && !Signed && !Unsigned &&'), (6325, 2, u'-    assert(HowLong == 0 && !Signed && !Unsigned &&'), (6330, 2, u'-    assert(HowLong < 2 && !Signed && !Unsigned &&'), (6338, 2, u'-    assert(HowLong == 0 && "Bad modifiers used with \'s\'!");'), (6355, 2, u'-    assert(HowLong == 0 && "Bad modifiers used with \'c\'!");'), (6364, 2, u'-    assert(HowLong == 0 && !Signed && !Unsigned && "Bad modifiers for \'b\'!");'), (6368, 2, u'-    assert(HowLong == 0 && !Signed && !Unsigned && "Bad modifiers for \'z\'!");'), (6382, 2, u'-    assert(!Type.isNull() && "builtin va list type not initialized!");'), (6394, 2, u'-    assert(!Type.isNull() && "builtin va list type not initialized!");'), (6403, 2, u'-    assert(End != Str && "Missing vector size");'), (6408, 2, u'-    assert(!RequiresICE && "Can\'t require vector ICE");'), (6418, 2, u'-    assert(!RequiresICE && "Can\'t require complex ICE");'), (6445, 2, u'-    assert(HowLong == 0 && !Signed && !Unsigned && "Bad modifiers for \'K\'!");'), (6489, 2, u'-  assert((!RequiresICE || Type->isIntegralOrEnumerationType()) &&'), (6510, 2, u'-  assert(!RequiresICE && "Result of intrinsic cannot be required to be an ICE");'), (6529, 2, u"-  assert((TypeStr[0] != '.' || TypeStr[1] == 0) &&"), (6687, 2, u'-  assert(VD->isFileVarDecl() && "Expected file scoped var");'), (6768, 2, u'-  assert(I != ParamIndices.end() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(248, 2, u'-      assert(ModLen == 0 && ArgLen == 0 &&'), (267, 2, u'-        assert(ModLen == 0 && ArgLen == 0 &&'), (276, 2, u'-        assert(ModLen == 0 && ArgLen == 0 &&'), (293, 2, u'-      assert(DC && "Should never have a null declaration context");')]
===========================================
Class:  class ASTNodeImporter : public TypeVisitor<ASTNodeImporter, QualType>,   class ASTNodeImporter : public TypeVisitor<ASTNodeImporter, QualType>,
Class:  class FinalOverriderCollector {   class FinalOverriderCollector 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(24, 2, u'-  assert(NumDeclsFound == 0 && !DeclsFound &&'), (361, 2, u'-  assert(((Decl *)BaseRecord)->getCanonicalDecl() == BaseRecord &&'), (370, 2, u'-  assert(((Decl *)BaseRecord)->getCanonicalDecl() == BaseRecord &&'), (683, 2, u'-    assert(!I->getType()->isDependentType() &&'), (706, 2, u'-    assert(!I->getType()->isDependentType() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(198, 2, u'-  assert(D->getDeclContext()->getRedeclContext()->isFileContext() &&'), (638, 2, u'-    assert(Linkage(CachedLinkage) =='), (651, 2, u'-  assert(!HasCachedLinkage || Linkage(CachedLinkage) == LI.linkage());'), (911, 2, u'-  assert(getDeclName() == OldD->getDeclName() && "Declaration name mismatch");'), (1050, 2, u'-  assert(NumTPLists > 0);'), (1121, 2, u'-  assert((NumTPLists == 0 || TPLists != 0) &&'), (1171, 2, u'-  assert(isLegalForVariable(SC));'), (1415, 2, u'-  assert(!Init->isValueDependent());'), (1458, 2, u'-  assert(!Init->isValueDependent());'), (1483, 2, u'-  assert(getType()->isReferenceType() &&"Non-references never extend lifetime");'), (1516, 2, u'-  assert(MSI && "Not an instantiated static data member?");'), (1555, 2, u'-  assert(!hasUnparsedDefaultArg() && "Default argument is not yet parsed!");'), (1556, 2, u'-  assert(!hasUninstantiatedDefaultArg() &&'), (1685, 2, u'-  assert(getDeclName().getNameKind() == DeclarationName::CXXOperatorName);'), (1686, 2, u'-  assert(getDeclName().getCXXOverloadedOperator() == OO_New ||'), (1692, 2, u'-  assert(getDeclContext()->getRedeclContext()->isTranslationUnit());'), (1751, 2, u'-    assert((!PrevDecl || PrevFunTmpl) && "Function/function template mismatch");'), (1768, 2, u'-  assert(isLegalForFunction(SC));'), (1836, 2, u'-  assert(ParamInfo == 0 && "Already has param info!");'), (1837, 2, u'-  assert(NewParamInfo.size() == getNumParams() && "Parameter count mismatch!");'), (1847, 2, u'-  assert(DeclsInPrototypeScope.empty() && "Already has prototype decls!");'), (1946, 2, u'-  assert(!doesThisDeclarationHaveABody() &&'), (2016, 2, u'-  assert(doesThisDeclarationHaveABody() && "Must have the function definition");'), (2017, 2, u'-  assert(isInlined() && "Function must be inline");'), (2110, 2, u'-  assert(TemplateOrSpecialization.isNull() &&'), (2231, 2, u'-  assert(TSK != TSK_Undeclared &&'), (2248, 2, u'-  assert(TemplateOrSpecialization.isNull());'), (2471, 2, u'-  assert(isBitField() && "not a bitfield");'), (2498, 2, u'-  assert(CachedFieldIndex && "failed to find field in parent");'), (2509, 2, u'-  assert(!InitializerOrBitWidth.getPointer() &&'), (2552, 2, u'-  assert((!isa<CXXRecordDecl>(this) ||'), (2600, 2, u'-  assert(NumTPLists > 0);'), (2636, 2, u'-  assert(!isCompleteDefinition() && "Cannot redefine enums!");'), (2655, 2, u'-  assert(MSI && "Not an instantiated member enumeration?");'), (2672, 2, u'-  assert(!SpecializationInfo && "Member enum is already a specialization");'), (2688, 2, u'-  assert(classof(static_cast<Decl*>(this)) && "Invalid Kind!");'), (2721, 2, u'-  assert(!isCompleteDefinition() && "Cannot redefine record!");'), (2727, 2, u'-  assert(hasExternalLexicalStorage() && Source && "No external storage?");'), (2746, 2, u'-    assert(isa<FieldDecl>(Decls[i]));'), (2761, 2, u'-  assert(ParamInfo == 0 && "Already has param info!");'), (2827, 2, u'-  assert(GnuLabelL != IdentL && "Use this only for GNU local labels");'), (3001, 2, u'-  assert(getNumModuleIdentifiers(Imported) == IdentifierLocs.size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(238, 2, u'-  assert(DC && "This decl is not contained in a translation unit!");'), (242, 2, u'-    assert(DC && "This decl is not contained in a translation unit!");'), (522, 2, u'-    case StaticAssert:'), (543, 2, u'-  assert(!HasAttrs && "Decl already contains attrs.");'), (546, 2, u'-  assert(AttrBlank.empty() && "HasAttrs was wrong?");'), (560, 2, u'-  assert(HasAttrs && "No attrs to get!");'), (658, 2, u'-      isa<StaticAssertDecl>(this) ||'), (668, 2, u'-  assert(Access != AS_none &&'), (686, 2, u'-  assert(!DC->isClosure());'), (832, 2, u'-      assert(isa<TagType>(Tag->TypeForDecl) ||'), (849, 2, u'-    assert(DeclKind >= Decl::firstFunction && DeclKind <= Decl::lastFunction &&'), (899, 2, u'-  assert(hasExternalLexicalStorage() && Source && "No external storage?");'), (945, 2, u'-  assert(List.isNull());'), (1003, 2, u'-  assert(D->getLexicalDeclContext() == this &&'), (1005, 2, u'-  assert((D->NextInContextAndBits.getPointer() || D == LastDecl) &&'), (1016, 2, u'-      assert(I && "decl not found in linked list");'), (1039, 2, u'-    assert(Pos != Map->end() && "no lookup entry for decl");'), (1046, 2, u'-  assert(D->getLexicalDeclContext() == this &&'), (1048, 2, u'-  assert(!D->getNextDeclInContext() && D != LastDecl &&'), (1117, 2, u'-  assert(this == getPrimaryContext() && "buildLookup called on non-primary DC");'), (1159, 2, u'-  assert(DeclKind != Decl::LinkageSpec &&'), (1276, 2, u'-  assert(this == getPrimaryContext() && "expected a primary DC");'), (1378, 2, u'-  assert(!LookupPtr.getPointer() && "context already has a decls map");'), (1379, 2, u'-  assert(getPrimaryContext() == this &&'), (1419, 2, u'-  assert(Parent->isDependentContext()')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(426, 2, u'-    assert(FnType && "Overloaded operator has no prototype.");'), (1165, 2, u'-      assert(std::find(Convs.begin(), Convs.end(), ConvDecl) == Convs.end()'), (1188, 2, u'-  assert(TemplateOrInstantiation.isNull() &&'), (1190, 2, u'-  assert(!isa<ClassTemplateSpecializationDecl>(this));'), (1277, 2, u'-        assert(SO->second.size() > 0 &&'), (1421, 2, u'-  assert(MD->isCanonicalDecl() && "Method is not canonical!");'), (1422, 2, u'-  assert(!MD->getParent()->isDependentContext() &&'), (1424, 2, u'-  assert(MD->isVirtual() && "Method is not virtual!");'), (1451, 2, u'-  assert(isInstance() && "No \'this\' for static methods!");'), (1602, 2, u'-  assert(NameInfo.getName().getNameKind()'), (1611, 2, u'-  assert(isDelegatingConstructor() && "Not a delegating constructor!");'), (1729, 2, u'-  assert(getASTContext().overridden_methods_size(this) == 0 &&'), (1749, 2, u'-  assert(NameInfo.getName().getNameKind()'), (1773, 2, u'-  assert(NameInfo.getName().getNameKind()'), (1903, 2, u'-  assert(std::find(shadow_begin(), shadow_end(), S) == shadow_end() &&'), (1905, 2, u'-  assert(S->getUsingDecl() == this);'), (1913, 2, u'-  assert(std::find(shadow_begin(), shadow_end(), S) != shadow_end() &&'), (1915, 2, u'-  assert(S->getUsingDecl() == this);'), (1990, 2, u'-void StaticAssertDecl::anchor() { }'), (1992, 2, u'-StaticAssertDecl *StaticAssertDecl::Create(ASTContext &C, DeclContext *DC,'), (1993, 2, u'-                                           SourceLocation StaticAssertLoc,'), (1994, 2, u'-                                           Expr *AssertExpr,'), (1997, 2, u'-  return new (C) StaticAssertDecl(DC, StaticAssertLoc, AssertExpr, Message,'), (2001, 2, u'-StaticAssertDecl *StaticAssertDecl::CreateDeserialized(ASTContext &C,'), (2003, 2, u'-  void *Mem = AllocateDeserializedDecl(C, ID, sizeof(StaticAssertDecl));'), (2004, 2, u'-  return new (Mem) StaticAssertDecl(0, SourceLocation(), 0, 0,SourceLocation());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 2, u'-    assert(isa<FunctionDecl>(D) ||'), (35, 2, u'-    assert(D->getFriendObjectKind() ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(21, 2, u'-  assert(NumDecls > 1 && "Invalid DeclGroup");'), (29, 2, u'-  assert(numdecls > 0);'), (30, 2, u'-  assert(decls);')]
===========================================
Class:  class DeclPrinter : public DeclVisitor<DeclPrinter> {   class DeclPrinter : public DeclVisitor<DeclPrinter> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(63, 2, u'-    void VisitStaticAssertDecl(StaticAssertDecl *D);'), (657, 2, u'-void DeclPrinter::VisitStaticAssertDecl(StaticAssertDecl *D) {'), (659, 2, u'-  D->getAssertExpr()->printPretty(Out, Context, 0, Policy, Indentation);'), (730, 2, u'-    assert(D->getLanguage() == LinkageSpecDecl::lang_cxx &&'), (746, 2, u'-  assert(Params);'), (747, 2, u'-  assert(!Args || Params->size() == Args->size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(334, 2, u'-    assert(Existing->isCanonicalDecl() && "Non-canonical specialization?");'), (357, 2, u'-    assert(Existing->isCanonicalDecl() && "Non-canonical specialization?");'), (373, 2, u'-    assert(!PS[P->getSequenceNumber()]);')]
===========================================
Class:class CXXSpecialName class CXXSpecialName
Class:   class CXXOperatorIdName : public DeclarationNameExtra { class CXXOperatorIdName : public DeclarationNameExtra 
Class:       class CXXLiteralOperatorIdName   : public DeclarationNameExtra, public llvm::FoldingSetNode {   : public DeclarationNameExtra, public llvm::FoldingSetNode 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(147, 2, u'-    assert((Ptr & PtrMask) == 0 && "Improperly aligned IdentifierInfo");'), (153, 2, u'-    assert((Ptr & PtrMask) == 0 && "Improperly aligned IdentifierInfo");'), (159, 2, u'-    assert((Ptr & PtrMask) == 0 && "Improperly aligned MultiKeywordSelector");'), (254, 2, u'-    assert(OpName && "not an overloaded operator");'), (415, 2, u'-  assert(Kind >= DeclarationName::CXXConstructorName &&'), (425, 2, u'-    assert(!Ty.hasQualifiers() &&"Constructor type must be unqualified");'), (429, 2, u'-    assert(!Ty.hasQualifiers() && "Destructor type must be unqualified");')]
===========================================
Class:  class TemporaryContainer {   class TemporaryContainer 
Class:  template <class E, class T>   template <class E, class T>
Class:  class NonTrivialCallFinder : public EvaluatedExprVisitor<NonTrivialCallFinder>   class NonTrivialCallFinder : public EvaluatedExprVisitor<NonTrivialCallFinder>
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(460, 2, u'-      assert(Params->size() == Args.size());'), (476, 2, u'-      assert(Params->size() == Args->size());'), (598, 2, u'-  assert((CharByteWidth & 7) == 0 && "Assumes character size is byte multiple");'), (600, 2, u'-  assert((CharByteWidth==1 || CharByteWidth==2 || CharByteWidth==4)'), (646, 2, u'-  assert((Str.size()%CharByteWidth == 0)'), (670, 2, u'-      assert(false && "unsupported CharByteWidth");'), (684, 2, u'-  assert(Kind == StringLiteral::Ascii && "This only works for ASCII strings");'), (690, 2, u'-    assert(TokNo < getNumConcatenated() && "Invalid byte number!");'), (1043, 2, u'-  assert(getKind() == Field || getKind() == Identifier);'), (1144, 2, u'-    assert(!path_empty() && "Cast kind should have a base path!");'), (1148, 2, u'-    assert(getType()->isObjCObjectPointerType());'), (1149, 2, u'-    assert(getSubExpr()->getType()->isPointerType());'), (1153, 2, u'-    assert(getType()->isObjCObjectPointerType());'), (1154, 2, u'-    assert(getSubExpr()->getType()->isBlockPointerType());'), (1158, 2, u'-    assert(getType()->isMemberPointerType());'), (1159, 2, u'-    assert(getSubExpr()->getType()->isMemberPointerType());'), (1167, 2, u'-      assert(getType()->isObjCObjectPointerType() =='), (1169, 2, u'-      assert(getType()->isBlockPointerType() =='), (1175, 2, u'-    assert(getType()->isBlockPointerType());'), (1176, 2, u'-    assert(getSubExpr()->getType()->isAnyPointerType() &&'), (1181, 2, u'-    assert(getType()->isBlockPointerType());'), (1182, 2, u'-    assert(getSubExpr()->getType()->isBlockPointerType());'), (1214, 2, u'-    assert(!getType()->isBooleanType() && "unheralded conversion to bool");'), (1231, 2, u'-    assert(path_empty() && "Cast kind should not have a base path!");'), (1390, 2, u'-  assert(Path.size() == path_size());'), (1584, 2, u'-  assert(!hasArrayFiller() && "Filler already set!");'), (1976, 2, u'-  assert(expr->hasPlaceholderType(BuiltinType::BoundMember));'), (1984, 2, u'-    assert(isa<CXXMethodDecl>(mem->getMemberDecl()));'), (1991, 2, u'-    assert(type->isFunctionType());'), (1995, 2, u'-  assert(isa<UnresolvedMemberExpr>(expr));'), (2599, 2, u'-    assert((E->getValueKind() == VK_LValue &&'), (2844, 2, u'-  assert((!SelLocs.empty() || isImplicit) &&'), (2867, 2, u'-  assert((!SelLocs.empty() || isImplicit) &&'), (2890, 2, u'-  assert((!SelLocs.empty() || isImplicit) &&'), (3092, 2, u'-  assert(Kind == FieldDesignator && "Only valid on a field designator");'), (3163, 2, u'-  assert(IndexIdx == NumIndexExprs && "Wrong number of index expressions");'), (3219, 2, u'-  assert(D.Kind == Designator::ArrayDesignator && "Requires array designator");'), (3227, 2, u'-  assert(D.Kind == Designator::ArrayRangeDesignator &&'), (3236, 2, u'-  assert(D.Kind == Designator::ArrayRangeDesignator &&'), (3319, 2, u'-  assert(syntax && "no syntactic expression!");'), (3320, 2, u'-  assert(semantics.size() && "no semantic expressions!");'), (3328, 2, u'-    assert(resultIndex < semantics.size());'), (3331, 2, u'-    assert(semantics[resultIndex]->getObjectKind() == OK_Ordinary);'), (3363, 2, u'-      assert(cast<OpaqueValueExpr>(E)->getSourceExpr() != 0 &&'), (3529, 2, u'-  assert(nexpr == getNumSubExprs(op) && "wrong number of subexpressions");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 2, u'-  assert(!TR->isReferenceType() && "Expressions can\'t have reference type.");'), (71, 2, u'-  case Cl::CL_LValue: assert(getValueKind() == VK_LValue); break;'), (72, 2, u'-  case Cl::CL_XValue: assert(getValueKind() == VK_XValue); break;'), (81, 2, u'-  case Cl::CL_PRValue: assert(getValueKind() == VK_RValue); break;'), (371, 2, u'-    assert(cast<InitListExpr>(E)->getNumInits() == 1 &&'), (483, 2, u'-  assert(Ctx.getLangOpts().CPlusPlus &&'), (519, 2, u'-  assert(Ctx.getLangOpts().CPlusPlus &&'), (582, 2, u'-    assert((E->getObjectKind() == OK_ObjCProperty ||'), (630, 2, u'-  assert(VC.getKind() == Cl::CL_LValue && "Unhandled kind");')]
===========================================
Class:  class OptionalDiagnostic {   class OptionalDiagnostic 
Class:         class SpeculativeEvaluationRAII {   class SpeculativeEvaluationRAII 
Class:class HasSideEffect class HasSideEffect
Class: class OpaqueValueEvaluation { class OpaqueValueEvaluation 
Class:class ExprEvaluatorBase class ExprEvaluatorBase
Class:class LValueExprEvaluatorBase class LValueExprEvaluatorBase
Class:class LValueExprEvaluator class LValueExprEvaluator
Class:class PointerExprEvaluator class PointerExprEvaluator
Class:class MemberPointerExprEvaluator class MemberPointerExprEvaluator
Class:  class RecordExprEvaluator   class RecordExprEvaluator
Class:class TemporaryExprEvaluator class TemporaryExprEvaluator
Class:  class VectorExprEvaluator   class VectorExprEvaluator
Class:  class ArrayExprEvaluator   class ArrayExprEvaluator
Class:class IntExprEvaluator class IntExprEvaluator
Class:class DataRecursiveIntBinOpEvaluator { class DataRecursiveIntBinOpEvaluator 
Class:class FloatExprEvaluator class FloatExprEvaluator
Class:class ComplexExprEvaluator class ComplexExprEvaluator
Class:class VoidExprEvaluator class VoidExprEvaluator
Class:class InheritanceHierarchyWriter { class InheritanceHierarchyWriter 
Class:class ItaniumCXXABI : public CXXABI { class ItaniumCXXABI : public CXXABI 
Class: class ARMCXXABI : public ItaniumCXXABI { class ARMCXXABI : public ItaniumCXXABI 
Class:class ItaniumMangleContext : public MangleContext { class ItaniumMangleContext : public MangleContext 
Class:  class CXXNameMangler { class CXXNameMangler 
Class:   class FunctionTypeDepthState {   class FunctionTypeDepthState 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 2, u'-  assert(DC == ExpectedDC && "Given decl context did not match expected!");'), (93, 2, u'-  assert(!isa<CXXConstructorDecl>(DC) && !isa<CXXDestructorDecl>(DC));'), (124, 2, u'-  assert (CD && "Missing container decl in GetNameForMethod");')]
===========================================
Class:class MicrosoftCXXABI : public CXXABI { class MicrosoftCXXABI : public CXXABI 
Class:class MicrosoftCXXNameMangler { class MicrosoftCXXNameMangler 
Class:   class MicrosoftMangleContext : public MangleContext { class MicrosoftMangleContext : public MangleContext 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(46, 2, u'-  assert(II && "Identifier cannot be NULL");'), (47, 2, u'-  assert((!Prefix || Prefix->isDependent()) && "Prefix must be dependent");'), (59, 2, u'-  assert(NS && "Namespace cannot be NULL");'), (60, 2, u'-  assert((!Prefix ||'), (74, 2, u'-  assert(Alias && "Namespace alias cannot be NULL");'), (75, 2, u'-  assert((!Prefix ||'), (89, 2, u'-  assert(T && "Type cannot be NULL");'), (99, 2, u'-  assert(II && "Identifier cannot be NULL");'), (260, 2, u'-    assert(!isa<ElaboratedType>(T) &&'), (291, 2, u'-  assert(Qualifier && "Expected a non-NULL qualifier");'), (387, 2, u'-  assert((Qualifier->getKind() == NestedNameSpecifier::TypeSpec ||'), (549, 2, u'-  assert(!Representation && "Already have a nested-name-specifier!?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 2, u'-        assert(getVBaseClassOffset(PrimaryBase).isZero() &&'), (84, 2, u'-        assert(getBaseClassOffsetInBits(PrimaryBase) == 0 &&')]
===========================================
Class:class EmptySubobjectMap { class EmptySubobjectMap 
Class: class RecordLayoutBuilder { class RecordLayoutBuilder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 2, u'-    assert(Index == 0);'), (35, 2, u'-  assert(Index < NumSelArgs);')]
===========================================
Class:  template <class S, class T>   template <class S, class T>
Class:         template <class S, class T>   SourceLocation getLocEndImpl(const Stmt *stmt,                                SourceLocation (T::*v)() const) {                                SourceLocation (T::*v)() const) 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(141, 2, u'-#define ASSERT_IMPLEMENTS_children(type) \\'), (143, 2, u'-#define ASSERT_IMPLEMENTS_getSourceRange(type) \\'), (152, 2, u'-  ASSERT_IMPLEMENTS_children(type); \\'), (153, 2, u'-  ASSERT_IMPLEMENTS_getSourceRange(type);'), (656, 2, u'-  assert(RangeDecl &&& "for-range should have a single var decl");'), (666, 2, u'-  assert(LV && "No loop variable in CXXForRangeStmt");')]
===========================================
Class:  class StmtDumper : public StmtVisitor<StmtDumper> {   class StmtDumper : public StmtVisitor<StmtDumper> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(294, 2, u'-  } else if (StaticAssertDecl *SAD = dyn_cast<StaticAssertDecl>(D)) {'), (296, 2, u'-    DumpSubTree(SAD->getAssertExpr());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(34, 2, u'-  assert (getVAPtr());'), (58, 2, u'-    assert (inSizeOfTypeVA());'), (59, 2, u'-    assert(!decl);'), (65, 2, u'-  assert (getVAPtr() == NULL);'), (68, 2, u'-    assert(decl);'), (77, 2, u'-    assert(inDeclGroup());'), (135, 2, u'-    assert (VAPtr->SizeExpr);'), (139, 2, u'-  assert (inDecl() || inDeclGroup());'), (146, 2, u'-  assert (inDecl());'), (149, 2, u'-    assert (VD->Init);')]
===========================================
Class:  class StmtPrinter : public StmtVisitor<StmtPrinter> {   class StmtPrinter : public StmtVisitor<StmtPrinter> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(525, 2, u'-    assert(F && "Must have a finally block...");'), (1274, 2, u'-    assert(Args);')]
===========================================
Class:  class StmtProfiler : public ConstStmtVisitor<StmtProfiler> {   class StmtProfiler : public ConstStmtVisitor<StmtProfiler> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(447, 2, u'-      assert(D->isArrayRangeDesignator());'), (697, 2, u'-      assert(SC == Stmt::ArraySubscriptExprClass);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(208, 2, u'-  assert(Kind == TemplateExpansion);'), (292, 2, u'-  assert(isPackExpansion());'), (426, 2, u'-  assert(Argument.isPackExpansion());'), (616, 2, u'-  assert(TemplateKWLoc.isValid());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(96, 2, u'-  assert(!getAsOverloadedTemplate() &&')]
===========================================
Class:  class GetContainedAutoVisitor :   class GetContainedAutoVisitor :
Class:class CachedProperties { class CachedProperties 
Class:template <class Private> class TypePropertyCache { template <class Private> class TypePropertyCache 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(431, 2, u'-  assert(getNumProtocols() == NumProtocols &&'), (782, 2, u'-  assert(isScalarType());'), (800, 2, u'-    assert(cast<EnumType>(T)->getDecl()->isComplete());'), (835, 2, u'-  assert(!isIncompleteType() && "This doesn\'t make sense for incomplete types");'), (836, 2, u'-  assert(!isDependentType() && "This doesn\'t make sense for dependent types");'), (1085, 2, u'-  assert(BaseTy && "NULL element type");'), (1134, 2, u'-  assert(BaseTy && "NULL element type");'), (1188, 2, u'-  assert(BaseTy && "NULL element type");'), (1370, 2, u'-  assert((!NNS || NNS->isDependent()) &&'), (1585, 2, u'-  assert(isICE && "AST should not contain bad noexcept expressions.");'), (1626, 2, u'-  assert(!(unsigned(epi.Variadic) & ~1) &&'), (1838, 2, u'-  assert(!T.getAsDependentTemplateName() &&'), (1840, 2, u'-  assert((T.getKind() == TemplateName::Template ||'), (1846, 2, u'-  assert((!Canon.isNull() ||'), (1989, 2, u'-    assert(T->TypeBits.isCacheValid() &&'), (2015, 2, u'-    assert(T->isInstantiationDependentType());'), (2129, 2, u'-  assert(isObjCLifetimeType() &&')]
===========================================
Class:  class TypeLocRanger : public TypeLocVisitor<TypeLocRanger, SourceRange> {   class TypeLocRanger : public TypeLocVisitor<TypeLocRanger, SourceRange> 
Class:  class TypeSizer : public TypeLocVisitor<TypeSizer, unsigned> {   class TypeSizer : public TypeLocVisitor<TypeSizer, unsigned> 
Class:  class NextLoc : public TypeLocVisitor<NextLoc, TypeLoc> {   class NextLoc : public TypeLocVisitor<NextLoc, TypeLoc> 
Class:  class IncludeStrongLifetimeRAII {   class IncludeStrongLifetimeRAII 
Class:   class TypePrinter {   class TypePrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 2, u'-    assert(!SecondaryVirtualPointerIndices.count(Base) &&')]
===========================================
Class:class FinalOverriders { class FinalOverriders 
Class:  class VCallAndVBaseOffsetBuilder { class VCallAndVBaseOffsetBuilder 
Class:  class VTableBuilder { class VTableBuilder 
Class:class FindBlockDeclRefExprsVals : public StmtVisitor<FindBlockDeclRefExprsVals>{ class FindBlockDeclRefExprsVals : public StmtVisitor<FindBlockDeclRefExprsVals>
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(122, 2, u'-  assert(forcedBlkExprs);'), (127, 2, u'-  assert(itr != forcedBlkExprs->end());'), (213, 2, u'-  assert(Manager &&')]
===========================================
Class:class CFGBuilder;
Class:              class AddStmtChoice { class AddStmtChoice 
Class:                      class LocalScope { class LocalScope 
Class:         class const_iterator {   class const_iterator 
Class:     class TryResult { class TryResult 
Class:               class CFGBuilder { class CFGBuilder 
Class:class StmtPrinterHelper : public PrinterHelper  { class StmtPrinterHelper : public PrinterHelper  
Class:class CFGBlockTerminatorPrint class CFGBlockTerminatorPrint
Class:class CGBuilder : public StmtVisitor<CGBuilder> { class CGBuilder : public StmtVisitor<CGBuilder> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 2, u'-  assert(D);'), (136, 2, u'-      assert(*CI != Root && "No one can call the root node.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 2, u'-    assert(Amt.getHowSpecified() == OptionalAmount::Constant);')]
===========================================
Class:class DataflowWorklist { class DataflowWorklist 
Class:class LiveVariablesImpl { class LiveVariablesImpl 
Class:class TransferFunctions : public StmtVisitor<TransferFunctions> { class TransferFunctions : public StmtVisitor<TransferFunctions> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(414, 2, u'-    assert(subEx->isLValue());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(236, 2, u'-  assert(I == E && "Format string not exhausted");')]
===========================================
Class:class DeadCodeScan { class DeadCodeScan 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(125, 2, u'-    assert(Amt.getHowSpecified() == OptionalAmount::Constant);'), (452, 2, u'-  assert(I == E && "Format string not exhausted");')]
===========================================
Class:class MutexID { class MutexID 
Class:                class LocalVariableMap { class LocalVariableMap 
Class:   class VarMapBuilder : public StmtVisitor<VarMapBuilder> { class VarMapBuilder : public StmtVisitor<VarMapBuilder> 
Class:  class ThreadSafetyAnalyzer { class ThreadSafetyAnalyzer 
Class:       class BuildLockset : public StmtVisitor<BuildLockset> { class BuildLockset : public StmtVisitor<BuildLockset> 
Class:class DeclToIndex { class DeclToIndex 
Class:class CFGBlockValues { class CFGBlockValues 
Class:class DataflowWorklist { class DataflowWorklist 
Class:class FindVarResult { class FindVarResult 
Class: class TransferFunctions : public StmtVisitor<TransferFunctions> { class TransferFunctions : public StmtVisitor<TransferFunctions> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 2, u'-  assert(ID - Builtin::FirstTSBuiltin < NumTSRecords && "Invalid builtin ID!");'), (43, 2, u'-  assert(NumTSRecords == 0 && "Already initialized target?");'), (94, 2, u'-  assert(*Printf == \':\' && "p or P specifier must have be followed by a \':\'");'), (97, 2, u'-  assert(strchr(Printf, \':\') && "printf specifier must end with a \':\'");'), (113, 2, u'-  assert(*Scanf == \':\' && "s or S specifier must have be followed by a \':\'");'), (116, 2, u'-  assert(strchr(Scanf, \':\') && "printf specifier must end with a \':\'");')]
===========================================
Class:    class CustomDiagInfo {     class CustomDiagInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(99, 2, u'-      assert(StaticDiagInfo[i-1].DiagID != StaticDiagInfo[i].DiagID &&'), (103, 2, u'-      assert(StaticDiagInfo[i-1] < StaticDiagInfo[i] &&'), (131, 2, u'-      assert(Info.getMapping() == diag::MAP_WARNING &&'), (137, 2, u'-      assert(Info.getMapping() == diag::MAP_WARNING &&'), (248, 2, u'-        assert(this && DiagID-DIAG_UPPER_LIMIT < DiagInfo.size() &&'), (255, 2, u'-        assert(this && DiagID-DIAG_UPPER_LIMIT < DiagInfo.size() &&'), (360, 2, u'-  assert(DiagClass != CLASS_NOTE && "Cannot get diagnostic level of a note!");'), (583, 2, u'-  assert(Diag.getClient() && "DiagnosticClient not set!");')]
===========================================
Class: class FileManager::UniqueDirContainer { class FileManager::UniqueDirContainer 
Class: class FileManager::UniqueFileContainer { class FileManager::UniqueFileContainer 
Class: class FileManager::UniqueFileContainer { class FileManager::UniqueFileContainer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(69, 2, u'-    assert(absPathStrPtr && "_fullpath() returned NULL!");'), (183, 2, u'-  assert(statCache && "No stat cache provided?");'), (212, 2, u'-  assert(PrevCache && "Stat cache not found for removal");'), (427, 2, u'-  assert(DirInfo &&')]
===========================================
Class:  class EmptyLookupIterator : public IdentifierIterator   class EmptyLookupIterator : public IdentifierIterator
Class:class MultiKeywordSelector class MultiKeywordSelector
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 2, u'-  assert(isValid());'), (79, 2, u'-  assert(isValid());'), (84, 2, u'-  assert(isValid());'), (89, 2, u'-  assert(isValid());'), (94, 2, u'-  assert(isValid());'), (99, 2, u'-  assert(isValid());'), (104, 2, u'-  assert(isValid());'), (109, 2, u'-  assert(isValid());'), (114, 2, u'-  assert(isValid());'), (123, 2, u'-  assert(isValid());'), (128, 2, u'-  assert(isValid());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 2, u'-  assert(Buffer.getPointer());'), (75, 2, u'-    assert(0 && "Replacing with the same buffer");'), (198, 2, u'-  assert((Entries.empty() || Entries.back().FileOffset < Offset) &&'), (229, 2, u'-  assert(FilenameID != -1 && "Unspecified filename should use other accessor");'), (233, 2, u'-  assert((Entries.empty() || Entries.back().FileOffset < Offset) &&'), (242, 2, u'-    assert(!Entries.empty() && Entries.back().IncludeOffset &&'), (262, 2, u'-  assert(!Entries.empty() && "No #line entries for this FID after all!");'), (322, 2, u'-    assert(!IsFileEntry && !IsFileExit && !IsSystemHeader && !IsExternCHeader &&'), (430, 2, u'-  assert(FileEnt && "Didn\'t specify a file entry to use?");'), (476, 2, u'-  assert(!SLocEntryLoaded[Index]);'), (496, 2, u'-  assert(ExternalSLocEntries && "Don\'t have an external sloc source");'), (500, 2, u'-  assert(CurrentLoadedOffset >= NextLocalOffset && "Out of source locations");'), (539, 2, u'-    assert(LoadedID != -1 && "Loading sentinel FileID");'), (541, 2, u'-    assert(Index < LoadedSLocEntryTable.size() && "FileID out of range");'), (542, 2, u'-    assert(!SLocEntryLoaded[Index] && "FileID already loaded");'), (552, 2, u'-  assert(NextLocalOffset + FileSize + 1 > NextLocalOffset &&'), (592, 2, u'-    assert(LoadedID != -1 && "Loading sentinel FileID");'), (594, 2, u'-    assert(Index < LoadedSLocEntryTable.size() && "FileID out of range");'), (595, 2, u'-    assert(!SLocEntryLoaded[Index] && "FileID already loaded");'), (601, 2, u'-  assert(NextLocalOffset + TokLength + 1 > NextLocalOffset &&'), (613, 2, u'-  assert(IR && "getOrCreateContentCache() cannot return NULL");'), (621, 2, u'-  assert(IR && "getOrCreateContentCache() cannot return NULL");'), (629, 2, u'-  assert(SourceFile->getSize() == NewFile->getSize() &&'), (632, 2, u'-  assert(FileInfos.count(SourceFile) == 0 &&'), (684, 2, u'-  assert(SLocOffset < NextLocalOffset && "Bad function choice");'), (777, 2, u'-    assert(0 && "Invalid SLocOffset or bad function choice");'), (923, 2, u'-  assert(Loc.isMacroID() && "Not a macro expansion loc!");'), (1281, 2, u'-  assert(!Loc.isInvalid() && "Can\'t get file characteristic of invalid loc!");'), (1295, 2, u'-  assert(LineTable && "Can\'t have linetable entries without a LineTable!");'), (1360, 2, u'-    assert(LineTable && "Can\'t have linetable entries without a LineTable!");'), (1433, 2, u'-  assert(SourceFile && "Null source file!");'), (1434, 2, u'-  assert(Line && Col && "Line and column should start from 1!");'), (1445, 2, u'-  assert(SourceFile && "Null source file!");'), (1624, 2, u'-  assert(!FID.isInvalid());'), (1625, 2, u'-  assert(!CachePtr);'), (1734, 2, u'-  assert(!MacroArgsCache->empty());'), (1772, 2, u'-  assert(LHS.isValid() && RHS.isValid() && "Passed invalid source location!");'), (1830, 2, u'-  assert(LIsBuiltins && RIsBuiltins &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(268, 2, u'-  assert(isValidGCCRegisterName(Name) && "Invalid register passed in");'), (282, 2, u'-      assert(n >= 0 && (unsigned)n < NumNames &&'), (378, 2, u'-  assert(*Name == \'[\' && "Symbolic name did not start with \'[\'");')]
===========================================
Class:class OSTargetInfo : public TgtInfo { class OSTargetInfo : public TgtInfo 
Class:class DarwinTargetInfo : public OSTargetInfo<Target> { class DarwinTargetInfo : public OSTargetInfo<Target> 
Class:class PPCTargetInfo : public TargetInfo { class PPCTargetInfo : public TargetInfo 
Class:class PPC32TargetInfo : public PPCTargetInfo { class PPC32TargetInfo : public PPCTargetInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 2, u'-  assert(Kind < tok::NUM_TOKENS);')]
===========================================
Class:class EmitAssemblyHelper { class EmitAssemblyHelper 
Class:class ObjectByrefHelpers : public CodeGenModule::ByrefHelpers { class ObjectByrefHelpers : public CodeGenModule::ByrefHelpers 
Class:  class ARCWeakByrefHelpers : public CodeGenModule::ByrefHelpers { class ARCWeakByrefHelpers : public CodeGenModule::ByrefHelpers 
Class:   class ARCStrongByrefHelpers : public CodeGenModule::ByrefHelpers { class ARCStrongByrefHelpers : public CodeGenModule::ByrefHelpers 
Class:   class ARCStrongBlockByrefHelpers : public CodeGenModule::ByrefHelpers { class ARCStrongBlockByrefHelpers : public CodeGenModule::ByrefHelpers 
Class:   class CXXByrefHelpers : public CodeGenModule::ByrefHelpers { class CXXByrefHelpers : public CodeGenModule::ByrefHelpers 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 2, u'-  assert(Context.BuiltinInfo.isLibFunction(BuiltinID));'), (62, 2, u'-  assert(V->getType() == IntType);'), (73, 2, u'-  assert(V->getType() == ResultType);'), (83, 2, u'-  assert(E->getArg(0)->getType()->isPointerType());'), (84, 2, u'-  assert(CGF.getContext().hasSameUnqualifiedType(T,'), (86, 2, u'-  assert(CGF.getContext().hasSameUnqualifiedType(T, E->getArg(1)->getType()));'), (118, 2, u'-  assert(E->getArg(0)->getType()->isPointerType());'), (119, 2, u'-  assert(CGF.getContext().hasSameUnqualifiedType(T,'), (121, 2, u'-  assert(CGF.getContext().hasSameUnqualifiedType(T, E->getArg(1)->getType()));'), (150, 2, u'-  assert(ValTyP && "isn\'t scalar fp type!");'), (346, 2, u'-    assert(CI);'), (696, 2, u'-    assert((IntTy->getBitWidth() == 32 || IntTy->getBitWidth() == 64) &&'), (1307, 2, u'-    assert(Error == ASTContext::GE_None && "Should not codegen an error");'), (1322, 2, u'-        assert(IsConst && "Constant arg isn\'t actually constant?");'), (1331, 2, u'-        assert(PTy->canLosslesslyBitCastTo(FTy->getParamType(i)) &&'), (1347, 2, u'-      assert(V->getType()->canLosslesslyBitCastTo(RetTy) &&'), (1641, 2, u'-    assert(Type.getEltType() == NeonTypeFlags::Float16 && !quad &&'), (1647, 2, u'-    assert(Type.getEltType() == NeonTypeFlags::Float16 && !quad &&'), (1882, 2, u'-    assert(Type.isPoly() && "vmul builtin only supported for polynomial types");'), (2222, 2, u'-  assert((Ops.size() & (Ops.size() - 1)) == 0 &&'), (2254, 2, u'-  assert(Error == ASTContext::GE_None && "Should not codegen an error");'), (2267, 2, u'-    assert(IsConst && "Constant arg isn\'t actually constant?"); (void)IsConst;')]
===========================================
Class:class CGNVCUDARuntime : public CGCUDARuntime { class CGNVCUDARuntime : public CGCUDARuntime 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(88, 2, u'-    assert(isa<llvm::PointerType>(V->getType()) && "Arg type not PointerType");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(160, 2, u'-    assert(Entry->isDeclaration() && "definition already exists for alias");'), (161, 2, u'-    assert(Entry->getType() == AliasType &&'), (320, 2, u'-  assert((Qual->getKind() == NestedNameSpecifier::TypeSpec) &&'), (326, 2, u'-  assert(RT && "BuildAppleKextVirtualCall - Qual type must be record");'), (335, 2, u'-  assert(VTable && "BuildVirtualCall = kext vtbl pointer is null");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(136, 2, u'-  assert(getThisDecl(CGF) && "no \'this\' variable for function");'), (184, 2, u'-  assert(E->getCastKind() == CK_DerivedToBaseMemberPointer ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(147, 2, u'-  assert(!isa<CXXConstructorDecl>(MD) && "wrong method for contructors!");'), (148, 2, u'-  assert(!isa<CXXDestructorDecl>(MD) && "wrong method for destructors!");'), (195, 2, u'-  assert(FTP->getNumArgs() == 0 && "dtor with formal parameters");'), (211, 2, u'-  assert(isa<FunctionType>(FTy));'), (223, 2, u'-  assert(isa<FunctionProtoType>(FTy));'), (349, 2, u'-    assert(I->isCanonicalAsParam());'), (368, 2, u'-  assert(inserted && "Recursively being processed?");'), (386, 2, u'-  assert(erased && "Not in set?");'), (424, 2, u'-    assert(!RD->hasFlexibleArrayMember() &&'), (435, 2, u'-        assert(!FD->isBitField() &&'), (449, 2, u'-        assert(!FD->isBitField() &&'), (465, 2, u'-  assert(LV.isSimple() &&'), (487, 2, u'-        assert(!FD->isBitField() &&'), (782, 2, u'-  assert(Inserted && "Recursively being processed?");'), (798, 2, u'-    assert(!retAI.getIndirectAlign() && "Align unused on indirect return.");'), (853, 2, u'-  assert(Erased && "Not in set?");'), (1040, 2, u'-  assert((varType->isIntegerTy() || varType->isFloatingPointTy())'), (1078, 2, u'-  assert(FI.arg_size() == Args.size() &&'), (1140, 2, u'-        assert(AI != Fn->arg_end() && "Argument mismatch!");'), (1192, 2, u'-            assert(AI != Fn->arg_end() && "Argument mismatch!");'), (1204, 2, u'-            assert(AI != Fn->arg_end() && "Argument mismatch!");'), (1214, 2, u'-        assert(AI != Fn->arg_end() && "Argument mismatch!");'), (1262, 2, u'-  assert(AI == Fn->arg_end() && "Argument mismatch!");'), (1383, 2, u'-  assert(retainCall->use_empty());'), (1422, 2, u'-    assert(!store->isAtomic() && !store->isVolatile()); // see below'), (1432, 2, u'-  assert(!store->isAtomic() && !store->isVolatile());'), (1516, 2, u'-      assert(getLangOpts().ObjCAutoRefCount &&'), (1583, 2, u'-  assert(!isProvablyNull(srcAddr) &&'), (1689, 2, u'-    assert(srcRV.isScalar());'), (1711, 2, u'-    assert(getContext().getLangOpts().ObjCAutoRefCount);'), (1712, 2, u'-    assert(getContext().hasSameType(E->getType(), type));'), (1716, 2, u'-  assert(type->isReferenceType() == E->isGLValue() &&'), (1720, 2, u'-    assert(E->getObjectKind() == OK_Ordinary);'), (1729, 2, u'-    assert(L.isSimple());'), (1781, 2, u'-    assert(Elt->getType() == FTy->getParamType(ArgNo));'), (1783, 2, u'-    assert(FTy->isVarArg());'), (1809, 2, u'-    assert(RV.isAggregate() && "Unexpected rvalue during struct expansion");'), (1819, 2, u'-        assert(!FD->isBitField() &&'), (1845, 2, u'-    assert(RV.isScalar() &&'), (1889, 2, u'-  assert(CallInfo.arg_size() == CallArgs.size() &&')]
===========================================
Class:  class DestroyField  : public EHScopeStack::Cleanup {   class DestroyField  : public EHScopeStack::Cleanup 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 2, u'-  assert(rv.isAggregate());'), (115, 2, u'-  assert(StartOfBuffer + Size <= StartOfData);'), (150, 2, u'-  assert(((Size % sizeof(void*)) == 0) && "cleanup type is misaligned");'), (172, 2, u'-  assert(!empty() && "popping exception stack when not empty");'), (174, 2, u'-  assert(isa<EHCleanupScope>(*begin()));'), (197, 2, u'-  assert(getInnermostEHScope() == stable_end());'), (205, 2, u'-  assert(!empty() && "popping exception stack when not empty");'), (235, 2, u'-  assert(hasNormalCleanups());'), (239, 2, u'-  assert(BranchFixups.size() >= MinSize && "fixup stack out of order");'), (260, 2, u'-  assert(cleanup.getActiveFlag() == 0 && "cleanup already has active flag?");'), (314, 2, u'-  assert(Term && "can\'t transition block without terminator");'), (317, 2, u'-    assert(Br->isUnconditional());'), (330, 2, u'-  assert(Block && "resolving a null target block");'), (333, 2, u'-  assert(EHStack.hasNormalCleanups() &&'), (369, 2, u'-  assert(Old.isValid());'), (386, 2, u'-  assert(Scope.isNormalCleanup());'), (407, 2, u'-  assert(Br->getSuccessor(0) == Entry);'), (413, 2, u'-  assert(!WasInsertBlock || CGF.Builder.GetInsertPoint() == Entry->end());'), (455, 2, u'-  assert(CGF.HaveInsertPoint() && "cleanup ended with no insertion point?");'), (473, 2, u'-    assert(Br->isUnconditional() && Br->getSuccessor(0) == From);'), (516, 2, u'-      assert(condition->getOperand(0) == CGF.NormalCleanupDest);'), (517, 2, u'-      assert(condition->use_empty());'), (522, 2, u'-  assert(entry->use_empty());'), (530, 2, u'-  assert(!EHStack.empty() && "cleanup stack is empty!");'), (531, 2, u'-  assert(isa<EHCleanupScope>(*EHStack.begin()) && "top not a cleanup!");'), (533, 2, u'-  assert(Scope.getFixupDepth() <= EHStack.getNumBranchFixups());'), (545, 2, u'-  assert(Scope.hasEHBranches() == (EHEntry != 0));'), (572, 2, u'-  assert(!Scope.isNormalCleanup() || !HasPrebranchedFallthrough ||'), (605, 2, u'-    assert(normalEntry && !normalEntry->use_empty());'), (615, 2, u'-    assert(EHStack.getNumBranchFixups() == 0 ||'), (670, 2, u'-        assert(!IsActive && "source without fallthrough for active cleanup");'), (694, 2, u'-        assert(HasEnclosingCleanups);'), (706, 2, u'-        assert(!BranchThroughDest || !IsActive);'), (753, 2, u'-        assert(BranchThroughDest);'), (759, 2, u'-      assert(EHStack.hasNormalCleanups() == HasEnclosingCleanups);'), (790, 2, u'-        assert(!IsActive);'), (797, 2, u'-        assert(!FallthroughIsBranchThrough);'), (826, 2, u'-  assert(EHStack.hasNormalCleanups() || EHStack.getNumBranchFixups() == 0);'), (849, 2, u'-  assert(Dest.getScopeDepth().encloses(EHStack.stable_begin())'), (874, 2, u'-  assert(Dest.getScopeDepth().encloses(EHStack.stable_begin())'), (928, 2, u'-      assert(Scope.isNormalCleanup());'), (959, 2, u'-    assert(C.strictlyEncloses(I));'), (977, 2, u'-    assert(cleanup.strictlyEncloses(i));'), (1037, 2, u'-    assert(dominatingIP && "no existing variable and no dominating IP!");'), (1058, 2, u'-  assert(C != EHStack.stable_end() && "activating bottom of stack?");'), (1060, 2, u'-  assert(!Scope.isActive() && "double activation");'), (1070, 2, u'-  assert(C != EHStack.stable_end() && "deactivating bottom of stack?");'), (1072, 2, u'-  assert(Scope.isActive() && "double deactivation");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-  assert(LexicalBlockStack.empty() &&'), (118, 2, u'-  assert (FD && "Invalid FunctionDecl!");'), (468, 2, u'-    assert(Qc.empty() && "Unknown type qualifier for debug info");'), (786, 2, u'-          assert(SizeInBitsOverride && "found named 0-width bitfield");'), (824, 2, u'-        assert(SizeInBitsOverride && "found named 0-width bitfield");'), (850, 2, u'-  assert (Args.getNumElements() && "Invalid number of arguments!");'), (1637, 2, u'-    assert(T != LastT && "Type unwrapping failed to unwrap!");'), (1781, 2, u'-  assert(Diag && "Fall through without a diagnostic?");'), (2116, 2, u'-  assert(!LexicalBlockStack.empty() && "Region stack mismatch, stack empty!");'), (2126, 2, u'-  assert(!LexicalBlockStack.empty() && "Region stack mismatch, stack empty!");'), (2128, 2, u'-  assert(RCount <= LexicalBlockStack.size() && "Region stack mismatch");'), (2208, 2, u'-  assert(!LexicalBlockStack.empty() && "Region stack mismatch, stack empty!");'), (2330, 2, u'-  assert(!LexicalBlockStack.empty() && "Region stack mismatch, stack empty!");')]
===========================================
Class:  class RegularPartialArrayDestroy : public EHScopeStack::Cleanup {   class RegularPartialArrayDestroy : public EHScopeStack::Cleanup 
Class:            class IrregularPartialArrayDestroy : public EHScopeStack::Cleanup {   class IrregularPartialArrayDestroy : public EHScopeStack::Cleanup 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 2, u'-  assert(D.hasGlobalStorage() && "VarDecl must have global storage!");'), (26, 2, u'-  assert(!D.getType()->isReferenceType() &&'), (87, 2, u'-    assert(!record->hasTrivialDestructor());'), (141, 2, u'-  assert(PerformInit && "cannot have constant initializer which needs "'), (313, 2, u'-      assert(CXXGlobalInits[I->second] == 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(311, 2, u'-  assert(std::strcmp(ObjCXX.PersonalityFn, CXX.PersonalityFn) != 0 &&'), (661, 2, u'-  assert(EHStack.requiresLandingPad());'), (662, 2, u'-  assert(!EHStack.empty());'), (674, 2, u'-  assert(LP);'), (737, 2, u'-  assert(EHStack.requiresLandingPad());'), (790, 2, u'-      assert(I.next() == EHStack.end() && "EH filter is not end of EH stack");'), (791, 2, u'-      assert(!hasCatchAll && "EH filter reached after catch-all");'), (805, 2, u'-      assert(!hasCatchAll);'), (819, 2, u'-        assert(!hasCatchAll);'), (833, 2, u'-  assert(!(hasCatchAll && hasFilter));'), (866, 2, u'-  assert((LPadInst->getNumClauses() > 0 || LPadInst->isCleanup()) &&'), (1041, 2, u'-  assert(isa<RecordType>(CatchType) && "unexpected catch type!");'), (1143, 2, u'-  assert(dispatchBlock);'), (1149, 2, u'-    assert(dispatchBlock == catchScope.getHandler(0).Block);'), (1165, 2, u'-    assert(i < e && "ran off end of handlers!");'), (1169, 2, u'-    assert(typeValue && "fell into catch-all case!");'), (1223, 2, u'-  assert(CatchScope.getNumHandlers() == NumHandlers);'), (1394, 2, u'-  assert((beginCatchFn != 0) == (endCatchFn != 0) &&'), (1396, 2, u'-  assert(rethrowFn && "rethrow function is required");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(294, 2, u'-          assert(!ObjCARCReferenceLifetimeType->isArrayType());'), (305, 2, u'-          assert(!ObjCARCReferenceLifetimeType->isArrayType());'), (341, 2, u'-          assert(ME->getBase()->getType()->isRecordType());'), (468, 2, u'-      assert(!ObjCARCReferenceLifetimeType.isNull());'), (679, 2, u'-    assert(cast<InitListExpr>(E)->getNumInits() == 1 &&'), (749, 2, u'-  assert(type.isCanonical());'), (750, 2, u'-  assert(!type->isReferenceType());'), (847, 2, u'-    assert(isa<EnumConstantDecl>(value));'), (902, 2, u'-      assert(NumBits <= Bitwidth);'), (906, 2, u'-      assert(NumPositiveBits <= Bitwidth);'), (944, 2, u'-    assert(Value->getType()->isIntegerTy(8) && "value rep of bool not i1/i8");'), (953, 2, u'-    assert(Value->getType()->isIntegerTy(8) && "memory rep of bool not i8");'), (997, 2, u'-    assert(!LV.getType()->isFunctionType());'), (1016, 2, u'-  assert(LV.isBitField() && "Unknown LValue type!");'), (1149, 2, u'-    assert(Dst.isBitField() && "Unknown LValue type");'), (1192, 2, u'-      assert(Dst.getBaseIvarExp() && "BaseIvarExp is NULL");'), (1211, 2, u'-  assert(Src.isScalar() && "Can\'t emit an agg store with this method");'), (1498, 2, u'-  assert((VD->hasExternalStorage() || VD->isFileVarDecl()) &&'), (1546, 2, u'-  assert((ND->isUsed(false) || !isa<VarDecl>(ND) ||'), (1580, 2, u'-      assert(isa<BlockDecl>(CurCodeDecl) && E->refersToEnclosingLocal());'), (1586, 2, u'-    assert(V && "DeclRefExpr not entered in LocalDeclMap?");'), (1625, 2, u'-    assert(!T.isNull() && "CodeGenFunction::EmitUnaryOpLValue: Illegal type");'), (1643, 2, u'-    assert(LV.isSimple() && "real/imag on non-ordinary l-value");'), (1651, 2, u'-      assert(E->getSubExpr()->getType()->isArithmeticType());'), (1655, 2, u'-    assert(E->getSubExpr()->getType()->isAnyComplexType());'), (1788, 2, u'-    assert(LHS.isSimple() && "Can only subscript lvalue vectors here!");'), (1860, 2, u'-    assert(Array->getType()->isArrayType() &&'), (1884, 2, u'-  assert(!T.isNull() &&'), (1934, 2, u'-    assert(E->getBase()->getType()->isVectorType());'), (1938, 2, u'-    assert(E->getBase()->getType()->isVectorType() &&'), (1960, 2, u'-  assert(Base.isExtVectorElt() && "Can only subscript lvalue vec elts here!");'), (2025, 2, u'-    assert(LV.isSimple());'), (2052, 2, u'-    assert(!type->isReferenceType() && "union has reference member");'), (2123, 2, u'-  assert(!FieldType.getObjCGCAttr() && "fields cannot have GC attrs");'), (2162, 2, u'-    assert((hasAggregateLLVMType(expr->getType()) &&'), (2366, 2, u'-  assert(OpaqueValueMappingData::shouldBindAsLValue(e));'), (2490, 2, u'-  assert(E->getOpcode() == BO_Assign && "unexpected binary l-value");'), (2528, 2, u'-  assert(E->getCallReturnType()->isReferenceType() &&'), (2541, 2, u'-  assert(E->getType()->getAsCXXRecordDecl()->hasTrivialDestructor()'), (2575, 2, u'-  assert(E->getMethodDecl()->getResultType()->isReferenceType() &&'), (2639, 2, u'-  assert(CalleeType->isFunctionPointerType() &&'), (2744, 2, u'-    assert(!Dest && "Store does not return a value");'), (2863, 2, u'-    assert(!Dest && "Init does not return a value");'), (3165, 2, u'-  assert(Val->getType()->isFPOrFPVectorTy());')]
===========================================
Class:class AggExprEmitter : public StmtVisitor<AggExprEmitter> { class AggExprEmitter : public StmtVisitor<AggExprEmitter> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(240, 2, u'-  assert(Dest.getAddr() != Src.getAggregateAddr());'), (250, 2, u'-  assert(Src.isAggregate() && "value must be aggregate value!");'), (290, 2, u'-  assert(Src.isSimple() && "Can\'t have aggregate bitfield, vector, etc");'), (387, 2, u'-  assert(NumInitElements <= NumArrayElements);'), (458, 2, u'-    assert(cons->getConstructor()->isDefaultConstructor());'), (552, 2, u'-    assert(isa<CXXDynamicCastExpr>(E) && "CK_Dynamic without a dynamic_cast?");'), (591, 2, u'-    assert(CGF.getContext().hasSameUnqualifiedType(E->getSubExpr()->getType(),'), (685, 2, u'-  assert(CGF.getContext().hasSameUnqualifiedType(E->getLHS()->getType(),'), (735, 2, u'-  assert(CGF.HaveInsertPoint() && "expression evaluation ended with no IP!");'), (885, 2, u'-      assert(lv.isSimple());'), (940, 2, u'-  assert(E->getType()->isRecordType() && "Only support structs/unions here!");'), (961, 2, u'-        assert(Field->isUnnamedBitfield() && "Only unnamed bitfields allowed");'), (1026, 2, u'-      assert(LV.isSimple());'), (1172, 2, u'-  assert(E && hasAggregateLLVMType(E->getType()) &&'), (1174, 2, u'-  assert((Slot.getAddr() != 0 || Slot.isIgnored()) &&'), (1184, 2, u'-  assert(hasAggregateLLVMType(E->getType()) && "Invalid argument!");'), (1196, 2, u'-  assert(!Ty->isAnyComplexType() && "Shouldn\'t happen for complex");'), (1201, 2, u'-      assert((Record->hasTrivialCopyConstructor() ||')]
===========================================
Class:  class CallDeleteDuringNew : public EHScopeStack::Cleanup {   class CallDeleteDuringNew : public EHScopeStack::Cleanup 
Class:            class CallDeleteDuringConditionalNew : public EHScopeStack::Cleanup {   class CallDeleteDuringConditionalNew : public EHScopeStack::Cleanup 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 2, u'-  assert(MD->isInstance() &&'), (333, 2, u'-  assert(MD->isInstance() &&'), (402, 2, u'-  assert(!Dest.isIgnored() && "Must have a destination!");'), (412, 2, u'-      assert(0 && "Delegating constructor should not need zeroing");'), (431, 2, u'-    assert(getContext().hasSameUnqualifiedType(E->getType(),'), (477, 2, u'-  assert(isa<CXXConstructExpr>(Exp) &&'), (490, 2, u'-  assert(!getContext().getAsConstantArrayType(E->getType())'), (534, 2, u'-  assert(isa<llvm::IntegerType>(numElements->getType()));'), (668, 2, u'-    assert(numElements->getType() == CGF.SizeTy);'), (716, 2, u'-          assert(arraySizeMultiplier == typeSizeMultiplier);'), (728, 2, u'-      assert(arraySizeMultiplier == 1);'), (763, 2, u'-    assert(sizeWithoutCookie && "didn\'t set sizeWithoutCookie?");'), (984, 2, u'-      assert(I < NumPlacementArgs && "index out of range");'), (991, 2, u'-      assert(FPT->getNumArgs() == NumPlacementArgs + 1 ||'), (1041, 2, u'-      assert(I < NumPlacementArgs && "index out of range");'), (1048, 2, u'-      assert(FPT->getNumArgs() == NumPlacementArgs + 1 ||'), (1157, 2, u'-    assert(getContext().hasSameUnqualifiedType(argType.getNonReferenceType(),'), (1166, 2, u'-  assert((placementArg == E->placement_arg_end() ||'), (1180, 2, u'-    assert(allocatorArgs.size() == 2);'), (1233, 2, u'-  assert((allocSize == allocSizeWithoutCookie) =='), (1236, 2, u'-    assert(E->isArray());'), (1284, 2, u'-  assert(DeleteFD->getOverloadedOperator() == OO_Delete);'), (1430, 2, u'-      assert(DeleteFTy->getNumArgs() == 1 || DeleteFTy->getNumArgs() == 2);'), (1483, 2, u'-  assert(allocatedPtr && "ReadArrayCookie didn\'t set allocated pointer");'), (1494, 2, u'-    assert(numElements && "no element count for a type with a destructor!");'), (1559, 2, u'-  assert(ConvertTypeForMem(DeleteTy) =='), (1720, 2, u'-  assert(SrcRecordTy->isRecordType() && "source type must be a record type!");'), (1721, 2, u'-  assert(DestRecordTy->isRecordType() && "dest type must be a record type!");')]
===========================================
Class:class ComplexExprEmitter class ComplexExprEmitter
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 2, u'-    assert(LV.isSimple() && "complex l-value must be simple");'), (78, 2, u'-    assert(LV.isSimple() && "complex l-value must be simple");'), (196, 2, u'-    assert(E->getType()->isAnyComplexType() && "Expected complex type!");'), (202, 2, u'-    assert(E->getType()->isAnyComplexType() && "Expected complex type!");'), (610, 2, u'-  assert(OpInfo.Ty->isAnyComplexType());'), (611, 2, u'-  assert(CGF.getContext().hasSameUnqualifiedType(OpInfo.Ty,'), (655, 2, u'-  assert(CGF.getContext().hasSameUnqualifiedType(E->getLHS()->getType(),'), (741, 2, u'-    assert (Ignore == false && "init list ignored");'), (744, 2, u'-    assert (Ignore == false && "init list ignored");'), (755, 2, u'-  assert(E->getNumInits() == 0 && "Unexpected number of inits");'), (786, 2, u'-  assert(E && E->getType()->isAnyComplexType() &&'), (798, 2, u'-  assert(E && E->getType()->isAnyComplexType() &&'), (819, 2, u'-  assert(E->getOpcode() == BO_Assign);')]
===========================================
Class:class ConstStructBuilder { class ConstStructBuilder 
Class:          class ConstExprEmitter :   public StmtVisitor<ConstExprEmitter, llvm::Constant*> {   public StmtVisitor<ConstExprEmitter, llvm::Constant*> 
Class:class ScalarExprEmitter class ScalarExprEmitter
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(522, 2, u'-  assert(SrcType.isCanonical() && "EmitScalarConversion strips typedefs");'), (530, 2, u'-  assert((SrcType->isIntegerType() || isa<llvm::PointerType>(Src->getType())) &&'), (536, 2, u'-  assert(isa<llvm::PointerType>(Src->getType()));'), (578, 2, u'-    assert(SrcType->isIntegerType() && "Not ptr->ptr or int->ptr conversion?");'), (591, 2, u'-    assert(isa<llvm::IntegerType>(DstTy) && "not ptr->int?");'), (636, 2, u'-    assert(SrcTy->isFloatingPointTy() && "Unknown real conversion");'), (642, 2, u'-    assert(SrcTy->isFloatingPointTy() && DstTy->isFloatingPointTy() &&'), (651, 2, u'-    assert(ResTy->isIntegerTy(16) && "Only half FP requires extra conversion");'), (844, 2, u'-  assert (Ignore == false && "init list ignored");'), (1082, 2, u'-    assert(E->getType()->isArrayType() &&'), (1090, 2, u'-      assert(isa<llvm::PointerType>(V->getType()) && "Expected pointer");'), (1091, 2, u'-      assert(isa<llvm::ArrayType>(cast<llvm::PointerType>(V->getType())'), (1159, 2, u'-    assert(CGF.getContext().hasSameUnqualifiedType(E->getType(), DestTy));'), (1160, 2, u'-    assert(E->isGLValue() && "lvalue-to-rvalue applied to r-value!");'), (1176, 2, u'-    assert(!DestTy->isBooleanType() && "bool should use PointerToBool");'), (1527, 2, u'-      assert(i < RL.getFieldCount() && "offsetof field in wrong type");'), (2186, 2, u'-    assert(E->getOpcode() == BO_EQ ||'), (2303, 2, u'-      assert(E->getOpcode() == BO_NE &&'), (2620, 2, u'-      assert(!RHS && "LHS and RHS types must match");'), (2742, 2, u'-  assert(E && !hasAggregateLLVMType(E->getType()) &&'), (2758, 2, u'-  assert(!hasAggregateLLVMType(SrcTy) && !hasAggregateLLVMType(DstTy) &&'), (2769, 2, u'-  assert(SrcTy->isAnyComplexType() && !hasAggregateLLVMType(DstTy) &&')]
===========================================
Class:  class PropertyImplStrategy {   class PropertyImplStrategy 
Class:class LazyRuntimeFunction { class LazyRuntimeFunction 
Class:     class CGObjCGNU : public CGObjCRuntime { class CGObjCGNU : public CGObjCRuntime 
Class:        class CGObjCGCC : public CGObjCGNU { class CGObjCGCC : public CGObjCGNU 
Class: class CGObjCGNUstep : public CGObjCGNU { class CGObjCGNUstep : public CGObjCGNU 
Class:class ObjCCommonTypesHelper { class ObjCCommonTypesHelper 
Class:   class ObjCTypesHelper : public ObjCCommonTypesHelper { class ObjCTypesHelper : public ObjCCommonTypesHelper 
Class:   class ObjCNonFragileABITypesHelper : public ObjCCommonTypesHelper { class ObjCNonFragileABITypesHelper : public ObjCCommonTypesHelper 
Class: class CGObjCCommonMac : public CodeGen::CGObjCRuntime { class CGObjCCommonMac : public CodeGen::CGObjCRuntime 
Class:   class SKIP_SCAN {   class SKIP_SCAN 
Class: class CGObjCMac : public CGObjCCommonMac { class CGObjCMac : public CGObjCCommonMac 
Class: class CGObjCNonFragileABIMac : public CGObjCCommonMac { class CGObjCNonFragileABIMac : public CGObjCCommonMac 
Class:  class FragileHazards {   class FragileHazards 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(62, 2, u'-  assert(Index < RL->getFieldCount() && "Ivar is not inside record layout!");')]
===========================================
Class:class RTTIBuilder { class RTTIBuilder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(459, 2, u'-    assert(isa<ObjCInterfaceType>(Ty));'), (543, 2, u'-  assert(TypeNameGV->hasAvailableExternallyLinkage() &&'), (731, 2, u'-  assert(isa<BuiltinType>(T) || isa<ObjCInterfaceType>(T));')]
===========================================
Class:class CGRecordLayoutBuilder { class CGRecordLayoutBuilder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(271, 2, u'-  assert(llvm::isPowerOf2_32(TypeSizeInBits) && "Unexpected type size!");'), (307, 2, u'-      assert(AccessWidth >= Types.getTarget().getCharWidth()'), (318, 2, u'-    assert(FieldOffset < AccessStart + AccessWidth && "Invalid access start!");'), (319, 2, u'-    assert(AccessStart < FieldOffset + FieldSize && "Invalid access start!");'), (325, 2, u'-    assert(NumComponents < 3 && "Unexpected number of components!");'), (352, 2, u'-  assert(AccessedTargetBits == FieldSize && "Invalid bit-field access!");'), (381, 2, u'-    assert(fieldOffset % charAlign == 0 &&'), (393, 2, u'-    assert(BitsAvailableInLastField && "Bitfield size mismatch!");'), (394, 2, u'-    assert(!NextFieldOffset.isZero() && "Must have laid out at least one byte");'), (401, 2, u'-    assert(fieldOffset % charAlign == 0 &&'), (411, 2, u'-    assert(!numBytesToAppend.isZero() && "No bytes to append!");'), (442, 2, u'-  assert(fieldOffset % Types.getTarget().getCharWidth() == 0'), (453, 2, u'-    assert(!Packed && "Alignment is wrong even with packed struct!");'), (481, 2, u'-    assert(!Packed && "Could not place field even with packed struct!");'), (525, 2, u'-  assert(D->isUnion() && "Can\'t call LayoutUnion on a non-union record!");'), (539, 2, u'-    assert(layout.getFieldOffset(fieldNo) == 0 &&'), (580, 2, u'-    assert(hasOnlyZeroSizedBitFields &&'), (619, 2, u'-    assert(IsZeroInitializable &&'), (725, 2, u'-    assert(NextFieldOffset.isZero() &&'), (777, 2, u'-    assert(!Packed && "cannot layout even as packed struct");'), (799, 2, u'-  assert(!D->isUnion() && "Can\'t call LayoutFields on a union!");'), (800, 2, u'-  assert(!Alignment.isZero() && "Did not set alignment!");'), (826, 2, u'-      assert(!Packed &&'), (836, 2, u'-      assert(!Packed && "Could not layout even with a packed LLVM struct!");'), (864, 2, u'-  assert(NextFieldOffset <= RecordSize && "Size mismatch!");'), (891, 2, u'-  assert(NextFieldOffset <= fieldOffset &&'), (903, 2, u'-    assert(alignedNextFieldOffset <= fieldOffset);'), (933, 2, u'-  assert(!numBytes.isZero() && "Empty byte arrays aren\'t allowed.");'), (1033, 2, u'-  assert(TypeSizeInBits == getTargetData().getTypeAllocSizeInBits(Ty) &&'), (1045, 2, u'-    assert(AlignedNonVirtualTypeSizeInBits =='), (1066, 2, u'-      assert(AST_RL.getFieldOffset(i) == SL->getElementOffsetInBits(FieldNo) &&'), (1096, 2, u'-      assert(AccessBitOffset + AI.AccessWidth <= TypeSizeInBits &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 2, u'-  assert(S && "Null statement?");'), (60, 2, u'-      assert(!isa<DeclStmt>(*S) && "Unexpected DeclStmt!");'), (98, 2, u'-    assert(incoming && "expression emission must have an insertion point");'), (103, 2, u'-    assert(outgoing && "expression emission cleared block!");'), (321, 2, u'-    assert(!Dest.getScopeDepth().isValid() && "already emitted label!");'), (797, 2, u'-  assert(!BreakContinueStack.empty() && "break stmt not in a loop or switch!");'), (810, 2, u'-  assert(!BreakContinueStack.empty() && "continue stmt not in a loop!");'), (826, 2, u'-  assert(S.getRHS() && "Expected RHS value in CaseStmt");'), (950, 2, u'-  assert(DefaultBlock->empty() &&'), (1047, 2, u'-          assert(FoundCase && "Didn\'t find case but returned fallthrough?");'), (1273, 2, u'-      assert(OutCons &&'), (1279, 2, u'-      assert(result && "Could not resolve symbolic name"); (void)result;'), (1311, 2, u'-  assert(Target.isValidGCCRegisterName(Register));'), (1425, 2, u'-    assert(IsValid && "Failed to parse output constraint");'), (1434, 2, u'-    assert(IsValid && "Failed to parse input constraint"); (void)IsValid;'), (1488, 2, u'-        assert(InputNo != S.getNumInputs() && "Didn\'t find matching input!");'), (1575, 2, u'-          assert(OutputTy->isFloatingPointTy() && "Unexpected output type");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 2, u'-    assert(VTable.getBaseOffset().isZero() &&'), (69, 2, u'-      assert(AddressPoint != 0 && "Did not find vtable address point!");'), (72, 2, u'-      assert(AddressPoint != 0 && "Did not find ctor vtable address point!");'), (100, 2, u'-  assert(RD->getNumVBases() && "Only classes with virtual bases need a VTT");'), (161, 2, u'-  assert(I != SubVTTIndicies.end() && "Did not find index!");'), (188, 2, u'-  assert(I != SecondaryVirtualPointerIndices.end() && "Did not find index!");')]
===========================================
Class:  class BackendConsumer : public ASTConsumer {   class BackendConsumer : public ASTConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(137, 2, u'-      assert(TheModule.get() == M &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(112, 2, u'-    assert(!CurBB->getTerminator() && "Unexpected terminated block.");'), (156, 2, u'-  assert(BreakContinueStack.empty() &&'), (181, 2, u'-  assert(EHStack.empty() &&'), (266, 2, u'-  assert(CurFn->isDeclaration() && "Function already has body?");'), (398, 2, u'-  assert(FD->getBody());'), (892, 2, u'-    assert(isa<ConstantArrayType>(arrayType));'), (893, 2, u'-    assert(cast<ConstantArrayType>(arrayType)->getSize().getZExtValue()'), (904, 2, u'-    assert(arrayType && "LLVM and Clang types are out-of-synch");'), (925, 2, u'-  assert(vla && "type was not a variable array type!");'), (938, 2, u'-    assert(vlaSize && "no size for VLA!");'), (939, 2, u'-    assert(vlaSize->getType() == SizeTy);'), (953, 2, u'-  assert(type->isVariablyModifiedType() &&'), (961, 2, u'-    assert(type->isVariablyModifiedType());'), (1072, 2, u'-  assert (Init && "Invalid DeclRefExpr initializer!");'), (1088, 2, u'-  assert(HaveInsertPoint());'), (1118, 2, u'-  assert(D->hasAttr<AnnotateAttr>() && "no annotate attribute");'), (1131, 2, u'-  assert(D->hasAttr<AnnotateAttr>() && "no annotate attribute");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(324, 2, u'-    assert(II && "Attempt to mangle unnamed decl.");'), (457, 2, u'-  assert(Linkage == GVA_StrongExternal);'), (614, 2, u'-  assert(!GV->isDeclaration() &&'), (672, 2, u'-    assert(CGRef && "Deferred decl wasn\'t referenced?");'), (751, 2, u'-  assert(D->hasAttr<AnnotateAttr>() && "no annotate attribute");'), (769, 2, u'-  assert(AA && "No alias?");'), (838, 2, u'-    assert(VD->isFileVarDecl() && "Cannot emit local var decl as global.");'), (1027, 2, u'-  assert(F->getName() == MangledName && "name was uniqued!");'), (1060, 2, u'-          assert(FD->isUsed() && "Sema didn\'t mark implicit function as used!");'), (1074, 2, u'-    assert(F->getType()->getElementType() == Ty);'), (1218, 2, u'-      assert(GV->isDeclaration() && "Declaration has wrong type!");'), (1248, 2, u'-  assert(D->hasGlobalStorage() && "Not a global variable");'), (1270, 2, u'-  assert(!D->getInit() && "Cannot emit definite definitions here!");'), (1480, 2, u'-  assert(llvmInit && "failed to initialize as constant");'), (1504, 2, u'-    assert(!ASTTy->isIncompleteType() && "Unexpected incomplete type");'), (1542, 2, u'-    assert(CE->getOpcode() == llvm::Instruction::BitCast ||'), (1748, 2, u'-    assert(CE->getOpcode() == llvm::Instruction::BitCast);'), (1757, 2, u'-    assert(OldFn->isDeclaration() &&'), (1818, 2, u'-  assert(AA && "Not an alias?");'), (1847, 2, u'-    assert(Entry->isDeclaration());'), (2196, 2, u'-  assert(!E->getType()->isPointerType() && "Strings are always arrays");'), (2225, 2, u'-  assert(ElemTy->getPrimitiveSizeInBits() == 32);'), (2501, 2, u'-  case Decl::StaticAssert:'), (2578, 2, u'-    assert(isa<TypeDecl>(D) && "Unsupported decl kind");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(406, 2, u'-    assert(A->getIndexTypeCVRQualifiers() == 0 &&'), (415, 2, u'-    assert(A->getIndexTypeCVRQualifiers() == 0 &&'), (564, 2, u'-  assert(ResultType && "Didn\'t convert a type?");'), (599, 2, u'-  assert(InsertResult && "Recursively compiling a struct?");'), (617, 2, u'-  assert(EraseResult && "struct not in RecordsBeingLaidOut set?");'), (648, 2, u'-  assert(Layout && "Unable to find record layout information for type");')]
===========================================
Class:class ItaniumCXXABI : public CodeGen::CGCXXABI { class ItaniumCXXABI : public CodeGen::CGCXXABI 
Class: class ARMCXXABI : public ItaniumCXXABI { class ARMCXXABI : public ItaniumCXXABI 
Class:class MicrosoftCXXABI : public CGCXXABI { class MicrosoftCXXABI : public CGCXXABI 
Class:  class CodeGeneratorImpl : public CodeGenerator {   class CodeGeneratorImpl : public CodeGenerator 
Class:class DefaultABIInfo : public ABIInfo { class DefaultABIInfo : public ABIInfo 
Class: class DefaultTargetCodeGenInfo : public TargetCodeGenInfo { class DefaultTargetCodeGenInfo : public TargetCodeGenInfo 
Class:      class X86_32ABIInfo : public ABIInfo { class X86_32ABIInfo : public ABIInfo 
Class: class X86_32TargetCodeGenInfo : public TargetCodeGenInfo { class X86_32TargetCodeGenInfo : public TargetCodeGenInfo 
Class:class X86_64ABIInfo : public ABIInfo { class X86_64ABIInfo : public ABIInfo 
Class:  class WinX86_64ABIInfo : public ABIInfo { class WinX86_64ABIInfo : public ABIInfo 
Class: class X86_64TargetCodeGenInfo : public TargetCodeGenInfo { class X86_64TargetCodeGenInfo : public TargetCodeGenInfo 
Class: class WinX86_64TargetCodeGenInfo : public TargetCodeGenInfo { class WinX86_64TargetCodeGenInfo : public TargetCodeGenInfo 
Class:  Class &Current = OffsetBase < 64 ? Lo : Hi;
Class:      Class FieldLo, FieldHi;
Class:        Class FieldLo, FieldHi;
Class:      Class FieldLo, FieldHi;
Class:class PPC32TargetCodeGenInfo : public DefaultTargetCodeGenInfo { class PPC32TargetCodeGenInfo : public DefaultTargetCodeGenInfo 
Class:class ARMABIInfo : public ABIInfo { class ARMABIInfo : public ABIInfo 
Class: class ARMTargetCodeGenInfo : public TargetCodeGenInfo { class ARMTargetCodeGenInfo : public TargetCodeGenInfo 
Class:class PTXABIInfo : public ABIInfo { class PTXABIInfo : public ABIInfo 
Class: class PTXTargetCodeGenInfo : public TargetCodeGenInfo { class PTXTargetCodeGenInfo : public TargetCodeGenInfo 
Class:class MBlazeABIInfo : public ABIInfo { class MBlazeABIInfo : public ABIInfo 
Class: class MBlazeTargetCodeGenInfo : public TargetCodeGenInfo { class MBlazeTargetCodeGenInfo : public TargetCodeGenInfo 
Class:class MSP430TargetCodeGenInfo : public TargetCodeGenInfo { class MSP430TargetCodeGenInfo : public TargetCodeGenInfo 
Class:class MipsABIInfo : public ABIInfo { class MipsABIInfo : public ABIInfo 
Class: class MIPSTargetCodeGenInfo : public TargetCodeGenInfo { class MIPSTargetCodeGenInfo : public TargetCodeGenInfo 
Class:class TCETargetCodeGenInfo : public DefaultTargetCodeGenInfo { class TCETargetCodeGenInfo : public DefaultTargetCodeGenInfo 
Class:class HexagonABIInfo : public ABIInfo { class HexagonABIInfo : public ABIInfo 
Class: class HexagonTargetCodeGenInfo : public TargetCodeGenInfo { class HexagonTargetCodeGenInfo : public TargetCodeGenInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(277, 2, u'-  assert(Index0 + 1 == Index1 && "Unexpected non-consecutive indices!");')]
===========================================
Class:class CC1AsOptTable : public OptTable { class CC1AsOptTable : public OptTable 
Class:class CC1OptTable : public OptTable { class CC1OptTable : public OptTable 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(184, 2, u'-    assert(Res && "Error string set with 0 result code!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(972, 2, u'-        assert(InputTypeArg && "InputType set w/o InputTypeArg");'), (1050, 2, u'-    assert(NumSteps && "Invalid number of steps!");'), (1089, 2, u'-        assert(i + 1 == NumSteps && "linking must be final compilation step.");'), (1134, 2, u'-      assert(OutputTy != types::TY_INVALID &&'), (1445, 2, u'-    assert(Suffix && "All types used for output should have a suffix.");')]
===========================================
Class:class DriverOptTable : public OptTable { class DriverOptTable : public OptTable 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 2, u'-  assert(((A.Kind == Option::JoinedClass) ^ (B.Kind == Option::JoinedClass)) &&'), (93, 2, u'-      assert(!TheInputOption && "Cannot have multiple input options!");'), (96, 2, u'-      assert(!TheUnknownOption && "Cannot have multiple input options!");'), (103, 2, u'-  assert(FirstSearchableIndex != 0 && "No searchable options?");'), (110, 2, u'-    assert((Kind != Option::InputClass && Kind != Option::UnknownClass &&'), (173, 2, u'-    assert((info.Kind == Option::JoinedOrSeparateClass ||'), (178, 2, u'-    assert((info.Kind == Option::JoinedOrSeparateClass ||'), (249, 2, u'-    assert(Index > Prev && "Parser failed to consume argument.");'), (253, 2, u'-      assert(Index >= End && "Unexpected parser error.");'), (254, 2, u'-      assert(Index - Prev - 1 && "No missing arguments!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 2, u'-  assert((!Alias || (!Alias->Alias && !Group)) &&'), (218, 2, u'-  assert(NumArgs > 1  && "Invalid MultiArgOption!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(511, 2, u'-  assert(define.startswith(SimulatorVersionDefineName()));'), (654, 2, u'-    assert((!iOSVersion && !iOSSimVersion) && "Unknown target platform!");'), (662, 2, u'-    assert(Version && "Unknown target platform!");'), (1484, 2, u'-      assert(0 && "Invalid tool kind.");'), (1492, 2, u'-      assert(false && "Unsupported action for Hexagon target.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(35, 2, u'-  assert(id > 0 && id - 1 < numTypes && "Invalid Type ID.");'), (215, 2, u'-  assert(N < getNumCompilationPhases(Id) && "Invalid index.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(22, 2, u'-  assert(Loc.isFileID());'), (34, 2, u'-  assert(Loc.isFileID());'), (324, 2, u'-  assert(!text.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(242, 2, u'-  assert(!offs.getFID().isInvalid());'), (245, 2, u'-  assert(Loc.isFileID());'), (250, 2, u'-    assert(len);'), (279, 2, u'-    assert(offs >= CurEnd);'), (305, 2, u'-  assert(BeginOffs.getFID() == EndOffs.getFID());'), (306, 2, u'-  assert(BeginOffs <= EndOffs);'), (309, 2, u'-  assert(BLoc.isFileID());')]
===========================================
Class:  class ASTPrinter : public ASTConsumer {   class ASTPrinter : public ASTConsumer 
Class:  class ASTViewer : public ASTConsumer {   class ASTViewer : public ASTConsumer 
Class:class DeclContextPrinter : public ASTConsumer { class DeclContextPrinter : public ASTConsumer 
Class:class ASTDumpXML : public ASTConsumer { class ASTDumpXML : public ASTConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(84, 2, u'-  assert(AdaptedAction && "ASTMergeAction needs an action to adapt");')]
===========================================
Class:  class SimpleTimer {   class SimpleTimer 
Class:class ASTInfoCollector : public ASTReaderListener { class ASTInfoCollector : public ASTReaderListener 
Class: class StoredDiagnosticConsumer : public DiagnosticConsumer { class StoredDiagnosticConsumer : public DiagnosticConsumer 
Class:   class CaptureDroppedDiagnostics { class CaptureDroppedDiagnostics 
Class:class MacroDefinitionTrackerPPCallbacks : public PPCallbacks { class MacroDefinitionTrackerPPCallbacks : public PPCallbacks 
Class: class TopLevelDeclTrackerConsumer : public ASTConsumer { class TopLevelDeclTrackerConsumer : public ASTConsumer 
Class: class TopLevelDeclTrackerAction : public ASTFrontendAction { class TopLevelDeclTrackerAction : public ASTFrontendAction 
Class: class PrecompilePreambleConsumer : public PCHGenerator { class PrecompilePreambleConsumer : public PCHGenerator 
Class: class PrecompilePreambleAction : public ASTFrontendAction { class PrecompilePreambleAction : public ASTFrontendAction 
Class:  class AugmentedCodeCompleteConsumer : public CodeCompleteConsumer {   class AugmentedCodeCompleteConsumer : public CodeCompleteConsumer 
Class:class PTHEntry { class PTHEntry 
Class:  class PTHEntryKeyVariant { class PTHEntryKeyVariant 
Class: class FileEntryPTHEntryInfo { class FileEntryPTHEntryInfo 
Class: class OffsetOpt { class OffsetOpt 
Class:class PTHWriter { class PTHWriter 
Class:class StatListener : public FileSystemStatCache { class StatListener : public FileSystemStatCache 
Class:class PTHIdKey { class PTHIdKey 
Class: class PTHIdentifierTableTrait { class PTHIdentifierTableTrait 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(63, 2, u'-  assert(!includes.empty() && "No \'-chain-include\' in options!");'), (121, 2, u'-      assert(!serialBufs.empty());'), (156, 2, u'-  assert(!serialBufs.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(439, 2, u'-  assert(OutFile.OS && "Attempt to add empty stream to output list!");'), (522, 2, u'-  assert((!CreateMissingDirectories || UseTemporary) &&'), (627, 2, u'-  assert(!SourceMgr.getMainFileID().isInvalid() &&'), (635, 2, u'-  assert(hasDiagnostics() && "Diagnostics engine is not initialized!");'), (636, 2, u'-  assert(!getFrontendOpts().ShowHelp && "Client must handle \'-help\'!");'), (637, 2, u'-  assert(!getFrontendOpts().ShowVersion && "Client must handle \'-version\'!");'), (817, 2, u'-  assert(ImportingInstance.getInvocation().getModuleHash() ==')]
===========================================
Class:  class ToArgsList {   class ToArgsList 
Class:  class ModuleSignature {   class ModuleSignature 
Class:class DependencyFileCallback : public PPCallbacks { class DependencyFileCallback : public PPCallbacks 
Class:class DependencyGraphCallback : public PPCallbacks { class DependencyGraphCallback : public PPCallbacks 
Class:class FixitReceiver : public edit::EditsReceiver { class FixitReceiver : public edit::EditsReceiver 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 2, u'-   assert(Loc.isMacroID() && "Only reasonble to call this on macros");'), (298, 2, u'-  assert(!Loc.isInvalid() && "must have a valid source location here");'), (303, 2, u'-    assert(MacroDepth == 0 && "We shouldn\'t hit a leaf node twice!");')]
===========================================
Class:class DelegatingDeserializationListener : public ASTDeserializationListener { class DelegatingDeserializationListener : public ASTDeserializationListener 
Class:  class DeserializedDeclsDumper : public DelegatingDeserializationListener { class DeserializedDeclsDumper : public DelegatingDeserializationListener 
Class:         class DeserializedDeclsChecker : public DelegatingDeserializationListener {   class DeserializedDeclsChecker : public DelegatingDeserializationListener 
Class:class HeaderIncludesCallback : public PPCallbacks { class HeaderIncludesCallback : public PPCallbacks 
Class:class InitHeaderSearch { class InitHeaderSearch 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(105, 2, u'-  assert(!Path.isTriviallyEmpty() && "can\'t handle empty path here");'), (513, 2, u'-      assert(CurEntry.isHeaderMap() && "Not a headermap or normal dir?");'), (530, 2, u'-        assert(FirstDir != i && "Didn\'t find dupe?");'), (544, 2, u'-          assert(CurEntry.isHeaderMap() && "Not a headermap or normal dir?");'), (639, 2, u'-        assert(SearchList[i].isHeaderMap() && "Unknown DirectoryLookup");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 2, u'-  assert(Sem == (const llvm::fltSemantics*)&llvm::APFloat::IEEEquad);'), (448, 2, u'-  assert(TI.getCharWidth() == 8 && "Only support 8-bit char so far");')]
===========================================
Class:class MultiplexASTDeserializationListener class MultiplexASTDeserializationListener
Class:   class MultiplexASTMutationListener : public ASTMutationListener { class MultiplexASTMutationListener : public ASTMutationListener 
Class:class PrintPPOutputPPCallbacks : public PPCallbacks { class PrintPPOutputPPCallbacks : public PPCallbacks 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(585, 2, u'-    assert(Opts.ShowMacros && "Not yet implemented!");')]
===========================================
Class:class AbbreviationMap { class AbbreviationMap 
Class: class SDiagsRenderer : public DiagnosticNoteRenderer { class SDiagsRenderer : public DiagnosticNoteRenderer 
Class: class SDiagsWriter : public DiagnosticConsumer { class SDiagsWriter : public DiagnosticConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(109, 2, u'-        assert(DiagOpts.ShowCategories == 2 && "Invalid ShowCategories value");'), (155, 2, u'-  assert(LangOpts && "Unexpected diagnostic outside source file processing");'), (156, 2, u'-  assert(DiagOpts && "Unexpected diagnostic without options set");'), (157, 2, u'-  assert(Info.hasSourceManager() &&')]
===========================================
Class:class Directive { class Directive 
Class:   class StandardDirective : public Directive { class StandardDirective : public Directive 
Class:   class RegexDirective : public Directive { class RegexDirective : public Directive 
Class: class ParseHelper { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(195, 2, u'-  assert(isHeaderMap() && "Unknown DirectoryLookup");'), (247, 2, u'-  assert(isHeaderMap() && "Unknown directory lookup");'), (568, 2, u'-  assert(ContextFileEnt && "No context file?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 2, u'-  assert(BufEnd[0] == 0 &&'), (189, 2, u'-  assert(L->BufferEnd[0] == 0 && "Buffer is not nul terminated!");'), (291, 2, u'-  assert((int)Tok.getLength() >= 0 && "Token character range is bogus!");'), (315, 2, u'-  assert(Result.size() != unsigned(Tok.getLength()) &&'), (333, 2, u'-  assert((int)Tok.getLength() >= 0 && "Token character range is bogus!");'), (375, 2, u'-  assert(unsigned(OutBuf-Buffer) != Tok.getLength() &&'), (424, 2, u'-  assert(Loc.isFileID());'), (495, 2, u'- assert(FileLocInfo.first == BeginFileLocInfo.first &&'), (743, 2, u'-  assert(loc.isValid() && loc.isMacroID() && "Expected a valid macro loc");'), (769, 2, u'-  assert(loc.isValid() && loc.isMacroID() && "Expected a valid macro loc");'), (801, 2, u'-  assert(Begin.isFileID() && End.isFileID());'), (855, 2, u'-  assert(Begin.isMacroID() && End.isMacroID());'), (930, 2, u'-  assert(Loc.isMacroID() && "Only reasonble to call this on macros");'), (1062, 2, u"-  assert(CHAR_HORZ_WS == CharInfo[(int)' ']);"), (1063, 2, u"-  assert(CHAR_HORZ_WS == CharInfo[(int)'\\t']);"), (1064, 2, u"-  assert(CHAR_HORZ_WS == CharInfo[(int)'\\f']);"), (1065, 2, u"-  assert(CHAR_HORZ_WS == CharInfo[(int)'\\v']);"), (1066, 2, u"-  assert(CHAR_VERT_WS == CharInfo[(int)'\\n']);"), (1067, 2, u"-  assert(CHAR_VERT_WS == CharInfo[(int)'\\r']);"), (1068, 2, u"-  assert(CHAR_UNDER   == CharInfo[(int)'_']);"), (1069, 2, u"-  assert(CHAR_PERIOD  == CharInfo[(int)'.']);"), (1071, 2, u'-    assert(CHAR_LETTER == CharInfo[i]);'), (1072, 2, u"-    assert(CHAR_LETTER == CharInfo[i+'A'-'a']);"), (1075, 2, u'-    assert(CHAR_NUMBER == CharInfo[i]);'), (1141, 2, u'-  assert(FileLoc.isMacroID() && "Must be a macro expansion");'), (1165, 2, u'-  assert(Loc >= BufferStart && Loc <= BufferEnd &&'), (1176, 2, u'-  assert(PP && "This doesn\'t work on raw lexers");'), (1579, 2, u'-  assert(getLangOpts().CPlusPlus);'), (2035, 2, u'-  assert(Spelling[0] == \'/\' && Spelling[1] == \'/\' && "Not bcpl comment?");'), (2050, 2, u"-  assert(CurPtr[0] == '\\n' || CurPtr[0] == '\\r');"), (2290, 2, u'-  assert(ParsingPreprocessorDirective && ParsingFilename == false &&'), (2320, 2, u'-      assert(CurPtr[-1] == Char && "Trigraphs for newline?");'), (2330, 2, u'-      assert(Tmp.is(tok::eod) && "Unexpected token!");'), (2394, 2, u'-  assert(!LexingRawMode && "How can we expand a macro from a skipping buffer?");'), (2474, 2, u'-      assert(CurPtr != BufferEnd && "Didn\'t find end of line");'), (2584, 2, u'-      assert(PPCache && "Raw buffer::LexEndOfFile should return a token");'), (2612, 2, u'-      assert(PPCache && "Raw buffer::LexEndOfFile should return a token");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(272, 2, u'-  assert((CharByteWidth == 1 || CharByteWidth == 2 || CharByteWidth) &&'), (276, 2, u'-  assert((UcnLen== 4 || UcnLen== 8) && "only ucn length of 4 or 8 supported");'), (306, 2, u'-  assert(CharByteWidth == 1 && "UTF-8 encoding is only for 1 byte characters");'), (396, 2, u"-  assert(!isalnum(*end) && *end != '.' && *end != '_' &&"), (568, 2, u'-  assert(s[0] == \'0\' && "Invalid method call");'), (729, 2, u'-    assert(C < radix && "NumericLiteralParser ctor should have rejected this");'), (811, 2, u'-  assert(begin[0] == \'\\\'\' && "Invalid token lexed");'), (825, 2, u'-  assert(end != begin && "Invalid token lexed");'), (831, 2, u'-  assert(PP.getTargetInfo().getCharWidth() == 8 &&'), (833, 2, u'-  assert(PP.getTargetInfo().getIntWidth() <= 64 &&'), (836, 2, u'-  assert(PP.getTargetInfo().getWCharWidth() <= 64 &&'), (1049, 2, u'-  assert(NumStringToks && "expected at least one token");'), (1051, 2, u'-  assert(StringToks[0].getLength() >= 2 && "literal token is invalid!");'), (1067, 2, u'-    assert(StringToks[i].getLength() >= 2 && "literal token is invalid!");'), (1095, 2, u'-  assert((CharByteWidth & 7) == 0 && "Assumes character size is byte multiple");'), (1188, 2, u'-      assert(ThisTokEnd >= ThisTokBuf && "malformed raw string literal");'), (1195, 2, u'-      assert(ThisTokBuf[0] == \'"\' && "Expected quote, lexer broken?");'), (1252, 2, u'-          assert(CharByteWidth == 1 && "Unexpected char width");'), (1271, 2, u'-      assert(CharByteWidth == 1 && "Unexpected char width");'), (1303, 2, u'-  assert(CharByteWidth==1 || CharByteWidth==2 || CharByteWidth==4);'), (1335, 2, u'-  assert((result != targetExhausted)'), (1368, 2, u"-  assert(SpellingPtr[0] != 'L' && SpellingPtr[0] != 'u' &&"), (1376, 2, u'-  assert(SpellingPtr[0] == \'"\' && "Should be a string literal!");'), (1381, 2, u'-    assert(SpellingPtr < SpellingEnd && "Didn\'t find byte offset!");'), (1395, 2, u'-    assert(!HadError && "This method isn\'t valid on erroneous strings");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 2, u'-  assert(MI->isFunctionLike() &&'), (120, 2, u'-    assert(Result < Start+NumUnexpArgTokens && "Invalid arg #");'), (124, 2, u'-  assert(Result < Start+NumUnexpArgTokens && "Invalid arg #");'), (150, 2, u'-  assert(Arg < MI->getNumArgs() && "Invalid argument number!");'), (305, 2, u'-  assert(ArgNo < NumUnexpArgTokens && "Invalid argument number!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 2, u'-  assert(!IsDefinitionLengthCached);'), (70, 2, u'-  assert(macroStart.isValid() && macroEnd.isValid());'), (71, 2, u'-  assert((macroStart.isFileID() || firstToken.is(tok::comment)) &&'), (73, 2, u'-  assert((macroEnd.isFileID() || lastToken.is(tok::comment)) &&'), (79, 2, u'-  assert(startInfo.first == endInfo.first &&'), (81, 2, u'-  assert(startInfo.second <= endInfo.second);')]
===========================================
Class:  class ModuleMapParser {   class ModuleMapParser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 2, u'-    assert(Unresolved.Wildcard && "Invalid unresolved export");'), (94, 2, u'-  assert((!this->Target || this->Target == &Target) &&'), (763, 2, u'-  assert(Tok.is(MMToken::ExplicitKeyword) || Tok.is(MMToken::ModuleKeyword) ||'), (994, 2, u'-  assert(Tok.is(MMToken::RequiresKeyword));'), (1066, 2, u'-  assert(Tok.is(MMToken::HeaderKeyword));'), (1240, 2, u'-  assert(Tok.is(MMToken::ExportKeyword));'), (1278, 2, u'-  assert(Tok.is(MMToken::Star));'), (1422, 2, u'-  assert(Target != 0 && "Missing target information");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 2, u'-  assert(!BacktrackPositions.empty()'), (41, 2, u'-  assert(!BacktrackPositions.empty()'), (87, 2, u'-  assert(CachedLexPos + N > CachedTokens.size() && "Confused caching.");'), (98, 2, u'-  assert(Tok.isAnnotation() && "Expected annotation token");'), (99, 2, u'-  assert(CachedLexPos != 0 && "Expected to have some cached tokens");'), (100, 2, u'-  assert(CachedTokens[CachedLexPos-1].getLastLoc() == Tok.getAnnotationEndLoc()'), (108, 2, u'-      assert((BacktrackPositions.empty() || BacktrackPositions.back() < i) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 2, u'-    assert(MIChainHead == MIChain);'), (91, 2, u'-    assert(Tmp.isNot(tok::eof) && "EOF seen while discarding directive tokens");'), (207, 2, u'-  assert(CurTokenLexer == 0 && CurPPLexer && "Lexing a macro, not a file?");'), (325, 2, u'-        assert(!InCond && "Can\'t be skipping if not in a conditional!");'), (369, 2, u'-          assert(CurPPLexer->LexingRawMode && "We have to be skipping here!");'), (411, 2, u'-    assert(CurPTHLexer);'), (412, 2, u'-    assert(CurPTHLexer->LexingRawMode == false);'), (421, 2, u'-      assert(!InCond && "Can\'t be skipping if not in a conditional!");'), (458, 2, u'-    assert(K == tok::pp_elif);'), (685, 2, u'-    case tok::pp_assert:'), (688, 2, u'-    case tok::pp_unassert:'), (832, 2, u'-    assert(Literal.isAscii() && "Didn\'t allow wide strings in");'), (968, 2, u'-    assert(Literal.isAscii() && "Didn\'t allow wide strings in");'), (1146, 2, u'-  assert(!Buffer.empty() && "Can\'t have tokens with empty spellings!");'), (1462, 2, u'-  assert(!FID.isInvalid() && "Expected valid file ID");'), (1540, 2, u'-    assert(TmpTok.isNot(tok::eof) && "Didn\'t find end of -imacros!");'), (1687, 2, u'-    assert(Ident__VA_ARGS__->isPoisoned() && "__VA_ARGS__ should be poisoned!");'), (1829, 2, u'-  assert(!MI->isUsed());'), (1919, 2, u'-      assert(isIfndef && "#ifdef shouldn\'t reach here");'), (2006, 2, u'-  assert(!CondInfo.WasSkipping && !CurPPLexer->LexingRawMode &&')]
===========================================
Class:class PPValue { class PPValue 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 2, u'-  assert(IsFileLexer(IncludeMacroStack[0]) &&'), (73, 2, u'-  assert(CurTokenLexer == 0 && "Cannot #include a file inside a macro!");'), (234, 2, u'-  assert(!CurTokenLexer &&'), (272, 2, u'-        assert(CurPTHLexer && "Got EOF but no current lexer set!");'), (335, 2, u'-    assert(CurPTHLexer && "Got EOF but no current lexer set!");'), (397, 2, u'-  assert(CurTokenLexer && !CurPPLexer &&'), (418, 2, u'-  assert(!IncludeMacroStack.empty() && "Ran out of stack entries to load");'), (435, 2, u'-  assert(CurTokenLexer && !CurPPLexer &&'), (476, 2, u'-    assert(FoundLexer && "Can\'t get end of line without an active lexer");'), (493, 2, u'-  assert(!FoundLexer && "Lexer should return EOD before EOF in PP mode");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(35, 2, u'-  assert(II->hasMacroDefinition() && "Identifier is not a macro!");'), (44, 2, u'-  assert(Pos != Macros.end() && "Identifier macro info is missing!");'), (347, 2, u'-  assert(Tok.is(tok::l_paren) && "Error computing l-paren-ness?");'), (356, 2, u'-    assert((Tok.is(tok::l_paren) || Tok.is(tok::comma)) &&'), (449, 2, u'-    assert(NumFixedArgsLeft != 0 && "Too many arguments parsed");'), (519, 2, u'-  assert(tokLexer);'), (544, 2, u'-  assert(!MacroExpandingLexersStack.empty());'), (546, 2, u'-  assert(tokIndex < MacroExpandedTokens.size());'), (893, 2, u'-  assert(II && "Can\'t be a macro without id info!");'), (1054, 2, u'-      assert(II == Ident__has_feature && "Must be feature check");'), (1112, 2, u'-        assert(Literal.isAscii() && "Didn\'t allow wide strings in");')]
===========================================
Class:class PTHFileData { class PTHFileData 
Class:  class PTHFileLookupCommonTrait { class PTHFileLookupCommonTrait 
Class: class PTHFileLookupTrait : public PTHFileLookupCommonTrait { class PTHFileLookupTrait : public PTHFileLookupCommonTrait 
Class: class PTHStringLookupTrait { class PTHStringLookupTrait 
Class:class PTHStatData { class PTHStatData 
Class: class PTHStatLookupTrait : public PTHFileLookupCommonTrait { class PTHStatLookupTrait : public PTHFileLookupCommonTrait 
Class: class PTHStatCache : public FileSystemStatCache { class PTHStatCache : public FileSystemStatCache 
Class:class LexingFor_PragmaRAII { class LexingFor_PragmaRAII 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 2, u'-  assert(!FID.isInvalid());'), (100, 2, u'-    assert(unsigned(-PPID-1) < LoadedPreprocessedEntities.size() &&'), (102, 2, u'-    assert(ExternalSource && "No external source to load from");'), (121, 2, u'-  assert(unsigned(PPID) < PreprocessedEntities.size() &&'), (131, 2, u'-  assert(Range.isValid());'), (132, 2, u'-  assert(!SourceMgr.isBeforeInTranslationUnit(Range.getEnd(),Range.getBegin()));'), (164, 2, u'-  assert(!SourceMgr.isBeforeInTranslationUnit(Range.getEnd(),Range.getBegin()));'), (249, 2, u'-  assert(Entity);'), (253, 2, u'-    assert((PreprocessedEntities.empty() ||'), (303, 2, u'-  assert(!ExternalSource &&'), (323, 2, u'-    assert(unsigned(-PPID-1) < LoadedPreprocessedEntities.size() &&'), (327, 2, u'-  assert(unsigned(PPID) < PreprocessedEntities.size() &&'), (335, 2, u'-  assert(Index < LoadedPreprocessedEntities.size() &&'), (337, 2, u'-  assert(ExternalSource && "No external source to load from");'), (468, 2, u'-  assert(CondDirectiveLocs.empty() ||'), (509, 2, u'-    assert(!CondDirectiveStack.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 2, u'-    assert(Target && "Must provide target information for PP initialization");'), (77, 2, u'-  assert(BacktrackPositions.empty() && "EnableBacktrack/Backtrack imbalance!");'), (111, 2, u'-  assert((!this->Target || this->Target == &Target) &&'), (287, 2, u'-  assert(File);'), (288, 2, u'-  assert(CompleteLine && CompleteColumn && "Starts from 1:1");'), (289, 2, u'-  assert(!CodeCompletionFile && "Already set");'), (404, 2, u'-  assert(NumEnteredSourceFiles == 0 && "Cannot reenter the main file!");'), (428, 2, u'-  assert(SB && "Cannot create predefined source buffer");'), (430, 2, u'-  assert(!FID.isInvalid() && "Could not create FileID for predefines?");'), (450, 2, u'-  assert(Identifier.getRawIdentifierData() != 0 && "No raw identifier data!");'), (477, 2, u'-  assert(Ident__exception_code && Ident__exception_info);'), (478, 2, u'-  assert(Ident___exception_code && Ident___exception_info);'), (491, 2, u'-  assert(Identifier.getIdentifierInfo() &&'), (510, 2, u'-  assert(Identifier.getIdentifierInfo() &&'), (626, 2, u'-  assert(Handler && "NULL comment handler");'), (627, 2, u'-  assert(std::find(CommentHandlers.begin(), CommentHandlers.end(), Handler) =='), (635, 2, u'-  assert(Pos != CommentHandlers.end() && "Comment handler not registered");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 2, u'-  assert(ParsingPreprocessorDirective &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 2, u'-    assert(Tokens[0].getLocation().isValid());'), (50, 2, u'-    assert((Tokens[0].getLocation().isFileID() || Tokens[0].is(tok::comment)) &&'), (52, 2, u'-    assert(ExpandLocStart.isValid());'), (144, 2, u'-      assert(ArgNo != -1 && "Token following # is not an argument?");'), (317, 2, u'-    assert(PasteBefore && ResultToks.back().is(tok::hashhash));'), (345, 2, u'-    assert(!OwnsTokens && "This would leak if we already own the token list");'), (461, 2, u'-    assert(!isAtEnd() && "No token on the RHS of a paste operator!");'), (516, 2, u'-      assert(ResultTokLoc.isFileID() &&'), (643, 2, u'-  assert(Macro && "Token streams can\'t paste comments");'), (655, 2, u'-  assert(ExpandLocStart.isValid() && MacroExpansionStart.isValid() &&'), (657, 2, u'-  assert(loc.isValid() && loc.isFileID());'), (660, 2, u'-  assert(SM.isInSLocAddrSpace(loc, MacroDefStart, MacroDefLength) &&'), (681, 2, u'-  assert(begin_tokens < end_tokens);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 2, u'-  assert(D.isFunctionDeclarator() && "This isn\'t a function declarator!");'), (32, 2, u'-  assert((Tok.is(tok::l_brace) || Tok.is(tok::colon) || Tok.is(tok::kw_try) ||'), (185, 2, u'-  assert((Tok.is(tok::l_brace) || Tok.is(tok::equal)) &&'), (313, 2, u'-      assert(Tok.is(tok::equal) && "Default argument not starting with \'=\'");'), (339, 2, u'-      assert(!PP.getSourceManager().isBeforeInTranslationUnit(origLoc,'), (385, 2, u'-  assert(!LM.Toks.empty() && "Empty body!");'), (393, 2, u'-  assert((Tok.is(tok::l_brace) || Tok.is(tok::colon) || Tok.is(tok::kw_try))'), (403, 2, u'-    assert(!PP.getSourceManager().isBeforeInTranslationUnit(origLoc,'), (648, 2, u'-        assert(kind == tok::l_brace && "Must be left paren or brace here.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(110, 2, u'-  assert(Tok.is(tok::kw___attribute) && "Not a GNU attribute list!");'), (180, 2, u'-  assert(Tok.is(tok::l_paren) && "Attribute arg list not starting with \'(\'");'), (292, 2, u'-  assert(Tok.is(tok::kw___declspec) && "Not a declspec!");'), (884, 2, u'-  assert(Tok.is(tok::l_paren) && "Attribute arg list not starting with \'(\'");'), (924, 2, u'-  assert(Tok.is(tok::l_square) && NextToken().is(tok::l_square));'), (940, 2, u'-    assert(Tok.is(tok::r_square) && "isCXX11AttributeSpecifier lied");'), (1005, 2, u'-  case tok::kw_static_assert:'), (1006, 2, u'-  case tok::kw__Static_assert:'), (1008, 2, u'-    SingleDecl = ParseStaticAssertDeclaration(DeclEnd);'), (1486, 2, u'-      assert(!Exprs.empty() && Exprs.size()-1 == CommaLocs.size() &&'), (1620, 2, u'-  assert(Tok.is(tok::identifier) && "should have identifier");'), (1635, 2, u'-  assert(!DS.hasTypeSpecifier() && "Type specifier checked above");'), (1780, 2, u'-  assert((Tok.is(tok::kw_alignas) || Tok.is(tok::kw__Alignas)) &&'), (1971, 2, u'-        assert(Tok.is(tok::annot_template_id) &&'), (2495, 2, u'-      assert(PrevSpec && "Method did not return previous specifier!");'), (2496, 2, u'-      assert(DiagID);'), (2945, 2, u'-    assert(TemplateInfo.TemplateParams && "no template parameters");'), (3401, 2, u'-  case tok::kw__Static_assert:'), (3639, 2, u'-      assert(PrevSpec && "Method did not return previous specifier!");'), (3964, 2, u'-    assert(!getLangOpts().CPlusPlus &&'), (3966, 2, u'-    assert(Tok.getIdentifierInfo() && "Not an identifier?");'), (4007, 2, u'-  assert(D.isPastIdentifier() &&'), (4060, 2, u'-  assert(!D.isPastIdentifier() && "Should be called before passing identifier");'), (4177, 2, u'-  assert(getCurScope()->isFunctionPrototypeScope() &&'), (4180, 2, u'-  assert(D.isPastIdentifier() && "Should not call before identifier!");'), (4704, 2, u'-  assert(Tok.is(tok::kw_typeof) && "Not a typeof specifier");'), (4766, 2, u'-  assert(Tok.is(tok::kw__Atomic) && "Not an atomic specifier");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 2, u'-  assert(Tok.is(tok::kw_namespace) && "Not a namespace!");'), (226, 2, u'-  assert(Tok.is(tok::equal) && "Not equal token");'), (268, 2, u'-  assert(Tok.is(tok::string_literal) && "Not a string literal!");'), (331, 2, u'-  assert(Tok.is(tok::kw_using) && "Not using token");'), (378, 2, u'-  assert(Tok.is(tok::kw_namespace) && "Not \'namespace\' token");'), (592, 2, u'-Decl *Parser::ParseStaticAssertDeclaration(SourceLocation &DeclEnd){'), (593, 2, u'-  assert((Tok.is(tok::kw_static_assert) || Tok.is(tok::kw__Static_assert)) &&'), (596, 2, u'-  if (Tok.is(tok::kw__Static_assert) && !getLangOpts().C11)'), (597, 2, u'-    Diag(Tok, diag::ext_c11_static_assert);'), (598, 2, u'-  if (Tok.is(tok::kw_static_assert))'), (599, 2, u'-    Diag(Tok, diag::warn_cxx98_compat_static_assert);'), (601, 2, u'-  SourceLocation StaticAssertLoc = ConsumeToken();'), (609, 2, u'-  ExprResult AssertExpr(ParseConstantExpression());'), (610, 2, u'-  if (AssertExpr.isInvalid()) {'), (624, 2, u'-  ExprResult AssertMessage(ParseStringLiteralExpression());'), (625, 2, u'-  if (AssertMessage.isInvalid()) {'), (633, 2, u'-  ExpectAndConsumeSemi(diag::err_expected_semi_after_static_assert);'), (635, 2, u'-  return Actions.ActOnStaticAssertDeclaration(StaticAssertLoc,'), (636, 2, u'-                                              AssertExpr.take(),'), (637, 2, u'-                                              AssertMessage.take(),'), (646, 2, u'-  assert((Tok.is(tok::kw_decltype) || Tok.is(tok::annot_decltype))'), (736, 2, u'-  assert(Tok.is(tok::kw___underlying_type) &&'), (817, 2, u'-      assert(Tok.is(tok::annot_typename) && "template-id -> type failed");'), (954, 2, u'-    assert(TagTokKind == tok::kw_union && "Not a class specifier");'), (1221, 2, u'-        assert(TUK == Sema::TUK_Definition && "Expected a definition here");'), (1305, 2, u'-      assert(TUK == Sema::TUK_Reference || TUK == Sema::TUK_Friend);'), (1313, 2, u'-    assert(Tok.is(tok::l_brace) ||'), (1429, 2, u'-  assert(Tok.is(tok::colon) && "Not a base clause");'), (1742, 2, u'-  if (Tok.is(tok::kw_static_assert) || Tok.is(tok::kw__Static_assert)) {'), (1745, 2, u'-    ParseStaticAssertDeclaration(DeclEnd);'), (1750, 2, u'-    assert(!TemplateInfo.TemplateParams &&'), (2129, 2, u'-  assert((Tok.is(tok::equal) || Tok.is(tok::l_brace))'), (2174, 2, u'-  assert((TagType == DeclSpec::TST_struct ||'), (2218, 2, u'-    assert(isCXX0XFinalKeyword() && "not a class definition");'), (2238, 2, u'-  assert(Tok.is(tok::l_brace));'), (2394, 2, u'-  assert(Tok.is(tok::colon) && "Constructor initializer always starts with \':\'");'), (2462, 2, u'-      assert(Tok.is(tok::annot_typename) && "template-id -> type failed");'), (2556, 2, u'-    assert(DynamicExceptions.size() == DynamicExceptionRanges.size() &&'), (2624, 2, u'-  assert(Tok.is(tok::kw_throw) && "expected throw");'), (2679, 2, u'-  assert(Tok.is(tok::arrow) && "expected arrow");'), (2691, 2, u'-  assert((NonNestedClass || !ClassStack.empty()) &&'), (2715, 2, u'-  assert(!ClassStack.empty() && "Mismatched push/pop for class parsing");'), (2727, 2, u'-  assert(!ClassStack.empty() && "Missing top-level class?");'), (2741, 2, u'-  assert(getCurScope()->isClassScope() && "Nested class outside of class scope?");'), (2834, 2, u'-  assert(Tok.is(tok::l_square) && NextToken().is(tok::l_square)'), (2947, 2, u'-  assert(Tok.is(tok::l_square) && "Not a Microsoft attribute list");')]
===========================================
Class:class CastExpressionIdValidator : public CorrectionCandidateCallback { class CastExpressionIdValidator : public CorrectionCandidateCallback 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(320, 2, u'-          assert(FILoc.isFileID());'), (406, 2, u'-    assert(NextTokPrec <= ThisPrec && "Recursion didn\'t work!");'), (720, 2, u'-    assert(Res.get() == 0 && "Stray primary-expression annotation?");'), (1399, 2, u'-        assert((ArgExprs.size() == 0 ||'), (1523, 2, u'-  assert((OpTok.is(tok::kw_typeof)    || OpTok.is(tok::kw_sizeof) ||'), (1583, 2, u'-  assert((Tok.is(tok::kw_sizeof) || Tok.is(tok::kw___alignof)'), (1890, 2, u'-  assert(Tok.is(tok::l_paren) && "Not a paren expr!");'), (1955, 2, u'-      assert(tokenKind == tok::kw___bridge_retain);'), (2113, 2, u'-  assert(Tok.is(tok::l_brace) && "Not a compound literal!");'), (2129, 2, u'-  assert(isTokenStringLiteral() && "Not a string literal!");'), (2157, 2, u'-  assert(Tok.is(tok::kw__Generic) && "_Generic keyword expected");'), (2336, 2, u'-  assert(Tok.is(tok::caret) && "block literal starts with ^");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(141, 2, u'-  assert(getLangOpts().CPlusPlus &&'), (299, 2, u'-      assert(Tok.is(tok::coloncolon) && "NextToken() not working properly!");'), (371, 2, u'-      assert((Tok.is(tok::coloncolon) || Tok.is(tok::colon)) &&'), (581, 2, u'-  assert(getLangOpts().CPlusPlus0x'), (622, 2, u'-  assert(Tok.is(tok::l_square) && "Lambda expressions begin with \'[\'.");'), (971, 2, u'-  assert(Tok.is(tok::kw_typeid) && "Not \'typeid\'!");'), (1031, 2, u'-  assert(Tok.is(tok::kw___uuidof) && "Not \'__uuidof\'!");'), (1105, 2, u'-    assert(Tok.is(tok::coloncolon) &&"ParseOptionalCXXScopeSpecifier fail");'), (1113, 2, u'-    assert(Tok.is(tok::coloncolon) &&"ParseOptionalCXXScopeSpecifier fail");'), (1120, 2, u'-  assert(Tok.is(tok::tilde) && "ParseOptionalCXXScopeSpecifier fail");'), (1175, 2, u'-  assert(Tok.is(tok::kw_throw) && "Not throw!");'), (1203, 2, u'-  assert(Tok.is(tok::kw_this) && "Not \'this\'!");'), (1225, 2, u'-  assert((Tok.is(tok::l_paren) ||'), (1260, 2, u'-    assert((Exprs.size() == 0 || Exprs.size()-1 == CommaLocs.size())&&'), (1601, 2, u'-  assert((AssumeTemplateId || Tok.is(tok::less)) &&'), (1803, 2, u'-  assert(Tok.is(tok::kw_operator) && "Expected \'operator\' keyword");'), (2229, 2, u'-  assert(Tok.is(tok::kw_new) && "expected \'new\' token");'), (2423, 2, u'-  assert(Tok.is(tok::kw_delete) && "Expected \'delete\' keyword");'), (2727, 2, u'-  assert(getLangOpts().CPlusPlus && "Should only be called for C++!");'), (2728, 2, u'-  assert(ExprType == CastExpr && "Compound literals are not ambiguous!");'), (2729, 2, u'-  assert(isTypeIdInParens() && "Not a type-id!");'), (2816, 2, u'-    assert(ParseAs == CastExpr);'), (2830, 2, u'-  assert(ParseAs == SimpleExpr);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(164, 2, u'-    assert(Tok.is(tok::colon) && "MayBeDesignationStart not working properly!");'), (200, 2, u'-    assert(Tok.is(tok::l_square) && "Unexpected token!");'), (360, 2, u'-  assert(!Desig.empty() && "Designator is empty?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(26, 2, u'-  assert(Tok.is(tok::annot_pragma_unused));'), (33, 2, u'-  assert(Tok.is(tok::annot_pragma_vis));'), (49, 2, u'-  assert(Tok.is(tok::annot_pragma_pack));'), (402, 2, u'-  assert(RParenLoc.isValid() && "Valid \'#pragma unused\' must have \')\'");'), (403, 2, u'-  assert(!Identifiers.empty() && "Valid \'#pragma unused\' must have arguments");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 2, u'-  assert((Attrs.empty() || Res.isInvalid() || Res.isUsable()) &&'), (363, 2, u'-  assert(Tok.is(tok::kw___try) && "Expected \'__try\'");'), (472, 2, u'-  assert(Tok.is(tok::identifier) && Tok.getIdentifierInfo() &&'), (478, 2, u'-  assert(Tok.is(tok::colon) && "Not a label!");'), (510, 2, u'-  assert((MissingCase || Tok.is(tok::kw_case)) && "Not a case stmt!");'), (614, 2, u'-  assert(!TopLevelCase.isInvalid() && "Should have parsed at least one case!");'), (647, 2, u'-  assert(Tok.is(tok::kw_default) && "Not a default stmt!");'), (720, 2, u'-  assert(Tok.is(tok::l_brace) && "Not a compount stmt!");'), (910, 2, u'-  assert(Tok.is(tok::kw_if) && "Not an if stmt!");'), (1041, 2, u'-  assert(Tok.is(tok::kw_switch) && "Not a switch stmt!");'), (1129, 2, u'-  assert(Tok.is(tok::kw_while) && "Not a while stmt!");'), (1201, 2, u'-  assert(Tok.is(tok::kw_do) && "Not a do stmt!");'), (1282, 2, u'-  assert(Tok.is(tok::kw_for) && "Not a for stmt!");'), (1427, 2, u'-    assert(!SecondPart.get() && "Shouldn\'t have a second expression yet.");'), (1537, 2, u'-  assert(Tok.is(tok::kw_goto) && "Not a goto stmt!");'), (1590, 2, u'-  assert(Tok.is(tok::kw_return) && "Not a return stmt!");'), (1764, 2, u'-  assert(Tok.is(tok::kw_asm) && "Not an asm stmt");'), (1843, 2, u'-  assert(Names.size() == Constraints.size() &&'), (1948, 2, u'-  assert(Tok.is(tok::l_brace));'), (1981, 2, u'-  assert(Tok.is(tok::kw_try) && "Expected \'try\'");'), (2013, 2, u'-  assert(Tok.is(tok::l_brace));'), (2014, 2, u'-  assert(SkipFunctionBodies &&'), (2037, 2, u'-  assert(Tok.is(tok::kw_try) && "Expected \'try\'");'), (2126, 2, u'-  assert(Tok.is(tok::kw_catch) && "Expected \'catch\'");')]
===========================================
Class:  class TemplateParameterDepthCounter {   class TemplateParameterDepthCounter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 2, u'-  case tok::kw_static_assert:'), (61, 2, u'-  case tok::kw__Static_assert:'), (130, 2, u'-  assert(TPR == TPResult::True() || TPR == TPResult::False());'), (145, 2, u'-  assert(isCXXDeclarationSpecifier() == TPResult::Ambiguous());'), (156, 2, u'-  assert(Tok.is(tok::l_paren) && "Expected \'(\'");'), (264, 2, u'-  assert(Tok.is(tok::l_paren) && "Expected \'(\'");'), (287, 2, u'-  assert(TPR == TPResult::True() || TPR == TPResult::False());'), (342, 2, u'-  assert(Tok.is(tok::l_paren) && "Expected \'(\'");'), (373, 2, u'-  assert(TPR == TPResult::True() || TPR == TPResult::False());'), (1029, 2, u'-    assert(Tok.is(tok::annot_typename));'), (1185, 2, u'-  assert(Tok.is(tok::kw_typeof) && "Expected \'typeof\'!");'), (1188, 2, u'-  assert(Tok.is(tok::l_paren) && "Expected \'(\'");'), (1200, 2, u'-  assert(Tok.is(tok::less) && "Expected \'<\' for qualifier list");'), (1235, 2, u'-  assert(Tok.is(tok::l_paren) && "Expected \'(\'!");')]
===========================================
Class:  class DestroyTemplateIdAnnotationsRAIIObj {   class DestroyTemplateIdAnnotationsRAIIObj 
Class:  class DeltaTreeNode {   class DeltaTreeNode 
Class:  class DeltaTreeInteriorNode : public DeltaTreeNode {   class DeltaTreeInteriorNode : public DeltaTreeNode 
Class:class RewritesReceiver : public edit::EditsReceiver { class RewritesReceiver : public edit::EditsReceiver 
Class:class FixItRewriteInPlace : public FixItOptions { class FixItRewriteInPlace : public FixItOptions 
Class: class FixItActionSuffixInserter : public FixItOptions { class FixItActionSuffixInserter : public FixItOptions 
Class: class FixItRewriteToTemp : public FixItOptions { class FixItRewriteToTemp : public FixItOptions 
Class:  class HTMLPrinter : public ASTConsumer {   class HTMLPrinter : public ASTConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(39, 2, u'-  assert(SM.getFileID(E) == FID && "B/E not in the same file!");'), (114, 2, u'-  assert (C <= FileEnd);'), (236, 2, u'-  assert (C <= FileEnd);'), (247, 2, u'-    assert (FilePos <= LineEndPos);'), (248, 2, u'-    assert (C < FileEnd);'), (526, 2, u'-    assert(SM.getFileID(LLoc.second) == FID &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-  assert(CurTok < RawTokens.size() && "Overran eof!");')]
===========================================
Class:  class RewriteModernObjC : public ASTConsumer {   class RewriteModernObjC : public ASTConsumer 
Class:    class DisableReplaceStmtScope {     class DisableReplaceStmtScope 
Class:  class RewriteObjC : public ASTConsumer {   class RewriteObjC : public ASTConsumer 
Class:    class DisableReplaceStmtScope {     class DisableReplaceStmtScope 
Class:   class RewriteObjCFragileABI : public RewriteObjC {   class RewriteObjCFragileABI : public RewriteObjC 
Class:  class RopePieceBTreeNode {   class RopePieceBTreeNode 
Class:  class RopePieceBTreeLeaf : public RopePieceBTreeNode {   class RopePieceBTreeLeaf : public RopePieceBTreeNode 
Class:  class RopePieceBTreeInterior : public RopePieceBTreeNode {   class RopePieceBTreeInterior : public RopePieceBTreeNode 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-  assert(RealOffset+Size < Buffer.size() && "Invalid location");'), (209, 2, u'-  assert(Loc.isValid() && "Invalid location");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(62, 2, u'-  assert(MapIt != TokenAtLoc.end() && "iterator not in rewriter?");'), (75, 2, u'-  assert(InsertSuccess && "Token location already in rewriter!");')]
===========================================
Class:  class UnreachableCodeHandler : public reachable_code::Callback {   class UnreachableCodeHandler : public reachable_code::Callback 
Class:class ContainsReference : public EvaluatedExprVisitor<ContainsReference> { class ContainsReference : public EvaluatedExprVisitor<ContainsReference> 
Class:class UninitValsDiagReporter : public UninitVariablesHandler { class UninitValsDiagReporter : public UninitVariablesHandler 
Class:class ThreadSafetyReporter : public clang::thread_safety::ThreadSafetyHandler { class ThreadSafetyReporter : public clang::thread_safety::ThreadSafetyHandler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 2, u'-  assert(size >= sizeof(AttributeList));'), (33, 2, u'-  assert((size % sizeof(void*)) == 0);'), (52, 2, u'-  assert(cur && "reclaiming empty pool!");'), (74, 2, u'-  assert(pool);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(202, 2, u'-  assert(NumChunks <= 0xffff);'), (203, 2, u'-  assert(NumAnnotations <= 0xffff);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(39, 2, u'-  assert(TemplateId && "NULL template-id annotation?");'), (47, 2, u'-  assert(TemplateId && "NULL template-id annotation?");'), (61, 2, u'-  assert(Range == Builder.getSourceRange() &&'), (74, 2, u'-  assert(Range == Builder.getSourceRange() &&'), (87, 2, u'-  assert(Range == Builder.getSourceRange() &&'), (100, 2, u'-  assert(Range == Builder.getSourceRange() &&'), (110, 2, u'-  assert(Range == Builder.getSourceRange() &&'), (451, 2, u'-        assert(!isInvalid && "auto SCS -> TST recovery failed");'), (466, 2, u'-  assert((unsigned)SC == StorageClassSpec && "SCS constants overflow bitfield");'), (538, 2, u'-  assert(isTypeRep(T) && "T does not store a type");'), (539, 2, u'-  assert(Rep && "no type provided!");'), (557, 2, u'-  assert(isExprRep(T) && "T does not store an expr");'), (558, 2, u'-  assert(Rep && "no expression provided!");'), (584, 2, u'-  assert(isDeclRep(T) && "T does not store a decl");'), (603, 2, u'-  assert(!isDeclRep(T) && !isTypeRep(T) && !isExprRep(T) &&'), (923, 2, u'-  assert(!TypeSpecOwned || isDeclRep((TST) TypeSpecType));')]
===========================================
Class:        class IdentifierResolver::IdDeclInfoMap { class IdentifierResolver::IdDeclInfoMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(137, 2, u'-      assert(S->getParent() && "No TUScope?");'), (217, 2, u'-  assert(D && "null param passed");'), (224, 2, u'-  assert(Ptr && "Didn\'t find this decl on its identifier\'s chain!");'), (227, 2, u'-    assert(D == Ptr && "Didn\'t find this decl on its identifier\'s chain!");'), (236, 2, u'-  assert(Old->getDeclName() == New->getDeclName() &&'), (436, 2, u'-  assert(!isDeclPtr(InfoPtr) && "Decl with wrong id ?");')]
===========================================
Class:class JumpScopeChecker { class JumpScopeChecker 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(110, 2, u'-      assert(Scopes[B].ParentScope < B);'), (113, 2, u'-      assert(Scopes[A].ParentScope < A);'), (499, 2, u'-      assert(LabelAndGotoScopes.count(SC) && "Case not visited?");'), (547, 2, u'-      assert(LabelAndGotoScopes.count(IG) &&'), (567, 2, u'-    assert(LabelAndGotoScopes.count(TheLabel->getStmt()) &&'), (673, 2, u'-  assert(!ToScopes.empty());'), (684, 2, u'-  assert(JumpScope != TargetScope);'), (721, 2, u'-  assert(LabelAndGotoScopes.count(From) && "Jump didn\'t get added to scopes?");'), (724, 2, u'-  assert(LabelAndGotoScopes.count(To) && "Jump didn\'t get added to scopes?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(252, 2, u'-      assert(0 && "can\'t implicitly cast lvalue to rvalue with this cast kind");'), (260, 2, u'-  assert((VK == VK_RValue || !E->isRValue()) && "can\'t cast rvalue to lvalue");'), (438, 2, u'-      assert(!(*I)->isDependentType() &&'), (629, 2, u'-  assert(ParsingInitForAutoVars.empty() &&'), (846, 2, u'-  assert(!FunctionScopes.empty() && "mismatched push/pop!");'), (872, 2, u'-  assert(!CurFunction->CompoundScopes.empty() && "mismatched push/pop");')]
===========================================
Class:  class SavedInstanceContext {   class SavedInstanceContext 
Class:  class PragmaPackStack {   class PragmaPackStack 
Class:class NestedNameSpecifierValidatorCCC : public CorrectionCandidateCallback { class NestedNameSpecifierValidatorCCC : public CorrectionCandidateCallback 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(152, 2, u'-    assert(Tag && "Non-tag type in nested-name-specifier");'), (190, 2, u'-  assert(getLangOpts().CPlusPlus && "Only callable in C++");'), (191, 2, u'-  assert(NNS->isDependent() && "Only dependent nested-name-specifier allowed");'), (211, 2, u'-  assert(DC != 0 && "given null context");'), (318, 2, u'-  assert(!Found.isAmbiguous() && "Cannot handle ambiguities here yet");'), (343, 2, u'-    assert(!SS.isSet() && "ObjectType and scope specifier cannot coexist");'), (430, 2, u'-    assert(!SS.isSet() && "ObjectType and scope specifier cannot coexist");'), (717, 2, u'-  assert(DS.getTypeSpecType() == DeclSpec::TST_decltype);'), (775, 2, u'-    assert(DTN->getQualifier()'), (881, 2, u'-  assert(SS.isSet() && "Parser passed invalid CXXScopeSpec.");'), (925, 2, u'-  assert(SS.isSet() && "Parser passed invalid CXXScopeSpec.");'), (952, 2, u'-  assert(SS.isSet() && "Parser passed invalid CXXScopeSpec.");'), (955, 2, u'-  assert(!SS.isInvalid() && computeDeclContext(SS, true) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(121, 2, u'-      assert(Self.getLangOpts().ObjCAutoRefCount);'), (219, 2, u'-  assert(!D.isInvalidType());'), (333, 2, u'-  assert(sequence.Failed() && "initialization succeeded on second try?");'), (472, 2, u'-  assert((SrcType->isAnyPointerType() || SrcType->isMemberPointerType() ||'), (475, 2, u'-  assert((DestType->isAnyPointerType() || DestType->isMemberPointerType() ||'), (561, 2, u'-    assert(DestPointer && "Reference to void is not possible");'), (609, 2, u'-  assert((DestPointer || DestReference) &&'), (611, 2, u'-  assert((DestRecord || DestPointee->isVoidType()) &&'), (613, 2, u'-  assert(SrcRecord && "Bad source pointee slipped through.");'), (649, 2, u'-  assert(SrcDecl && "Definition missing");'), (1235, 2, u'-    assert(StillOkay);'), (1581, 2, u'-    assert(!IsLValueCast);'), (1661, 2, u'-    assert(srcIsPtr && "One type must be a pointer");'), (1676, 2, u'-    assert(destIsPtr && "One type must be a pointer");'), (1805, 2, u'-    assert(Kind == CK_Dependent);'), (1872, 2, u'-      assert(!Fn && "cast failed but able to resolve overload expression!!");'), (1890, 2, u'-  assert(!Self.getLangOpts().CPlusPlus);'), (1922, 2, u'-  assert(!SrcType->isPlaceholderType());'), (2100, 2, u'-  assert(LPLoc.isValid() && "List-initialization shouldn\'t get here.");')]
===========================================
Class:class CheckFormatHandler : public analyze_format_string::FormatStringHandler { class CheckFormatHandler : public analyze_format_string::FormatStringHandler 
Class:class CheckPrintfHandler : public CheckFormatHandler { class CheckPrintfHandler : public CheckFormatHandler 
Class:class CheckScanfHandler : public CheckFormatHandler { class CheckScanfHandler : public CheckFormatHandler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 2, u'-    assert(TheCall->getNumArgs() == 1 &&'), (297, 2, u'-    assert(!shift && "cannot shift float types!");'), (300, 2, u'-    assert(!shift && "cannot shift float types!");'), (521, 2, u'-  assert(AtomicExpr::AO__c11_atomic_init == 0 &&'), (699, 2, u'-        assert(Form != Load);'), (787, 2, u'-  assert(Fn && "builtin call without direct callee!");'), (1302, 2, u'-      assert(Cast->getType()->isSpecificBuiltinType(BuiltinType::Double) &&'), (1962, 2, u'-      assert((unsigned)notCoveredArg < NumDataArgs);'), (2167, 2, u'-      assert(ATR.isValid());'), (2683, 2, u'-  assert(BId != 0);'), (3102, 2, u'-  assert((E->getType()->isAnyPointerType() ||'), (3155, 2, u'-    assert (Base->getType()->isPointerType());'), (3437, 2, u'-    assert(T->isCanonicalUnqualified());'), (3457, 2, u'-    assert(BT->isInteger());'), (3468, 2, u'-    assert(T->isCanonicalUnqualified());'), (3478, 2, u'-    assert(BT->isInteger());'), (3534, 2, u'-  assert(result.isLValue() || result.isAddrLabelDiff());'), (3797, 2, u'-  assert(value.isComplexFloat());'), (3868, 2, u'-  assert(S.Context.hasSameUnqualifiedType(T, E->getRHS()->getType())'), (3888, 2, u'-    assert(!RHS->getType()->hasSignedIntegerRepresentation() &&'), (3924, 2, u'-    assert(unsignedRange.NonNegative && "unsigned range includes negative?");'), (3940, 2, u'-  assert(Bitfield->isBitField());'), (4881, 2, u'-  assert(owner.Variable && owner.Loc.isValid());'), (4895, 2, u'-  assert(capturer);'), (4896, 2, u'-  assert(owner.Variable && owner.Loc.isValid());'), (4938, 2, u'-    assert(msg->getReceiverKind() == ObjCMessageExpr::SuperInstance);'), (5088, 2, u'-  assert(!CurrentInstantiationScope); // Ensured by caller')]
===========================================
Class:  class ResultBuilder {   class ResultBuilder 
Class:    class ShadowMapEntry {     class ShadowMapEntry 
Class:  class pointer {   class pointer 
Class:  class CodeCompletionDeclConsumer : public VisibleDeclConsumer {   class CodeCompletionDeclConsumer : public VisibleDeclConsumer 
Class:      Class = ObjCPtr->getInterfaceDecl();
Class:      Class = BaseType->getAs<ObjCObjectType>()->getInterface();
Class:      Class = Category->getClassInterface();
Class:      Class = Category->getClassInterface();
Class:    Class = Class->getSuperClass();
Class:    Class = ClassImpl->getClassInterface();
Class:class TypeNameValidatorCCC : public CorrectionCandidateCallback { class TypeNameValidatorCCC : public CorrectionCandidateCallback 
Class:      Class = Alias->getClassInterface();
Class:class DifferentNameValidatorCCC : public CorrectionCandidateCallback { class DifferentNameValidatorCCC : public CorrectionCandidateCallback 
Class:  class SelfReferenceChecker   class SelfReferenceChecker
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 2, u'-    assert(isa<ObjCMethodDecl>(D) || isa<BlockDecl>(D));'), (355, 2, u'-  assert(!Attr.isInvalid());'), (378, 2, u'-  assert(!Attr.isInvalid());'), (409, 2, u'-  assert(!Attr.isInvalid());'), (429, 2, u'-  assert(!Attr.isInvalid());'), (446, 2, u'-  assert(!Attr.isInvalid());'), (463, 2, u'-  assert(!Attr.isInvalid());'), (493, 2, u'-  assert(Size == Attr.getNumArgs());'), (506, 2, u'-  assert(!Attr.isInvalid());'), (523, 2, u'-  assert(Size == Attr.getNumArgs());'), (538, 2, u'-  assert(!Attr.isInvalid());'), (578, 2, u'-  assert(!Attr.isInvalid());'), (595, 2, u'-  assert(Size == Attr.getNumArgs());'), (610, 2, u'-  assert(!Attr.isInvalid());'), (626, 2, u'-  assert(Size == Attr.getNumArgs());'), (635, 2, u'-  assert(!Attr.isInvalid());'), (658, 2, u'-  assert(!Attr.isInvalid());'), (675, 2, u'-  assert(Size == Attr.getNumArgs());'), (1287, 2, u'-  assert(!Attr.isInvalid());'), (1296, 2, u'-  assert(!Attr.isInvalid());'), (3056, 2, u'-  assert(!Attr.isInvalid());'), (3462, 2, u'-    assert(type->isDependentType() &&'), (3886, 2, u'-  assert(isa<FunctionDecl>(ND) || isa<VarDecl>(ND));'), (4039, 2, u'-  assert(StackSize <= StackCapacity);'), (4055, 2, u'-  assert(StackSize < StackCapacity);'), (4064, 2, u'-  assert(DD.StackSize >= state.SavedStackSize);'), (4065, 2, u'-  assert(state.SavedStackSize >= DD.ActiveStackBase);'), (4066, 2, u'-  assert(DD.ParsingDepth > 0);')]
===========================================
Class:  class CheckDefaultArgumentVisitor   class CheckDefaultArgumentVisitor
Class:class MemInitializerValidatorCCC : public CorrectionCandidateCallback { class MemInitializerValidatorCCC : public CorrectionCandidateCallback 
Class:class NamespaceValidatorCCC : public CorrectionCandidateCallback { class NamespaceValidatorCCC : public CorrectionCandidateCallback 
Class:  class ImplicitlyDefinedFunctionScope {   class ImplicitlyDefinedFunctionScope 
Class:  Class = cast<CXXRecordDecl>(Class->getCanonicalDecl());
Class:  class FindCXXThisExpr : public RecursiveASTVisitor<FindCXXThisExpr> {   class FindCXXThisExpr : public RecursiveASTVisitor<FindCXXThisExpr> 
Class:class ObjCInterfaceValidatorCCC : public CorrectionCandidateCallback { class ObjCInterfaceValidatorCCC : public CorrectionCandidateCallback 
Class:class OverrideSearch { class OverrideSearch 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(347, 2, u'-  assert(OldEST != EST_Delayed && NewEST != EST_Delayed &&'), (465, 2, u'-  assert(OldEST == EST_Dynamic && NewEST == EST_Dynamic &&'), (545, 2, u'-  assert(SuperEST != EST_Delayed && SubEST != EST_Delayed &&'), (582, 2, u'-  assert(SuperEST == EST_Dynamic && SubEST == EST_Dynamic &&'), (704, 2, u'-  assert(Target->getNumArgs() == Source->getNumArgs() &&'), (811, 2, u'-    assert(isa<CXXConstructorDecl>(D) &&')]
===========================================
Class:  class TransformToPE : public TreeTransform<TransformToPE> {   class TransformToPE : public TreeTransform<TransformToPE> 
Class:  class MarkReferencedDecls : public RecursiveASTVisitor<MarkReferencedDecls> {   class MarkReferencedDecls : public RecursiveASTVisitor<MarkReferencedDecls> 
Class:  class EvaluatedExprMarker : public EvaluatedExprVisitor<EvaluatedExprMarker> {   class EvaluatedExprMarker : public EvaluatedExprVisitor<EvaluatedExprMarker> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(137, 2, u'-    assert((isDependent || !SearchType->isIncompleteType()) &&'), (274, 2, u'-    assert(DS.getTypeSpecType() == DeclSpec::TST_decltype'), (491, 2, u'-  assert((Kind == tok::kw_true || Kind == tok::kw_false) &&'), (817, 2, u'-  assert((!ListInitialization || (NumExprs == 1 && isa<InitListExpr>(Exprs[0])))'), (1030, 2, u'-    assert(isa<InitListExpr>(Init) &&'), (1053, 2, u'-    assert(Initializer && "Have parens but no initializer.");'), (1065, 2, u'-    assert((!Initializer || isa<ImplicitValueInitExpr>(Initializer) ||'), (1863, 2, u'-    assert(StdBadAlloc && "Must have std::bad_alloc declared");'), (1987, 2, u'-  assert(Operator && "Did not find a deallocation function!");'), (2328, 2, u'-    assert(!From->getType()->isPointerType() && "Arg can\'t have pointer type!");'), (2375, 2, u'-      assert(FD && "FIXME: aggregate initialization from init list");'), (2460, 2, u'-    assert(!ToType->isReferenceType());'), (2507, 2, u'-    assert(From->getObjectKind() != OK_ObjCProperty);'), (2510, 2, u'-    assert(!FromRes.isInvalid() && "Can\'t perform deduced conversion?!");'), (2710, 2, u'-        assert(From->getType()->isIntegerType());'), (2722, 2, u'-      assert(FromComplex);'), (2741, 2, u'-        assert(ToType->isIntegerType());'), (2762, 2, u'-    assert ((ConvTy == Sema::Compatible) &&'), (2929, 2, u'-  assert(!T->isDependentType() && "Cannot evaluate traits of dependent type");'), (3410, 2, u'-  assert(!LhsT->isDependentType() && !RhsT->isDependentType() &&'), (3426, 2, u'-    assert(Self.Context.hasSameUnqualifiedType(LhsT, RhsT)'), (3600, 2, u'-  assert(!T->isDependentType() && "Cannot evaluate traits of dependent type");'), (3717, 2, u'-  assert(!LHS.get()->getType()->isPlaceholderType() &&'), (4267, 2, u'-  assert(getLangOpts().CPlusPlus && "This function assumes C++");'), (4469, 2, u'-  assert(!isa<CXXBindTemporaryExpr>(E) && "Double-bound temporary?");'), (4504, 2, u'-      assert(FTy && "call to value not of function type?");'), (4621, 2, u'-  assert(SubExpr && "sub expression can\'t be null!");'), (4626, 2, u'-  assert(ExprCleanupObjects.size() >= FirstCleanup);'), (4627, 2, u'-  assert(ExprNeedsCleanups || ExprCleanupObjects.size() == FirstCleanup);'), (4642, 2, u'-  assert(SubStmt && "sub statement can\'t be null!");'), (4667, 2, u'-  assert(Rec.IsDecltype && "not in a decltype expression");'), (5005, 2, u'-  assert((FirstTypeName.getKind() == UnqualifiedId::IK_TemplateId ||'), (5008, 2, u'-  assert((SecondTypeName.getKind() == UnqualifiedId::IK_TemplateId ||')]
===========================================
Class:class RecordMemberExprValidatorCCC : public CorrectionCandidateCallback { class RecordMemberExprValidatorCCC : public CorrectionCandidateCallback 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 2, u'-  assert(!R.empty() && (*R.begin())->isCXXClassMember());'), (438, 2, u'-      assert(BaseExpr && "cannot happen with implicit member accesses");'), (445, 2, u'-  assert(BaseType->isDependentType() ||'), (497, 2, u'-    assert(BaseType->isDependentType());'), (576, 2, u'-    assert(DC && "Cannot handle non-computable dependent contexts in lookup");'), (691, 2, u'-    assert(baseVariable->getType()->isRecordType());'), (698, 2, u'-    assert(!baseObjectExpr && "anonymous struct/union is static data member?");'), (800, 2, u'-  assert((!isArrow || Base->isRValue()) && "-> base must be a pointer rvalue");'), (820, 2, u'-    assert(BaseType->isPointerType());'), (876, 2, u'-  assert(R.isSingleResult());'), (948, 2, u'-  assert(!isa<FunctionDecl>(MemberDecl) && "member function not C++ method?");'), (1037, 2, u'-  assert(BaseExpr.get() && "no base expression");'), (1045, 2, u'-  assert(!BaseType->isDependentType());'), (1151, 2, u'-        assert(!ClassDeclared);'), (1172, 2, u'-    assert(ClassDeclared);'), (1245, 2, u'-    assert(Context.hasSameUnqualifiedType(BaseType, BaseExpr.get()->getType()));'), (1559, 2, u'-    assert(!MemberQuals.hasAddressSpace());'), (1587, 2, u'-  assert(!R.empty() && !R.isAmbiguous());'), (1601, 2, u'-  assert(!ThisTy.isNull() && "didn\'t correctly pre-flight capture of \'this\'");')]
===========================================
Class:class ObjCInterfaceOrSuperCCC : public CorrectionCandidateCallback { class ObjCInterfaceOrSuperCCC : public CorrectionCandidateCallback 
Class:  class ARCCastChecker : public StmtVisitor<ARCCastChecker, ACCResult> {   class ARCCastChecker : public StmtVisitor<ARCCastChecker, ACCResult> 
Class:class InitListChecker { class InitListChecker 
Class:class FieldInitializerValidatorCCC : public CorrectionCandidateCallback { class FieldInitializerValidatorCCC : public CorrectionCandidateCallback 
Class:    Class = cast<CXXRecordDecl>(Record->getDecl());
Class:    Class = LSI->Lambda;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(249, 2, u'-    assert(ParamInfo.isFunctionDeclarator() &&'), (261, 2, u'-    assert(MethodTyInfo && "no type from lambda-declarator");'), (336, 2, u'-    assert(C->Id && "missing identifier for capture");'), (597, 2, u'-      assert(!From.isBlockCapture() && "Cannot capture __block variables");')]
===========================================
Class:  class UnqualUsingEntry {   class UnqualUsingEntry 
Class:         class UnqualUsingDirectiveSet {   class UnqualUsingDirectiveSet 
Class:    Class = Bases.back();
Class:class ShadowContextRAII;
Class: class VisibleDeclsRecord { class VisibleDeclsRecord 
Class:  class ShadowContextRAII { class ShadowContextRAII 
Class:class TypoCorrectionConsumer : public VisibleDeclConsumer { class TypoCorrectionConsumer : public VisibleDeclConsumer 
Class:class SpecifierInfo { class SpecifierInfo 
Class: class NamespaceSpecifierSet { class NamespaceSpecifierSet 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 2, u'-      assert(propertyLifetime == Qualifiers::OCL_ExplicitNone);'), (601, 2, u'-    assert(IDecl &&'), (681, 2, u'-      assert(!getLangOpts().ObjCAutoRefCount);'), (708, 2, u'-          assert(lifetime && "no lifetime for property?");'), (820, 2, u'-  assert (property && "ActOnPropertyImplDecl - property declaration missing");'), (1084, 2, u'-    assert (CatDecl && "MatchOneProtocolPropertiesInClass");'), (1125, 2, u'-    assert (CatDecl && "CompareProperties");')]
===========================================
Class:  class UnbridgedCastsSet {   class UnbridgedCastsSet 
Class:     class BuiltinCandidateTypeSet  { class BuiltinCandidateTypeSet  
Class:class BuiltinOperatorOverloadBuilder { class BuiltinOperatorOverloadBuilder 
Class:   class AddressOfFunctionResolver { 
Class:class RecoveryCallCCC : public CorrectionCandidateCallback { class RecoveryCallCCC : public CorrectionCandidateCallback 
Class:  class NoTypoCorrectionCCC : public CorrectionCandidateCallback { class NoTypoCorrectionCCC : public CorrectionCandidateCallback 
Class:  class PseudoOpBuilder {   class PseudoOpBuilder 
Class:      class ObjCPropertyOpBuilder : public PseudoOpBuilder {   class ObjCPropertyOpBuilder : public PseudoOpBuilder 
Class:    class ObjCSubscriptOpBuilder : public PseudoOpBuilder {  class ObjCSubscriptOpBuilder : public PseudoOpBuilder 
Class:class TypeWithHandler { class TypeWithHandler 
Class:  class UnnamedLocalNoLinkageFinder   class UnnamedLocalNoLinkageFinder
Class:  class CurrentInstantiationRebuilder   class CurrentInstantiationRebuilder
Class:  class SubstituteAutoTransform :   class SubstituteAutoTransform :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(293, 2, u'-  assert(NTTP->getDepth() == 0 &&'), (321, 2, u'-  assert(NTTP->getDepth() == 0 &&'), (323, 2, u'-  assert((Value->isTypeDependent() || Value->isValueDependent()) &&'), (352, 2, u'-  assert(NTTP->getDepth() == 0 &&'), (436, 2, u'-  assert(Arg.isCanonical() && "Argument type must be canonical");'), (751, 2, u'-    assert(!PackIndices.empty() && "Pack expansion without unexpanded packs?");'), (1002, 2, u'-    assert(TemplateTypeParm->getDepth() == 0 && "Can\'t deduce with depth > 0");'), (1003, 2, u'-    assert(Arg != S.Context.OverloadTy && "Unresolved overloaded function");'), (1245, 2, u'-      assert(NTTP->getDepth() == 0 &&'), (1307, 2, u'-      assert(isa<TemplateSpecializationType>(Param) &&'), (1385, 2, u'-              assert(Base->getType()->isRecordType() &&'), (1665, 2, u'-  assert(ArgIdx == NumArgs - 1 && "Pack not at the end of argument list?");'), (1772, 2, u'-    assert(!PackIndices.empty() && "Pack expansion without unexpanded packs?");'), (2307, 2, u'-  assert(Proto && "Function template does not have a prototype?");'), (2640, 2, u'-  assert(Specialization->getPrimaryTemplate()->getCanonicalDecl() =='), (3133, 2, u'-    assert(!PackIndices.empty() && "Pack expansion without unexpanded packs?");'), (3333, 2, u'-    assert(!A->isReferenceType() && "Reference types were handled above");'), (3510, 2, u'-  assert(FuncParamInfo && "substituting template parameter for \'auto\' failed");'), (3621, 2, u'-  assert(Proto1 && Proto2 && "Function templates must have prototypes");'), (3881, 2, u'-  assert(!(Better1 && Better2) && "Should have broken out in the loop above");'), (3972, 2, u'-  assert(BestTemplate && "Not a function template specialization?");'), (3976, 2, u'-    assert(Challenger && "Not a function template specialization?");')]
===========================================
Class:  class TemplateInstantiator : public TreeTransform<TemplateInstantiator> {   class TemplateInstantiator : public TreeTransform<TemplateInstantiator> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 2, u'-      assert(Spec->getSpecializedTemplate() && "No class template?");'), (113, 2, u'-        assert(Function->getPrimaryTemplate() && "No function template?");'), (298, 2, u'-  assert(!Inst.isInstantiationRecord());'), (352, 2, u'-  assert(!Inst.isInstantiationRecord());'), (379, 2, u'-  assert(!Inst.isInstantiationRecord());'), (407, 2, u'-  assert(!Inst.isInstantiationRecord());'), (414, 2, u'-      assert(SemaRef.NonInstantiationEntries > 0);'), (427, 2, u'-  assert(SemaRef.NonInstantiationEntries <='), (659, 2, u'-      assert(Active->DeductionInfo && "Missing deduction info pointer");'), (888, 2, u'-        assert(Arg.getKind() == TemplateArgument::Pack &&'), (891, 2, u'-        assert(getSema().ArgumentPackSubstitutionIndex >= 0);'), (892, 2, u'-        assert(getSema().ArgumentPackSubstitutionIndex < (int)Arg.pack_size());'), (897, 2, u'-      assert(!Template.isNull() && Template.getAsTemplateDecl() &&'), (932, 2, u'-        assert(Arg.getKind() == TemplateArgument::Pack &&'), (938, 2, u'-        assert(getSema().ArgumentPackSubstitutionIndex < (int)Arg.pack_size());'), (1033, 2, u'-        assert(Arg.getKind() == TemplateArgument::Pack &&'), (1043, 2, u'-        assert(getSema().ArgumentPackSubstitutionIndex < (int)Arg.pack_size());'), (1048, 2, u'-      assert(!Template.isNull() && "Null template template argument");'), (1067, 2, u'-    assert(getSema().ArgumentPackSubstitutionIndex < (int)ArgPack.pack_size() &&'), (1083, 2, u'-  assert(currentDecl && "Must have current function declaration when "'), (1112, 2, u'-    assert(Arg.getKind() == TemplateArgument::Pack &&'), (1131, 2, u'-    assert(getSema().ArgumentPackSubstitutionIndex < (int)Arg.pack_size());'), (1181, 2, u'-    assert(!type.isNull() && "type substitution failed for param type");'), (1182, 2, u'-    assert(!type->isDependentType() && "param type still dependent");'), (1212, 2, u'-  assert(Index < ArgPack.pack_size() && "Substitution index out-of-range");'), (1236, 2, u'-  assert(!cast<FunctionDecl>(E->getParam()->getDeclContext())->'), (1292, 2, u'-      assert(Arg.getKind() == TemplateArgument::Pack &&'), (1307, 2, u'-      assert(getSema().ArgumentPackSubstitutionIndex < (int)Arg.pack_size());'), (1311, 2, u'-    assert(Arg.getKind() == TemplateArgument::Type &&'), (1359, 2, u'-  assert(Index < ArgPack.pack_size() && "Substitution index out-of-range");'), (1402, 2, u'-  assert(!ActiveTemplateInstantiations.empty() &&'), (1418, 2, u'-  assert(!ActiveTemplateInstantiations.empty() &&'), (1448, 2, u'-  assert(!ActiveTemplateInstantiations.empty() &&'), (1499, 2, u'-  assert(!ActiveTemplateInstantiations.empty() &&'), (1623, 2, u'-  assert(!ActiveTemplateInstantiations.empty() &&'), (1766, 2, u'-    assert(PatternDef->isBeingDefined());'), (1916, 2, u'-          assert(MSInfo && "no spec info for member enum specialization");'), (1956, 2, u'-        assert(Init && "no-argument initializer in class");'), (1957, 2, u'-        assert(!isa<ParenListExpr>(Init) && "call-style init in class");'), (1968, 2, u'-    assert(CurrentInstantiationScope == Instantiator.getStartingScope());'), (2275, 2, u'-        assert(MSInfo && "No member specialization information?");'), (2311, 2, u'-        assert(MSInfo && "No member specialization information?");'), (2349, 2, u'-      assert(MSInfo && "No member specialization information?");'), (2364, 2, u'-      assert(Pattern && "Missing instantiated-from-template information");'), (2400, 2, u'-      assert(MSInfo && "No member specialization information?");'), (2417, 2, u'-      assert(Pattern && "Missing instantiated-from-template information");'), (2555, 2, u'-  assert(isa<LabelDecl>(D) && "declaration not instantiated in this scope");'), (2564, 2, u'-    assert(Stored.get<Decl *>() == Inst && "Already instantiated this local");'), (2578, 2, u'-  assert(Stored.isNull() && "Already instantiated this local");'), (2587, 2, u'-  assert((!PartiallySubstitutedPack || PartiallySubstitutedPack == Pack) &&'), (2589, 2, u'-  assert((!PartiallySubstitutedPack')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(175, 2, u'-      assert(!newTag->getIdentifier() && !newTag->getTypedefNameForAnonDecl());'), (522, 2, u'-  assert(ND && "friend decl must be a decl or a type!");'), (540, 2, u'-Decl *TemplateDeclInstantiator::VisitStaticAssertDecl(StaticAssertDecl *D) {'), (541, 2, u'-  Expr *AssertExpr = D->getAssertExpr();'), (547, 2, u'-  ExprResult InstantiatedAssertExpr'), (548, 2, u'-    = SemaRef.SubstExpr(AssertExpr, TemplateArgs);'), (549, 2, u'-  if (InstantiatedAssertExpr.isInvalid())'), (554, 2, u'-  return SemaRef.ActOnStaticAssertDeclaration(D->getLocation(),'), (555, 2, u'-                                              InstantiatedAssertExpr.get(),'), (587, 2, u'-      assert(!D->getIntegerType()->isDependentType()'), (943, 2, u'-  assert(InstTemplate &&'), (1084, 2, u'-    assert(D->getDeclContext()->isFileContext());'), (1101, 2, u'-    assert(Proto && "No function prototype in template instantiation?");'), (1172, 2, u'-    assert(isFriend && "non-friend has dependent specialization info?");'), (1310, 2, u'-  assert(!D->isDefaulted() && "only methods should be defaulted");'), (1377, 2, u'-    assert(!Params.size() && "Instantiating type could not yield parameters");'), (1554, 2, u'-    assert(!D->isDefaulted() &&'), (1582, 2, u'-  assert(D->getTypeForDecl()->isTemplateTypeParmType());'), (1965, 2, u'-  assert(Specialization && "Class scope Specialization is null");'), (2142, 2, u'-  assert(OldTInfo && "substituting function without type source info");'), (2143, 2, u'-  assert(Params.empty() && "parameter vector is non-empty at start");'), (2167, 2, u'-      assert(NewProtoLoc && "Missing prototype?");'), (2230, 2, u'-      assert(FParamIdx < Function->getNumParams());'), (2254, 2, u'-  assert(Proto->getExceptionSpecType() != EST_Uninstantiated);'), (2282, 2, u'-      assert(!Unexpanded.empty() &&'), (2366, 2, u'-  assert(NewProto && "Template instantiation without function prototype?");'), (2431, 2, u'-      assert(FunTmpl->getTemplatedDecl() == Tmpl &&'), (2441, 2, u'-  assert(Proto && "Function template without prototype?");'), (2459, 2, u'-      assert(NewProto && "Template instantiation without function prototype?");'), (2535, 2, u'-  assert(PatternDecl && "instantiating a non-template");'), (2538, 2, u'-  assert(PatternDecl && "template definition is not a template");'), (2543, 2, u'-  assert(PatternDecl && "template definition is not a template");'), (2678, 2, u'-    assert(VTableUses.empty() &&'), (2683, 2, u'-    assert(PendingInstantiations.empty() &&'), (2715, 2, u'-  assert(Def && "This data member was not instantiated from a template?");'), (2716, 2, u'-  assert(Def->isStaticDataMember() && "Not a static data member?");'), (2790, 2, u'-    assert(MSInfo && "Missing member specialization information?");'), (2807, 2, u'-    assert(VTableUses.empty() &&'), (2813, 2, u'-    assert(PendingInstantiations.empty() &&'), (2859, 2, u'-      assert(ShouldExpand && "Partial instantiation of base initializer?");'), (3118, 2, u'-  assert(Instance->isStaticDataMember());'), (3267, 2, u'-    assert(isa<LabelDecl>(D));'), (3270, 2, u'-    assert(Inst && "Failed to instantiate label??");'), (3348, 2, u'-        assert(Tag && "type of non-dependent record is not a RecordType");'), (3401, 2, u'-        assert(Spec->getTemplateSpecializationKind() =='), (3456, 2, u'-    assert(Var->isStaticDataMember() && "Not a static data member?");')]
===========================================
Class:  class CollectUnexpandedParameterPacksVisitor :   class CollectUnexpandedParameterPacksVisitor :
Class:class ParameterPackValidatorCCC : public CorrectionCandidateCallback { class ParameterPackValidatorCCC : public CorrectionCandidateCallback 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(217, 2, u'-  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");'), (232, 2, u'-  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");'), (249, 2, u'-  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");'), (286, 2, u'-  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");'), (301, 2, u'-  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");'), (315, 2, u'-  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");')]
===========================================
Class:  class TypeProcessingState {   class TypeProcessingState 
Class:  class TypeSpecLocFiller : public TypeLocVisitor<TypeSpecLocFiller> {   class TypeSpecLocFiller : public TypeLocVisitor<TypeSpecLocFiller> 
Class:   class DeclaratorLocFiller : public TypeLocVisitor<DeclaratorLocFiller> {   class DeclaratorLocFiller : public TypeLocVisitor<DeclaratorLocFiller> 
Class:  class MSP430AttributesSema : public TargetAttributesSema {   class MSP430AttributesSema : public TargetAttributesSema 
Class:  class MBlazeAttributesSema : public TargetAttributesSema {   class MBlazeAttributesSema : public TargetAttributesSema 
Class:  class X86AttributesSema : public TargetAttributesSema {   class X86AttributesSema : public TargetAttributesSema 
Class:class ASTStatData { class ASTStatData 
Class: class ASTStatLookupTrait { class ASTStatLookupTrait 
Class:     class ASTStatCache : public FileSystemStatCache { class ASTStatCache : public FileSystemStatCache 
Class:  class IdentifierLookupVisitor {   class IdentifierLookupVisitor 
Class:  class HeaderFileInfoVisitor {   class HeaderFileInfoVisitor 
Class: class clang::TypeLocReader : public TypeLocVisitor<TypeLocReader> { class clang::TypeLocReader : public TypeLocVisitor<TypeLocReader> 
Class:  class FindExternalLexicalDeclsVisitor {   class FindExternalLexicalDeclsVisitor 
Class:class DeclIDComp { class DeclIDComp 
Class:  class DeclContextNameLookupVisitor {   class DeclContextNameLookupVisitor 
Class:  class DeclContextAllNamesVisitor {   class DeclContextAllNamesVisitor 
Class:  class ASTIdentifierIterator : public IdentifierIterator {   class ASTIdentifierIterator : public IdentifierIterator 
Class:  class ReadMethodPoolVisitor {   class ReadMethodPoolVisitor 
Class:  class ASTDeclReader : public DeclVisitor<ASTDeclReader, void> {   class ASTDeclReader : public DeclVisitor<ASTDeclReader, void> 
Class:    class RedeclarableResult {     class RedeclarableResult 
Class:                              class FindExistingResult {     class FindExistingResult 
Class:  class RedeclChainVisitor {   class RedeclChainVisitor 
Class:  class ObjCCategoriesVisitor {   class ObjCCategoriesVisitor 
Class:  class ASTStmtReader : public StmtVisitor<ASTStmtReader> {   class ASTStmtReader : public StmtVisitor<ASTStmtReader> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(111, 2, u'-  assert(Idx == NumStmtFields && "Incorrect statement field count");'), (329, 2, u'-  assert(Idx == NumExprFields && "Incorrect expression field count");'), (387, 2, u'-  assert(Record[Idx] == E->getNumConcatenated() &&'), (439, 2, u'-  assert(E->getNumComponents() == Record[Idx]);'), (441, 2, u'-  assert(E->getNumExpressions() == Record[Idx]);'), (514, 2, u'-  assert(E->getStmtClass() == Stmt::MemberExprClass &&'), (542, 2, u'-  assert(NumBaseSpecs == E->path_size());'), (650, 2, u'-  assert(NumSubExprs == E->getNumSubExprs() && "Wrong number of subexprs");'), (787, 2, u'-  assert(numSemanticExprs + 1 == E->PseudoObjectExprBits.NumSubExprs);'), (830, 2, u'-  assert(NumElements == E->getNumElements() && "Wrong number of elements");'), (841, 2, u'-  assert(NumElements == E->getNumElements() && "Wrong number of elements");'), (843, 2, u'-  assert(HasPackExpansions == E->HasPackExpansions &&"Pack expansion mismatch");'), (926, 2, u'-  assert(Record[Idx] == E->getNumArgs());'), (952, 2, u'-  assert(Kind == E->getReceiverKind());'), (1001, 2, u'-  assert(Record[Idx] == S->getNumCatchStmts());'), (1045, 2, u'-  assert(Record[Idx] == S->getNumHandlers() && "NumStmtFields is wrong ?");'), (1104, 2, u'-  assert(NumCaptures == E->NumCaptures);(void)NumCaptures;'), (1204, 2, u'-  assert((bool)Record[Idx] == E->Param.getInt() && "We messed up at creation ?");'), (1278, 2, u'-  assert(NumObjects == E->getNumObjects());'), (1317, 2, u'-  assert(Record[Idx] == E->arg_size() && "Read wrong record during creation ?");'), (1613, 2, u'-      assert(StmtEntries.find(Record[0]) != StmtEntries.end() &&'), (1764, 2, u'-      assert(Idx == 0);'), (2217, 2, u'-    assert(Idx == Record.size() && "Invalid deserialization of statement");'), (2222, 2, u'-  assert(StmtStack.size() > PrevNumStmts && "Read too many sub stmts!");'), (2223, 2, u'-  assert(StmtStack.size() == PrevNumStmts + 1 && "Extra expressions on stack!");')]
===========================================
Class:  class ASTTypeWriter {   class ASTTypeWriter 
Class:class TypeLocWriter : public TypeLocVisitor<TypeLocWriter> { class TypeLocWriter : public TypeLocVisitor<TypeLocWriter> 
Class:class ASTStatCacheTrait { class ASTStatCacheTrait 
Class:  class HeaderFileInfoTrait {   class HeaderFileInfoTrait 
Class:class ASTMethodPoolTrait { class ASTMethodPoolTrait 
Class:class ASTIdentifierTableTrait { class ASTIdentifierTableTrait 
Class:class ASTDeclContextNameLookupTrait { class ASTDeclContextNameLookupTrait 
Class:  class ASTDeclWriter : public DeclVisitor<ASTDeclWriter, void> {   class ASTDeclWriter : public DeclVisitor<ASTDeclWriter, void> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 2, u'-    void VisitStaticAssertDecl(StaticAssertDecl *D);'), (424, 2, u'-    assert(Context.getObjCMethodRedeclaration(D));'), (730, 2, u'-  assert(!D->isARCPseudoStrong()); // can be true of ImplicitParamDecl'), (755, 2, u'-  assert(!D->isThreadSpecified() && "PARM_VAR_DECL can\'t be __thread");'), (756, 2, u'-  assert(D->getAccess() == AS_none && "PARM_VAR_DECL can\'t be public/private");'), (757, 2, u'-  assert(!D->isExceptionVariable() && "PARM_VAR_DECL can\'t be exception var");'), (758, 2, u'-  assert(D->getPreviousDecl() == 0 && "PARM_VAR_DECL can\'t be redecl");'), (759, 2, u'-  assert(!D->isStaticDataMember() &&'), (1061, 2, u'-      assert(I->isCanonicalDecl() && "Expected only canonical decls in set");'), (1069, 2, u'-      assert(I->isCanonicalDecl() && "Expected only canonical decls in set");'), (1152, 2, u'-      assert(I->Function->isCanonicalDecl() &&'), (1217, 2, u'-void ASTDeclWriter::VisitStaticAssertDecl(StaticAssertDecl *D) {'), (1219, 2, u'-  Writer.AddStmt(D->getAssertExpr());'), (1222, 2, u'-  Code = serialization::DECL_STATIC_ASSERT;')]
===========================================
Class:  class ASTStmtWriter : public StmtVisitor<ASTStmtWriter, void> {   class ASTStmtWriter : public StmtVisitor<ASTStmtWriter, void> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(651, 2, u'-      assert(D->isArrayRangeDesignator() && "Unknown designator");'), (1552, 2, u'-  assert(SwitchCaseIDs.find(S) == SwitchCaseIDs.end() &&'), (1560, 2, u'-  assert(SwitchCaseIDs.find(S) != SwitchCaseIDs.end() &&'), (1591, 2, u'-  assert(!ParentStmts.count(S) && "There is a Stmt cycle!");'), (1648, 2, u'-  assert(SubStmtEntries.empty() && "unexpected entries in sub stmt map");'), (1649, 2, u'-  assert(ParentStmts.empty() && "unexpected entries in parent stmt map");'), (1654, 2, u'-    assert(N == StmtsToEmit.size() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-  assert(SemaPtr && "No Sema?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 2, u'-      assert(Buffer && "Passed null buffer");')]
===========================================
Class:class AdjustedReturnValueChecker : class AdjustedReturnValueChecker :
Class:class AnalyzerStatsChecker : public Checker<check::EndAnalysis> { class AnalyzerStatsChecker : public Checker<check::EndAnalysis> 
Class:class ArrayBoundChecker : class ArrayBoundChecker :
Class:class ArrayBoundCheckerV2 : class ArrayBoundCheckerV2 :
Class:  class RegionRawOffsetV2 { class RegionRawOffsetV2 
Class:class AttrNonNullChecker class AttrNonNullChecker
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 2, u'-        assert(CSV_I != CSV->end());'), (78, 2, u'-        assert(++CSV_I == CSV->end());'), (123, 2, u'-    assert(stateNotNull);')]
===========================================
Class:class APIMisuse : public BugType { class APIMisuse : public BugType 
Class:  class NilArgChecker : public Checker<check::PreObjCMessage> {   class NilArgChecker : public Checker<check::PreObjCMessage> 
Class:class CFNumberCreateChecker : public Checker< check::PreStmt<CallExpr> > { class CFNumberCreateChecker : public Checker< check::PreStmt<CallExpr> > 
Class:  class Optional {   class Optional 
Class:class CFRetainReleaseChecker : public Checker< check::PreStmt<CallExpr> > { class CFRetainReleaseChecker : public Checker< check::PreStmt<CallExpr> > 
Class:class ClassReleaseChecker : public Checker<check::PreObjCMessage> { class ClassReleaseChecker : public Checker<check::PreObjCMessage> 
Class:class VariadicMethodTypeChecker : public Checker<check::PreObjCMessage> { class VariadicMethodTypeChecker : public Checker<check::PreObjCMessage> 
Class:  class BoolAssignmentChecker : public Checker< check::Bind > {   class BoolAssignmentChecker : public Checker< check::Bind > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(116, 2, u'-  assert(stateGE == state);'), (152, 2, u'-  assert(stateLE == state);')]
===========================================
Class:class BuiltinFunctionChecker : public Checker<eval::Call> { class BuiltinFunctionChecker : public Checker<eval::Call> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-    assert (CE->arg_begin() != CE->arg_end());')]
===========================================
Class:class CStringChecker : public Checker< eval::Call, class CStringChecker : public Checker< eval::Call,
Class: class CStringLength { class CStringLength 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(247, 2, u'-    assert(CurrentFunctionDescription);'), (262, 2, u'-  assert(stateNonNull);'), (284, 2, u'-  assert(ER->getValueType() == C.getASTContext().CharTy &&'), (315, 2, u'-      assert(CurrentFunctionDescription);'), (316, 2, u"-      assert(CurrentFunctionDescription[0] != '\\0');"), (460, 2, u'-  assert(stateFalse);'), (528, 2, u'-  assert(stateFalse);'), (617, 2, u'-    assert(stateOkay);'), (627, 2, u'-  assert(!strLength.isUndef() && "Attempt to set an undefined string length");'), (708, 2, u'-        assert(CurrentFunctionDescription);'), (769, 2, u'-      assert(CurrentFunctionDescription);'), (943, 2, u'-      assert(destRegVal && "Destination should be a known MemRegionVal here");'), (1243, 2, u'-  assert(!result.isUnknown() && "Should have conjured a value by now");'), (1422, 2, u'-      assert(!amountCopied.isUndef());'), (1457, 2, u'-  assert(state);'), (1494, 2, u'-      assert(!finalStrLength.isUndef());'), (1533, 2, u'-  assert(state);'), (1592, 2, u'-  assert(state);'), (1694, 2, u'-  assert(StNotSameBuf);'), (1816, 2, u'-  assert(!(CurrentFunctionDescription = NULL));'), (1859, 2, u'-    assert(StrVal.isValid() && "Initializer string is unknown or undefined");')]
===========================================
Class:class WalkAST: public StmtVisitor<WalkAST> { class WalkAST: public StmtVisitor<WalkAST> 
Class:class CStringSyntaxChecker: public Checker<check::ASTCodeBody> { class CStringSyntaxChecker: public Checker<check::ASTCodeBody> 
Class:class CallAndMessageChecker class CallAndMessageChecker
Class:    class FindUninitializedField {     class FindUninitializedField 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(144, 2, u'-          assert(RD && "Referred record has no definition");')]
===========================================
Class:class CastSizeChecker : public Checker< check::PreStmt<CastExpr> > { class CastSizeChecker : public Checker< check::PreStmt<CastExpr> > 
Class:class CastToStructChecker : public Checker< check::PreStmt<CastExpr> > { class CastToStructChecker : public Checker< check::PreStmt<CastExpr> > 
Class:class ObjCDeallocChecker : public Checker< class ObjCDeallocChecker : public Checker<
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 2, u'-  assert (LOpts.getGC() != LangOptions::GCOnly);')]
===========================================
Class:class ObjCMethSigsChecker : public Checker< class ObjCMethSigsChecker : public Checker<
Class:class WalkAST : public StmtVisitor<WalkAST> { class WalkAST : public StmtVisitor<WalkAST> 
Class:class SecuritySyntaxChecker : public Checker<check::ASTCodeBody> { class SecuritySyntaxChecker : public Checker<check::ASTCodeBody> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(438, 2, u'-  assert(ArgSuffix.first >= 0 && "Unsupported function");')]
===========================================
Class:class WalkAST : public StmtVisitor<WalkAST> { class WalkAST : public StmtVisitor<WalkAST> 
Class:class SizeofPointerChecker : public Checker<check::ASTCodeBody> { class SizeofPointerChecker : public Checker<check::ASTCodeBody> 
Class:class CheckerDocumentation : public Checker< check::PreStmt<DeclStmt>, class CheckerDocumentation : public Checker< check::PreStmt<DeclStmt>,
Class:class ChrootChecker : public Checker<eval::Call, check::PreStmt<CallExpr> > { class ChrootChecker : public Checker<eval::Call, check::PreStmt<CallExpr> > 
Class:class ReachableCode { class ReachableCode 
Class:class DeadStoreObs : public LiveVariables::Observer { class DeadStoreObs : public LiveVariables::Observer 
Class:class FindEscaped : public CFGRecStmtDeclVisitor<FindEscaped>{ class FindEscaped : public CFGRecStmtDeclVisitor<FindEscaped>
Class:class DeadStoresChecker : public Checker<check::ASTCodeBody> { class DeadStoresChecker : public Checker<check::ASTCodeBody> 
Class:class DominatorsTreeDumper : public Checker<check::ASTCodeBody> { class DominatorsTreeDumper : public Checker<check::ASTCodeBody> 
Class:class LiveVariablesDumper : public Checker<check::ASTCodeBody> { class LiveVariablesDumper : public Checker<check::ASTCodeBody> 
Class:class CFGViewer : public Checker<check::ASTCodeBody> { class CFGViewer : public Checker<check::ASTCodeBody> 
Class:class CFGDumper : public Checker<check::ASTCodeBody> { class CFGDumper : public Checker<check::ASTCodeBody> 
Class:class CallGraphViewer : public Checker< check::ASTDecl<TranslationUnitDecl> > { class CallGraphViewer : public Checker< check::ASTDecl<TranslationUnitDecl> > 
Class:class CallGraphDumper : public Checker< check::ASTDecl<TranslationUnitDecl> > { class CallGraphDumper : public Checker< check::ASTDecl<TranslationUnitDecl> > 
Class:class DereferenceChecker class DereferenceChecker
Class:class DivZeroChecker : public Checker< check::PreStmt<BinaryOperator> > { class DivZeroChecker : public Checker< check::PreStmt<BinaryOperator> > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(78, 2, u'-    assert(stateZero);')]
===========================================
Class:class FixedAddressChecker class FixedAddressChecker
Class:class GenericTaintChecker : public Checker< check::PostStmt<CallExpr>, class GenericTaintChecker : public Checker< check::PostStmt<CallExpr>,
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(501, 2, u'-    assert(ArgNum < CE->getNumArgs());'), (513, 2, u'-  assert(CE->getNumArgs() >= 2);'), (634, 2, u'-  assert(E);')]
===========================================
Class:class IdempotentOperationChecker class IdempotentOperationChecker
Class:  class VisitWL : public WorkList::Visitor {   class VisitWL : public WorkList::Visitor 
Class:class RefState { class RefState 
Class: class IteratorsChecker :     public Checker<check::PreStmt<CXXOperatorCallExpr>,                    check::PreStmt<DeclStmt>,                    check::PreStmt<CXXMemberCallExpr>,                    check::PreStmt<CallExpr> >   {   
Class: class IteratorState { class IteratorState 
Class:class StringRefCheckerVisitor : public StmtVisitor<StringRefCheckerVisitor> { class StringRefCheckerVisitor : public StmtVisitor<StringRefCheckerVisitor> 
Class:class ASTFieldVisitor { class ASTFieldVisitor 
Class:class LLVMConventionsChecker : public Checker< class LLVMConventionsChecker : public Checker<
Class:class MacOSKeychainAPIChecker : public Checker<check::PreStmt<CallExpr>, class MacOSKeychainAPIChecker : public Checker<check::PreStmt<CallExpr>,
Class:  class SecKeychainBugVisitor   class SecKeychainBugVisitor
Class:class MacOSXAPIChecker : public Checker< check::PreStmt<CallExpr> > { class MacOSXAPIChecker : public Checker< check::PreStmt<CallExpr> > 
Class:class RefState { class RefState 
Class: class MallocChecker : public Checker<check::DeadSymbols,                                      check::EndPath,                                      check::PreStmt<ReturnStmt>,                                      check::PreStmt<CallExpr>,                                      check::PostStmt<CallExpr>,                                      check::PostStmt<BlockExpr>,                                      check::Location,                                      check::Bind,                                      eval::Assume,                                      check::RegionChanges> { 
Class:            class MallocBugVisitor : public BugReporterVisitorImpl<MallocBugVisitor> {   class MallocBugVisitor : public BugReporterVisitorImpl<MallocBugVisitor> 
Class:class RegionState 
Class:class ReallocPairs 
Class:class StopTrackingCallback : public SymbolVisitor { class StopTrackingCallback : public SymbolVisitor 
Class:class MallocOverflowSecurityChecker : public Checker<check::ASTCodeBody> { class MallocOverflowSecurityChecker : public Checker<check::ASTCodeBody> 
Class:class CheckOverflowOps : class CheckOverflowOps :
Class:class CastedAllocFinder class CastedAllocFinder
Class: class SizeofFinder : public ConstStmtVisitor<SizeofFinder> { class SizeofFinder : public ConstStmtVisitor<SizeofFinder> 
Class: class MallocSizeofChecker : public Checker<check::ASTCodeBody> { class MallocSizeofChecker : public Checker<check::ASTCodeBody> 
Class:class NSAutoreleasePoolChecker class NSAutoreleasePoolChecker
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 2, u'-    assert(0);')]
===========================================
Class:class NSErrorMethodChecker class NSErrorMethodChecker
Class:class CFErrorFunctionChecker class CFErrorFunctionChecker
Class:class NSErrorDerefBug : public BugType { class NSErrorDerefBug : public BugType 
Class: class CFErrorDerefBug : public BugType { class CFErrorDerefBug : public BugType 
Class:class NSOrCFErrorDerefChecker class NSOrCFErrorDerefChecker
Class:class NoReturnFunctionChecker : public Checker< check::PostStmt<CallExpr>, class NoReturnFunctionChecker : public Checker< check::PostStmt<CallExpr>,
Class:class OSAtomicChecker : public Checker<eval::InlineCall> { class OSAtomicChecker : public Checker<eval::InlineCall> 
Class:class ObjCAtSyncChecker class ObjCAtSyncChecker
Class:class WalkAST : public StmtVisitor<WalkAST> { class WalkAST : public StmtVisitor<WalkAST> 
Class:class ObjCContainersASTChecker : public Checker<check::ASTCodeBody> { class ObjCContainersASTChecker : public Checker<check::ASTCodeBody> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(129, 2, u'-    assert(ArgNum == 1 || ArgNum == 2);'), (133, 2, u'-    assert(ArgNum == 1 || ArgNum == 2);')]
===========================================
Class:class ObjCContainersChecker : public Checker< check::PreStmt<CallExpr>, class ObjCContainersChecker : public Checker< check::PreStmt<CallExpr>,
Class:class ObjCSelfInitChecker : public Checker<  check::PreObjCMessage, class ObjCSelfInitChecker : public Checker<  check::PreObjCMessage,
Class:class InitSelfBug : public BugType { class InitSelfBug : public BugType 
Class:class ObjCUnusedIvarsChecker : public Checker< class ObjCUnusedIvarsChecker : public Checker<
Class:class PointerArithChecker class PointerArithChecker
Class:class PointerSubChecker class PointerSubChecker
Class:class PthreadLockChecker : public Checker< check::PostStmt<CallExpr> > { class PthreadLockChecker : public Checker< check::PostStmt<CallExpr> > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(139, 2, u'-    assert(lockFail && lockSucc);'), (145, 2, u'-    assert(lockSucc);'), (149, 2, u'-    assert((semantics == XNUSemantics) && "Unknown locking semantics");')]
===========================================
Class:class GenericNodeBuilderRefCount { class GenericNodeBuilderRefCount 
Class:class RetEffect { class RetEffect 
Class:     class RefVal { class RefVal 
Class:class RetainSummary { class RetainSummary 
Class:class ObjCSummaryKey { class ObjCSummaryKey 
Class:class ObjCSummaryCache { class ObjCSummaryCache 
Class:class RetainSummaryManager { class RetainSummaryManager 
Class:      Class = msg.getReceiverInterface();
Class:     class RetainSummaryTemplate { class RetainSummaryTemplate 
Class:  class CFRefBug : public BugType {   class CFRefBug : public BugType 
Class:   class UseAfterRelease : public CFRefBug {   class UseAfterRelease : public CFRefBug 
Class:   class BadRelease : public CFRefBug {   class BadRelease : public CFRefBug 
Class:   class DeallocGC : public CFRefBug {   class DeallocGC : public CFRefBug 
Class:   class DeallocNotOwned : public CFRefBug {   class DeallocNotOwned : public CFRefBug 
Class:   class OverAutorelease : public CFRefBug {   class OverAutorelease : public CFRefBug 
Class:   class ReturnedNotOwnedForOwned : public CFRefBug {   class ReturnedNotOwnedForOwned : public CFRefBug 
Class:   class Leak : public CFRefBug {   class Leak : public CFRefBug 
Class:   class LeakAtReturn : public Leak {   class LeakAtReturn : public Leak 
Class:   class LeakWithinFunction : public Leak {   class LeakWithinFunction : public Leak 
Class:             class CFRefReportVisitor : public BugReporterVisitorImpl<CFRefReportVisitor> {   class CFRefReportVisitor : public BugReporterVisitorImpl<CFRefReportVisitor> 
Class:   class CFRefLeakReportVisitor : public CFRefReportVisitor {   class CFRefLeakReportVisitor : public CFRefReportVisitor 
Class:   class CFRefReport : public BugReport {   class CFRefReport : public BugReport 
Class:   class CFRefLeakReport : public CFRefReport {   class CFRefLeakReport : public CFRefReport 
Class:class RetainCountChecker class RetainCountChecker
Class:class StopTrackingCallback : public SymbolVisitor { class StopTrackingCallback : public SymbolVisitor 
Class:class ReturnPointerRangeChecker : class ReturnPointerRangeChecker :
Class:class ReturnUndefChecker : class ReturnUndefChecker :
Class:class StackAddrEscapeChecker : public Checker< check::PreStmt<ReturnStmt>, class StackAddrEscapeChecker : public Checker< check::PreStmt<ReturnStmt>,
Class:  class CallBack : public StoreManager::BindingsHandler {   class CallBack : public StoreManager::BindingsHandler 
Class:class StreamChecker : public Checker<eval::Call, class StreamChecker : public Checker<eval::Call,
Class:class TaintTesterChecker : public Checker< check::PostStmt<Expr> > { class TaintTesterChecker : public Checker< check::PostStmt<Expr> > 
Class:class UndefBranchChecker : public Checker<check::BranchCondition> { class UndefBranchChecker : public Checker<check::BranchCondition> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 2, u'-      assert (!N->pred_empty());')]
===========================================
Class:class UndefCapturedBlockVarChecker class UndefCapturedBlockVarChecker
Class:class UndefResultChecker class UndefResultChecker
Class:class UndefinedArraySubscriptChecker class UndefinedArraySubscriptChecker
Class:class UndefinedAssignmentChecker class UndefinedAssignmentChecker
Class:class UnixAPIChecker : public Checker< check::PreStmt<CallExpr> > { class UnixAPIChecker : public Checker< check::PreStmt<CallExpr> > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(260, 2, u'-  assert(trueState);'), (296, 2, u'-  assert(trueState);')]
===========================================
Class:class UnreachableCodeChecker : public Checker<check::EndAnalysis> { class UnreachableCodeChecker : public Checker<check::EndAnalysis> 
Class:class VLASizeChecker : public Checker< check::PreStmt<DeclStmt> > { class VLASizeChecker : public Checker< check::PreStmt<DeclStmt> > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(154, 2, u'-  assert(state);')]
===========================================
Class:class WalkAST : public StmtVisitor<WalkAST> { class WalkAST : public StmtVisitor<WalkAST> 
Class:class VirtualCallChecker : public Checker<check::ASTDecl<CXXRecordDecl> > { class VirtualCallChecker : public Checker<check::ASTDecl<CXXRecordDecl> > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 2, u'-    assert(!WList.empty());'), (90, 2, u'-      assert(FD && FD->getBody());'), (106, 2, u'-      assert(VisitedFunctions[FD] == PostVisited);'), (177, 2, u'-    assert(FD);')]
===========================================
Class:class BasicConstraintManager class BasicConstraintManager
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(154, 2, u'-      assert (false && "Invalid Opcode.");')]
===========================================
Class:class CountKey { class CountKey 
Class:class NodeMapClosure : public BugReport::NodeResolver { class NodeMapClosure : public BugReport::NodeResolver 
Class: class PathDiagnosticBuilder : public BugReporterContext { class PathDiagnosticBuilder : public BugReporterContext 
Class:class ContextLocation : public PathDiagnosticLocation { class ContextLocation : public PathDiagnosticLocation 
Class: class EdgeBuilder { class EdgeBuilder 
Class:class DiagCacheItem : public llvm::FoldingSetNode { class DiagCacheItem : public llvm::FoldingSetNode 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(356, 2, u'-  assert(R && "The memory region is null.");'), (516, 2, u'-  assert(Cond);'), (517, 2, u'-  assert(srcBlk->succ_size() == 2);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 2, u'-    assert(I->second.HasDispatcher && "No dispatcher registered for an event");'), (57, 2, u'-  assert(D);'), (74, 2, u'-  assert(checkers);'), (82, 2, u'-  assert(D && D->hasBody());'), (476, 2, u'-    assert(InlineCallCheckers.size() <= 1 &&'), (486, 2, u'-      assert(!(evaluated && anyEvaluated)'), (519, 2, u'-      assert(!(evaluated && anyEvaluated)'), (651, 2, u'-  assert(S);'), (668, 2, u'-  assert(checkers);')]
===========================================
Class:class DFS : public WorkList { class DFS : public WorkList 
Class: class BFS : public WorkList { class BFS : public WorkList 
Class:  class BFSBlockDFSContents : public WorkList {   class BFSBlockDFSContents : public WorkList 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 2, u'-    assert (!Stack.empty());'), (129, 2, u'-      assert(!Queue.empty());'), (170, 2, u'-    assert (Entry->empty() &&'), (173, 2, u'-    assert (Entry->succ_size() == 1 &&'), (237, 2, u'-      assert (false && "BlockExit location never occur in forward analysis.");'), (256, 2, u'-      assert(Pred->hasSinglePred() &&'), (263, 2, u'-      assert(isa<PostStmt>(Loc) ||'), (296, 2, u'-    assert (L.getLocationContext()->getCFG()->getExit().size() == 0'), (401, 2, u'-        assert (B->succ_size() == 1);'), (440, 2, u'-  assert (B->succ_size() == 1 &&'), (449, 2, u'-  assert(B->succ_size() == 2);'), (460, 2, u'-  assert(B);'), (461, 2, u'-  assert(!B->empty());'), (483, 2, u'-    assert (IsNew);'), (493, 2, u'-  assert(Block);'), (494, 2, u'-  assert (!N->isSink());'), (667, 2, u'-  assert(Src->succ_rbegin() != Src->succ_rend());')]
===========================================
Class:class MarkLiveCallback : public SymbolVisitor { class MarkLiveCallback : public SymbolVisitor 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(119, 2, u'-  assert(node->pred_size() == 1 || node->succ_size() == 1);'), (137, 2, u'-  assert(reclaimCounter > 0);'), (160, 2, u'-  assert (!V->isSink());'), (169, 2, u'-  assert(getKind() == Size1);'), (171, 2, u'-  assert(getKind() == Size1);'), (175, 2, u'-  assert((reinterpret_cast<uintptr_t>(N) & Mask) == 0x0);'), (176, 2, u'-  assert(!getFlag());'), (185, 2, u'-      assert((reinterpret_cast<uintptr_t>(V) & Mask) == 0x0);'), (189, 2, u'-      assert(getPtr() == (void*) V);'), (190, 2, u'-      assert(getKind() == SizeOther);'), (194, 2, u'-      assert(getKind() == Size1);'), (198, 2, u'-    assert(getKind() == SizeOther);'), (282, 2, u'-  assert (NBeg < NEnd);'), (307, 2, u'-    assert(*I);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 2, u'-    assert (B->isCompoundAssignmentOp());'), (414, 2, u'-        assert(isa<nonloc::LazyCompoundVal>(InitVal));'), (441, 2, u'-  assert(B->getOpcode() == BO_LAnd ||'), (448, 2, u'-  assert(X.isUndef());'), (451, 2, u'-  assert(Ex);'), (524, 2, u'-    assert(IE->getNumInits() == 1);'), (544, 2, u'-  assert (X.isUndef());'), (546, 2, u'-  assert(SE);'), (559, 2, u'-    assert(IV.getBitWidth() == getContext().getTypeSize(OOE->getType()));'), (560, 2, u'-    assert(OOE->getType()->isIntegerType());'), (561, 2, u'-    assert(IV.isSigned() == OOE->getType()->isSignedIntegerOrEnumerationType());'), (581, 2, u'-      assert(T->isVariableArrayType() && "Unknown non-constant-sized type.");'), (627, 2, u'-      assert (U->getType() == Ex->getType());'), (651, 2, u'-      assert(!U->isLValue());'), (674, 2, u'-      assert (!U->isLValue());'), (729, 2, u'-  assert (U->isIncrementDecrementOp());'), (745, 2, u'-    assert(LCtx == (*I)->getLocationContext());'), (792, 2, u'-          assert(state);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(69, 2, u'-  assert(CD);')]
===========================================
Class:  class DefaultEval : public GraphExpander {   class DefaultEval : public GraphExpander 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 2, u'-  assert(Entry->empty());'), (32, 2, u'-  assert(Entry->succ_size() == 1);'), (59, 2, u'-      assert(Node->pred_size() == 1);'), (276, 2, u'-    assert(MDecl->param_size() <= Call.getNumArgs());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 2, u'-    assert(elemD->getInit() == 0);'), (114, 2, u'-        assert(Loc::isLocType(T));'), (167, 2, u'-        assert(notNilState);'), (271, 2, u'-  assert(Bldr.hasGeneratedNodes());')]
===========================================
Class:class HTMLDiagnostics : public PathDiagnosticConsumer { class HTMLDiagnostics : public PathDiagnosticConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(576, 2, u'-  assert(STC);'), (589, 2, u'-  assert(STC);'), (608, 2, u'-    assert(K == MemRegion::GlobalInternalSpaceRegionKind);'), (612, 2, u'-  assert(K == MemRegion::StaticGlobalSpaceRegionKind);'), (689, 2, u'-        assert(D->isStaticLocal());'), (733, 2, u'-      assert(STC);'), (756, 2, u'-    assert(STC);'), (819, 2, u'-  assert(SFC);'), (833, 2, u'-  assert(STC);'), (835, 2, u'-  assert(PT);'), (843, 2, u'-  assert(STC);'), (970, 2, u'-  assert(superR && "super region cannot be NULL");'), (1074, 2, u'-    assert(VR);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-  assert(isFunctionCall());'), (49, 2, u'-  assert(!isCXXCall());'), (55, 2, u'-  assert(isCXXCall());'), (70, 2, u'-  assert(isObjCMessage());'), (78, 2, u'-    assert(CE);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(247, 2, u'-  assert(!LAC.isNull() && "A valid LocationContext or AnalysisDeclContext should "'), (349, 2, u'-  assert(N && "Cannot create a location with a null node.");'), (379, 2, u'-  assert(isValid());'), (404, 2, u'-  assert(isValid());'), (477, 2, u'-  assert(path.size() > 0 &&'), (484, 2, u'-      assert(!cp->path.empty());'), (671, 2, u'-  assert(CExit && "Stack Hints should be constructed at CallExit points.");'), (721, 2, u'-  assert(ValNo != 0 && "ValNo must be strictly positive!");')]
===========================================
Class:  class PlistDiagnostics : public PathDiagnosticConsumer {   class PlistDiagnostics : public PathDiagnosticConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 2, u'-  assert(state->refCount > 0);'), (194, 2, u'-  assert(!isa<loc::MemRegionVal>(LV) && "Use invalidateRegion instead.");'), (641, 2, u'-  assert(NewState);'), (688, 2, u'-    assert(isa<SymbolData>(*SI));')]
===========================================
Class:class Range : public std::pair<const llvm::APSInt*, class Range : public std::pair<const llvm::APSInt*,
Class:  class RangeTrait : public llvm::ImutContainerInfo<Range> { class RangeTrait : public llvm::ImutContainerInfo<Range> 
Class:    class RangeSet { class RangeSet 
Class:class RangeConstraintManager : public SimpleConstraintManager{ class RangeConstraintManager : public SimpleConstraintManager
Class:class BindingKey { class BindingKey 
Class:class RegionStoreFeatures { class RegionStoreFeatures 
Class:class RegionStoreSubRegionMap : public SubRegionMap { class RegionStoreSubRegionMap : public SubRegionMap 
Class: class RegionStoreManager : public StoreManager { class RegionStoreManager : public StoreManager 
Class:class ClusterAnalysis  { class ClusterAnalysis  
Class:class invalidateRegionsWorker : public ClusterAnalysis<invalidateRegionsWorker> class invalidateRegionsWorker : public ClusterAnalysis<invalidateRegionsWorker>
Class:class removeDeadBindingsWorker : class removeDeadBindingsWorker :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 2, u'-  assert(lhs);'), (49, 2, u'-  assert(!Loc::isLocType(type));'), (56, 2, u'-  assert(rhs);'), (57, 2, u'-  assert(!Loc::isLocType(type));'), (63, 2, u'-  assert(lhs && rhs);'), (64, 2, u'-  assert(haveSameType(lhs->getType(Context), rhs->getType(Context)) == true);'), (65, 2, u'-  assert(!Loc::isLocType(type));'), (71, 2, u'-  assert(operand);'), (72, 2, u'-  assert(!Loc::isLocType(toTy));'), (156, 2, u'-  assert(SymbolManager::canSymbolicate(type) && "Invalid metadata symbol type");'), (244, 2, u'-    assert(op == BO_Add);'), (316, 2, u'-    assert(Loc::isLocType(castTy));'), (332, 2, u'-    assert(castTy->isIntegerType());'), (373, 2, u'-    assert(Loc::isLocType(originalTy) || originalTy->isFunctionType() ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(217, 2, u'-  assert (Op == BO_Add || Op == BO_Sub ||'), (296, 2, u'-      assert (false && "Pretty-printed not implemented for this NonLoc.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(79, 2, u'-    assert (false && "\'Assume\' not implemented for this Loc.");'), (171, 2, u'-    assert(sym);'), (246, 2, u'-  assert(BinaryOperator::isComparisonOp(op) &&'), (267, 2, u'-  assert(T->isIntegerType() || Loc::isLocType(T));')]
===========================================
Class:class SimpleSValBuilder : public SValBuilder { class SimpleSValBuilder : public SValBuilder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 2, u'-  assert(!T.isNull());'), (231, 2, u'-    assert(svalBuilder.getContext().hasSameUnqualifiedType(castTy, T));'), (329, 2, u'-  assert(BaseIdxI.isSigned());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(124, 2, u'-  assert(!itr.empty() && "attempting to iterate on an \'end\' iterator");'), (125, 2, u'-  assert(isa<SymbolData>(itr.back()));'), (133, 2, u'-  assert(!itr.empty() && "attempting to dereference an \'end\' iterator");'), (391, 2, u'-  assert(LI != TheLiving.end() && "The primary symbol is not live.");')]
===========================================
Class:class TextPathDiagnostics : public PathDiagnosticConsumer { class TextPathDiagnostics : public PathDiagnosticConsumer 
Class:class AnalysisConsumer : public ASTConsumer, class AnalysisConsumer : public ASTConsumer,
Class:class UbigraphViz : public ExplodedNode::Auditor { class UbigraphViz : public ExplodedNode::Auditor 
Class:class ClangCheckerRegistry : public CheckerRegistry { class ClangCheckerRegistry : public CheckerRegistry 
Class:class CommandLineArgumentParser { class CommandLineArgumentParser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 2, u'-  assert(!CC1Args.empty() && "Must at least contain the program name!");'), (123, 2, u'-  assert(llvm::sys::path::is_absolute(BaseDirectory));')]
===========================================
Class:    class A { class A 
Class:   class A { class A 
Class: class B : public A { class B : public A 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 2, u'-#define Assert(condition)if (!(condition)) { DebugStop("Assertion failure: %s [File: %s, Line: %lu]", #condition, __FILE__, __LINE__); }'), (38, 2, u'-#define AssertMsg(condition, message)if (!(condition)) { DebugStop("Assertion failure: %s (%s) [File: %s, Line: %lu]", #condition, message, __FILE__, __LINE__); }'), (42, 2, u'-#define AssertNoErr(err){ DebugDisplayOSStatusMsg((err), #err, __FILE__, __LINE__); }')]
===========================================
Class:     class Test2 { class Test2 
Class:  class pencil {   class pencil 
Class:  class A { class A 
Class: class B : public A { class B : public A 
Class:  class A { class A 
Class:   class A { class A 
Class: class B : public virtual A { class B : public virtual A 
Class: class C : public virtual A { class C : public virtual A 
Class: class TestOrder : public C, public B, public virtual A { class TestOrder : public C, public B, public virtual A 
Class: class TestArray { class TestArray 
Class:  class A { class A 
Class:class B : public A{ class B : public A
Class:class C : public A
Class:class BB: public B
Class:class M : public B, public C 
Class:  class A { class A 
Class:   class A { class A 
Class: class B : public virtual A { class B : public virtual A 
Class: class C : public virtual A { class C : public virtual A 
Class: class TestOrder : public C, public B, public A { class TestOrder : public C, public B, public A 
Class: class TestControlFlow { class TestControlFlow 
Class:  class A { class A 
Class:class Test3_Base 
Class:class Test3_Derived : public Test3_Base 
Class:     class TestHandleThis { class TestHandleThis 
Class:   class String8419 { class String8419 
Class: template <class T> class Foo { template <class T> class Foo 
Class:class Dummy 
Class: template <typename T> class Foo2 { class Foo2 
Class:   template <typename T> class Foo3 { class Foo3 
Class:   class RDar9203355 { class RDar9203355 
Class:class Rdar9212495_B : public Rdar9212495_C 
Class:class Rdar9212495_A : public Rdar9212495_B 
Class: class PR9645_SideEffect { 
Class:  class RDar9267815 { class RDar9267815 
Class:  class TestInvalidateClass { class TestInvalidateClass 
Class:  class TestInvalidateInCtor { class TestInvalidateInCtor 
Class:   class ClassWithStatic { class ClassWithStatic 
Class:    class PR11146 { class PR11146 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(6, 2, u'-extern void __assert_fail (__const char *__assertion, __const char *__file,'), (10, 2, u'-#define assert(expr) \\'), (11, 2, u'-  ((expr)  ? (void)(0)  : __assert_fail (#expr, __FILE__, __LINE__, __func__))'), (194, 2, u'-  assert (len != 0);'), (205, 2, u"-  assert (len > 0);  // note use of '>'")]
===========================================
Class:   class A { class A 
Class: class B { class B 
Class: class TestCtorInits { class TestCtorInits 
Class:  class A { class A 
Class: class B : public A { class B : public A 
Class: class C : public B { class C : public B 
Class:  class type_info;
Class:    class Foo {     class Foo 
Class:   class Test {   class Test 
Class:  class A {   class A 
Class:  class B {   class B 
Class:  class D 
Class:  class C 
Class:  template <class T> class A {   template <class T> class A 
Class:  class X 
Class:  class Ident<int> AIdent; 
Class:   class C { class C 
Class:    class C 
Class:  class C : C 
Class:    class C;
Class:  class bad_alloc 
Class:class foo 
Class:  class bad_alloc 
Class:  class Base {   class Base 
Class:   class Test : public Base {   class Test : public Base 
Class:  class Base {    class Base 
Class:   class Test : protected Base {    class Test : protected Base 
Class:  class Base {    class Base 
Class:   class Test : private Base {    class Test : private Base 
Class:  class A {   class A 
Class:  class B : private A 
Class:  class C : private A {   class C : private A 
Class:  class A {   class A 
Class:  class B : public A 
Class:  class C : private A {   class C : private A 
Class:  class Test0 {   class Test0 
Class:  class A {   class A 
Class:  class E {   class E 
Class:    class B 
Class:     class I {     class I 
Class:  class ClassFriend {   class ClassFriend 
Class:   class MemberFriend {   class MemberFriend 
Class:   class Class {   class Class 
Class:   class UndeclaredClassFriend {   class UndeclaredClassFriend 
Class:   class ClassNonFriend {   class ClassNonFriend 
Class:  class ilist_half_node {   class ilist_half_node 
Class:   class ilist_node : private ilist_half_node {    class ilist_node : private ilist_half_node 
Class:  class A 
Class:   class B : public A {   class B : public A 
Class:  class A 
Class:   class B : public A {   class B : public A 
Class:  template <class T> class Holder {   template <class T> class Holder 
Class:    class A;
Class:   class ns::A {   class ns::A 
Class:    class B {     class B 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class B {   class B 
Class:    class C {     class C 
Class:  class A {   class A 
Class:   class B {   class B 
Class:  class B : private A {   class B : private A 
Class:    class A {     class A 
Class:    class A {     class A 
Class:class X1 
Class:class Y1 
Class:  class A {   class A 
Class:  class B : public A 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {    class C : protected A 
Class:  class D : private B {    class D : private B 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class B;
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class C;
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {    class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class D;
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {    class D : private B 
Class:  class Static 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class Static 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class Static 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class A {    class A 
Class:   class B : public A {    class B : public A 
Class:   class C : protected B {    class C : protected B 
Class:   class D : public A {   class D : public A 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:   class C {   class C 
Class:  class A 
Class:  class B : public virtual A 
Class:  class C : private B 
Class:  class D : private C, public virtual A 
Class:  class A 
Class:  class B : private virtual A 
Class:  class C : private B 
Class:  class D : public virtual A 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:  class A {   class A 
Class:   class B : public virtual A {   class B : public virtual A 
Class:   class C : public B {   class C : public B 
Class:class Public 
Class:class Protected 
Class:class Private 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class B : A 
Class:   class C : virtual A {   class C : virtual A 
Class:  class D : C 
Class:  class A {   class A 
Class:  class Base2 : virtual Base<2> 
Class:  class Base3 : virtual Base<3> 
Class:  class Derived0 : Base<0> 
Class:  class Derived1 : Base<1> 
Class:   class Derived2 :                          Base<0>,       virtual Base<1>,      Base2,      virtual Base3   {   
Class:  class Base {   class Base 
Class:   class Derived1 : private Base {    class Derived1 : private Base 
Class:                                               class Derived2 : public Base {   class Derived2 : public Base 
Class:   class Derived3 : private Base {    class Derived3 : private Base 
Class:                                              class Derived4 : public Base {   class Derived4 : public Base 
Class:  class A {   class A 
Class:  class Test1 
Class:  class Test2 : A 
Class:  class A {   class A 
Class:  class Test1 
Class:  class Test2 : A 
Class:  class A {   class A 
Class:  class B : A {   class B : A 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class B : private A {    class B : private A 
Class:  class C : public B {   class C : public B 
Class:  class A {   class A 
Class:   class B {   class B 
Class:   class C {   class C 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:  class A {   class A 
Class:      class Local {       class Local 
Class:  class A {   class A 
Class:   class X {   class X 
Class:  template <class T> class A {   template <class T> class A 
Class:   template <class T> class B : public A<T> {   template <class T> class B : public A<T> 
Class:  class A 
Class:  class A {   class A 
Class:  template <class T> class A 
Class:  class B : A<int> {   class B : A<int> 
Class:            class C : B {   class C : B 
Class:  class A 
Class:  class Foo {   class Foo 
Class:  template <class T> class A {   template <class T> class A 
Class:    class Inner; 
Class:  template <class T> class A<T>::Inner 
Class:  class B {   class B 
Class:  template <typename T> class A {   template <typename T> class A 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class A {   class A 
Class:   class B {   class B 
Class:  class Green 
Class:    template <class T, class Nat> class A {     template <class T, class Nat> class A 
Class:   template <class T> class Outer::A<T, typename T::nature> {   template <class T> class Outer::A<T, typename T::nature> 
Class:   class B {   class B 
Class:  template <class T> class A {   template <class T> class A 
Class:  class A {   class A 
Class:   class B {   class B 
Class:  class A {   class A 
Class:   class B : A {   class B : A 
Class:  class A {   class A 
Class:  class B {   class B 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class V { class V 
Class: class W { class W 
Class: class B : public virtual V, public W { 
Class:class C : public virtual V, public W 
Class:class D : public B, public C 
Class:  class ClsA {   class ClsA 
Class:   class ClsB : virtual private ClsA {   class ClsB : virtual private ClsA 
Class:   class ClsF : virtual private ClsA {   class ClsF : virtual private ClsA 
Class:   class ClsE : public ClsB, public ClsF {   class ClsE : public ClsB, public ClsF 
Class: class foo { class foo 
Class:  class A { class A 
Class:  class AInner {   class AInner 
Class: class A { class A 
Class:  class AInner {   class AInner 
Class:  class facet 
Class: class A { class A 
Class:  class A { class A 
Class:  class X {   class X 
Class:    class Inner {     class Inner 
Class:   class Y {   class Y 
Class:    class Inner {     class Inner 
Class:       class A { class A 
Class:   class B {   class B 
Class:  class A {   class A 
Class:  class Outer { class Outer 
Class:      class Inner {   class Inner 
Class:  class Outer { class Outer 
Class:      class Inner {   class Inner 
Class:  class E {   class E 
Class:    class I1;
Class:    class I1 
Class:  class E::I2 
Class:  class X { class X 
Class:  class Y 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 2, u'-static_assert(U<int>::a == 0, "");')]
===========================================
Class: class Okay { class Okay 
Class: class Virtual { class Virtual 
Class: class VirtualBase : virtual Okay {  class VirtualBase : virtual Okay 
Class: class Ctor { class Ctor 
Class:class Ctor2 { class Ctor2 
Class:class CtorTmpl { class CtorTmpl 
Class: class CopyCtor { class CopyCtor 
Class:  class CopyAssign {  class CopyAssign 
Class: class Dtor { class Dtor 
Class: template <class A, class B> struct Either { template <class A, class B> struct Either 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 2, u'-static_assert(U2<int>::k1 == sizeof(int), "");'), (31, 2, u'-static_assert(U2<char>::k1 == sizeof(char), "");')]
===========================================
Class:class A final 
Class:class A final 
Class:class B : A 
Class:class Trivial 
Class:class NonTrivial1 
Class:class NonTrivial2 
Class:class NonTrivial3 
Class:class NonTrivial4 
Class:class NonTrivial5 
Class:class NonTrivial6 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(10, 2, u'-static_assert(__is_trivial(Trivial), "Trivial is not trivial");'), (11, 2, u'-static_assert(!__is_trivial(NonTrivial1), "NonTrivial1 is trivial");'), (12, 2, u'-static_assert(!__is_trivial(NonTrivial2), "NonTrivial2 is trivial");'), (13, 2, u'-static_assert(!__is_trivial(NonTrivial3), "NonTrivial3 is trivial");'), (14, 2, u'-static_assert(!__is_trivial(NonTrivial4), "NonTrivial4 is trivial");'), (15, 2, u'-static_assert(!__is_trivial(NonTrivial5), "NonTrivial5 is trivial");'), (30, 2, u'-static_assert(!__is_trivial(NonTrivial6), "NonTrivial6 is trivial");')]
===========================================
Class:  class Y {   class Y 
Class:    class A {     class A 
Class:  class Test3 
Class:  class Test3 
Class:    class Test4 
Class:    class Test4 
Class:  class A 
Class:  template <class Tp> class allocator;
Class:  class allocator<void>   class allocator<void>
Class:   template <class Tp>   class allocator   {   
Class:class foo 
Class:  class foo 
Class:      class foo a;
Class:      class foo a;
Class:      class ::foo a;
Class:    class a 
Class:  class A {   class A 
Class:   class B : private A {   class B : private A 
Class:  class A {   class A 
Class:   class B {   class B 
Class:   class C : public B {   class C : public B 
Class:    class tag;
Class:  class Test0 {   class Test0 
Class:   class Test1 {   class Test1 
Class:  template <typename> class Test0 {   template <typename> class Test0 
Class:   template <typename> class Test1 {   template <typename> class Test1 
Class:  template <typename T> class Test0 {   template <typename T> class Test0 
Class:   template <typename T> class Test1 {   template <typename T> class Test1 
Class:  class Base {   class Base 
Class: class C { class C 
Class: class D2 : public B { class D2 : public B 
Class:  class Test0 {   class Test0 
Class:  class B {   class B 
Class:   class test5 { class test5 
Class:class C2 
Class:class C4 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 2, u'-  static_assert(true, "the impossible happened!");')]
===========================================
Class:  class C : public B {   class C : public B 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(19, 2, u'-static_assert(f(0) == 0, "");'), (20, 2, u'-static_assert(f(\'0\') == 1, "");'), (21, 2, u'-static_assert(g1() == 0, "");'), (22, 2, u'-static_assert(g2(0) == 1, "");'), (23, 2, u'-static_assert(g2(1) == 1, "");'), (24, 2, u'-static_assert(g3(0) == 1, "");'), (25, 2, u'-static_assert(g3(1) == 1, "");'), (26, 2, u'-static_assert(N::h() == 5, "");'), (27, 2, u'-static_assert(g4() == 5, "");'), (85, 2, u'-static_assert(BcpCall(0), "");')]
===========================================
Class:  class debug_flag {    class debug_flag 
Class:  class A { class A 
Class:  class type_info;
Class: class X { class X 
Class:  class type_info;
Class:class A 
Class: class A1 { class A1 
Class:  class Member 
Class: template <> class B<int> { template <> class B<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(18, 2, u'-static_assert(is_same<decltype(foo()), const int&&>::value, "");'), (19, 2, u'-static_assert(is_same<decltype(i), int>::value, "");'), (20, 2, u'-static_assert(is_same<decltype(a->x), double>::value, "");'), (21, 2, u'-static_assert(is_same<decltype((a->x)), const double&>::value, "");'), (22, 2, u'-static_assert(is_same<decltype(static_cast<int&&>(i)), int&&>::value, "");')]
===========================================
Class: class PD { class PD 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 2, u'-  static_assert(swappable<int>(), "");'), (77, 2, u'-  static_assert(!swappable<const int>(), "");'), (82, 2, u'-    static_assert(OK, "boom!"); // expected-error 2{{boom!}}')]
===========================================
Class: class K { class K 
Class:  class C0 {   class C0 
Class:  class C1 {   class C1 
Class:  class C2 {   class C2 
Class:  class C5 {   class C5 
Class:  class C6 {   class C6 
Class:    class c 
Class:  class C0 {   class C0 
Class:  class C1 {   class C1 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(16, 2, u'-static_assert(S(true), "");'), (17, 2, u'-static_assert(S(false), "not so fast"); // expected-error {{not so fast}}'), (18, 2, u'-static_assert(T(), "");'), (19, 2, u'-static_assert(U(), ""); // expected-error {{ambiguous}}'), (21, 2, u'-static_assert(false, L"\\x14hi" "!" R"x(")x"); // expected-error {{static_assert failed L"\\024hi!\\""}}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 2, u'-static_assert(S5().m == 4, "");')]
===========================================
Class:   class C { class C 
Class: template <typename T> class E { class E 
Class: class NonCopyable { class NonCopyable 
Class: class NonCopyableDerived : public NonCopyable { class NonCopyableDerived : public NonCopyable 
Class:  class map {   class map 
Class:  class Value {   class Value 
Class:class Private { class Private 
Class:class Friend { class Friend 
Class:  class S { class S 
Class:  class C { class C 
Class: class A { class A 
Class: class A { class A 
Class: template <class T> class RefMem {  template <class T> class RefMem 
Class:  template <class T> class PtrMem { template <class T> class PtrMem 
Class: template <class T> class ArrMem { template <class T> class ArrMem 
Class:template <class T, unsigned N> class DepArrMem { template <class T, unsigned N> class DepArrMem 
Class:   class foo { class foo 
Class:class basic_string class basic_string
Class: template <class T, class Value, class _Compare> __map_value_compare<T, Value, _Compare>::__map_value_compare()   noexcept(__is_nothrow_constructible<_Compare>::value) {}   noexcept(__is_nothrow_constructible<_Compare>::value) 
Class:  class Class {   class Class 
Class:  class CA1 {   class CA1 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 2, u'-static_assert(noexcept(IC0()), "IC0() does not throw");'), (41, 2, u'-static_assert(!noexcept(IC1()), "IC1() throws");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 2, u'-static_assert((T() = {4, 9}) == 4, "");'), (31, 2, u'-static_assert((T() += {4, 9}) == 9, "");')]
===========================================
Class:  class B {   class B 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(115, 2, u'-  static_assert(p, "");'), (124, 2, u'-  static_assert(!q, "");'), (202, 2, u'-    static_assert((A*)nb == 0, "");'), (203, 2, u'-    static_assert((B*)na == 0, "");'), (219, 2, u'-    static_assert(&a[2][0] == &a[1][3], "");'), (260, 2, u'-    static_assert(65536u * 65536u == 0u, ""); // ok'), (261, 2, u'-    static_assert(4294967295u + 1u == 0u, ""); // ok'), (262, 2, u'-    static_assert(0u - 1u == 4294967295u, ""); // ok'), (263, 2, u'-    static_assert(~0u * ~0u == 1u, ""); // ok'), (292, 2, u'-  static_assert(vi, ""); // expected-error {{constant expression}} expected-note {{read of volatile-qualified type}}'), (293, 2, u'-  static_assert(const_cast<int&>(vi), ""); // expected-error {{constant expression}} expected-note {{read of volatile object \'vi\'}}'), (294, 2, u'-  static_assert(vrci, ""); // expected-error {{constant expression}} expected-note {{read of volatile-qualified type}}'), (313, 2, u'-  static_assert(s.i, "");'), (314, 2, u'-  static_assert(s.v, ""); // expected-error {{constant expression}} expected-note {{read of volatile-qualified type}}'), (315, 2, u'-  static_assert(const_cast<int&>(s.v), ""); // expected-error {{constant expression}} expected-note {{read of volatile object \'vi\'}}'), (316, 2, u'-  static_assert(vs.i, ""); // expected-error {{constant expression}} expected-note {{read of volatile-qualified type}}'), (317, 2, u'-  static_assert(const_cast<int&>(vs.i), ""); // expected-error {{constant expression}} expected-note {{read of volatile object \'vs\'}}'), (318, 2, u'-  static_assert(vrs.i, ""); // expected-error {{constant expression}} expected-note {{read of volatile-qualified type}}'), (324, 2, u'-  static_assert(f().i, ""); // ok! there\'s no lvalue-to-rvalue conversion here!'), (325, 2, u'-  static_assert(((volatile const S&&)(S)0).i, ""); // expected-error {{constant expression}}'), (342, 2, u'-  static_assert(u.a == 0, "");'), (595, 2, u'-static_assert(and_value == false, "");'), (596, 2, u'-static_assert(or_value == true, "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(26, 2, u'-    static_assert(!vowels[5], "unexpected number of vowels");'), (78, 2, u'-static_assert(Val<bool, E1>::value == 1, ""); // ok'), (79, 2, u'-static_assert(Val<bool, \'\\0\'>::value == 0, ""); // ok'), (80, 2, u'-static_assert(Val<bool, U\'\\1\'>::value == 1, ""); // ok'), (81, 2, u'-static_assert(Val<bool, E5>::value == 1, ""); // expected-error {{5, which cannot be narrowed to type \'bool\'}}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 2, u'-static_assert(test_ok == 8, "");'), (42, 2, u'-static_assert(test_explicit == 4, "");'), (43, 2, u'-static_assert(test_ambiguous == 2, "");')]
===========================================
Class:  class type_info;
Class:class Poly 
Class:  class A   class A
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(15, 2, u'-  static_assert(!noexcept(a.g1()), "exception-specification failure");'), (16, 2, u'-  static_assert(noexcept(a.g2()), "exception-specification failure");'), (41, 2, u'-  static_assert(!noexcept(ci.g1()), "exception-specification failure");'), (42, 2, u'-  static_assert(noexcept(ci.g2()), "exception-specification failure");')]
===========================================
Class: class X0 { class X0 
Class: class NonCopyable { class NonCopyable 
Class: class NonConstCopy { class NonConstCopy 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 2, u'-  static_assert(sizeof(x) == sizeof(ExpectedArrayLayout), "layout mismatch");'), (66, 2, u'-  static_assert(sizeof(x) == sizeof(ExpectedLayout), "Layout mismatch!");'), (73, 2, u'-    static_assert(sizeof(x) == sizeof(ExpectedThisLayout), "Layout mismatch!");')]
===========================================
Class:  class NonCopyable { class NonCopyable 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(20, 2, u'-    static_assert(is_same<decltype(((r))), float const&>::value,'), (22, 2, u'-    static_assert(is_same<decltype(x), float>::value, "should be float");'), (23, 2, u'-    static_assert(is_same<decltype((x)), const float&>::value,'), (25, 2, u'-    static_assert(is_same<decltype(r), float&>::value, "should be float&");'), (26, 2, u'-    static_assert(is_same<decltype(ir), int&>::value, "should be int&");'), (27, 2, u'-    static_assert(is_same<decltype((ir)), int&>::value, "should be int&");'), (28, 2, u'-    static_assert(is_same<decltype(irc), const int&>::value,'), (30, 2, u'-    static_assert(is_same<decltype((irc)), const int&>::value,'), (36, 2, u'-      static_assert(is_same<decltype(x), float>::value, "should be float");'), (37, 2, u'-      static_assert(is_same<decltype((x)), float&>::value,'), (43, 2, u'-    static_assert(is_same<decltype((i)), int&>::value, "should be int&");')]
===========================================
Class:  class type_info;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 2, u'-  static_assert(!noexcept(tl1()), "lambda can throw");'), (55, 2, u'-  static_assert(!noexcept(tl2()), "lambda can throw");'), (60, 2, u'-  static_assert(noexcept(ntl1()), "lambda cannot throw");'), (61, 2, u'-  static_assert(noexcept(ntl2()), "lambda cannot throw");'), (62, 2, u'-  static_assert(noexcept(ntl3()), "lambda cannot throw");')]
===========================================
Class:  class X0 { class X0 
Class:  class type_info;
Class:class T0 
Class:class T2_A 
Class:class T3_A { class T3_A 
Class:template < typename T > class templ { template < typename T > class templ 
Class:  class ctor { class ctor 
Class: class dtor { class dtor 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 2, u'-#define P(e) static_assert(noexcept(e), "expected nothrow")'), (4, 2, u'-#define N(e) static_assert(!noexcept(e), "expected throw")'), (5, 2, u'-#define B(b, e) static_assert(b == noexcept(e), "expectation failed")')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(18, 2, u'-static_assert(123456789012345678901234567890123456789012345678901234567890_x3 == 60, "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(18, 2, u'-static_assert(1e1000000_x3 == 9, "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(10, 2, u'-static_assert(streq(s, "foobarbazquux"), "");'), (16, 2, u'-static_assert(streq(t, "foo"), "");')]
===========================================
Class:        class Y { class Y 
Class: class C { class C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 2, u'-static_assert(operator "" _a("foo") == \'f\', "");')]
===========================================
Class:  template <class T, class U> T& f(U); 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 2, u'-  static_assert(!noexcept(HasCopyConstructor((HasCopyConstructor()))), "");'), (49, 2, u'-  static_assert(!noexcept(hcc = HasCopyConstructor()), "");'), (51, 2, u'-  static_assert(!noexcept(HasCopyAssignment((HasCopyAssignment()))), "");'), (53, 2, u'-  static_assert(!noexcept(hca = HasCopyAssignment()), "");'), (55, 2, u'-  static_assert(noexcept(HasMoveConstructor((HasMoveConstructor()))), "");'), (61, 2, u'-  static_assert(noexcept(hma = HasMoveAssignment()), "");'), (63, 2, u'-  static_assert(!noexcept(HasDestructor((HasDestructor()))), "");'), (65, 2, u'-  static_assert(!noexcept(hd = HasDestructor()), "");'), (127, 2, u'-  static_assert(!noexcept(InheritsPrivateMove(InheritsPrivateMove())), "");'), (128, 2, u'-  static_assert(!noexcept(ContainsPrivateMove(ContainsPrivateMove())), "");'), (130, 2, u'-  static_assert(!noexcept(ipm = InheritsPrivateMove()), "");'), (132, 2, u'-  static_assert(!noexcept(cpm = ContainsPrivateMove()), "");'), (137, 2, u'-  static_assert(!noexcept(InheritsNonTrivialCopyOnly(InheritsNonTrivialCopyOnly())), "");'), (138, 2, u'-  static_assert(!noexcept(ContainsNonTrivialCopyOnly(ContainsNonTrivialCopyOnly())), "");'), (140, 2, u'-  static_assert(!noexcept(intco = InheritsNonTrivialCopyOnly()), "");'), (142, 2, u'-  static_assert(!noexcept(cntco = ContainsNonTrivialCopyOnly()), "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(38, 2, u'-  static_assert(noexcept(declval<X>()), "noexcept isn\'t working at all");'), (39, 2, u'-  static_assert(noexcept(X(declval<X&>())), "copy constructor can\'t throw");'), (40, 2, u'-  static_assert(noexcept(X(declval<X>())), "move constructor can\'t throw");')]
===========================================
Class: class X { class X 
Class:class PrivateDefCtor 
Class:class PrivateDtor 
Class:class Friend { class Friend 
Class:   class Deleted2a { class Deleted2a 
Class:class NotDeleted2a 
Class:class NotDeleted2b 
Class:class NotDeleted2c 
Class:class Deleted3a 
Class:class Deleted3b 
Class:class Deleted3c 
Class:class NotDeleted3a 
Class:class NotDeleted3b 
Class:class NotDeleted3c 
Class:class Trivial 
Class:class NonTrivialDefCtor1 
Class:class NonTrivialDefCtor2 
Class:class NonTrivialDefCtor3 : virtual Trivial 
Class:class NonTrivialDefCtor4 
Class:class NonTrivialDefCtor5 : NonTrivialDefCtor1 
Class:class NonTrivialDefCtor6 
Class:class Trivial2 
Class:class Trivial3 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(146, 2, u'-static_assert(__has_trivial_constructor(Trivial), "Trivial is nontrivial");'), (150, 2, u'-static_assert(!__has_trivial_constructor(NonTrivialDefCtor1), "NonTrivialDefCtor1 is trivial");'), (154, 2, u'-static_assert(!__has_trivial_constructor(NonTrivialDefCtor2), "NonTrivialDefCtor2 is trivial");'), (156, 2, u'-static_assert(!__has_trivial_constructor(NonTrivialDefCtor3), "NonTrivialDefCtor3 is trivial");'), (160, 2, u'-static_assert(!__has_trivial_constructor(NonTrivialDefCtor4), "NonTrivialDefCtor4 is trivial");'), (164, 2, u'-static_assert(!__has_trivial_constructor(NonTrivialDefCtor5), "NonTrivialDefCtor5 is trivial");'), (169, 2, u'-static_assert(!__has_trivial_constructor(NonTrivialDefCtor6), "NonTrivialDefCtor5 is trivial");'), (173, 2, u'-static_assert(__has_trivial_constructor(Trivial2), "Trivial2 is trivial");'), (176, 2, u'-static_assert(__has_trivial_constructor(Trivial3), "Trivial3 is trivial");'), (179, 2, u'-static_assert(__has_trivial_constructor(Trivial4<int>), "Trivial4 is trivial");'), (182, 2, u'-static_assert(__has_trivial_constructor(Trivial5<int>), "Trivial5 is trivial");')]
===========================================
Class:class InaccessibleDtor { class InaccessibleDtor 
Class:   class D1 { class D1 
Class:  class A {   class A 
Class:   class B : protected A {   class B : protected A 
Class:   class C : protected B {   class C : protected B 
Class:  class A {   class A 
Class:   class B : protected A {   class B : protected A 
Class:   class C : protected B {   class C : protected B 
Class:  class ADL 
Class:  class NoADL 
Class:  class X {   class X 
Class:template <class T> class X 
Class:  class Representation 
Class: class A { class A 
Class:template <class T> class B { template <class T> class B 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  template <typename T> class HasChecker {   template <typename T> class HasChecker 
Class:  template <typename T> class HasNotChecker {   template <typename T> class HasNotChecker 
Class:  class Bool;
Class:   class Bool {   class Bool 
Class:   template <class T> class User {   template <class T> class User 
Class:  template <class T> class A {   template <class T> class A 
Class:    template <class T0> friend class B;
Class:   template <class T> class B {   template <class T> class B 
Class:  template <class T, class U=int> class A 
Class:  template <class T> class B {   template <class T> class B 
Class:  template <class T> class A {    template <class T> class A 
Class:   class B {   class B 
Class:   class C {   class C 
Class:      template <class T> class D {   template <class T> class D 
Class:  template <class N> class A {   template <class N> class A 
Class:  template <class T> class A {   template <class T> class A 
Class:    class B; class C;
Class:     class B {     class B 
Class:     class C {     class C 
Class:  template <class T> class A;
Class:  template <class T> class A {   template <class T> class A 
Class:  template <typename T> class Foo {   template <typename T> class Foo 
Class:  template <int N, template <int> class Temp>   template <int N, template <int> class Temp>
Class:  class Role : public Temp<N> {   class Role : public Temp<N> 
Class:   template <int N> class Foo {   template <int N> class Foo 
Class:  template <class T> class B;
Class:  template <class T> class A {   template <class T> class A 
Class:   template <class T> class B {   template <class T> class B 
Class:  template <class T> class B;
Class:  template <class T> class A {   template <class T> class A 
Class:   template <class T> class B {   template <class T> class B 
Class:   template <> class B<float> {   template <> class B<float> 
Class:  template <class T> class A { template <class T> class A 
Class: class B { class B 
Class:  template <class T> class A {   template <class T> class A 
Class:    class Member 
Class:   class B {   class B 
Class:  class C {   class C 
Class:  class C {   class C 
Class:  template <class U> class C {   template <class U> class C 
Class: class X { class X 
Class:  class Foo { class Foo 
Class:  class X0 
Class:  class X0 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 2, u'-  static_assert(is_same<X1<int, int>::type,'), (33, 2, u'-  static_assert(is_same<X1<int, int, float>::type,'), (37, 2, u'-  static_assert(is_same<X1<int, int, float, double>::type,'), (55, 2, u'-  static_assert(is_same<X1<int>::type,'), (59, 2, u'-  static_assert(is_same<X1<int, float>::type,'), (63, 2, u'-  static_assert(is_same<X1<int, float, double>::type,')]
===========================================
Class:  class type_info;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(172, 2, u'-  static_assert(static_cast<Types>(0), "Boom"); // expected-error{{static assertion contains unexpanded parameter pack \'Types\'}}')]
===========================================
Class:    template <class Get, class Set>     template <class Get, class Set>
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 2, u'-static_assert(member_pointer_kind<int (X::*)(int)>::value == 1, "");'), (43, 2, u'-static_assert(member_pointer_kind<int (X::*)(int) &>::value == 2, "");'), (44, 2, u'-static_assert(member_pointer_kind<int (X::*)(int) &&>::value == 3, "");'), (45, 2, u'-static_assert(member_pointer_kind<int (X::*)(int) const>::value == 4, "");'), (46, 2, u'-static_assert(member_pointer_kind<int (X::*)(int) const&>::value == 5, "");'), (47, 2, u'-static_assert(member_pointer_kind<int (X::*)(int) const&&>::value == 6, "");')]
===========================================
Class:  class C {   class C 
Class:class X0 
Class:  class C1 
Class:class X1 
Class:class T 
Class: class X1 { class X1 
Class:  class WebVector {   class WebVector 
Class:    class Bar     class Bar
Class:    class Foo;
Class:  class S<A>::F
Class:  template <class> class A {   template <class> class A 
Class:   template <> class A<double> {   template <> class A<double> 
Class:class A<long>::B 
Class:    template <class T, class U> class Inner;
Class:  class X { class X 
Class: class A { class A 
Class:  class B 
Class:  class C 
Class:  template <class T> class foo {   template <class T> class foo 
Class: class Foo { class Foo 
Class: class Proxy { class Proxy 
Class:class T 
Class:class X 
Class:  class A;
Class:  class Y;
Class:    class     class
Class:  class allocator {   class allocator 
Class:  class B0 { class B0 
Class: class D0 : public B0 { class D0 : public B0 
Class: class B1 { class B1 
Class: class D1 : public B1 { class D1 : public B1 
Class: class D2 : public B0 { class D2 : public B0 
Class:  class B { class B 
Class: class D : public B { class D : public B 
Class:  class exception 
Class:   class type_info {   class type_info 
Class:  class __si_class_type_info : public std::type_info {   class __si_class_type_info : public std::type_info 
Class:class nsISupports { 
Class:  template < class T > struct nsCOMTypeInfo   template < class T > struct nsCOMTypeInfo
Class:class nsIDOMEventListener:public nsISupports { 
Class:class nsIDOMMouseListener:public nsIDOMEventListener { 
Class: class L { class L 
Class:  class CallbackHandle   class CallbackHandle
Class:  class __normal_iterator   class __normal_iterator
Class:  class vector:protected _Vector_base < _Tp,_Alloc >   class vector:protected _Vector_base < _Tp,_Alloc >
Class:  class MantaInterface   {   
Class:  class RTRT   {   
Class:template <class T> class K2PtrVectorBase 
Class:template <class T> class K2Vector 
Class:template <class U > class K2Vector<U*> : public K2PtrVectorBase<U*> 
Class:class ScriptInfoManager { class ScriptInfoManager 
Class: class X { class X 
Class:     class MO { class MO 
Class:  class Foo { 
Class:     class A { class A 
Class:class Pointer32 { class Pointer32 
Class:class Pointer64 { class Pointer64 
Class:class BigEndian 
Class:class LittleEndian 
Class:template <typename _SIZE, typename _ENDIANNESS> class SizeAndEndianness { template <typename _SIZE, typename _ENDIANNESS> class SizeAndEndianness 
Class:template <typename SIZE> class TRange { template <typename SIZE> class TRange 
Class:template <typename SIZE, typename T> class TRangeValue : public TRange<SIZE> { template <typename SIZE, typename T> class TRangeValue : public TRange<SIZE> 
Class:class CSCppSymbolOwner
Class:class CSCppSymbolOwnerData
Class:class E 
Class:  class D {   class D 
Class:   class foo { class foo 
Class:  class SMLoc { class SMLoc 
Class: class foo { class foo 
Class: class bar : public foo { class bar : public foo 
Class: class xpto { class xpto 
Class:  class x { class x 
Class: class C { class C 
Class: class Zone { class Zone 
Class: class X : public virtual Zone { class X : public virtual Zone 
Class:  template <typename T> class A {   template <typename T> class A 
Class:  class C 
Class:  class B : public C {   class B : public C 
Class:  class E : public B 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(232, 2, u'-  static_assert(!__is_literal(NonTrivialDtor), "");'), (240, 2, u'-  static_assert(!__is_literal(VolatileMember), "");')]
===========================================
Class:class C { class C 
Class: class X {  class X 
Class:   class Twine { class Twine 
Class: class X {  class X 
Class:  class Test1 { class Test1 
Class: class Test2 { class Test2 
Class:    class Test3 { class Test3 
Class:   template <typename T> class List { template <typename T> class List 
Class: template <typename T> class Node { template <typename T> class Node 
Class: class X {  class X 
Class: class Y {  class Y 
Class:class O {  class O 
Class:  class XB { class XB 
Class: class Yb : public XB { class Yb : public XB 
Class: class ioapic_redir_t { class ioapic_redir_t 
Class: class X {  class X 
Class:                   class foo { class foo 
Class: class A { class A 
Class:  class initializer_list   class initializer_list
Class:  class initializer_list   class initializer_list
Class:  class initializer_list   class initializer_list
Class: class A { 
Class:   class DAG { class DAG 
Class: class EVT { class EVT 
Class: class VAL { class VAL 
Class:   class locale { class locale 
Class:class ios_base { class ios_base 
Class:   class MyClass { 
Class:  class Test { 
Class: class SomeClass { 
Class:   class B { class B 
Class: class A { class A 
Class:    class A { class A 
Class: class A { class A 
Class:  class A { class A 
Class: class A { class A 
Class:     class A { class A 
Class:          class G { class G 
Class:  class MyClass { 
Class:class base 
Class: template <class T> class foo : public base  { template <class T> class foo : public base  
Class:class bar : public foo<void> 
Class: class TheTemplateTest : public TheTemplate<42> { class TheTemplateTest : public TheTemplate<42> 
Class:  class Class { 
Class:template < template < typename > class T1, template < typename > class > struct Templates2 { 
Class:template < template < typename > class T1,   template < typename > class T2 > struct Templates <T1, T2 > { 
Class:template < template < typename > class, class TestSel,   typename Types > class TypeParameterizedTest { 
Class:  template < typename gtest_TypeParam_ > class A:TypedTestP1 <   template < typename gtest_TypeParam_ > class A:TypedTestP1 <
Class:  template < typename gtest_TypeParam_ > class A:TypedTestP2 <   template < typename gtest_TypeParam_ > class A:TypedTestP2 <
Class:template < class SSS, class = EEE < SSS > >class FFF 
Class:template < class SSS, class GGG = EEE < SSS > >class AAA:FFF <GGG> 
Class:class BBB:virtual CCC { class BBB:virtual CCC 
Class:class ZZZ:AAA < Data >, BBB 
Class:template < typename _Tp > class allocator:__gnu_cxx::new_allocator < _Tp > { template < typename _Tp > class allocator:__gnu_cxx::new_allocator < _Tp > 
Class:      class > struct hash;
Class:class class
Class:  class   class
Class:class class
Class:        class         class
Class:  class   class
Class:  class       C4:         n1::Test {         n1::Test 
Class:  class       C6:         C4,         n1::C7 <         C5 > {         C5 > 
Class:  class       C8:         C6 {         C6 
Class:  class       C9:         C8 {         C8 
Class:template <typename T> class A { template <typename T> class A 
Class: class Cls { class Cls 
Class: class X {  class X 
Class:class obj
Class:   class A { class A 
Class:class B { class B 
Class:class B::C : public A { class B::C : public A 
Class:  template <typename T> class A { class A 
Class:class A 
Class:class B { class B 
Class:  class err 
Class:  class A 
Class:  class B 
Class:  class C 
Class:  class D 
Class:      class A { class A 
Class:               class A { class A 
Class:  template <typename T> class ClassTemplate {   template <typename T> class ClassTemplate 
Class:       class C {   class C 
Class:  class Rdar9445102 {   class Rdar9445102 
Class:  template <typename T> class klass { template <typename T> class klass 
Class:      class StringRef { class StringRef 
Class:  class initializer_list   class initializer_list
Class:  template <class T, class U> void a(T x, U y, decltype(x.*y) z) {}   template <class T, class U> void a(T x, U y, decltype(x.*y) z) 
Class:  class foo { class foo 
Class:    class C {     class C 
Class:   template <class T>   class D {   class D 
Class:  class C;
Class:  class B 
Class:  template <class zaz, class zed>   template <class zaz, class zed>
Class:  template <template <class> class T> class A 
Class:  template <class U> class B 
Class:   template <template<class> class T> void foo(const A<T> &a) {}   template <template<class> class T> void foo(const A<T> &a) 
Class:  template <template <class> class T> void foo(decltype(T<float>::object) &object) {}   template <template <class> class T> void foo(decltype(T<float>::object) &object) 
Class:  template <template <class> class T> struct A {   template <template <class> class T> struct A 
Class:     class t { class t 
Class:  class foo {   class foo 
Class:  class MyClass;
Class:class CoinModel { class CoinModel 
Class:    class X { class X 
Class:      class teste { class teste 
Class:  class nsOggCodecState { class nsOggCodecState 
Class:class nsVorbisState : public nsOggCodecState { class nsVorbisState : public nsOggCodecState 
Class: class ClassInTopLevelNamespace { class ClassInTopLevelNamespace 
Class:  class ClassInAnonymousNamespace {   class ClassInAnonymousNamespace 
Class:class ClassTemplate { class ClassTemplate 
Class: class Base { class Base 
Class: class Derived : public Base { class Derived : public Base 
Class: class Constructor { class Constructor 
Class: class Destructor { class Destructor 
Class: class ContainerForAnonymousRecords { class ContainerForAnonymousRecords 
Class:  class LocalClass {   class LocalClass 
Class:  class MiddleClass   class MiddleClass
Class:    class InnerClass     class InnerClass
Class: template <typename T, template <typename> class Param = NS::ClassTemplate> class ClassWithTemplateTemplateParam { 
Class: class A  : public B, public B1 { class A  : public B, public B1 
Class:  class A { class A 
Class:  class X {   class X 
Class:class __class_type_info : public std::type_info 
Class: class __si_class_type_info : public __class_type_info { class __si_class_type_info : public __class_type_info 
Class: class __vmi_class_type_info : public __class_type_info { class __vmi_class_type_info : public __class_type_info 
Class: template <unsigned N> class T { template <unsigned N> class T 
Class: class C { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 2, u'-static_assert(true, "");'), (6, 2, u'-  static_assert(true, "");')]
===========================================
Class:class A 
Class:class B : public A 
Class:  class C {   class C 
Class:  class basic_fstreamXX  {   class basic_fstreamXX  
Class:  class B {   class B 
Class:template <int i> class A { template <int i> class A 
Class:  class B* g;
Class:class B { class B 
Class:  class X { class X 
Class: class C { class C 
Class:   class A { class A 
Class:class B : public A { class B : public A 
Class:template < class SSS, class = EEE < SSS > >class FFF 
Class:template < class SSS, class GGG = EEE < SSS > >class AAA:FFF <GGG> 
Class:class BBB:virtual CCC { class BBB:virtual CCC 
Class:class ZZZ:AAA < Data >, BBB 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:   class C : public A  {   class C : public A  
Class:   class D : public B,             public C {             public C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 2, u'-  Foo() { static_assert(b, "Foo::Foo used"); }'), (8, 2, u'-  ~Foo() { static_assert(b, "Foo::~Foo used"); }')]
===========================================
Class: class enum_holder { 
Class:class C;
Class:  class Base { class Base 
Class: class Foo : public Base { class Foo : public Base 
Class:    class Foo { class Foo 
Class:  class foo { class foo 
Class:class B : A<int> { class B : A<int> 
Class:  template <class T> class B 
Class:  class Foo {   class Foo 
Class:  class DEFAULT A 
Class:  class DEFAULT foo {   class DEFAULT foo 
Class:  class C {   class C 
Class:    class __attribute__((visibility())) D {     class __attribute__((visibility())) D 
Class:  class HIDDEN A 
Class:  class B : public A 
Class:  class DEFAULT B {   class DEFAULT B 
Class:  class A1 
Class:  class A2 
Class:      class bar {       class bar 
Class:    class bar;
Class:    class zed {     class zed 
Class:  class DEFAULT A;
Class:  class DEFAULT Version 
Class:  class DEFAULT A 
Class:  class C {   class C 
Class:class C0 class C0
Class:class C1  :  virtual public C0 { 
Class:class C2  :  public C0  ,  virtual public C1 { 
Class:class C3  :  virtual public C0  ,  virtual public C1  ,  public C2 { 
Class:class C4  :  public C2  ,  virtual public C3  ,  public C0 { 
Class:class C5  :  public C0  ,  virtual public C4  ,  public C2  ,  public C1  ,  virtual public C3 { 
Class:class C6  :  virtual public C3  ,  public C0  ,  public C5  ,  public C4  ,  public C1 { 
Class:class C7  :  virtual public C5  ,  virtual public C6  ,  virtual public C3  ,  public C4  ,  virtual public C2 { 
Class:class C8  :  public C7  ,  public C5  ,  public C3  ,  virtual public C4  ,  public C1  ,  public C2 { 
Class:                                                                                                                       class C9  :  virtual public C6  ,  public C2  ,  public C4  ,  virtual public C8 { 
Class:class E : virtual D { class E : virtual D 
Class:class C : virtual B 
Class:class D : virtual C 
Class:class E : virtual C 
Class:                               class F : virtual D, virtual E { class F : virtual D, virtual E 
Class:class D : virtual B, virtual C { class D : virtual B, virtual C 
Class:  class B : virtual public A {   class B : virtual public A 
Class:                                                                                           template <typename T> class G { class G 
Class:      template <typename T> class H { class H 
Class:  class A1 
Class:  class A2 
Class:  class V1 : public A1, public A2 
Class:  class B1 
Class:  class B2 
Class:  class V2 : public B1, public B2, public virtual V1 
Class:  class V3 
Class:  class C1 : public virtual V1 
Class:  class C2 : public virtual V3, virtual V2 
Class:  class X1 
Class:  class C3 : public X1 
Class:  class D : public C1, public C2, public C3 
Class:  class A1 
Class:  class A2 
Class:  class V1 : public A1, public virtual A2 
Class:  class B1 
Class:  class B2 
Class:  class V2 : public B1, public B2, public virtual V1 
Class:  class V3 
Class:  class C1 : public virtual V1 
Class:  class C2 : public virtual V3, virtual V2 
Class:  class X1 
Class:  class C3 : public X1 
Class:  class D : public C1, public C2, public C3 
Class: class B : public A { class B : public A 
Class:class T 
Class:class T1 
Class: class C : public T1, public B, public T { class C : public T1, public B, public T 
Class: class V1 : public virtual A { class V1 : public virtual A 
Class: class V2 : public virtual V1 { class V2 : public virtual V1 
Class:          class _Traits = char_traits<_CharT>,           class _Traits = char_traits<_CharT>,
Class: class _LIBCPP_EXCEPTION_ABI exception { 
Class: class _LIBCPP_EXCEPTION_ABI runtime_error     : public exception { 
Class:  class C { class C 
Class:  class A 
Class:  class A {   class A 
Class:  class B : public A 
Class:class C : A 
Class: class C3 { class C3 
Class:  class A { class A 
Class: class B : public A { class B : public A 
Class:  class A 
Class: template <class A> class F1 { class F1 
Class:class AD 
Class:class BD: public AD 
Class:  class Test { class Test 
Class:class Base { class Base 
Class: class Derived final : public Base { class Derived final : public Base 
Class: class Z { class Z 
Class:                         class P { class P 
Class: class Q : public P { class Q : public P 
Class:class MyCls { class MyCls 
Class: class OtherClass : public MyCls { class OtherClass : public MyCls 
Class:  class string { class string 
Class:  class C {   class C 
Class: class Foo { 
Class:class X { class X 
Class:  class Cls { class Cls 
Class:  class C {   class C 
Class:class vector<T*> 
Class:  class A { class A 
Class: class B { class B 
Class: class C : public A, private B { class C : public A, private B 
Class:class D : virtual public C, virtual private A 
Class:  class type_info 
Class:class ClassTmpl 
Class:  template < class _T1, class _T2 > struct pair 
Class:  class IdentifierInfo;
Class:  class AttributeList {   class AttributeList 
Class:class StringRef { class StringRef 
Class:class IdentifierInfo { class IdentifierInfo 
Class:template < typename T, typename R = T > class StringSwitch { template < typename T, typename R = T > class StringSwitch 
Class: class ClsA { class ClsA 
Class:  class ClsB : public ClsA {   class ClsB : public ClsA 
Class:  class ClsC : public foo::ClsB 
Class:  class ClsD : public foo::ClsB {   class ClsD : public foo::ClsB 
Class:class RDar9371763_Foo { class RDar9371763_Foo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(13, 2, u'-  static_assert((unsigned char)\'\xe9\' == 0xE9, ""); // expected-warning {{illegal character encoding in character literal}}'), (14, 2, u'-  static_assert(\'\xe9\xe9\' == 0xE9E9, ""); // expected-warning {{illegal character encoding in character literal}} expected-warning {{multi-character character constant}}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-int static_assert; /* expected-error {{expected unqualified-id}} */')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(21, 2, u'-#define static_assert(b, s) int CONCAT(check, __LINE__)[(b) ? 1 : 0];'), (22, 2, u'-static_assert(1 > 0, "hello"); // ok'), (35, 2, u"-int static_assert; // expected-warning {{'static_assert' is a keyword in C++11}}")]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(17, 2, u'-#if __has_extension(c_static_assert)'), (18, 2, u'-int has_c_static_assert();'), (20, 2, u'-int no_c_static_assert();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 2, u'-#if __has_extension(c_static_assert)'), (5, 2, u'-int c_static_assert();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(13, 2, u'-#if __has_feature(c_static_assert)'), (14, 2, u'-int has_static_assert();'), (16, 2, u'-int no_static_assert();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 2, u'-#if __has_feature(cxx_static_assert)'), (84, 2, u'-int has_static_assert();'), (86, 2, u'-int no_static_assert();')]
===========================================
Class:  class foo 
Class:    class foo;
Class:  class basic_string;
Class:    template <class X, class Y> TClass<X> problematic(X * ptr, const TClass<Y> &src);
Class:     template <class T>     class TBaseClass     {     
Class:    template <class X, class T>     template <class X, class T>
Class:class s 
Class:       class F { class F 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(12, 2, u'-    static_assert(N == 2, "N is not 2!"); // expected-error {{static_assert failed "N is not 2!"}}')]
===========================================
Class: class quux { class quux 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 2, u'-static_assert(D(4).k == 9, "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(14, 2, u'-static_assert(!noexcept(f<false>()), "");'), (15, 2, u'-static_assert(noexcept(f<true>()), "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 2, u'-static_assert(true_value, "true_value is true");'), (32, 2, u'-static_assert(!false_value, "false_value is false");')]
===========================================
Class:  class C;
Class:    class C;
Class:  class Foo { 
Class:      class BarTypes 
Class:      class BarImpl 
Class:  template <class T> class A { class A 
Class: template <class T> class B { class B 
Class:class Outmost { class Outmost 
Class:    class Inner {     class Inner 
Class:class Callback { class Callback 
Class: class T { class T 
Class: class class_attr { class class_attr 
Class:class COM_CLASS_TEMPLATE  
Class:class COM_CLASS_TEMPLATE_REF  
Class:  class CtorCall { class CtorCall 
Class: template <class A> class C1 { class C1 
Class:class AAAA 
Class:class IF_EXISTS { class IF_EXISTS 
Class:  class IF_EXISTS_CLASS_TEST { class IF_EXISTS_CLASS_TEST 
Class: class inline_definition_pure_spec { class inline_definition_pure_spec 
Class:class A { class A 
Class: class B : public A{ class B : public A
Class:   class tuple<> { 
Class:   class vc__v { class vc__v 
Class: class c_v { class c_v 
Class:  class VectorClassNonPod { 
Class:  class VectorClassMultipleMembers { 
Class:  class c { class c 
Class:  template <class T> class A 
Class:template <class T> class D 
Class:class F 
Class:class C { class C 
Class:   class D { class D 
Class:   class E { class E 
Class: class F { class F 
Class:  class Foo 
Class:   class Ctor {    class Ctor 
Class: template <typename T> class someclass { class someclass 
Class: class asm_class_test { class asm_class_test 
Class: class Class2 { class Class2 
Class:   class C { class C 
Class:  class C { class C 
Class: class A { class A 
Class: class B { class B 
Class:  class Test { class Test 
Class:  class type_info;
Class: class Foo::Bar {  class Foo::Bar 
Class:class A 
Class:  class C {   class C 
Class:  class C;
Class:class [[]] class_attr 
Class:class foo { class foo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 2, u'-[[]] static_assert(true, ""); //expected-error {{an attribute list cannot appear here}}')]
===========================================
Class: class C { class C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(24, 2, u'-static_assert(true, "foo"_bar); // expected-error {{user-defined suffix cannot be used here}}')]
===========================================
Class: class outer { class outer 
Class:  class inner1 
Class:  class inner2 
Class:  class inner3 
Class:  class inner4 
Class:  class inner5 
Class:  class inner6 
Class:  class inner7 
Class:  class inner8 
Class:  class inner9 
Class:  class inner10 
Class:  class inner11 
Class:  class inner12 
Class:  class inner13 
Class:  class inner14 
Class:  class inner15 
Class:  class inner16 
Class:  class inner17 
Class:  class inner18 
Class:  class inner19 
Class:  class inner20 
Class:  class inner21 
Class:  class inner22 
Class:  class inner23 
Class:  class inner24 
Class:  class inner25 
Class:  class inner26 
Class:  class inner27 
Class:  class inner28 
Class:  class inner29 
Class:  class inner30 
Class:  class inner31 
Class:  class inner32 
Class:  class inner33 
Class:  class inner34 
Class:  class inner35 
Class:  class inner36 
Class:  class inner37 
Class:  class inner38 
Class:  class inner39 
Class:  class inner40 
Class:  class inner41 
Class:  class inner42 
Class:  class inner43 
Class:  class inner44 
Class:  class inner45 
Class:  class inner46 
Class:  class inner47 
Class:  class inner48 
Class:  class inner49 
Class:  class inner50 
Class:  class inner51 
Class:  class inner52 
Class:  class inner53 
Class:  class inner54 
Class:  class inner55 
Class:  class inner56 
Class:  class inner57 
Class:  class inner58 
Class:  class inner59 
Class:  class inner60 
Class:  class inner61 
Class:  class inner62 
Class:  class inner63 
Class:  class inner64 
Class:  class inner65 
Class:  class inner66 
Class:  class inner67 
Class:  class inner68 
Class:  class inner69 
Class:  class inner70 
Class:  class inner71 
Class:  class inner72 
Class:  class inner73 
Class:  class inner74 
Class:  class inner75 
Class:  class inner76 
Class:  class inner77 
Class:  class inner78 
Class:  class inner79 
Class:  class inner80 
Class:  class inner81 
Class:  class inner82 
Class:  class inner83 
Class:  class inner84 
Class:  class inner85 
Class:  class inner86 
Class:  class inner87 
Class:  class inner88 
Class:  class inner89 
Class:  class inner90 
Class:  class inner91 
Class:  class inner92 
Class:  class inner93 
Class:  class inner94 
Class:  class inner95 
Class:  class inner96 
Class:  class inner97 
Class:  class inner98 
Class:  class inner99 
Class:  class inner100 
Class:  class inner101 
Class:  class inner102 
Class:  class inner103 
Class:  class inner104 
Class:  class inner105 
Class:  class inner106 
Class:  class inner107 
Class:  class inner108 
Class:  class inner109 
Class:  class inner110 
Class:  class inner111 
Class:  class inner112 
Class:  class inner113 
Class:  class inner114 
Class:  class inner115 
Class:  class inner116 
Class:  class inner117 
Class:  class inner118 
Class:  class inner119 
Class:  class inner120 
Class:  class inner121 
Class:  class inner122 
Class:  class inner123 
Class:  class inner124 
Class:  class inner125 
Class:  class inner126 
Class:  class inner127 
Class:  class inner128 
Class:  class inner129 
Class:  class inner130 
Class:  class inner131 
Class:  class inner132 
Class:  class inner133 
Class:  class inner134 
Class:  class inner135 
Class:  class inner136 
Class:  class inner137 
Class:  class inner138 
Class:  class inner139 
Class:  class inner140 
Class:  class inner141 
Class:  class inner142 
Class:  class inner143 
Class:  class inner144 
Class:  class inner145 
Class:  class inner146 
Class:  class inner147 
Class:  class inner148 
Class:  class inner149 
Class:  class inner150 
Class:  class inner151 
Class:  class inner152 
Class:  class inner153 
Class:  class inner154 
Class:  class inner155 
Class:  class inner156 
Class:  class inner157 
Class:  class inner158 
Class:  class inner159 
Class:  class inner160 
Class:  class inner161 
Class:  class inner162 
Class:  class inner163 
Class:  class inner164 
Class:  class inner165 
Class:  class inner166 
Class:  class inner167 
Class:  class inner168 
Class:  class inner169 
Class:  class inner170 
Class:  class inner171 
Class:  class inner172 
Class:  class inner173 
Class:  class inner174 
Class:  class inner175 
Class:  class inner176 
Class:  class inner177 
Class:  class inner178 
Class:  class inner179 
Class:  class inner180 
Class:  class inner181 
Class:  class inner182 
Class:  class inner183 
Class:  class inner184 
Class:  class inner185 
Class:  class inner186 
Class:  class inner187 
Class:  class inner188 
Class:  class inner189 
Class:  class inner190 
Class:  class inner191 
Class:  class inner192 
Class:  class inner193 
Class:  class inner194 
Class:  class inner195 
Class:  class inner196 
Class:  class inner197 
Class:  class inner198 
Class:  class inner199 
Class:  class inner200 
Class:  class inner201 
Class:  class inner202 
Class:  class inner203 
Class:  class inner204 
Class:  class inner205 
Class:  class inner206 
Class:  class inner207 
Class:  class inner208 
Class:  class inner209 
Class:  class inner210 
Class:  class inner211 
Class:  class inner212 
Class:  class inner213 
Class:  class inner214 
Class:  class inner215 
Class:  class inner216 
Class:  class inner217 
Class:  class inner218 
Class:  class inner219 
Class:  class inner220 
Class:  class inner221 
Class:  class inner222 
Class:  class inner223 
Class:  class inner224 
Class:  class inner225 
Class:  class inner226 
Class:  class inner227 
Class:  class inner228 
Class:  class inner229 
Class:  class inner230 
Class:  class inner231 
Class:  class inner232 
Class:  class inner233 
Class:  class inner234 
Class:  class inner235 
Class:  class inner236 
Class:  class inner237 
Class:  class inner238 
Class:  class inner239 
Class:  class inner240 
Class:  class inner241 
Class:  class inner242 
Class:  class inner243 
Class:  class inner244 
Class:  class inner245 
Class:  class inner246 
Class:  class inner247 
Class:  class inner248 
Class:  class inner249 
Class:  class inner250 
Class:  class inner251 
Class:  class inner252 
Class:  class inner253 
Class:  class inner254 
Class:  class inner255 
Class:  class inner256 
Class:      class foo{       class foo
Class:  class A { class A 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(72, 2, u'-#define static_assert'), (157, 2, u'-static_assert')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(14, 2, u'-_Static_assert(__alignof(align_big) == __alignof(int), "k\'s alignment is wrong");'), (15, 2, u'-_Static_assert(__alignof(align_small) == 1, "j\'s alignment is wrong");'), (16, 2, u'-_Static_assert(__alignof(align_multiple) == 8, "l\'s alignment is wrong");'), (17, 2, u'-_Static_assert(__alignof(struct align_member) == 8, "quuux\'s alignment is wrong");'), (18, 2, u'-_Static_assert(sizeof(struct align_member) == 8, "quuux\'s size is wrong");'), (19, 2, u'-_Static_assert(__alignof(align_typedef) == 8, "typedef\'s alignment is wrong");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(12, 2, u'-_Static_assert(__GCC_ATOMIC_BOOL_LOCK_FREE == 2, "");'), (13, 2, u'-_Static_assert(__GCC_ATOMIC_CHAR_LOCK_FREE == 2, "");'), (14, 2, u'-_Static_assert(__GCC_ATOMIC_CHAR16_T_LOCK_FREE == 2, "");'), (15, 2, u'-_Static_assert(__GCC_ATOMIC_CHAR32_T_LOCK_FREE == 2, "");'), (16, 2, u'-_Static_assert(__GCC_ATOMIC_WCHAR_T_LOCK_FREE == 2, "");'), (17, 2, u'-_Static_assert(__GCC_ATOMIC_SHORT_LOCK_FREE == 2, "");'), (18, 2, u'-_Static_assert(__GCC_ATOMIC_INT_LOCK_FREE == 2, "");'), (19, 2, u'-_Static_assert(__GCC_ATOMIC_LONG_LOCK_FREE == 2, "");'), (20, 2, u'-_Static_assert(__GCC_ATOMIC_LLONG_LOCK_FREE == 1, "");'), (21, 2, u'-_Static_assert(__GCC_ATOMIC_POINTER_LOCK_FREE == 2, "");'), (23, 2, u'-_Static_assert(__c11_atomic_is_lock_free(1), "");'), (24, 2, u'-_Static_assert(__c11_atomic_is_lock_free(2), "");'), (25, 2, u'-_Static_assert(__c11_atomic_is_lock_free(3), ""); // expected-error {{not an integral constant expression}}'), (26, 2, u'-_Static_assert(__c11_atomic_is_lock_free(4), "");'), (27, 2, u'-_Static_assert(__c11_atomic_is_lock_free(8), "");'), (28, 2, u'-_Static_assert(__c11_atomic_is_lock_free(16), ""); // expected-error {{not an integral constant expression}}'), (29, 2, u'-_Static_assert(__c11_atomic_is_lock_free(17), ""); // expected-error {{not an integral constant expression}}'), (31, 2, u'-_Static_assert(__atomic_is_lock_free(1, 0), "");'), (32, 2, u'-_Static_assert(__atomic_is_lock_free(2, 0), "");'), (33, 2, u'-_Static_assert(__atomic_is_lock_free(3, 0), ""); // expected-error {{not an integral constant expression}}'), (34, 2, u'-_Static_assert(__atomic_is_lock_free(4, 0), "");'), (35, 2, u'-_Static_assert(__atomic_is_lock_free(8, 0), "");'), (36, 2, u'-_Static_assert(__atomic_is_lock_free(16, 0), ""); // expected-error {{not an integral constant expression}}'), (37, 2, u'-_Static_assert(__atomic_is_lock_free(17, 0), ""); // expected-error {{not an integral constant expression}}'), (45, 2, u'-_Static_assert(__atomic_is_lock_free(1, &i8), "");'), (46, 2, u'-_Static_assert(__atomic_is_lock_free(1, &i64), "");'), (47, 2, u'-_Static_assert(__atomic_is_lock_free(2, &i8), ""); // expected-error {{not an integral constant expression}}'), (48, 2, u'-_Static_assert(__atomic_is_lock_free(2, &i16), "");'), (49, 2, u'-_Static_assert(__atomic_is_lock_free(2, &i64), "");'), (50, 2, u'-_Static_assert(__atomic_is_lock_free(4, &i16), ""); // expected-error {{not an integral constant expression}}'), (51, 2, u'-_Static_assert(__atomic_is_lock_free(4, &i32), "");'), (52, 2, u'-_Static_assert(__atomic_is_lock_free(4, &i64), "");'), (53, 2, u'-_Static_assert(__atomic_is_lock_free(8, &i32), ""); // expected-error {{not an integral constant expression}}'), (54, 2, u'-_Static_assert(__atomic_is_lock_free(8, &i64), "");'), (56, 2, u'-_Static_assert(__atomic_always_lock_free(1, 0), "");'), (57, 2, u'-_Static_assert(__atomic_always_lock_free(2, 0), "");'), (58, 2, u'-_Static_assert(!__atomic_always_lock_free(3, 0), "");'), (59, 2, u'-_Static_assert(__atomic_always_lock_free(4, 0), "");'), (60, 2, u'-_Static_assert(__atomic_always_lock_free(8, 0), "");'), (61, 2, u'-_Static_assert(!__atomic_always_lock_free(16, 0), "");'), (62, 2, u'-_Static_assert(!__atomic_always_lock_free(17, 0), "");'), (64, 2, u'-_Static_assert(__atomic_always_lock_free(1, incomplete), "");'), (65, 2, u'-_Static_assert(!__atomic_always_lock_free(2, incomplete), "");'), (66, 2, u'-_Static_assert(!__atomic_always_lock_free(4, incomplete), "");'), (68, 2, u'-_Static_assert(__atomic_always_lock_free(1, &i8), "");'), (69, 2, u'-_Static_assert(__atomic_always_lock_free(1, &i64), "");'), (70, 2, u'-_Static_assert(!__atomic_always_lock_free(2, &i8), "");'), (71, 2, u'-_Static_assert(__atomic_always_lock_free(2, &i16), "");'), (72, 2, u'-_Static_assert(__atomic_always_lock_free(2, &i64), "");'), (73, 2, u'-_Static_assert(!__atomic_always_lock_free(4, &i16), "");'), (74, 2, u'-_Static_assert(__atomic_always_lock_free(4, &i32), "");'), (75, 2, u'-_Static_assert(__atomic_always_lock_free(4, &i64), "");'), (76, 2, u'-_Static_assert(!__atomic_always_lock_free(8, &i32), "");'), (77, 2, u'-_Static_assert(__atomic_always_lock_free(8, &i64), "");')]
===========================================
Class:    Class isa;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 2, u'-#define ASSERT(...) { int arr[(__VA_ARGS__) ? 1 : -1]; }'), (118, 2, u'-#define T(...) ASSERT(__builtin_constant_p(__VA_ARGS__))'), (119, 2, u'-#define F(...) ASSERT(!__builtin_constant_p(__VA_ARGS__))'), (150, 2, u'-  ASSERT(OPT("abc"));'), (151, 2, u'-  ASSERT(!OPT("abcd"));'), (154, 2, u'-  ASSERT(!OPT(test17_c));        // expected-warning {{folded}}'), (155, 2, u'-  ASSERT(!OPT(&test17_c[0]));    // expected-warning {{folded}}'), (156, 2, u'-  ASSERT(!OPT((char*)test17_c)); // expected-warning {{folded}}'), (157, 2, u'-  ASSERT(!OPT(test17_d));        // expected-warning {{folded}}'), (158, 2, u'-  ASSERT(!OPT(&test17_d[0]));    // expected-warning {{folded}}'), (159, 2, u'-  ASSERT(!OPT((char*)test17_d)); // expected-warning {{folded}}')]
===========================================
Class: class A : public B { class A : public B 
Class: class D { class D 
Class: class C : public virtual A,           public D, public B {           public D, public B 
Class:	Class *object;
Class:	Class *obj;
Class:	Class *object;
Class:	Class obj;
Class: class Stream { class Stream 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 2, u'-_Static_assert("foo", "string is nonzero"); // expected-error {{static_assert expression is not an integral constant expression}}'), (5, 2, u'-_Static_assert(1, "1 is nonzero");'), (6, 2, u'-_Static_assert(0, "0 is nonzero"); // expected-error {{static_assert failed "0 is nonzero"}}'), (9, 2, u'-  _Static_assert(1, "1 is nonzero");'), (10, 2, u'-  _Static_assert(0, "0 is nonzero"); // expected-error {{static_assert failed "0 is nonzero"}}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(118, 2, u'-void __myassert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));'), (120, 2, u'-#define myassert(e) \\'), (121, 2, u'-    (__builtin_expect(!(e), 0) ? __myassert_rtn(__func__, __FILE__, __LINE__, #e) : (void)0)'), (123, 2, u'-void test_assert() {'), (124, 2, u'-  myassert(0 && "unreachable");')]
===========================================
Class:class A { class A 
Class: class B : public A { class B : public A 
Class: class C : public B { class C : public B 
Class:class C : private A<T>, public B<U> { class C : private A<T>, public B<U> 
Class: class D { class D 
Class:class A { class A 
Class: class B : public A { class B : public A 
Class:  class AAA { class AAA 
Class:   template <class T> class BB { class BB 
Class:class A { class A 
Class:  class Nested {   class Nested 
Class:  class X {   class X 
Class:    class iterator 
Class:  class hash_map {   class hash_map 
Class:    class const_iterator 
Class:    class iterator 
Class:class C1 
Class:class C2 
Class:class FooTable { class FooTable 
Class:  class C { class C 
Class:class baz { class baz 
Class:  class A <T> ::iterator foo;  
Class:  class bar {   class bar 
Class: class Base { class Base 
Class: class Base { class Base 
Class:  class Derived : public Base { class Derived : public Base 
Class:  template <class _Tp, class _Up, bool = false> struct __allocator_traits_rebind { 
Class:  template <class _Tp, class _Up> struct __allocator_traits_rebind { 
Class: class D : C { class D : C 
Class: class E : D { class E : D 
Class: class F { class F 
Class:   class D {   class D 
Class: class Abstract { class Abstract 
Class:  class foo { class foo 
Class: class bar : public foo { class bar : public foo 
Class:  class A { class A 
Class: class B : public A { class B : public A 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 2, u'-#define static_assert(__b, __m) \\'), (15, 2, u'-static_assert(__is_abstract(C), "C has a pure virtual function");'), (20, 2, u'-static_assert(__is_abstract(D), "D inherits from an abstract class");'), (26, 2, u'-static_assert(!__is_abstract(E), "E inherits from an abstract class but implements f");')]
===========================================
Class:class A 
Class:class B : private A 
Class:class A 
Class:class B : A 
Class:class A 
Class:class B : public A 
Class:class A 
Class:class B : private virtual A 
Class:class C : public virtual A 
Class:class D : public B, public C 
Class:  class A 
Class:   class B : private A {   class B : private A 
Class:  class C;
Class:  class A 
Class:   class B : private A {    class B : private A 
Class:   class C : public B {   class C : public B 
Class:  class A 
Class:  class B : public A 
Class:  class C : private B {   class C : private B 
Class:  class M { class M 
Class: class P { class P 
Class: class N : M,P { class N : M,P 
Class:class A 
Class:class B : private A 
Class:  class C { class C 
Class:    class C; 
Class:    class C 
Class: class T { class T 
Class:  class A {   class A 
Class:    class X; 
Class:    class X 
Class:  class Foo {   class Foo 
Class: class c { class c 
Class: class NonAggr3 {  class NonAggr3 
Class: class Agg { class Agg 
Class: class AggAgg { class AggAgg 
Class:  class C0 {   class C0 
Class:  class C1 {   class C1 
Class:  class C2 {   class C2 
Class:  class C5 {   class C5 
Class:  class C6 {   class C6 
Class:    class c 
Class:  class C0 {   class C0 
Class:  class C1 {   class C1 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 2, u'-  static_assert(alignof(r) == 1, "bad alignment");'), (8, 2, u'-  static_assert(sizeof(r) == 1, "bad size");')]
===========================================
Class:  class y 
Class:  class A {   class A 
Class:  class Foo {   class Foo 
Class:   template <char *sz> class Qux { template <char *sz> class Qux 
Class:  class baz {   class baz 
Class:class Point 
Class:class Line_Segment
Class:class Node 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(21, 2, u'-static_assert(alignof(align_big) == alignof(int), "k\'s alignment is wrong");'), (22, 2, u'-static_assert(alignof(align_small) == 1, "j\'s alignment is wrong");'), (23, 2, u'-static_assert(alignof(align_multiple) == 8, "l\'s alignment is wrong");'), (24, 2, u'-static_assert(alignof(align_member) == 8, "quuux\'s alignment is wrong");'), (25, 2, u'-static_assert(sizeof(align_member) == 8, "quuux\'s size is wrong");'), (26, 2, u'-static_assert(alignof(align_typedef) == 8, "typedef\'s alignment is wrong");'), (27, 2, u'-static_assert(alignof(align_class_template<8>) == 8, "template\'s alignment is wrong");'), (28, 2, u'-static_assert(alignof(align_class_template<16>) == 16, "template\'s alignment is wrong");'), (32, 2, u'-static_assert(alignof(align_alias_template<int>) == 8, "alias template\'s alignment is wrong");')]
===========================================
Class: class A { class A 
Class:  class xpto { class xpto 
Class:  class c { class c 
Class:  class Power {   class Power 
Class:  class C { class C 
Class:  class S { class S 
Class:  class A {   class A 
Class:class A 
Class:class B : A 
Class:class C : virtual A 
Class:class F : virtual E 
Class:class C 
Class:class D 
Class:class B 
Class: class C { class C 
Class:   class NestedC {   class NestedC 
Class: class C2 { class C2 
Class:    class LC1 {     class LC1 
Class:    class LC2 {     class LC2 
Class:  class EnclosingClass {   class EnclosingClass 
Class:  class C {   class C 
Class:class Base 
Class:class Derived1 : public Base 
Class:class Derived2 : public Base 
Class:  class X {   class X 
Class:class complex { class complex 
Class: class complex_wrap : public complex { class complex_wrap : public complex 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(34, 2, u'-static_assert(recurse(5), "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(65, 2, u'-static_assert(q8.check(')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(39, 2, u'-static_assert(test_printing(12, 39.762, 3 + 4i, 12.9 + 3.6i, &u2.arr[4], u2.another.arr[2], (vector_int){5, 1, 2, 3}, u1) == 0, ""); // \\'), (53, 2, u'-static_assert(passLargeArray(v) == 0, ""); // expected-error {{constant expression}} expected-note {{in call to \'passLargeArray({{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...}})\'}}'), (63, 2, u'-static_assert(badness(myUnion), ""); // expected-error {{constant expression}} \\'), (74, 2, u'-static_assert(MemPtr(&MemPtrTest::n, &MemPtrTest::f, mpt.*&MemPtrTest::n), ""); // expected-error {{constant expression}} \\'), (96, 2, u'-  static_assert(mulBy3((LabelDiffTy)&&a-(LabelDiffTy)&&b) == 3, ""); // expected-error {{constant expression}} expected-note {{call to \'mulBy3(&&a - &&b)\'}}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 2, u'-static_assert(run(bb3, Tape(), 0) == 14, "");'), (55, 2, u'-static_assert(run(bb4, Tape(), 0) == 108, "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(19, 2, u'-static_assert(b2.a.a == 1, "");'), (20, 2, u'-static_assert(b2.a.b == 2, "");'), (30, 2, u'-static_assert(D().c == 0, "");'), (31, 2, u'-static_assert(D().d == 0, "");')]
===========================================
Class: class A { class A 
Class: class B : public A { class B : public A 
Class:  class C : public virtual B { class C : public virtual B 
Class: class D : public C { class D : public C 
Class: class E : public D, public B { class E : public D, public B 
Class: class F : public B { class F : public B 
Class: class G : A { class G : A 
Class: class H : A { class H : A 
Class:class  X 
Class:class Y 
Class: class U { class U 
Class:class TwoInOne 
Class:class InitializeUsingSelfTest { class InitializeUsingSelfTest 
Class:class InitializeUsingSelfExceptions { class InitializeUsingSelfExceptions 
Class: class CopyConstructorTest { class CopyConstructorTest 
Class:  class A : public std::exception 
Class:  class B : public A {   class B : public A 
Class:  class Class   class Class
Class: class Foo { class Foo 
Class:class a { class a 
Class: class X { class X 
Class: class Y { class Y 
Class: class Z { class Z 
Class:class A 
Class: class B : public A { class B : public A 
Class:  class XB { class XB 
Class: class Yb : public XB { class Yb : public XB 
Class:class AutoPtrRef 
Class: class AutoPtr { class AutoPtr 
Class:  class Y {   class Y 
Class:    class YRef 
Class:class Z 
Class: class Y { class Y 
Class: class X { class X 
Class:  class FromShort { class FromShort 
Class: class FromShortExplicitly {  class FromShortExplicitly 
Class: class X { class X 
Class:class Y : public X 
Class:  class Bar;
Class:class callback class callback
Class:  class InfallibleTArray {   class InfallibleTArray 
Class:  class CompVariant {   class CompVariant 
Class:  class Variant {   class Variant 
Class: class C { class C 
Class:  class Foo;
Class:  class Foo {   class Foo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 2, u'-static_assert(__is_trivial(foo), "foo should be trivial");'), (33, 2, u'-static_assert(!__has_trivial_destructor(bar), "bar\'s destructor isn\'t trivial");'), (34, 2, u'-static_assert(!__has_trivial_constructor(bar),'), (36, 2, u'-static_assert(!__has_trivial_copy(bar), "bar has no trivial copy");'), (37, 2, u'-static_assert(!__has_trivial_assign(bar), "bar has no trivial assign");')]
===========================================
Class: class inaccessible_default { class inaccessible_default 
Class: class friend_default { class friend_default 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 2, u'-    static_assert(sizeof(overloaded({1, 2})) == sizeof(one), "bad overload");'), (68, 2, u'-    static_assert(sizeof(overloaded({1, "two"})) == sizeof(two),'), (71, 2, u'-    static_assert(sizeof(overloaded({1})) == sizeof(one), "bad overload");')]
===========================================
Class:  class initializer_list   class initializer_list
Class:  class ArrayRef; 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 2, u'-    static_assert(sizeof(arrayRef) == 3 * sizeof(int), "bad array size");'), (61, 2, u'-    static_assert(sizeof(f({1})) == sizeof(one), "bad overload resolution");'), (66, 2, u'-    static_assert(sizeof(g({1})) == sizeof(two), "bad overload resolution");'), (71, 2, u'-    static_assert(sizeof(h({1, 2})) == sizeof(two), "bad overload resolution");')]
===========================================
Class:  class initializer_list   class initializer_list
Class:  class initializer_list   class initializer_list
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(22, 2, u'-static_assert(\'x\'_kind == LitKind::Char, "");'), (23, 2, u'-static_assert(L\'x\'_kind == LitKind::WideChar, "");'), (24, 2, u'-static_assert(u\'x\'_kind == LitKind::Char16, "");'), (25, 2, u'-static_assert(U\'x\'_kind == LitKind::Char32, "");'), (26, 2, u'-static_assert("foo"_kind == LitKind::CharStr, "");'), (27, 2, u'-static_assert(u8"foo"_kind == LitKind::CharStr, "");'), (28, 2, u'-static_assert(L"foo"_kind == LitKind::WideStr, "");'), (29, 2, u'-static_assert(u"foo"_kind == LitKind::Char16Str, "");'), (30, 2, u'-static_assert(U"foo"_kind == LitKind::Char32Str, "");'), (31, 2, u'-static_assert(194_kind == LitKind::Integer, "");'), (32, 2, u'-static_assert(0377_kind == LitKind::Integer, "");'), (33, 2, u'-static_assert(0x5ffc_kind == LitKind::Integer, "");'), (34, 2, u'-static_assert(.5954_kind == LitKind::Floating, "");'), (35, 2, u'-static_assert(1._kind == LitKind::Floating, "");'), (36, 2, u'-static_assert(1.e-2_kind == LitKind::Floating, "");'), (37, 2, u'-static_assert(4e6_kind == LitKind::Floating, "");'), (38, 2, u'-static_assert(4e6_kind2 == LitKind::Raw, "");'), (39, 2, u'-static_assert(4e6_kind3 == LitKind::Template, "");'), (51, 2, u'-static_assert(streq(143.97_fractional_digits, "97"), "");'), (52, 2, u'-static_assert(streq(0x786_fractional_digits, "0x786"), "");'), (53, 2, u'-static_assert(streq(.4_fractional_digits, "4"), "");'), (54, 2, u'-static_assert(streq(4._fractional_digits, ""), "");'), (55, 2, u'-static_assert(streq(1e+97_fractional_digits, "1e+97"), "");'), (56, 2, u'-static_assert(streq(0377_fractional_digits, "0377"), "");'), (57, 2, u'-static_assert(streq(0377.5_fractional_digits, "5"), "");'), (127, 2, u'-static_assert(0x1234_hash == 0x103eff5e, "");'), (128, 2, u'-static_assert(hash<\'0\', \'x\', \'1\', \'2\', \'3\', \'4\'>(0) == 0x103eff5e, "");')]
===========================================
Class:class Variadic1 
Class:class Variadic2 
Class:class Variadic3 
Class: class PrivateMember { class PrivateMember 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(115, 2, u'-static_assert(true, "!"); // expected-warning {{static_assert declarations are incompatible with C++98}}')]
===========================================
Class:class C7 
Class:class C 
Class: class B : public BASE , public BASE1 { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(12, 2, u'-  void f() { static_assert(is_same<decltype(this), S*>::value, ""); }'), (13, 2, u'-  void g() const { static_assert(is_same<decltype(this), const S*>::value, ""); }'), (14, 2, u'-  void h() volatile { static_assert(is_same<decltype(this), volatile S*>::value, ""); }'), (15, 2, u'-  void i() const volatile { static_assert(is_same<decltype(this), const volatile S*>::value, ""); }')]
===========================================
Class:  class A{   class A
Class:   class foo { class foo 
Class:  class Base {  class Base 
Class: class X  : Base {   class X  : Base 
Class:class Z : Y 
Class:class T 
Class:  class V { class V 
Class:class W : V 
Class:   class B1 { class B1 
Class:class D1 : B1 
Class:   class E1 {  class E1 
Class: class X { class X 
Class:  class C { class C 
Class:    class Z { class Z 
Class:  class C2 { class C2 
Class:  class XX { class XX 
Class:  class BadDtor { class BadDtor 
Class: class K : BadDtor { class K : BadDtor 
Class:class A 
Class:class B : public A 
Class:class C : public A 
Class:class D : public B, public C 
Class:class Object2 
Class:class A2 : public Object2 
Class:class B2 : public virtual A2 
Class:class C2 : virtual public A2 
Class:class D2 : public B2, public C2 
Class:class E2 : public D2, public C2, public virtual A2 
Class:class F2 : public E2, public A2 
Class: class A { class A 
Class: class B { class B 
Class: class C { class C 
Class:  class T; 
Class:   class QGenericArgument    {   
Class:  template <class T> class A {   template <class T> class A 
Class:  class B : A<int> 
Class:class simple_ptr { class simple_ptr 
Class: template <typename T> class simple_ptr2 { class simple_ptr2 
Class:  class B 
Class:  class C : virtual B 
Class: class Y { class Y 
Class: class X {  class X 
Class: class Z {  class Z 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 2, u'-static_assert(icd1.get<int>() == 4, "");'), (107, 2, u'-static_assert(icd2.get<char>() == \'x\', "");'), (108, 2, u'-static_assert(icd3.get<double>() == 6.5, "");'), (117, 2, u'-static_assert(icd4.get<const icd*>()->get<char>() == \'x\', "");'), (118, 2, u'-static_assert(icd5.get<non_triv>().n == 5, "");')]
===========================================
Class:  class X {   class X 
Class:class B 
Class:class C : A, virtual B 
Class:class F : D, E 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(14, 2, u'-static_assert(sizeof(E1) == sizeof(int), "bad size");'), (15, 2, u'-static_assert(sizeof(E1::Val1) == sizeof(int), "bad size");'), (16, 2, u'-static_assert(sizeof(E2) == sizeof(int), "bad size");'), (17, 2, u'-static_assert(sizeof(E2::Val1) == sizeof(int), "bad size");'), (29, 2, u'-static_assert(sizeof(E3) == 1, "bad size");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(20, 2, u'-static_assert(S<char>().f() == 1, "");'), (21, 2, u'-static_assert(S<int>().f() == 1, "");'), (26, 2, u'-static_assert(S<char>().g() == 1, ""); // expected-note {{here}} expected-error {{not an integral constant expression}} expected-note {{undefined}}'), (27, 2, u'-static_assert(S<short>().g() == 2, "");'), (28, 2, u'-static_assert(S<long>().g() == 8, "");'), (34, 2, u'-  static_assert(b != 8, "");'), (35, 2, u'-  static_assert(sizeof(c) != 8, "");')]
===========================================
Class:  template <class A, class B> struct is_same 
Class:  class foo { class foo 
Class:    class Y 
Class:   template <class Key, class T> struct QMap { 
Class:  template <class Key, class T> void QMap<Key, T>::insert(const Key &, const T &avalue) { 
Class: class A { class A 
Class:  class value_range_iter {   class value_range_iter 
Class:  class vector {   class vector 
Class:  class A {   class A 
Class:  class Foo { class Foo 
Class:      class A { class A 
Class:  class X;
Class: class N::X { class N::X 
Class:class C 
Class:class D 
Class:  class Bar {   class Bar 
Class:  class Foo {   class Foo 
Class:  class T4A {   class T4A 
Class:  class T4B 
Class:  class A {   class A 
Class:  class vectorA {   class vectorA 
Class:  class vector {   class vector 
Class:  class A {   class A 
Class:  class vector {   class vector 
Class:  class A {   class A 
Class:    class X {     class X 
Class:  class A { class A 
Class: class A { class A 
Class:    class A {     class A 
Class:  class Inner 
Class: class Crash { class Crash 
Class:                                        class TestConst { class TestConst 
Class: class C { class C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(13, 2, u'-static_assert(A<int>::id == 1, "fail");'), (14, 2, u'-static_assert(A<float>::id == 2, "fail");'), (15, 2, u'-static_assert(A<double, double>::id == 3, "fail");'), (44, 2, u'-static_assert(TypeMask<int, long, short>::result == 7, "fail");'), (45, 2, u'-static_assert(TypeMask<float, short>::result == 12, "fail");'), (46, 2, u'-static_assert(TypeMask<int, float, float>::result == 9, "fail");')]
===========================================
Class: class X { class X 
Class:  class Foo {   class Foo 
Class:  class A 
Class:   class B {   class B 
Class:class A 
Class:class B1 : A 
Class:class B2 : virtual A 
Class:class B3 : virtual virtual A 
Class:class C : public B1, private B2 
Class:class E : public D 
Class:class F : public I 
Class:class G : public U2 
Class:  class Two { class Two 
Class:  template <typename T> class SmallVectorImpl  { class SmallVectorImpl  
Class: template <typename T, unsigned N> class SmallVector : public SmallVectorImpl<T> { class SmallVector : public SmallVectorImpl<T> 
Class:class InlineFunctionInfo { class InlineFunctionInfo 
Class:class X 
Class:  template <class A, class B> struct pair 
Class:    class iterator 
Class:template <class X> class Y { template <class X> class Y 
Class:  class C {   class C 
Class:class NonAggregate 
Class: class HasConstExprCtor { class HasConstExprCtor 
Class:template <typename T> class HasConstExprCtorTemplate { template <typename T> class HasConstExprCtorTemplate 
Class:template <typename T> class HasConstExprCtorT { template <typename T> class HasConstExprCtorT 
Class:  class String;
Class: class _IOConfigThread { class _IOConfigThread 
Class:  class X{ class X
Class:  class X {   class X 
Class:   class Y : public X {   class Y : public X 
Class:class NoWarning { class NoWarning 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 2, u'-static_assert(!noexcept(Throw()), "incorrect exception specification");'), (44, 2, u'-static_assert(noexcept(NoThrow()), "incorrect exception specification");')]
===========================================
Class:  class A { class A 
Class:  class X { class X 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(12, 2, u'-  typedef int assert1[sizeof(dataMember) == sizeof(ptrdiff_t) ? 1 : -1];'), (13, 2, u'-  typedef int assert2[sizeof(memberFunction) == sizeof(ptrdiff_t) * 2 ? 1 : -1];')]
===========================================
Class:  template <class F, class T> void bindmem(F (T::*f)()); 
Class:   template <class T> class B {   template <class T> class B 
Class:class AnalysisDeclContext 
Class:    class C 
Class:  class B 
Class:  class dummy {    class dummy 
Class:    class myvector 
Class:    class mylinkedlist 
Class:  class linkedlist 
Class:class Message 
Class:  class C1;
Class:  class C1;
Class:    class C2;
Class:    class C2;
Class:class B 
Class:  class D 
Class: class C2 { class C2 
Class:  class Operators { class Operators 
Class: template <typename T> class foo { class foo 
Class:    class Counter 
Class:   class Test {   class Test 
Class:  class A; 
Class:    class Foo;
Class:  class B 
Class:   class A {   class A 
Class:  class A 
Class:  class X3 { class X3 
Class: class X4 { class X4 
Class: class X5 { class X5 
Class: class Base { class Base 
Class:class Tier 
Class:class Comp : public Tier 
Class: class Thai : public Base { class Thai : public Base 
Class: class X6 { class X6 
Class: class X7 { class X7 
Class: class X8 : public X6, public X7 { class X8 : public X6, public X7 
Class: class X9 { class X9 
Class: class X14 { class X14 
Class: class X15 { class X15 
Class:class S2 { class S2 
Class:  class Bar 
Class:  class Bar2 
Class:   class MessageLoop {   class MessageLoop 
Class:  template <class CookieStoreTestTraits>   class CookieStoreTest {   class CookieStoreTest 
Class:  class DeferredCookieTaskTest : public CookieStoreTest<CookieMonsterTestTraits>   {   
Class:  class Foo {   class Foo 
Class:  class X;
Class:  class X;
Class:    class C1 
Class:class X 
Class: class A { class A 
Class:class B : public A 
Class:class C : public B 
Class:class A 
Class:class B : public A 
Class:class C : public B 
Class:class D : public C 
Class:class string 
Class:class opt : public string 
Class:  class qrgb666 {   class qrgb666 
Class:  class A;
Class:  class B {   class B 
Class:  class A 
Class:  class B : public A 
Class:  class A {   class A 
Class: class X { class X 
Class:  class A {   class A 
Class:  class C { class C 
Class:  class X {   class X 
Class:class X 
Class:   class pr5244_foo { 
Class: class pr5244_baz { 
Class:class RegAlloc { class RegAlloc 
Class:class StringRef { class StringRef 
Class:class A 
Class:class B : virtual A 
Class:class C : B 
Class:class F : virtual A, virtual C 
Class:  class X0 
Class:  template <typename T> class ClassChecker {   template <typename T> class ClassChecker 
Class:    class X {     class X 
Class:   class Z {   class Z 
Class: class Test6 {  class Test6 
Class:  class string { class string 
Class:class A;
Class:  class B 
Class:  class Test   class Test
Class:  class type_info;
Class:class Poly 
Class:class A 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(5, 2, u'-static_assert(f(), "f"); // expected-error {{static_assert expression is not an integral constant expression}} expected-note {{non-constexpr function \'f\' cannot be used in a constant expression}}'), (6, 2, u'-static_assert(true, "true is not false");'), (7, 2, u'-static_assert(false, "false is false"); // expected-error {{static_assert failed "false is false"}}'), (10, 2, u'-    static_assert(false, "false is false"); // expected-error {{static_assert failed "false is false"}}'), (14, 2, u'-    static_assert(false, "false is false"); // expected-error {{static_assert failed "false is false"}}'), (18, 2, u'-    static_assert(N == 2, "N is not 2!"); // expected-error {{static_assert failed "N is not 2!"}}'), (25, 2, u'-    static_assert(sizeof(T) > sizeof(char), "Type not big enough!"); // expected-error {{static_assert failed "Type not big enough!"}}'), (31, 2, u'-static_assert(false, L"\\xFFFFFFFF"); // expected-error {{static_assert failed L"\\xFFFFFFFF"}}'), (32, 2, u'-static_assert(false, u"\\U000317FF"); // expected-error {{static_assert failed u"\\U000317FF"}}'), (34, 2, u'-static_assert(false, u8"\xce\xa9"); // expected-error {{static_assert failed u8"\\316\\251"}}'), (35, 2, u'-static_assert(false, L"\\u1234"); // expected-error {{static_assert failed L"\\x1234"}}'), (36, 2, u'-static_assert(false, L"\\x1ff" "0\\x123" "fx\\xfffff" "goop"); // expected-error {{static_assert failed L"\\x1FF""0\\x123""fx\\xFFFFFgoop"}}')]
===========================================
Class:class C 
Class:class D 
Class:class E 
Class:  class Point;
Class: class Test { 
Class: class C { class C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(11, 2, u'-        static_assert(sizeof(U) == 0, "expected type failure");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 2, u'-static_assert(__has_trivial_constructor(T1), "T1 has trivial constructor!");'), (9, 2, u'-static_assert(!__has_trivial_constructor(T2), "T2 has a user-declared constructor!");'), (14, 2, u'-static_assert(!__has_trivial_constructor(T3), "T3 has a virtual function!");'), (18, 2, u'-static_assert(!__has_trivial_constructor(T4), "T4 has a virtual base class!");'), (22, 2, u'-static_assert(__has_trivial_constructor(T5), "All the direct base classes of T5 have trivial constructors!");'), (29, 2, u'-static_assert(__has_trivial_constructor(T6), "All nonstatic data members of T6 have trivial constructors!");'), (34, 2, u'-static_assert(!__has_trivial_constructor(T7), "t4 does not have a trivial constructor!");'), (38, 2, u'-static_assert(!__has_trivial_constructor(T8), "The base class T2 does not have a trivial constructor!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 2, u'-static_assert(__has_trivial_destructor(T1), "T1 has trivial destructor!");'), (9, 2, u'-static_assert(!__has_trivial_destructor(T2), "T2 has a user-declared destructor!");'), (14, 2, u'-static_assert(__has_trivial_destructor(T3), "T3 has a virtual function (but still a trivial destructor)!");'), (18, 2, u'-static_assert(__has_trivial_destructor(T4), "T4 has a virtual base class! (but still a trivial destructor)!");'), (22, 2, u'-static_assert(__has_trivial_destructor(T5), "All the direct base classes of T5 have trivial destructors!");'), (29, 2, u'-static_assert(__has_trivial_destructor(T6), "All nonstatic data members of T6 have trivial destructors!");'), (34, 2, u'-static_assert(!__has_trivial_destructor(T7), "t2 does not have a trivial destructor!");'), (38, 2, u'-static_assert(!__has_trivial_destructor(T8), "The base class T2 does not have a trivial destructor!");')]
===========================================
Class: class X { class X 
Class:class Statics 
Class:class  HasPriv 
Class:class  HasProt 
Class: class AllPrivate { class AllPrivate 
Class: class PR11110 { class PR11110 
Class: class UsingAssignBase { class UsingAssignBase 
Class: class UsingAssign : public UsingAssignBase { class UsingAssign : public UsingAssignBase 
Class:class Base 
Class:class Derived : Base 
Class:class Derived2a : Derived 
Class:class Derived2b : Derived 
Class:class Derived3 : virtual Derived2a, virtual Derived2b 
Class:template <class T> class DerivedTemp : Base 
Class:template <class T> class NonderivedTemp 
Class:class TemplateClass 
Class:class PrivateCopy { class PrivateCopy 
Class:  class type_info;
Class:  class type_info;
Class: class error_condition { 
Class:class some_name 
Class:  class string 
Class:  class StreamOut 
Class:class Message 
Class:    class Parent { class Parent 
Class:class Child: public Parent 
Class:class ConstructExpr 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(18, 2, u'-static_assert(is_same_type<char, __underlying_type(f)>::value,'), (22, 2, u'-static_assert(is_same_type<int, __underlying_type(g)>::value,'), (26, 2, u'-static_assert(is_same_type<char, decltype(h)>::value,'), (34, 2, u'-static_assert(is_same_type<underlying_type<f>::type, char>::value,'), (42, 2, u'-static_assert(is_same_type<underlying_type<foo>::type, unsigned>::value,')]
===========================================
Class:  class Foo { class Foo 
Class:  class Rdar9188004A { class Rdar9188004A 
Class:class Rdar9188004C : public Rdar9188004B<Rdar9188004A> { class Rdar9188004C : public Rdar9188004B<Rdar9188004A> 
Class:   class A { class A 
Class:  class FooBase 
Class:  class Foo : public FooBase {   class Foo : public FooBase 
Class:  template <typename T> class FooImpl : public Foo {   template <typename T> class FooImpl : public Foo 
Class:class BaseEx 
Class:class Ex1: public BaseEx 
Class:   class PR6130 { class PR6130 
Class:  class APInt { class APInt 
Class:class APSInt : public APInt { class APSInt : public APInt 
Class:  class A {   class A 
Class:class C : B 
Class:    class Foo 
Class:  class B : A {   class B : A 
Class:  class Class1; 
Class:  class Class2   {   
Class:  class Base {   class Base 
Class:   template <typename T>   class Derived : public Base<T> {   class Derived : public Base<T> 
Class:  class K1 {   class K1 
Class: class X {  class X 
Class:  template <unsigned I> class C0 { class C0 
Class: class C { class C 
Class: class D { class D 
Class: class E { class E 
Class:  class Foo { class Foo 
Class:  class type_info 
Class:class NoDestroy 
Class:class A { class A 
Class: class B : A { class B : A 
Class:class A { class A 
Class: class B : A { class B : A 
Class:class A { class A 
Class: class B : A { class B : A 
Class:class A { class A 
Class: class B : A { class B : A 
Class:class A { class A 
Class: class B : A { class B : A 
Class:class A { class A 
Class: class B : A { class B : A 
Class:  class A {   class A 
Class:   class B : A {   class B : A 
Class:  class A {   class A 
Class:   class B : A {   class B : A 
Class:  class A {   class A 
Class:   class B : A {   class B : A 
Class:class X1 : public X0 { class X1 : public X0 
Class:  class Base 
Class:  class Derived : public Base 
Class:   class Foo {   class Foo 
Class:   class Bar : public Foo {   class Bar : public Foo 
Class:  class Base 
Class:  class Derived : public Base 
Class:  class X 
Class:  class X1 : public X 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:  class A { class A 
Class: class B : public A { class B : public A 
Class:  class Target   class Target
Class: class C1 { class C1 
Class:    class PR12271 { class PR12271 
Class: template <class Dest, class Source> inline Dest bit_cast(const Source& source) { inline Dest bit_cast(const Source& source) 
Class:  class I { class I 
Class:class Test { class Test 
Class:class A { class A 
Class: class B : public A { class B : public A 
Class: class complex : public BB, BB1 { class complex : public BB, BB1 
Class: class Anon { class Anon 
Class:class Anon2 { class Anon2 
Class:class Anon3 { class Anon3 
Class:  class A {   class A 
Class: class A { class A 
Class:  class B : A { class B : A 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(5, 2, u'-void assert(bool condition);'), (10, 2, u'-  assert("error"); // expected-warning{{implicit conversion turns string literal into bool: \'const char [6]\' to \'bool\'}}'), (11, 2, u'-  assert(0 && "error");')]
===========================================
Class: class __attribute__((scoped_lockable)) MutexLock { class __attribute__((scoped_lockable)) MutexLock 
Class: class __attribute__((scoped_lockable)) ReaderMutexLock { class __attribute__((scoped_lockable)) ReaderMutexLock 
Class: class MutexWrapper { class MutexWrapper 
Class: class GlobalLocker { class GlobalLocker 
Class:  class WeirdMethods { class WeirdMethods 
Class: class PGBFoo { class PGBFoo 
Class: class GBFoo { class GBFoo 
Class:     class LateFoo { class LateFoo 
Class: class LateBar { class LateBar 
Class:  class LRBar { class LRBar 
Class: class LRFoo { class LRFoo 
Class:class Bar { class Bar 
Class:class Bar { class Bar 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class: class FooBar { class FooBar 
Class:class Foo { class Foo 
Class: class Bar { class Bar 
Class:class Foo { class Foo 
Class:class Bar { class Bar 
Class: template <typename T> class Foo { class Foo 
Class:class Bar { class Bar 
Class:  class FooBar {   class FooBar 
Class:class Base { class Base 
Class: class Child : public Base { class Child : public Base 
Class:class Foo { class Foo 
Class:  class Bar {   class Bar 
Class:class Bar { class Bar 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:class Base { class Base 
Class: class Child : public Base { class Child : public Base 
Class:class Foo { class Foo 
Class:  class MyData  {   class MyData  
Class:    class DataLocker {   class DataLocker 
Class:    class Foo {   class Foo 
Class:  class Foo {   class Foo 
Class:class LOCKABLE MyLockable { class LOCKABLE MyLockable 
Class:class Foo { class Foo 
Class:class Foo1 { class Foo1 
Class: class Foo2 { class Foo2 
Class:  class Bar { class Bar 
Class:  template <class T> class BarT { class BarT 
Class: template <class T> class Cell { class Cell 
Class:  template <class T> class CellDelayed { class CellDelayed 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:class LOCKABLE MyLock { class LOCKABLE MyLock 
Class:  class LOCKABLE MyLock2 { class LOCKABLE MyLock2 
Class:class Foo;
Class: class Foo { class Foo 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class: class Bar { class Bar 
Class: class UnlockableMu{ class UnlockableMu
Class: class MuWrapper { class MuWrapper 
Class:  class MuDoubleWrapper { class MuDoubleWrapper 
Class:     class Foo { class Foo 
Class: class Foo2 { class Foo2 
Class: class Bar { class Bar 
Class:    class NoanalFoo { class NoanalFoo 
Class: class __attribute__((no_thread_safety_analysis)) NoanalTestClass {  class __attribute__((no_thread_safety_analysis)) NoanalTestClass 
Class:    class GVFoo { class GVFoo 
Class: class __attribute__((guarded_var)) GV {  class __attribute__((guarded_var)) GV 
Class:      class PGVFoo { class PGVFoo 
Class: class __attribute__((pt_guarded_var)) PGV {  class __attribute__((pt_guarded_var)) PGV 
Class: class __attribute__((lockable (1))) LTestClass_args {  class __attribute__((lockable (1))) LTestClass_args 
Class:    class LFoo { class LFoo 
Class: class __attribute__((scoped_lockable (1))) SLTestClass_args {  class __attribute__((scoped_lockable (1))) SLTestClass_args 
Class:    class SLFoo { class SLFoo 
Class:    class GBFoo { class GBFoo 
Class: class __attribute__((guarded_by(mu1))) GB {  class __attribute__((guarded_by(mu1))) GB 
Class:    class PGBFoo { class PGBFoo 
Class: class __attribute__((pt_guarded_by(mu1))) PGB {  class __attribute__((pt_guarded_by(mu1))) PGB 
Class:    class AAFoo { class AAFoo 
Class: class __attribute__((acquired_after(mu1))) AA {  class __attribute__((acquired_after(mu1))) AA 
Class:    class ABFoo { class ABFoo 
Class: class __attribute__((acquired_before(mu1))) AB {  class __attribute__((acquired_before(mu1))) AB 
Class:    class ElfFoo { class ElfFoo 
Class: class __attribute__((exclusive_lock_function)) ElfTestClass {  class __attribute__((exclusive_lock_function)) ElfTestClass 
Class:    class SlfFoo { class SlfFoo 
Class: class __attribute__((shared_lock_function)) SlfTestClass {  class __attribute__((shared_lock_function)) SlfTestClass 
Class:    class EtfFoo { class EtfFoo 
Class: class __attribute__((exclusive_trylock_function(1))) EtfTestClass {  class __attribute__((exclusive_trylock_function(1))) EtfTestClass 
Class:     class StfFoo { class StfFoo 
Class: class __attribute__((shared_trylock_function(1))) StfTestClass {  class __attribute__((shared_trylock_function(1))) StfTestClass 
Class:    class UfFoo { class UfFoo 
Class: class __attribute__((no_thread_safety_analysis)) UfTestClass {  class __attribute__((no_thread_safety_analysis)) UfTestClass 
Class:    class LrFoo { class LrFoo 
Class: class __attribute__((lock_returned(mu1))) LrTestClass {  class __attribute__((lock_returned(mu1))) LrTestClass 
Class:    class LeFoo { class LeFoo 
Class: class __attribute__((locks_excluded(mu1))) LeTestClass {  class __attribute__((locks_excluded(mu1))) LeTestClass 
Class:    class ElrFoo { class ElrFoo 
Class: class __attribute__((exclusive_locks_required(mu1))) ElrTestClass {  class __attribute__((exclusive_locks_required(mu1))) ElrTestClass 
Class:    class SlrFoo { class SlrFoo 
Class: class __attribute__((shared_locks_required(mu1))) SlrTestClass {  class __attribute__((shared_locks_required(mu1))) SlrTestClass 
Class:  class UnFoo { class UnFoo 
Class: class StaticMu { class StaticMu 
Class: class FooLate { class FooLate 
Class:     class __attribute__((lockable)) EmptyArgListsTest { class __attribute__((lockable)) EmptyArgListsTest 
Class:class Foo { class Foo 
Class: template <class T> class Bar { class Bar 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:  class Bar {   class Bar 
Class:  class X   class X
Class:  class Box {   class Box 
Class:  class Parent { class Parent 
Class: class Derived : public Parent { class Derived : public Parent 
Class: class VeryDerived : public Derived {  class VeryDerived : public Derived 
Class:   class Foo { class Foo 
Class: class Bar { class Bar 
Class:  class Base {   class Base 
Class:   template <class ParentClass>   class Derived : public ParentClass {   class Derived : public ParentClass 
Class:   class Final : public Derived<Base> {   class Final : public Derived<Base> 
Class: class X { class X 
Class:  template <unsigned, class _Tp> class tuple_element;
Class:   template <class _T1, class _T2>   class tuple_element<0, pair<_T1, _T2> >   {   
Class:  class B : public A<int> 
Class:class C1 : public N::A<int> 
Class:class C2 : public N::A<float> 
Class:class Wibble<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 2, u'-  static_assert(w == 1, "");'), (32, 2, u'-  static_assert(sizeof(arr) == \'x\', "");'), (76, 2, u'-  static_assert(n == 5, "");')]
===========================================
Class:  class wxObject;
Class:  class __attribute__ ((visibility())) wxGDIObject : public wxObject { \   class __attribute__ ((visibility())) wxGDIObject : public wxObject 
Class:  class Class {   class Class 
Class:  class X0  {   class X0  
Class:    class Inner1;
Class:     class Inner2  {     class Inner2  
Class:  class X {   class X 
Class:  class X<XT>::Inner 
Class:  class Bar {   class Bar 
Class:  class bar {   class bar 
Class:class C 
Class:  class ExternallyImplementedClass;
Class:   class MyClass {   class MyClass 
Class:  class string   class string
Class:    class Nested 
Class:      class HasDepBase::Nested nested;
Class:      class NoDepBase::Nested nested; 
Class:  class B : public A<T>   class B : public A<T>
Class:  class Base_B 
Class:  class A1 { class A1 
Class:class A2 
Class:template <class C> class B2 { template <class C> class B2 
Class:template <class C> class B3 { template <class C> class B3 
Class:  class A : public T::type   class A : public T::type
Class:  class A {   class A 
Class:  class A   class A
Class:  template <typename T> class chained_map {   template <typename T> class chained_map 
Class:  template <class T> class Base {   template <class T> class Base 
Class:    class Inner {     class Inner 
Class:   template <class T> class Derived1 : Base<T> {   template <class T> class Derived1 : Base<T> 
Class:   template <class T> class Derived2 : Base<T>::Inner {   template <class T> class Derived2 : Base<T>::Inner 
Class:  class MyClassCore   class MyClassCore
Class:   template <class T>   class MyClass : public MyClassCore<T>   {   
Class:  class B {   class B 
Class:  class D {   class D 
Class:    class X 
Class:    class T::bar;  
Class:    class T::bar 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 2, u'-  assert(di.size() == 5);'), (136, 2, u'-    assert(*I == I - di.begin());'), (139, 2, u'-    assert(di[I] == I);'), (142, 2, u'-  assert(di.size() == 4);'), (146, 2, u'-  assert(di2.size() == 5);'), (147, 2, u'-  assert(di.begin() != di2.begin());'), (150, 2, u'-    assert(*I == I - di2.begin());'), (153, 2, u'-  assert(di3.size() == 5);'), (154, 2, u'-  assert(di.begin() != di3.begin());'), (157, 2, u'-    assert(*I == I - di3.begin());'), (160, 2, u'-  assert(di4.size() == 0);'), (162, 2, u'-  assert(di4.size() == 5);'), (163, 2, u'-  assert(di.begin() != di4.begin());'), (166, 2, u'-    assert(*I == I - di4.begin());'), (168, 2, u'-  assert(di4 == di);'), (170, 2, u'-  assert(di4 != di);'), (174, 2, u'-  assert(dp.size() == 1);')]
===========================================
Class:  class TC1 { class TC1 
Class:  class TC2 {   class TC2 
Class:  class numpunct : public locale::facet    class numpunct : public locale::facet 
Class:    class X {     class X 
Class:  class X {   class X 
Class:  template <typename T> class Foo {   template <typename T> class Foo 
Class:  class outer {   class outer 
Class:    class foo;
Class:  class outer::foo {   class outer::foo 
Class:  template <class T1, class T2 , class T3  > class A;
Class:    template <class U> class B;
Class:    template <class S> template <class U> friend class A<S>::B;
Class:   template <class S> template <class U> class A<S>::B {   template <class S> template <class U> class A<S>::B 
Class:  template <class T> class A {   template <class T> class A 
Class: template <typename T> class TenElementArray { template <typename T> class TenElementArray 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 2, u'-#define static_assert(__b, __m) \\'), (15, 2, u'-static_assert(sizeof(IntArray<10>) == sizeof(int) * 10, "Array size mismatch");'), (16, 2, u'-static_assert(sizeof(IntArray<1>) == sizeof(int) * 1, "Array size mismatch");'), (22, 2, u'-static_assert(sizeof(TenElementArray<int>) == sizeof(int) * 10, "Array size mismatch");'), (28, 2, u'-static_assert(sizeof(Array<int, 10>) == sizeof(int) * 10, "Array size mismatch");')]
===========================================
Class: class Base { class Base 
Class:class Derived : public Base 
Class:  template <class T, class U>   template <class T, class U>
Class:  class X   {   
Class:    class false_t 
Class:  template <class T> class A; 
Class:  template <class T> class B {   template <class T> class B 
Class:  class BaseT 
Class:  class DerivedT : public BaseT<T> 
Class:   template <typename T>   class FromT {   class FromT 
Class:  template <typename T> class Foo { class Foo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(23, 2, u'-static_assert(noexcept(A<int>::B<char>::f()), "");')]
===========================================
Class:  class A {   class A 
Class:  class A{   class A
Class:  class type_info;
Class:    class D; 
Class:  class B {   class B 
Class:   template <class T> class X { 
Class:  template <class T> class A 
Class:  class SomeClass {   class SomeClass 
Class:    class scanline_u8 {}     class scanline_u8 
Class:class the_application : public agg::platform_support class the_application : public agg::platform_support
Class:    class X;
Class:    class X : public T 
Class:  template <typename T> class A {   template <typename T> class A 
Class:    class Foo;
Class:    class Foo {     class Foo 
Class:   template <typename T> class B {   template <typename T> class B 
Class:    class Foo {     class Foo 
Class:   template <typename T> class C {   template <typename T> class C 
Class:  template <typename T> class C<T>::Foo {   template <typename T> class C<T>::Foo 
Class:    class A<N>::B::C X; 
Class: class ExprEngine { class ExprEngine 
Class:class RetainReleaseChecker 
Class:  template <class T> class B {   template <class T> class B 
Class:template <class T> class BB : public AA<T> { template <class T> class BB : public AA<T> 
Class:    class type {     class type 
Class:  class C {   class C 
Class:    template <class _Tp, class _Up>     template <class _Tp, class _Up>
Class:  template <class T, class U> struct D1 
Class:   template <class T, class U>   struct D   {   
Class:  template <class T> class A 
Class:  template <class T> class B {   template <class T> class B 
Class:  class type_info 
Class: class Y3 { class Y3 
Class: template <typename T, template <T, T> class TT, class R = TT<1, 2> > struct Comp { struct Comp 
Class:  class Templated {   class Templated 
Class:  class Knot : public JoinVisitor<Knot> {   class Knot : public JoinVisitor<Knot> 
Class:  template <class T, class Trt,   template <class T, class Trt,
Class:  template <class X, template<class> class = less> struct interval_type_default {   template <class X, template<class> class = less> struct interval_type_default 
Class:   template <class T,             template<class _T, template<class> class Compare = PR9016::less,                      class = typename interval_type_default<_T,Compare>::type,                      template<class> class = allocator> class IntervalSet>   struct ZZZ   {   
Class:  class C { class C 
Class:template <class T> class A { class A 
Class: template <class T> class B : public A<T> { class B : public A<T> 
Class:   class A { 
Class: class B { 
Class: class Base { 
Class:class Derived1 : public Base 
Class:class Derived2 : public Base 
Class: class X : public B, public Derived2, public Derived1 { 
Class:  class X3 { class X3 
Class:  template <class T> class Base;
Class:  template <class T> class Derived : public Base<T> {   template <class T> class Derived : public Base<T> 
Class:class A 
Class:  template <typename T1> template <template <typename> class TC>   template <typename T1> template <template <typename> class TC>
Class:  class Outer   class Outer
Class:class G 
Class:class Bar 
Class:   class A { class A 
Class:    template <class T> class B { class B 
Class:   template <class T> class A { class A 
Class:  template <class T> class B : public A<T> { class B : public A<T> 
Class:class B : public A<T> { class B : public A<T> 
Class:class A { class A 
Class:  template <class T> class B : public A<T> { class B : public A<T> 
Class:class A { class A 
Class:class B { class B 
Class: template <class T> class A : public B<T> { class A : public B<T> 
Class:class C { class C 
Class: template <class T> class A : public T { class A : public T 
Class: class S { class S 
Class:  class Inner0;
Class:  class Foo {   class Foo 
Class:  class ReferenceElement< Topology, ctype > :: BaryCenterArray    class ReferenceElement< Topology, ctype > :: BaryCenterArray 
Class:    class It     class It
Class:  class Y;
Class:  template <class T> class Base 
Class:  template <class T> class Derived : public Base<T> {   template <class T> class Derived : public Base<T> 
Class:  class Impl {   class Impl 
Class:  template <class T> class Magic : public Impl {   template <class T> class Magic : public Impl 
Class:  class Outer2 {   class Outer2 
Class:    class Outer2<V>::Inner; 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 2, u'-template< bool C > struct assert { };'), (5, 2, u'-template< bool > struct assert_arg_pred_impl { }; // expected-note 3 {{declared here}}'), (6, 2, u'-template< typename Pred > assert<false> assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type ); // expected-error 5 {{}}')]
===========================================
Class:  class type_info 
Class:  template <class t> class foo 
Class:  template <class t> class bar {   template <class t> class bar 
Class: class X { class X 
Class:        class basic;
Class:        class basic         class basic
Class:  template <template<typename,int> class TT, typename T, int N>   template <template<typename,int> class TT, typename T, int N>
Class:  class X 
Class:  class a;
Class:   template <class U>   class a<s>    {   
Class:  class BasicGeometry   class BasicGeometry
Class: class A { 
Class:  class type_info;
Class:  class A 
Class:    class Inner : public A 
Class:class PrintTransforms : public MigrationProcess::RewriteListener { class PrintTransforms : public MigrationProcess::RewriteListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 2, u'-    assert(Ctx);'), (97, 2, u'-    assert(Ctx);'), (177, 2, u'-  assert(!transforms.empty());'), (224, 2, u'-  assert(!resultFiles.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(285, 2, u'-  assert(MAI && "Unable to create target asm info!");'), (288, 2, u'-  assert(MRI && "Unable to create target register info!");'), (343, 2, u'-    assert(Opts.OutputType == AssemblerInvocation::FT_Obj &&')]
===========================================
Class:class NAME : public VisitorJob {\ class NAME : public VisitorJob 
Class:class TypeLocVisit : public VisitorJob { class TypeLocVisit : public VisitorJob 
Class: class LabelRefVisit : public VisitorJob { class LabelRefVisit : public VisitorJob 
Class: class NestedNameSpecifierLocVisit : public VisitorJob { class NestedNameSpecifierLocVisit : public VisitorJob 
Class: class DeclarationNameInfoVisit : public VisitorJob { class DeclarationNameInfoVisit : public VisitorJob 
Class:class MemberRefVisit : public VisitorJob { class MemberRefVisit : public VisitorJob 
Class:class EnqueueVisitor : public StmtVisitor<EnqueueVisitor, void> { class EnqueueVisitor : public StmtVisitor<EnqueueVisitor, void> 
Class:class AnnotateTokensWorker { class AnnotateTokensWorker 
Class:class MarkMacroArgTokensVisitor { class MarkMacroArgTokensVisitor 
Class:  class CaptureCompletionResults : public CodeCompleteConsumer {   class CaptureCompletionResults : public CodeCompleteConsumer 
Class:class CXDiagnosticCustomNoteImpl : public CXDiagnosticImpl { class CXDiagnosticCustomNoteImpl : public CXDiagnosticImpl 
Class: class CXDiagnosticRenderer : public DiagnosticNoteRenderer { class CXDiagnosticRenderer : public DiagnosticNoteRenderer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(135, 2, u'-  assert(Loc.isMacroID());'), (214, 2, u'-  assert(clang_isDeclaration(declCursor.kind));')]
===========================================
Class:class USRGenerator : public DeclVisitor<USRGenerator> { class USRGenerator : public DeclVisitor<USRGenerator> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(436, 2, u'-  assert(Buf.size() > 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(34, 2, u'-  assert(K >= CXCursor_FirstInvalid && K <= CXCursor_LastInvalid);'), (40, 2, u'-  assert(A && "Invalid arguments!");'), (57, 2, u'-  assert(A && Parent && TU && "Invalid arguments!");'), (65, 2, u'-  assert(D && TU && "Invalid arguments!");'), (93, 2, u'-  assert(S && TU && "Invalid arguments!");'), (489, 2, u'-  assert(Super && TU && "Invalid arguments!");'), (497, 2, u'-  assert(C.kind == CXCursor_ObjCSuperClassRef);'), (506, 2, u'-  assert(Proto && TU && "Invalid arguments!");'), (514, 2, u'-  assert(C.kind == CXCursor_ObjCProtocolRef);'), (526, 2, u'-  assert(TU && "Invalid arguments!");'), (534, 2, u'-  assert(C.kind == CXCursor_ObjCClassRef);'), (542, 2, u'-  assert(Type && TU && "Invalid arguments!");'), (550, 2, u'-  assert(C.kind == CXCursor_TypeRef);'), (559, 2, u'-  assert(Template && TU && "Invalid arguments!");'), (567, 2, u'-  assert(C.kind == CXCursor_TemplateRef);'), (577, 2, u'-  assert(NS && (isa<NamespaceDecl>(NS) || isa<NamespaceAliasDecl>(NS)) && TU &&'), (586, 2, u'-  assert(C.kind == CXCursor_NamespaceRef);'), (595, 2, u'-  assert(Var && TU && "Invalid arguments!");'), (603, 2, u'-  assert(C.kind == CXCursor_VariableRef);'), (612, 2, u'-  assert(Field && TU && "Invalid arguments!");'), (620, 2, u'-  assert(C.kind == CXCursor_MemberRef);'), (633, 2, u'-  assert(C.kind == CXCursor_CXXBaseSpecifier);'), (648, 2, u'-  assert(C.kind == CXCursor_PreprocessingDirective);'), (664, 2, u'-  assert(C.kind == CXCursor_MacroDefinition);'), (675, 2, u'-  assert(C.kind == CXCursor_MacroExpansion);'), (686, 2, u'-  assert(C.kind == CXCursor_InclusionDirective);'), (693, 2, u'-  assert(Label && TU && "Invalid arguments!");'), (701, 2, u'-  assert(C.kind == CXCursor_LabelRef);'), (709, 2, u'-  assert(E && TU && "Invalid arguments!");'), (722, 2, u'-  assert(D && TU && "Invalid arguments!");'), (735, 2, u'-  assert(Name.getAsOverloadedTemplate() && TU && "Invalid arguments!");'), (747, 2, u'-  assert(C.kind == CXCursor_OverloadedDeclRef);'), (869, 2, u'-  assert(clang_isDeclaration(cursor.kind));'), (1013, 2, u'-  assert(clang_isDeclaration(C.kind));')]
===========================================
Class:class CXLoadedDiagnosticSetImpl : public CXDiagnosticSetImpl { class CXLoadedDiagnosticSetImpl : public CXDiagnosticSetImpl 
Class:class DiagLoader { class DiagLoader 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(95, 2, u'-  assert(Diag.getLocation().isValid());')]
===========================================
Class:class BodyIndexer : public RecursiveASTVisitor<BodyIndexer> { class BodyIndexer : public RecursiveASTVisitor<BodyIndexer> 
Class:class IndexingDeclVisitor : public DeclVisitor<IndexingDeclVisitor, bool> { class IndexingDeclVisitor : public DeclVisitor<IndexingDeclVisitor, bool> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(209, 2, u'-    assert(D->getPropertyImplementation() == ObjCPropertyImplDecl::Synthesize);')]
===========================================
Class:class TypeIndexer : public RecursiveASTVisitor<TypeIndexer> { class TypeIndexer : public RecursiveASTVisitor<TypeIndexer> 
Class:class IndexPPCallbacks : public PPCallbacks { class IndexPPCallbacks : public PPCallbacks 
Class:     class IndexingConsumer : public ASTConsumer { class IndexingConsumer : public ASTConsumer 
Class:     class CaptureDiagnosticConsumer : public DiagnosticConsumer { class CaptureDiagnosticConsumer : public DiagnosticConsumer 
Class:     class IndexingFrontendAction : public ASTFrontendAction { class IndexingFrontendAction : public ASTFrontendAction 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(728, 2, u'-  assert(D);')]
===========================================
Class:class FakeStatCache : public FileSystemStatCache { class FakeStatCache : public FileSystemStatCache 
Class:  class FileManagerTest : public ::testing::Test { class FileManagerTest : public ::testing::Test 
Class:class SourceManagerTest : public ::testing::Test { class SourceManagerTest : public ::testing::Test 
Class: class VoidModuleLoader : public ModuleLoader { class VoidModuleLoader : public ModuleLoader 
Class:class MacroTracker : public PPCallbacks { class MacroTracker : public PPCallbacks 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 2, u'-  ASSERT_EQ(3U, toks.size());'), (87, 2, u'-  ASSERT_EQ(tok::l_square, toks[0].getKind());'), (88, 2, u'-  ASSERT_EQ(tok::identifier, toks[1].getKind());'), (89, 2, u'-  ASSERT_EQ(tok::r_square, toks[2].getKind());'), (97, 2, u'-  ASSERT_TRUE(macroExpStartLoc.isFileID());'), (98, 2, u'-  ASSERT_TRUE(macroExpEndLoc.isFileID());'), (101, 2, u'-  ASSERT_EQ("M", PP.getSpelling(macroExpStartLoc, str));'), (102, 2, u'-  ASSERT_EQ(")", PP.getSpelling(macroExpEndLoc, str));'), (153, 2, u'-  ASSERT_EQ(4U, toks.size());'), (154, 2, u'-  ASSERT_EQ(tok::numeric_constant, toks[0].getKind());'), (155, 2, u'-  ASSERT_EQ(tok::numeric_constant, toks[1].getKind());'), (156, 2, u'-  ASSERT_EQ(tok::numeric_constant, toks[2].getKind());'), (157, 2, u'-  ASSERT_EQ(tok::numeric_constant, toks[3].getKind());'), (254, 2, u'-  ASSERT_EQ(0U, toks.size());'), (256, 2, u'-  ASSERT_EQ(9U, Macros.size());'), (258, 2, u'-  ASSERT_TRUE(Macros[0].isDefinition);'), (259, 2, u'-  ASSERT_EQ("M", Macros[0].Name);'), (261, 2, u'-  ASSERT_TRUE(Macros[1].isDefinition);'), (262, 2, u'-  ASSERT_EQ("INC", Macros[1].Name);'), (264, 2, u'-  ASSERT_FALSE(Macros[2].isDefinition);'), (265, 2, u'-  ASSERT_EQ("M", Macros[2].Name);'), (267, 2, u'-  ASSERT_FALSE(Macros[3].isDefinition);'), (268, 2, u'-  ASSERT_EQ("INC", Macros[3].Name);'), (270, 2, u'-  ASSERT_TRUE(Macros[4].isDefinition);'), (271, 2, u'-  ASSERT_EQ("MACRO_IN_INCLUDE", Macros[4].Name);'), (273, 2, u'-  ASSERT_TRUE(Macros[5].isDefinition);'), (274, 2, u'-  ASSERT_EQ("INC2", Macros[5].Name);'), (276, 2, u'-  ASSERT_FALSE(Macros[6].isDefinition);'), (277, 2, u'-  ASSERT_EQ("M", Macros[6].Name);'), (279, 2, u'-  ASSERT_FALSE(Macros[7].isDefinition);'), (280, 2, u'-  ASSERT_EQ("INC2", Macros[7].Name);'), (282, 2, u'-  ASSERT_TRUE(Macros[8].isDefinition);'), (283, 2, u'-  ASSERT_EQ("MACRO_IN_INCLUDE", Macros[8].Name);')]
===========================================
Class:class TestASTFrontendAction : public ASTFrontendAction { class TestASTFrontendAction : public ASTFrontendAction 
Class:  class Visitor : public ASTConsumer, public RecursiveASTVisitor<Visitor> {   class Visitor : public ASTConsumer, public RecursiveASTVisitor<Visitor> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 2, u'-  ASSERT_TRUE(compiler.ExecuteAction(test_action));'), (68, 2, u'-  ASSERT_EQ(3U, test_action.decl_names.size());')]
===========================================
Class:class LexerTest : public ::testing::Test { class LexerTest : public ::testing::Test 
Class: class VoidModuleLoader : public ModuleLoader { class VoidModuleLoader : public ModuleLoader 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 2, u'-  ASSERT_EQ(10U, toks.size());'), (92, 2, u'-  ASSERT_EQ(tok::l_square, toks[0].getKind());'), (93, 2, u'-  ASSERT_EQ(tok::identifier, toks[1].getKind());'), (94, 2, u'-  ASSERT_EQ(tok::r_square, toks[2].getKind());'), (95, 2, u'-  ASSERT_EQ(tok::l_square, toks[3].getKind());'), (96, 2, u'-  ASSERT_EQ(tok::identifier, toks[4].getKind());'), (97, 2, u'-  ASSERT_EQ(tok::r_square, toks[5].getKind());'), (98, 2, u'-  ASSERT_EQ(tok::identifier, toks[6].getKind());'), (99, 2, u'-  ASSERT_EQ(tok::identifier, toks[7].getKind());'), (100, 2, u'-  ASSERT_EQ(tok::identifier, toks[8].getKind());'), (101, 2, u'-  ASSERT_EQ(tok::identifier, toks[9].getKind());')]
===========================================
Class:class PreprocessingRecordTest : public ::testing::Test { class PreprocessingRecordTest : public ::testing::Test 
Class: class VoidModuleLoader : public ModuleLoader { class VoidModuleLoader : public ModuleLoader 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 2, u'-  ASSERT_EQ(10U, toks.size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 2, u'-  ASSERT_EQ(4u, FoundCommand.CommandLine.size()) << ErrorMessage;'), (82, 2, u'-  ASSERT_EQ(2u, FoundCommand.CommandLine.size());'), (118, 2, u'-  ASSERT_EQ(1u, FoundCommand.CommandLine.size()) << ErrorMessage;'), (140, 2, u'-  ASSERT_EQ(3ul, Result.size());'), (148, 2, u'-  ASSERT_EQ(2ul, Result.size());'), (155, 2, u'-  ASSERT_EQ(1ul, Backslash.size());'), (158, 2, u'-  ASSERT_EQ(1ul, Quote.size());'), (164, 2, u'-  ASSERT_EQ(1ul, Result.size());'), (171, 2, u'-  ASSERT_EQ(2ul, Result.size());'), (179, 2, u'-  ASSERT_EQ(1ul, Result.size());'), (186, 2, u'-  ASSERT_EQ(1ul, Result.size());'), (193, 2, u'-  ASSERT_EQ(4ul, Result.size());'), (203, 2, u'-  ASSERT_EQ(1ul, QuotedNoSpaces.size());'), (208, 2, u'-  ASSERT_EQ(1ul, MixedNoSpaces.size());'), (214, 2, u'-  ASSERT_EQ(1ul, Unclosed.size());'), (218, 2, u'-  ASSERT_EQ(1ul, Empty.size());'), (229, 2, u'-  ASSERT_EQ(1ul, Result.size());'), (260, 2, u'-  ASSERT_TRUE(Database);'), (263, 2, u'-  ASSERT_EQ(1ul, Result.size());'), (264, 2, u'-  ASSERT_EQ(".", Result[0].Directory);'), (270, 2, u'-  ASSERT_EQ(CommandLine, Result[0].CommandLine);'), (279, 2, u'-  ASSERT_TRUE(Database);'), (282, 2, u'-  ASSERT_EQ(1ul, Result.size());'), (283, 2, u'-  ASSERT_EQ(".", Result[0].Directory);'), (287, 2, u'-  ASSERT_EQ(CommandLine, Result[0].CommandLine);')]
===========================================
Class:class TestAction : public clang::ASTFrontendAction { class TestAction : public clang::ASTFrontendAction 
Class:class FindTopLevelDeclConsumer : public clang::ASTConsumer { class FindTopLevelDeclConsumer : public clang::ASTConsumer 
Class:class FindClassDeclXConsumer : public clang::ASTConsumer { class FindClassDeclXConsumer : public clang::ASTConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(245, 2, u'-  assert(__ashldi3(1, 1) == 2);'), (246, 2, u'-  assert(__ashrdi3(2, 1) == 1);'), (247, 2, u'-  assert(__lshrdi3(2, 1) == 1);'), (248, 2, u'-  assert(__clzsi2(1) == 31);'), (249, 2, u'-  assert(__clzdi2(1) == 63);'), (250, 2, u'-  assert(__ctzsi2(2) == 1);'), (251, 2, u'-  assert(__ctzdi2(2) == 1);'), (252, 2, u'-  assert(__ffsdi2(12) == 3);'), (253, 2, u'-  assert(__paritysi2(13) == 1);'), (254, 2, u'-  assert(__paritydi2(13) == 1);'), (255, 2, u'-  assert(__popcountsi2(13) == 3);'), (256, 2, u'-  assert(__popcountdi2(13) == 3);'), (257, 2, u'-  assert(__negdi2(3) == -3);'), (258, 2, u'-  assert(__muldi3(2,2) == 4);'), (259, 2, u'-  assert(__divdi3(-4,2) == -2);'), (260, 2, u'-  assert(__udivdi3(4,2) == 2);'), (261, 2, u'-  assert(__moddi3(3,2) == 1);'), (262, 2, u'-  assert(__umoddi3(3,2) == 1);'), (263, 2, u'-  assert(__udivmoddi4(5,2,&du_tmp) == 2 && du_tmp == 1);'), (264, 2, u'-  assert(__absvsi2(-2) == 2);'), (265, 2, u'-  assert(__absvdi2(-2) == 2);'), (266, 2, u'-  assert(__negvsi2(2) == -2);'), (267, 2, u'-  assert(__negvdi2(2) == -2);'), (268, 2, u'-  assert(__addvsi3(2, 3) == 5);'), (269, 2, u'-  assert(__addvdi3(2, 3) == 5);'), (270, 2, u'-  assert(__subvsi3(2, 3) == -1);'), (271, 2, u'-  assert(__subvdi3(2, 3) == -1);'), (272, 2, u'-  assert(__mulvsi3(2, 3) == 6);'), (273, 2, u'-  assert(__mulvdi3(2, 3) == 6);'), (274, 2, u'-  assert(__cmpdi2(3, 2) == 2);'), (275, 2, u'-  assert(__ucmpdi2(3, 2) == 2);'), (276, 2, u'-  assert(__fixsfdi(2.0) == 2);'), (277, 2, u'-  assert(__fixdfdi(2.0) == 2);'), (278, 2, u'-  assert(__fixunssfsi(2.0) == 2);'), (279, 2, u'-  assert(__fixunsdfsi(2.0) == 2);'), (280, 2, u'-  assert(__fixunssfdi(2.0) == 2);'), (281, 2, u'-  assert(__fixunsdfdi(2.0) == 2);'), (282, 2, u'-  assert(__floatdisf(2) == 2.0);'), (283, 2, u'-  assert(__floatdidf(2) == 2.0);'), (284, 2, u'-  assert(__floatundisf(2) == 2.0);'), (285, 2, u'-  assert(__floatundidf(2) == 2.0);'), (286, 2, u'-  assert(__powisf2(2.0, 2) == 4.0);'), (287, 2, u'-  assert(__powidf2(2.0, 2) == 4.0);'), (298, 2, u'-  assert(__mulsc3(1.0, 2.0, 4.0, 8.0) == (-12.0 + 16.0j));'), (299, 2, u'-  assert(__muldc3(1.0, 2.0, 4.0, 8.0) == (-12.0 + 16.0j));'), (300, 2, u'-  assert(__divsc3(1.0, 2.0, 4.0, 8.0) == (0.25 + 0j));'), (301, 2, u'-  assert(__divdc3(1.0, 2.0, 4.0, 8.0) == (0.25 + 0j));'), (305, 2, u'-  assert(__divxc3(1.0, 2.0, 4.0, 8.0) == (0.25 + 0j));'), (306, 2, u'-  assert(__fixunsxfdi(2.0) == 2);'), (307, 2, u'-  assert(__fixunsxfsi(2.0) == 2);'), (308, 2, u'-  assert(__fixxfdi(2.0) == 2);'), (309, 2, u'-  assert(__floatdixf(2) == 2.0);'), (310, 2, u'-  assert(__floatundixf(2) == 2);'), (311, 2, u'-  assert(__mulxc3(1.0, 2.0, 4.0, 8.0) == (-12.0 + 16.0j));'), (312, 2, u'-  assert(__powixf2(2.0, 2) == 4.0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 2, u'-    assert (Last && "Got a first node but not a last node for a range!");')]
===========================================
Class:  class Argument {   class Argument 
Class:   class SimpleArgument : public Argument {   class SimpleArgument : public Argument 
Class:   class StringArgument : public Argument {   class StringArgument : public Argument 
Class:   class AlignedArgument : public Argument {   class AlignedArgument : public Argument 
Class:   class VariadicArgument : public Argument {   class VariadicArgument : public Argument 
Class:   class EnumArgument : public Argument {   class EnumArgument : public Argument 
Class:   class VersionArgument : public Argument {   class VersionArgument : public Argument 
Class:   class ExprArgument : public SimpleArgument {   class ExprArgument : public SimpleArgument 
Class:   class VariadicExprArgument : public VariadicArgument {   class VariadicExprArgument : public VariadicArgument 
Class:class DiagGroupParentMap { class DiagGroupParentMap 
Class:  class DiagCategoryIDMap {   class DiagCategoryIDMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(1014, 2, u'-  assert(!proto.empty() && "");'), (1437, 2, u'-        assert(immPos > 0 && "unexpected immediate operand");'), (1478, 2, u'-  assert(!proto.empty() && "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 2, u'-  assert(APrec != BPrec && "Options are equivalent!");')]
===========================================
Class:class ClangTableGenAction : public TableGenAction { class ClangTableGenAction : public TableGenAction 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(369, 2, u'-  assert(code_gen);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(456, 2, u'-  assert(target.get() && "Could not allocate target machine!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(738, 2, u'-    assert(TheArchive && "Unable to instantiate the archive");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 2, u'-  assert(AC && "Invalid component name!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 2, u'-  assert(!Numbering.empty() && "asked for numbering but numbering was no-op");'), (174, 2, u"-    assert(format[percent] == '%');")]
===========================================
Class:template <class T, class Sorter, unsigned InlineCapacity> template <class T, class Sorter, unsigned InlineCapacity>
Class:class PriorityQueue { class PriorityQueue 
Class:  class FunctionDifferenceEngine { class FunctionDifferenceEngine 
Class:class CommentWriter : public AssemblyAnnotationWriter { class CommentWriter : public AssemblyAnnotationWriter 
Class:class VectorMemoryObject : public MemoryObject { class VectorMemoryObject : public MemoryObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(389, 2, u'-  assert(MAI && "Unable to create target asm info!");'), (392, 2, u'-  assert(MRI && "Unable to create target register info!");'), (445, 2, u'-    assert(FileType == OFT_ObjectFile && "Invalid file type!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(145, 2, u'-  assert(bytes.size() <= 15')]
===========================================
Class:  class ProfileAnnotator : public AssemblyAnnotationWriter {   class ProfileAnnotator : public AssemblyAnnotationWriter 
Class:  class ProfileInfoPrinterPass : public ModulePass {   class ProfileInfoPrinterPass : public ModulePass 
Class:     class TrivialMemoryManager : public RTDyldMemoryManager { class TrivialMemoryManager : public RTDyldMemoryManager 
Class:     class Random { class Random 
Class:  class RecordStreamer : public MCStreamer {   class RecordStreamer : public MCStreamer 
Class:  class DomInfoPrinter : public FunctionPass {   class DomInfoPrinter : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(336, 2, u'-  ASSERT_EQ("10", convertToString(10.0, 6, 3));'), (337, 2, u'-  ASSERT_EQ("1.0E+1", convertToString(10.0, 6, 0));'), (338, 2, u'-  ASSERT_EQ("10100", convertToString(1.01E+4, 5, 2));'), (339, 2, u'-  ASSERT_EQ("1.01E+4", convertToString(1.01E+4, 4, 2));'), (340, 2, u'-  ASSERT_EQ("1.01E+4", convertToString(1.01E+4, 5, 1));'), (341, 2, u'-  ASSERT_EQ("0.0101", convertToString(1.01E-2, 5, 2));'), (342, 2, u'-  ASSERT_EQ("0.0101", convertToString(1.01E-2, 4, 2));'), (343, 2, u'-  ASSERT_EQ("1.01E-2", convertToString(1.01E-2, 5, 1));'), (344, 2, u'-  ASSERT_EQ("0.7853981633974483", convertToString(0.78539816339744830961, 0, 3));'), (345, 2, u'-  ASSERT_EQ("4.940656458412465E-324", convertToString(4.9406564584124654e-324, 0, 3));'), (346, 2, u'-  ASSERT_EQ("873.1834", convertToString(873.1834, 0, 1));'), (347, 2, u'-  ASSERT_EQ("8.731834E+2", convertToString(873.1834, 0, 0));'), (408, 2, u'-  ASSERT_EQ(0x7fc00000, nanbits(APFloat::IEEEsingle, false, false, 0));'), (409, 2, u'-  ASSERT_EQ(0xffc00000, nanbits(APFloat::IEEEsingle, false, true, 0));'), (410, 2, u'-  ASSERT_EQ(0x7fc0ae72, nanbits(APFloat::IEEEsingle, false, false, 0xae72));'), (411, 2, u'-  ASSERT_EQ(0x7fffae72, nanbits(APFloat::IEEEsingle, false, false, 0xffffae72));'), (412, 2, u'-  ASSERT_EQ(0x7fa00000, nanbits(APFloat::IEEEsingle, true, false, 0));'), (413, 2, u'-  ASSERT_EQ(0xffa00000, nanbits(APFloat::IEEEsingle, true, true, 0));'), (414, 2, u'-  ASSERT_EQ(0x7f80ae72, nanbits(APFloat::IEEEsingle, true, false, 0xae72));'), (415, 2, u'-  ASSERT_EQ(0x7fbfae72, nanbits(APFloat::IEEEsingle, true, false, 0xffffae72));'), (417, 2, u'-  ASSERT_EQ(0x7ff8000000000000ULL, nanbits(APFloat::IEEEdouble, false, false, 0));'), (418, 2, u'-  ASSERT_EQ(0xfff8000000000000ULL, nanbits(APFloat::IEEEdouble, false, true, 0));'), (419, 2, u'-  ASSERT_EQ(0x7ff800000000ae72ULL, nanbits(APFloat::IEEEdouble, false, false, 0xae72));'), (420, 2, u'-  ASSERT_EQ(0x7fffffffffffae72ULL, nanbits(APFloat::IEEEdouble, false, false, 0xffffffffffffae72ULL));'), (421, 2, u'-  ASSERT_EQ(0x7ff4000000000000ULL, nanbits(APFloat::IEEEdouble, true, false, 0));'), (422, 2, u'-  ASSERT_EQ(0xfff4000000000000ULL, nanbits(APFloat::IEEEdouble, true, true, 0));'), (423, 2, u'-  ASSERT_EQ(0x7ff000000000ae72ULL, nanbits(APFloat::IEEEdouble, true, false, 0xae72));'), (424, 2, u'-  ASSERT_EQ(0x7ff7ffffffffae72ULL, nanbits(APFloat::IEEEdouble, true, false, 0xffffffffffffae72ULL));')]
===========================================
Class:class FixedDAGDeltaAlgorithm : public DAGDeltaAlgorithm { class FixedDAGDeltaAlgorithm : public DAGDeltaAlgorithm 
Class:class FixedDeltaAlgorithm : public DeltaAlgorithm { class FixedDeltaAlgorithm : public DeltaAlgorithm 
Class:class DenseMapTest : public testing::Test { class DenseMapTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(163, 2, u'-    ASSERT_TRUE(visited[i]) << "Entry #" << i << " was never visited";')]
===========================================
Class:class DenseSetTest : public testing::Test { class DenseSetTest : public testing::Test 
Class:class ImmutableSetTest : public testing::Test { class ImmutableSetTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(149, 2, u'-  ASSERT_STREQ("aeiou", buffer);'), (161, 2, u'-  ASSERT_STREQ("bcdfgh", buffer);'), (162, 2, u'-  ASSERT_EQ(6, obj.counter);'), (166, 2, u'-  ASSERT_STREQ("bcd", buffer);'), (167, 2, u'-  ASSERT_EQ(3, obj2.counter);'), (171, 2, u'-  ASSERT_STREQ("", buffer);'), (172, 2, u'-  ASSERT_EQ(0, obj3.counter);'), (184, 2, u'-    ASSERT_EQ(i++, *I);'), (186, 2, u'-  ASSERT_EQ(0, i);'), (190, 2, u'-    ASSERT_EQ(i++, *I);'), (192, 2, u'-  ASSERT_EQ(3, i);'), (196, 2, u'-    ASSERT_EQ(i++, *I);'), (198, 2, u'-  ASSERT_EQ(6, i);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 2, u'-  ASSERT_TRUE(I.valid());'), (94, 2, u'-  ASSERT_TRUE(I.valid());'), (103, 2, u'-  ASSERT_TRUE(I.valid());'), (110, 2, u'-  ASSERT_TRUE(I.valid());'), (116, 2, u'-  ASSERT_TRUE(I.valid());'), (123, 2, u'-  ASSERT_TRUE(I.valid());'), (129, 2, u'-  ASSERT_TRUE(I.valid());'), (204, 2, u'-  ASSERT_TRUE(I.valid());'), (241, 2, u'-  ASSERT_TRUE(I.valid());'), (246, 2, u'-  ASSERT_TRUE(I.valid());'), (260, 2, u'-  ASSERT_TRUE(I.valid());'), (264, 2, u'-  ASSERT_TRUE(I.valid());'), (268, 2, u'-  ASSERT_TRUE(I.valid());'), (272, 2, u'-  ASSERT_TRUE(I.valid());'), (282, 2, u'-  ASSERT_TRUE(I.valid());'), (286, 2, u'-  ASSERT_TRUE(I.valid());'), (290, 2, u'-  ASSERT_TRUE(I.valid());'), (294, 2, u'-  ASSERT_TRUE(I.valid());'), (304, 2, u'-  ASSERT_TRUE(I.valid());'), (308, 2, u'-  ASSERT_TRUE(I.valid());'), (312, 2, u'-  ASSERT_TRUE(I.valid());'), (353, 2, u'-    ASSERT_TRUE(I.valid());'), (365, 2, u'-    ASSERT_TRUE(I.valid());'), (374, 2, u'-  ASSERT_TRUE(I.valid());'), (380, 2, u'-  ASSERT_TRUE(I.valid());'), (387, 2, u'-  ASSERT_TRUE(I.valid());'), (394, 2, u'-  ASSERT_TRUE(I.valid());'), (401, 2, u'-  ASSERT_TRUE(I.valid());'), (408, 2, u'-  ASSERT_TRUE(I.valid());'), (410, 2, u'-  ASSERT_TRUE(I.valid());'), (417, 2, u'-  ASSERT_TRUE(I.valid());'), (423, 2, u'-  ASSERT_TRUE(I.valid());'), (430, 2, u'-  ASSERT_TRUE(I.valid());'), (437, 2, u'-  ASSERT_TRUE(I.valid());'), (444, 2, u'-  ASSERT_TRUE(I.valid());'), (446, 2, u'-  ASSERT_TRUE(I.valid());'), (492, 2, u'-    ASSERT_TRUE(I.valid());'), (504, 2, u'-    ASSERT_TRUE(I.valid());'), (513, 2, u'-  ASSERT_TRUE(I.valid());'), (519, 2, u'-  ASSERT_TRUE(I.valid());'), (525, 2, u'-  ASSERT_TRUE(I.valid());'), (593, 2, u'-  ASSERT_TRUE(AB.valid());'), (600, 2, u'-  ASSERT_TRUE(BA.valid());'), (636, 2, u'-  ASSERT_TRUE(AB.valid());'), (640, 2, u'-  ASSERT_TRUE(AB.valid());'), (644, 2, u'-  ASSERT_TRUE(AB.valid());'), (648, 2, u'-  ASSERT_TRUE(AB.valid());'), (652, 2, u'-  ASSERT_TRUE(AB.valid());'), (656, 2, u'-  ASSERT_TRUE(AB.valid());'), (665, 2, u'-  ASSERT_TRUE(AB2.valid());'), (671, 2, u'-  ASSERT_TRUE(AB2.valid());'), (677, 2, u'-  ASSERT_TRUE(BA.valid());'), (681, 2, u'-  ASSERT_TRUE(BA.valid());'), (685, 2, u'-  ASSERT_TRUE(BA.valid());'), (689, 2, u'-  ASSERT_TRUE(BA.valid());'), (693, 2, u'-  ASSERT_TRUE(BA.valid());'), (697, 2, u'-  ASSERT_TRUE(BA.valid());'), (706, 2, u'-  ASSERT_TRUE(BA2.valid());'), (711, 2, u'-  ASSERT_TRUE(BA2.valid());')]
===========================================
Class:class Graph { class Graph 
Class:  class NodeSubset {   class NodeSubset 
Class:      class ChildIterator {   class ChildIterator 
Class:class SmallStringTest : public testing::Test { class SmallStringTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 2, u'-  void assertEmpty(StringType & v) {'), (43, 2, u'-  assertEmpty(theString);')]
===========================================
Class:class Constructable { class Constructable 
Class:  class SmallVectorTest : public testing::Test { class SmallVectorTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(174, 2, u'-  ASSERT_TRUE(I == Set.begin());'), (180, 2, u'-  ASSERT_TRUE(I == Set.begin());')]
===========================================
Class:class StringMapTest : public testing::Test { class StringMapTest : public testing::Test 
Class:class StringMapEntryInitializer<uint32_t> { class StringMapEntryInitializer<uint32_t> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 2, u'-  void assertEmptyMap() {'), (46, 2, u'-  void assertSingleItemMap() {'), (79, 2, u'-  assertEmptyMap();'), (107, 2, u'-  assertSingleItemMap();'), (115, 2, u'-  assertEmptyMap();'), (123, 2, u'-  assertEmptyMap();'), (131, 2, u'-  assertEmptyMap();'), (140, 2, u'-  assertSingleItemMap();'), (160, 2, u'-    ASSERT_STREQ(ss.str().c_str(), it->first().data());'), (166, 2, u'-    ASSERT_TRUE(visited[i]) << "Entry #" << i << " was never visited";'), (204, 2, u'-  assertSingleItemMap();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(366, 2, u'-      ASSERT_FALSE(U8Success);'), (369, 2, u'-      ASSERT_TRUE(U8Success);'), (373, 2, u'-      ASSERT_FALSE(U16Success);'), (376, 2, u'-      ASSERT_TRUE(U16Success);'), (380, 2, u'-      ASSERT_FALSE(U32Success);'), (383, 2, u'-      ASSERT_TRUE(U32Success);'), (387, 2, u'-      ASSERT_FALSE(U64Success);'), (390, 2, u'-      ASSERT_TRUE(U64Success);'), (402, 2, u'-      ASSERT_FALSE(S8Success);'), (405, 2, u'-      ASSERT_TRUE(S8Success);'), (409, 2, u'-      ASSERT_FALSE(S16Success);'), (412, 2, u'-      ASSERT_TRUE(S16Success);'), (416, 2, u'-      ASSERT_FALSE(S32Success);'), (419, 2, u'-      ASSERT_TRUE(S32Success);'), (423, 2, u'-      ASSERT_FALSE(S64Success);'), (426, 2, u'-      ASSERT_TRUE(S64Success);')]
===========================================
Class:class ScalarEvolutionsTest : public testing::Test { class ScalarEvolutionsTest : public testing::Test 
Class:class ExecutionEngineTest : public testing::Test { class ExecutionEngineTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 2, u'-    ASSERT_TRUE(Engine.get() != NULL) << "EngineBuilder returned error: \'"')]
===========================================
Class: class IntelJITEventListenerTest   : public JITEventListenerTestBase<IntelJITEventsWrapper> {   : public JITEventListenerTestBase<IntelJITEventsWrapper> 
Class:class JITEventListenerTest : public testing::Test { class JITEventListenerTest : public testing::Test 
Class: class JITEnvironment : public testing::Environment { class JITEnvironment : public testing::Environment 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 2, u'-  ASSERT_EQ(2U, Listener.EmittedEvents.size());'), (102, 2, u'-  ASSERT_EQ(2U, Listener.FreedEvents.size());'), (154, 2, u'-  ASSERT_EQ(1U, Listener1.EmittedEvents.size());'), (155, 2, u'-  ASSERT_EQ(1U, Listener1.FreedEvents.size());'), (168, 2, u'-  ASSERT_EQ(2U, Listener2.EmittedEvents.size());'), (169, 2, u'-  ASSERT_EQ(1U, Listener2.FreedEvents.size());'), (189, 2, u'-  ASSERT_EQ(1U, Listener3.EmittedEvents.size());'), (190, 2, u'-  ASSERT_EQ(1U, Listener3.FreedEvents.size());'), (216, 2, u'-  ASSERT_EQ(1U, Listener.EmittedEvents.size());'), (217, 2, u'-  ASSERT_EQ(1U, Listener.FreedEvents.size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 2, u'-  ASSERT_LE(bigFuncSize, size);'), (95, 2, u'-  ASSERT_LE(bigFuncSize, size);'), (103, 2, u'-  ASSERT_LE(bigFuncSize, size);'), (115, 2, u'-  ASSERT_LE(smallFuncSize, size);'), (124, 2, u'-  ASSERT_LE(smallFuncSize, size);'), (133, 2, u'-  ASSERT_LE(smallFuncSize, size);')]
===========================================
Class:class RecordingJITMemoryManager : public JITMemoryManager { class RecordingJITMemoryManager : public JITMemoryManager 
Class: class JITTest : public testing::Test { class JITTest : public testing::Test 
Class:class JITEnvironment : public testing::Environment { class JITEnvironment : public testing::Environment 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(214, 2, u'-    ASSERT_TRUE(TheJIT.get() != NULL) << Error;'), (248, 2, u'-  ASSERT_EQ(Error, "");'), (270, 2, u'-  ASSERT_NE((int32_t*)NULL, GPtr);'), (519, 2, u'-  ASSERT_EQ(stubsBefore, RJMM->stubsAllocated);'), (729, 2, u'-  ASSERT_FALSE(Bitcode.empty()) << "Assembling failed";'), (732, 2, u'-  ASSERT_TRUE(TheJIT.get()) << "Failed to create JIT.";'), (768, 2, u'-  ASSERT_FALSE(Bitcode.empty()) << "Assembling failed";'), (771, 2, u'-  ASSERT_TRUE(TheJIT.get()) << "Failed to create JIT.";')]
===========================================
Class: class OProfileJITEventListenerTest : public JITEventListenerTestBase<OProfileWrapper> { 
Class:class MockSlabAllocator : public SlabAllocator { class MockSlabAllocator : public SlabAllocator 
Class:class TempEnvVar { class TempEnvVar 
Class:class ConstantRangeTest : public ::testing::Test { class ConstantRangeTest : public ::testing::Test 
Class:class IRBuilderTest : public testing::Test { class IRBuilderTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 2, u'-  ASSERT_TRUE(II_Start1 != NULL);'), (70, 2, u'-  ASSERT_TRUE(II_End1 != NULL);')]
===========================================
Class:class MDBuilderTest : public testing::Test { class MDBuilderTest : public testing::Test 
Class:class FileSystemTest : public testing::Test { class FileSystemTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(20, 2, u'-#define ASSERT_NO_ERROR(x) \\'), (21, 2, u'-  if (error_code ASSERT_NO_ERROR_ec = x) { \\'), (96, 2, u'-      ASSERT_FALSE(ci->empty());'), (129, 2, u'-    ASSERT_NO_ERROR(fs::make_absolute(temp_store));'), (152, 2, u'-    ASSERT_NO_ERROR('), (164, 2, u'-    ASSERT_NO_ERROR(fs::remove_all(TestDirectory.str(), removed));'), (172, 2, u'-  ASSERT_NO_ERROR('), (177, 2, u'-  ASSERT_NO_ERROR(sys::fs::exists(Twine(TempPath), TempFileExists));'), (183, 2, u'-  ASSERT_NO_ERROR(fs::unique_file("%%-%%-%%-%%.temp", FD2, TempPath2));'), (184, 2, u'-  ASSERT_NE(TempPath.str(), TempPath2.str());'), (187, 2, u'-  ASSERT_NO_ERROR(fs::status(Twine(TempPath), A));'), (188, 2, u'-  ASSERT_NO_ERROR(fs::status(Twine(TempPath2), B));'), (197, 2, u'-  ASSERT_NO_ERROR(fs::copy_file(Twine(TempPath), Twine(TempPath2),'), (200, 2, u'-  ASSERT_NO_ERROR(fs::remove(Twine(TempPath2), TempFileExists));'), (204, 2, u'-  ASSERT_NO_ERROR(fs::exists(Twine(TempPath2), TempFileExists));'), (208, 2, u'-  ASSERT_NO_ERROR(fs::create_hard_link(Twine(TempPath), Twine(TempPath2)));'), (210, 2, u'-  ASSERT_NO_ERROR(fs::equivalent(Twine(TempPath), Twine(TempPath2), equal));'), (212, 2, u'-  ASSERT_NO_ERROR(fs::status(Twine(TempPath), A));'), (213, 2, u'-  ASSERT_NO_ERROR(fs::status(Twine(TempPath2), B));'), (218, 2, u'-  ASSERT_NO_ERROR(fs::remove(Twine(TempPath), TempFileExists));'), (222, 2, u'-  ASSERT_NO_ERROR(fs::remove(Twine(TempPath2), TempFileExists));'), (226, 2, u'-  ASSERT_NO_ERROR(fs::exists(Twine(TempPath), TempFileExists));'), (233, 2, u'-    ASSERT_NO_ERROR(ec);'), (237, 2, u'-  ASSERT_NO_ERROR(fs::create_directories(Twine(TestDirectory)'), (239, 2, u'-  ASSERT_NO_ERROR(fs::create_directories(Twine(TestDirectory)'), (241, 2, u'-  ASSERT_NO_ERROR(fs::create_directories(Twine(TestDirectory)'), (243, 2, u'-  ASSERT_NO_ERROR(fs::create_directories(Twine(TestDirectory)'), (245, 2, u'-  ASSERT_NO_ERROR(fs::create_directories(Twine(TestDirectory)'), (251, 2, u'-    ASSERT_NO_ERROR(ec);'), (273, 2, u'-  ASSERT_NE(a0, visited.end());'), (274, 2, u'-  ASSERT_NE(aa1, visited.end());'), (275, 2, u'-  ASSERT_NE(ab1, visited.end());'), (276, 2, u'-  ASSERT_NE(dontlookhere, visited.end());'), (277, 2, u'-  ASSERT_EQ(da1, visited.end()); // Not visited.'), (278, 2, u'-  ASSERT_NE(z0, visited.end());'), (279, 2, u'-  ASSERT_NE(za1, visited.end());'), (280, 2, u'-  ASSERT_NE(pop, visited.end());'), (281, 2, u'-  ASSERT_EQ(p1, visited.end()); // Not visited.'), (285, 2, u'-  ASSERT_LT(a0, aa1);'), (286, 2, u'-  ASSERT_LT(a0, ab1);'), (287, 2, u'-  ASSERT_LT(z0, za1);'), (305, 2, u'-    ASSERT_FALSE(file.has_error());'), (310, 2, u'-    ASSERT_NO_ERROR(fs::has_magic(file_pathname.c_str(), magic, res));')]
===========================================
Class:class RegexTest : public ::testing::Test { class RegexTest : public ::testing::Test 
Class:class MyType { class MyType 
Class: class MyPortableType { class MyPortableType 
Class:class ValueHandle : public testing::Test { class ValueHandle : public testing::Test 
Class: class ConcreteCallbackVH : public CallbackVH { class ConcreteCallbackVH : public CallbackVH 
Class:  class RecordingVH : public CallbackVH {   class RecordingVH : public CallbackVH 
Class:  class RecordingVH : public CallbackVH {   class RecordingVH : public CallbackVH 
Class:  class RecoveringVH : public CallbackVH {   class RecoveringVH : public CallbackVH 
Class:  class DestroyingVH : public CallbackVH {   class DestroyingVH : public CallbackVH 
Class:  class ClearingVH : public CallbackVH {   class ClearingVH : public CallbackVH 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 2, u'-  assert(BytesLeftInBuffer < 256 && "Invalid buffer count!");')]
===========================================
Class:class CloneInstruction : public ::testing::Test { class CloneInstruction : public ::testing::Test 
Class:class MetadataTest : public testing::Test { class MetadataTest : public testing::Test 
Class:class ValueMapTest : public testing::Test { class ValueMapTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 2, u'-  ASSERT_TRUE(I != VM.end());'), (84, 2, u'-  ASSERT_TRUE(CI != CVM.end());'), (120, 2, u'-void CompileAssertHasType(VarType) {'), (121, 2, u'-  typedef char assert[is_same<ExpectedType, VarType>::value ? 1 : -1];'), (133, 2, u'-    CompileAssertHasType<TypeParam*>(I->first);'), (155, 2, u'-    CompileAssertHasType<TypeParam*>(I->first);')]
===========================================
Class:     class Pattern { class Pattern 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(336, 2, u'-  assert(!MatchInfo.empty() && "Didn\'t get any match");'), (341, 2, u'-    assert(VariableDefs[i].second < MatchInfo.size() &&'), (712, 2, u'-      assert(LastMatch != F->getBufferStart() &&')]
===========================================
Class:  class ScopedHandle {   class ScopedHandle 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(116, 2, u'-    assert(TheOperators.back() == this);'), (138, 2, u'-        assert(SrcElt == 8 && "Bad src elt!");'), (153, 2, u'-    assert(0 && "bad zero cost operation");'), (395, 2, u'-    assert(OpNum < 16 && "Too few bits to encode operation!");')]
===========================================
Class:class AsmMatcherInfo;
Class:  class AsmMatcherInfo { class AsmMatcherInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(218, 2, u'-    assert(isUserClass() && RHS.isUserClass() && "Unexpected class!");'), (630, 2, u'-    assert(Def->isSubClassOf("Predicate") && "Invalid predicate type!");'), (706, 2, u'-      assert(i != String.size() && "Invalid quoted character");'), (724, 2, u'-      assert(End != String.end() && "Missing brace in operand reference!");'), (923, 2, u'-  assert(Rec->isSubClassOf("Operand") && "Unexpected operand!");'), (1046, 2, u'-    assert(CI && "Missing singleton register class info!");'), (1095, 2, u'-      assert(dynamic_cast<UnsetInit*>(PMName) &&'), (1105, 2, u'-      assert(dynamic_cast<UnsetInit*>(RMName) &&'), (1175, 2, u'-    assert(FeatureNo < 32 && "Too many subtarget features!");'), (1289, 2, u'-        assert(Op.Class && Op.Class->Registers.size() == 1 &&'), (1363, 2, u'-    assert(Rec->isSubClassOf("Operand") && "Unexpected operand!");'), (1461, 2, u'-      assert(AsmOperands[SrcOperand+AI].SubOpIdx == (int)AI &&'), (1612, 2, u'-        assert(i > TiedOp && "Tied operand precedes its target!");'), (2018, 2, u'-  assert(Range < 0xFFFFFFFFULL && "Enum too large");')]
===========================================
Class:class IAPrinter { class IAPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(370, 2, u'-          assert(NumOps <= Inst->Operands.size() &&'), (412, 2, u'-    assert(NumBits <= BitsLeft && "consistency error");'), (796, 2, u'-            assert(Rec->isSubClassOf("Operand") && "Unexpected operand!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(111, 2, u'-    assert(!CGI.Operands.isFlatOperandNotEmitted(OpIdx) &&')]
===========================================
Class:     class InstAnalyzer { class InstAnalyzer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(145, 2, u'-  assert(!Name.empty() && "Cannot search for operand with no name!");'), (221, 2, u'-  assert(pos != std::string::npos && "Unrecognized constraint");'), (344, 2, u'-  assert(FirstImplicitDef->isSubClassOf("Register"));'), (392, 2, u'-    assert(VariantsEnd != Cur.size() &&')]
===========================================
Class:class RegUnitIterator { class RegUnitIterator 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(112, 2, u'-  unsigned operator* () const { assert(isValid()); return *UnitI; };'), (114, 2, u'-  const CodeGenRegister *getReg() const { assert(isValid()); return *RegI; }'), (118, 2, u'-    assert(isValid() && "Cannot advance beyond the last operand");'), (320, 2, u'-  assert(RegUnits.empty() && "Should only initialize RegUnits once");'), (331, 2, u'-  assert(SubRegsComplete && "Must precompute sub-registers");'), (480, 2, u'-  assert(!VTs.empty() && "RegisterClass must contain at least one ValueType!");'), (558, 2, u'-  assert(!getDef() && "Only synthesized classes can inherit properties");'), (559, 2, u'-  assert(!SuperClasses.empty() && "Synthesized class without super class");'), (599, 2, u'-  assert(Members && B.Members);'), (953, 2, u'-  assert(Registers.size() == Registers[Registers.size()-1]->EnumValue &&'), (970, 2, u'-    assert(USetID && "register number 0 is invalid");'), (1117, 2, u'-  assert(RegUnitWeights.empty() && "Only initialize RegUnitWeights once");'), (1133, 2, u'-    assert(NumIters <= NumNativeRegUnits && "Runaway register unit weights");'), (1166, 2, u'-  assert(RegClassUnitSets.empty() && "this invalidates RegClassUnitSets");'), (1236, 2, u'-    assert(Idx < (2*NumRegUnitSubSets) && "runaway unit set inference");'), (1293, 2, u'-    assert(!RegClassUnitSets[RCIdx].empty() && "missing unit set for regclass");'), (1330, 2, u'-  assert(Map.empty());'), (1490, 2, u'-      assert(Sub && "Missing sub-register");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(298, 2, u'-    assert(Instr && "Missing target independent instruction");'), (299, 2, u'-    assert(Instr->Namespace == "TargetOpcode" && "Bad namespace");'), (311, 2, u'-  assert(InstrsByEnum.size() == Insts.size() && "Missing predefined instr");'), (431, 2, u'-    assert(TyEl->isSubClassOf("LLVMType") && "Expected a type!");'), (435, 2, u'-      assert(MatchTy < OverloadedVTs.size() &&'), (441, 2, u'-      assert(((!TyEl->isSubClassOf("LLVMExtendedElementVectorType") &&'), (465, 2, u'-    assert(TyEl->isSubClassOf("LLVMType") && "Expected a type!");'), (469, 2, u'-      assert(MatchTy < OverloadedVTs.size() &&'), (475, 2, u'-      assert(((!TyEl->isSubClassOf("LLVMExtendedElementVectorType") &&'), (499, 2, u'-    assert(Property->isSubClassOf("IntrinsicProperty") &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 2, u'-    assert(LHS == RHS || LHS->ID != RHS->ID);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(57, 2, u'-    assert(Other && "Other didn\'t come before \'this\'?");')]
===========================================
Class:class MatcherTableEmitter { class MatcherTableEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(145, 2, u'-    assert(SM->getNext() == 0 && "Shouldn\'t have next after scope");'), (180, 2, u'-      assert(ChildSize != 0 && "Should not have a zero-sized child!");'), (315, 2, u'-      assert(ChildSize != 0 && "Should not have a zero-sized child!");'), (354, 2, u'-    assert(cast<CheckTypeMatcher>(N)->getResNo() == 0 &&'), (626, 2, u'-      assert(!PredFn.isAlwaysTrue() && "No code in this predicate");')]
===========================================
Class:  class MatcherGen {   class MatcherGen 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(449, 2, u'-      assert(Opcodes.insert(COM->getOpcode().getEnumName()) &&')]
===========================================
Class:class State { class State 
Class:class DFA { class DFA 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(226, 2, u'-  assert(!states.count(S) && "State already exists");'), (300, 2, u'-      assert (((*SI)->stateNum == (int) i) && "Mismatch in state numbers");'), (392, 2, u'-      assert(NameToBitsMap.count(UnitName));')]
===========================================
Class:  class EnumEmitter {   class EnumEmitter 
Class:   class ConstantEmitter {   class ConstantEmitter 
Class:   class LiteralConstantEmitter : public ConstantEmitter {   class LiteralConstantEmitter : public ConstantEmitter 
Class:   class CompoundConstantEmitter : public ConstantEmitter {   class CompoundConstantEmitter : public ConstantEmitter 
Class:   class FlagsConstantEmitter : public ConstantEmitter {   class FlagsConstantEmitter : public ConstantEmitter 
Class:class ImmPredicateSet { class ImmPredicateSet 
Class:  class OpKind {   class OpKind 
Class: class FastISelMap { class FastISelMap 
Class:                                     class Filter { class Filter 
Class:                class FilterChooser { class FilterChooser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(113, 2, u'-      assert(!Inst.Operands[i].OperandType.empty() && "Invalid operand type.");'), (126, 2, u'-        assert(Constraint.isTied());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(203, 2, u'-    assert(false && "Unsupported ValueType!");'), (236, 2, u'-    assert(Number < ArgNo && "Invalid matching number!");'), (358, 2, u'-        assert(Number < OverloadedTypeIndices.size() &&'), (386, 2, u'-        assert(Number < OverloadedTypeIndices.size() &&'), (532, 2, u'-    assert(AttrNum < 256 && "Too many unique attributes for table!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 2, u'-      assert(BaseIdx == 0 && "Named subargument in pseudo expansion?!");'), (81, 2, u'-  assert(Dag && "Missing result instruction in pseudo expansion!");'), (225, 2, u'-  assert(ExpansionClass && "PseudoInstExpansion class definition missing!");'), (226, 2, u'-  assert(InstructionClass && "Instruction class definition missing!");')]
===========================================
Class:  class BitVectorEmitter { class BitVectorEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 2, u'-  assert(Registers.size() <= 0xffff && "Too many regs to fit in tables");'), (59, 2, u'-  assert(Registers.size() == Registers[Registers.size()-1]->EnumValue &&'), (70, 2, u'-    assert(RegisterClasses.size() <= 0xffff &&'), (409, 2, u'-  assert(Width <= 32 && "Width too large");'), (574, 2, u'-    assert((RC.SpillSize/8) <= 0xffff && "SpillSize too large.");'), (575, 2, u'-    assert((RC.SpillAlignment/8) <= 0xffff && "SpillAlignment too large.");'), (576, 2, u'-    assert(RC.CopyCost >= -128 && RC.CopyCost <= 127 && "Copy cost too large.");'), (760, 2, u'-          assert(RC2 && "Invalid register class in SubRegClasses");'), (1083, 2, u'-    assert(Regs && "Cannot expand CalleeSavedRegs instance");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 2, u'-  assert(!Matches.empty());'), (46, 2, u'-  assert(!Matches.empty() && "Must have at least one string to match!");'), (52, 2, u'-    assert(Matches.size() == 1 && "Had duplicate keys to match on");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(511, 2, u'-    assert(ItinList.size() == ItinClassList.size() && "bad itinerary");')]
===========================================
Class:class Type { class Type 
Class: class ExtendedVectorType : public Type { class ExtendedVectorType : public Type 
Class:  class LLVMTableGenAction : public TableGenAction {   class LLVMTableGenAction : public TableGenAction 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(174, 2, u'-          assert(Elts && "Couldn\'t expand Set instance");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(180, 2, u'-  assert(width <= 8 && "Field is too large for uint8_t!");'), (522, 2, u'-    assert(physicalOperandIndex < numPhysicalOperands);'), (576, 2, u'-  assert(numOperands <= X86_MAX_OPERANDS && "X86_MAX_OPERANDS is not large enough");'), (632, 2, u'-    assert(numPhysicalOperands <= 2 &&'), (640, 2, u'-    assert(numPhysicalOperands >= 1 && numPhysicalOperands <= 2 &&'), (651, 2, u'-      assert(numPhysicalOperands >= 3 && numPhysicalOperands <= 4 &&'), (654, 2, u'-      assert(numPhysicalOperands >= 2 && numPhysicalOperands <= 3 &&'), (673, 2, u'-      assert(numPhysicalOperands >= 3 && numPhysicalOperands <= 4 &&'), (676, 2, u'-      assert(numPhysicalOperands >= 2 && numPhysicalOperands <= 3 &&'), (695, 2, u'-      assert(numPhysicalOperands >= 3 && numPhysicalOperands <= 5 &&'), (698, 2, u'-      assert(numPhysicalOperands >= 2 && numPhysicalOperands <= 3 &&'), (727, 2, u'-      assert(numPhysicalOperands >= 3 && numPhysicalOperands <= 5 &&'), (730, 2, u'-      assert(numPhysicalOperands >= 2 && numPhysicalOperands <= 3 &&'), (763, 2, u'-      assert(numPhysicalOperands <= 3 &&'), (766, 2, u'-      assert(numPhysicalOperands <= 2 &&'), (784, 2, u'-      assert(numPhysicalOperands >= 2 && numPhysicalOperands <= 3 &&'), (787, 2, u'-      assert(numPhysicalOperands >= 1 && numPhysicalOperands <= 2 &&'), (797, 2, u'-    assert(numPhysicalOperands == 2 &&'), (952, 2, u'-    assert(Opcode >= 0xc0 && "Unexpected opcode for an escape opcode");'), (1017, 2, u'-  assert(opcodeType != (OpcodeType)-1 &&'), (1019, 2, u'-  assert(filter && "Filter not set");'), (1023, 2, u'-      assert(opcodeToSet < 0xf9 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 2, u'-    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);'), (37, 2, u'-    _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);')]
===========================================
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-            BOOST_ASSERT(current_thread_tls_key!=tls_out_of_index);'), (3, 1, u'+            BOOST_ASSERT(current_thread_tls_key!=TLS_OUT_OF_INDEXES);')]
===========================================
===========================================
Total add: 1
Total del: 1
Header: namespace boost
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-            BOOST_ASSERT(current_thread_tls_key!=tls_out_of_index);'), (3, 1, u'+            BOOST_ASSERT(current_thread_tls_key!=TLS_OUT_OF_INDEXES);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-            BOOST_ASSERT(current_thread_tls_key!=tls_out_of_index);'), (3, 1, u'+            BOOST_ASSERT(current_thread_tls_key!=TLS_OUT_OF_INDEXES);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  X_ASSERT( unit );')]
===========================================
===========================================
Total add: 18
Total del: 3
Header: ClangCompleter::UpdateTranslationUnit
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  X_ASSERT( unit );')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  X_ASSERT( unit );')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  X_ASSERT( unit );')]
===========================================
===========================================
Total add: 3
Total del: 1
Header: ClangCompleter::CandidatesForLocationInFile
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  X_ASSERT( unit );')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 2, u'-  X_ASSERT( unit );')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 1, u'+  X_ASSERT( unit );')]
===========================================
===========================================
Total add: 6
Total del: 20
Header: ClangCompleter::UpdateTranslationUnit
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 1, u'+  X_ASSERT( unit );')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 1, u'+  X_ASSERT( unit );')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+  X_ASSERT( unit );')]
===========================================
===========================================
Total add: 7
Total del: 27
Header: ClangCompleter::CandidatesForLocationInFile
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+  X_ASSERT( unit );')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+  X_ASSERT( unit );')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+namespace assert_ns'), (38, 1, u'+Assert::FailBehavior DefaultHandler(const char* condition,'), (53, 1, u'+  return Assert::Halt;'), (56, 1, u'+Assert::Handler& GetAssertHandlerInstance()'), (58, 1, u'+  static Assert::Handler s_handler = &DefaultHandler;'), (64, 1, u'+Assert::Handler Assert::GetHandler()'), (66, 1, u'+  return GetAssertHandlerInstance();'), (69, 1, u'+void Assert::SetHandler(Assert::Handler newHandler)'), (71, 1, u'+  GetAssertHandlerInstance() = newHandler;'), (74, 1, u'+Assert::FailBehavior Assert::ReportFailure(const char* condition,'), (99, 1, u'+  return GetAssertHandlerInstance()(condition, message, file, line);')]
===========================================
Class:  class codecvt_error_cat : public boost::system::error_category   class codecvt_error_cat : public boost::system::error_category
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(439, 1, u'+      BOOST_ASSERT(infile >= 0);'), (848, 1, u'+    BOOST_ASSERT_MSG(result.is_absolute(), "canonical() implementation error; please report");'), (1372, 1, u'+    BOOST_ASSERT_MSG(!((prms & add_perms) && (prms & remove_perms)),'), (1961, 1, u'+    BOOST_ASSERT(buffer != 0);'), (2169, 1, u'+    BOOST_ASSERT_MSG(it.m_imp.get(), "attempt to increment end iterator");'), (2170, 1, u'+    BOOST_ASSERT_MSG(it.m_imp->handle != 0, "internal program error");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(470, 1, u'+    BOOST_ASSERT_MSG(!str.empty() && is_separator(str[pos]),'), (653, 1, u'+        BOOST_ASSERT(first2->native() == first1->native());'), (691, 1, u'+    BOOST_ASSERT_MSG(it.m_pos < it.m_path_ptr->m_pathname.size(),'), (750, 1, u'+    BOOST_ASSERT_MSG(it.m_pos, "path::iterator decrement past begin()");'), (888, 1, u'+    BOOST_ASSERT_MSG(codecvt_facet_ptr(), "codecvt_facet_ptr() facet hasn\'t been properly initialized");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(138, 1, u'+    BOOST_ASSERT(from);'), (172, 1, u'+    BOOST_ASSERT(from);')]
===========================================
Class:  class generic_error_category : public error_category   class generic_error_category : public error_category
Class:   class system_error_category : public error_category   {   
Class:    class  future_error_category :     class  future_error_category :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 2, u'-\t\t\t\tBOOST_ASSERT(current_thread_tls_key!=0xFFFFFFFF);'), (6, 2, u'-\t\t\t\tBOOST_ASSERT(current_thread_tls_key!=TLS_OUT_OF_INDEXES);'), (8, 1, u'+            BOOST_ASSERT(current_thread_tls_key!=tls_out_of_index);')]
===========================================
===========================================
Total add: 1
Total del: 6
Header: namespace boost
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 2, u'-\t\t\t\tBOOST_ASSERT(current_thread_tls_key!=0xFFFFFFFF);'), (6, 2, u'-\t\t\t\tBOOST_ASSERT(current_thread_tls_key!=TLS_OUT_OF_INDEXES);'), (8, 1, u'+            BOOST_ASSERT(current_thread_tls_key!=tls_out_of_index);')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 2, u'-\t\t\t\tBOOST_ASSERT(current_thread_tls_key!=0xFFFFFFFF);'), (6, 2, u'-\t\t\t\tBOOST_ASSERT(current_thread_tls_key!=TLS_OUT_OF_INDEXES);'), (8, 1, u'+            BOOST_ASSERT(current_thread_tls_key!=tls_out_of_index);')]
===========================================
Class: class Access { class Access 
Class:   class S {   class S 
Class: class X { class X 
Class:  class Bar {   class Bar 
Class: template <template <class> class T> template <class F> void X2<T>::Bar<F>::Func() {} void X2<T>::Bar<F>::Func() 
Class:class PrintFunctionsConsumer : public ASTConsumer { class PrintFunctionsConsumer : public ASTConsumer 
Class: class PrintFunctionNamesAction : public PluginASTAction { class PrintFunctionNamesAction : public PluginASTAction 
Class:class MainCallChecker : public Checker < check::PreStmt<CallExpr> > { class MainCallChecker : public Checker < check::PreStmt<CallExpr> > 
Class:class CaptureDiagnosticConsumer : public DiagnosticConsumer { class CaptureDiagnosticConsumer : public DiagnosticConsumer 
Class:class ARCMTMacroTrackerPPCallbacks : public PPCallbacks { class ARCMTMacroTrackerPPCallbacks : public PPCallbacks 
Class: class ARCMTMacroTrackerAction : public ASTFrontendAction { class ARCMTMacroTrackerAction : public ASTFrontendAction 
Class: class RewritesApplicator : public TransformActions::RewriteReceiver { class RewritesApplicator : public TransformActions::RewriteReceiver 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+  assert(ToFromMappings.empty());'), (45, 1, u'+  assert(!outputDir.empty());'), (60, 1, u'+  assert(FromToMappings.empty() &&'), (247, 1, u'+  assert(file);'), (254, 1, u'+  assert(file && newfile);'), (269, 1, u'+    assert(FromToMappings.find(file) != FromToMappings.end() &&')]
===========================================
Class:class ObjCMigrateASTConsumer : public ASTConsumer { class ObjCMigrateASTConsumer : public ASTConsumer 
Class:class ObjCMigrator : public RecursiveASTVisitor<ObjCMigrator> { class ObjCMigrator : public RecursiveASTVisitor<ObjCMigrator> 
Class:class RewritesReceiver : public edit::EditsReceiver { class RewritesReceiver : public edit::EditsReceiver 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+  assert(I != FIDs.end());')]
===========================================
Class:class APIChecker : public RecursiveASTVisitor<APIChecker> { class APIChecker : public RecursiveASTVisitor<APIChecker> 
Class:class ARCAssignChecker : public RecursiveASTVisitor<ARCAssignChecker> { class ARCAssignChecker : public RecursiveASTVisitor<ARCAssignChecker> 
Class:class ReleaseCollector : public RecursiveASTVisitor<ReleaseCollector> { class ReleaseCollector : public RecursiveASTVisitor<ReleaseCollector> 
Class:class AutoreleasePoolRewriter class AutoreleasePoolRewriter
Class:class RootBlockObjCVarRewriter : class RootBlockObjCVarRewriter :
Class:  class BlockVarChecker : public RecursiveASTVisitor<BlockVarChecker> {   class BlockVarChecker : public RecursiveASTVisitor<BlockVarChecker> 
Class: class BlockObjCVarRewriter : public RecursiveASTVisitor<BlockObjCVarRewriter> { class BlockObjCVarRewriter : public RecursiveASTVisitor<BlockObjCVarRewriter> 
Class:class EmptyChecker : public StmtVisitor<EmptyChecker, bool> { class EmptyChecker : public StmtVisitor<EmptyChecker, bool> 
Class: class EmptyStatementsRemover :                             public RecursiveASTVisitor<EmptyStatementsRemover> {                             public RecursiveASTVisitor<EmptyStatementsRemover> 
Class:class GCAttrsCollector : public RecursiveASTVisitor<GCAttrsCollector> { class GCAttrsCollector : public RecursiveASTVisitor<GCAttrsCollector> 
Class:class GCCollectableCallsChecker : class GCCollectableCallsChecker :
Class:class PropertiesRewriter { class PropertiesRewriter 
Class:  class PlusOneAssign : public RecursiveASTVisitor<PlusOneAssign> {   class PlusOneAssign : public RecursiveASTVisitor<PlusOneAssign> 
Class:class RetainReleaseDeallocRemover : class RetainReleaseDeallocRemover :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(255, 1, u'+    assert(E);')]
===========================================
Class:class UnbridgedCastRewriter : public RecursiveASTVisitor<UnbridgedCastRewriter>{ class UnbridgedCastRewriter : public RecursiveASTVisitor<UnbridgedCastRewriter>
Class:class UnusedInitRewriter : public RecursiveASTVisitor<UnusedInitRewriter> { class UnusedInitRewriter : public RecursiveASTVisitor<UnusedInitRewriter> 
Class:class ZeroOutInDeallocRemover : class ZeroOutInDeallocRemover :
Class:class TransformActionsImpl { class TransformActionsImpl 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(69, 1, u'+      assert(beginLoc.isValid() && endLoc.isValid());'), (77, 1, u'+      assert(Begin.isValid() && End.isValid());'), (184, 1, u'+  assert(!IsInTransaction &&'), (190, 1, u'+  assert(IsInTransaction && "No transaction started");'), (215, 1, u'+      assert(act.S);'), (279, 1, u'+  assert(IsInTransaction && "No transaction started");'), (285, 1, u'+  assert(IsInTransaction && "Actions only allowed during a transaction");'), (295, 1, u'+  assert(IsInTransaction && "Actions only allowed during a transaction");'), (305, 1, u'+  assert(IsInTransaction && "Actions only allowed during a transaction");'), (313, 1, u'+  assert(IsInTransaction && "Actions only allowed during a transaction");'), (321, 1, u'+  assert(IsInTransaction && "Actions only allowed during a transaction");'), (329, 1, u'+  assert(IsInTransaction && "Actions only allowed during a transaction");'), (350, 1, u'+  assert(IsInTransaction && "Actions only allowed during a transaction");'), (359, 1, u'+  assert(IsInTransaction && "Actions only allowed during a transaction");'), (369, 1, u'+  assert(IsInTransaction && "Actions only allowed during a transaction");'), (449, 1, u'+  assert(S);'), (466, 1, u'+  assert(comp == Range_Contained);'), (677, 1, u'+  assert(!static_cast<TransformActionsImpl*>(Impl)->isInTransaction() &&'), (697, 1, u'+  assert(!static_cast<TransformActionsImpl*>(Impl)->isInTransaction() &&'), (716, 1, u'+  assert(!static_cast<TransformActionsImpl*>(Impl)->isInTransaction() &&')]
===========================================
Class:class ReferenceClear : public RecursiveASTVisitor<ReferenceClear> { class ReferenceClear : public RecursiveASTVisitor<ReferenceClear> 
Class: class ReferenceCollector : public RecursiveASTVisitor<ReferenceCollector> { class ReferenceCollector : public RecursiveASTVisitor<ReferenceCollector> 
Class: class RemovablesCollector : public RecursiveASTVisitor<RemovablesCollector> { class RemovablesCollector : public RecursiveASTVisitor<RemovablesCollector> 
Class:class ASTTransform : public RecursiveASTVisitor<ASTTransform> { class ASTTransform : public RecursiveASTVisitor<ASTTransform> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(459, 1, u'+        assert(BI != CD->bases_end());'), (513, 1, u'+  assert(isLValue() && "Invalid accessor");'), (518, 1, u'+  assert(isLValue() && "Invalid accessor");'), (523, 1, u'+  assert(isLValue() && "Invalid accessor");'), (528, 1, u'+  assert(isLValue() && "Invalid accessor");'), (533, 1, u'+  assert(isLValue() && hasLValuePath() && "Invalid accessor");'), (539, 1, u'+  assert(isLValue() && "Invalid accessor");'), (545, 1, u'+  assert(isLValue() && "Invalid accessor");'), (557, 1, u'+  assert(isLValue() && "Invalid accessor");'), (568, 1, u'+  assert(isMemberPointer() && "Invalid accessor");'), (574, 1, u'+  assert(isMemberPointer() && "Invalid accessor");'), (580, 1, u'+  assert(isMemberPointer() && "Invalid accessor");'), (586, 1, u'+  assert(isUninit() && "Bad state change");'), (587, 1, u'+  assert(sizeof(LV) <= MaxSize && "LV too big");'), (593, 1, u'+  assert(isUninit() && "Bad state change");'), (600, 1, u'+  assert(isUninit() && "Bad state change");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(178, 1, u'+  assert(Canonical == 0 && "Shouldn\'t be in the map!");'), (250, 1, u'+    assert(t && "No target supplied for ASTContext initialization");'), (389, 1, u'+  assert((!this->Target || this->Target == &Target) &&'), (391, 1, u'+  assert(VoidTy.isNull() && "Context reinitialized?");'), (524, 1, u'+  assert(Var->isStaticDataMember() && "Not a static data member");'), (537, 1, u'+  assert(Inst->isStaticDataMember() && "Not a static data member");'), (538, 1, u'+  assert(Tmpl->isStaticDataMember() && "Not a static data member");'), (539, 1, u'+  assert(!InstantiatedFromStaticDataMember[Inst] &&'), (547, 1, u'+  assert(FD && "Specialization is 0");'), (558, 1, u'+  assert(FD && "Specialization is 0");'), (559, 1, u'+  assert(Pattern && "Class scope specialization pattern is 0");'), (575, 1, u'+  assert((isa<UsingDecl>(Pattern) ||'), (579, 1, u'+  assert(!InstantiatedFromUsingDecl[Inst] && "pattern already exists");'), (596, 1, u'+  assert(!InstantiatedFromUsingShadowDecl[Inst] && "pattern already exists");'), (611, 1, u'+  assert(!Inst->getDeclName() && "Instantiated field decl is not unnamed");'), (612, 1, u'+  assert(!Tmpl->getDeclName() && "Template field decl is not unnamed");'), (613, 1, u'+  assert(!InstantiatedFromUnnamedFieldDecl[Inst] &&'), (687, 1, u'+  assert(!Import->NextLocalImport && "Import declaration already in the chain");'), (688, 1, u'+  assert(!Import->isFromASTFile() && "Non-local import declaration");'), (707, 1, u'+  assert(BT && "Not a floating point type!");'), (865, 1, u'+    assert((Size == 0 || EltInfo.first <= (uint64_t)(-1)/Size) &&'), (1052, 1, u'+    assert(A->isDeduced() && "Cannot request the size of a dependent type");'), (1096, 1, u'+    assert(getCanonicalType(T) != T &&'), (1126, 1, u'+  assert(llvm::isPowerOf2_32(Align) && "Alignment must be power of 2");'), (1300, 1, u'+  assert(IFaceD && ImplD && "Passed null params");'), (1306, 1, u'+  assert(CatD && ImplD && "Passed null params");'), (1324, 1, u'+  assert(VD && "Passed null params");'), (1325, 1, u'+  assert(VD->hasAttr<BlocksAttr>() &&'), (1334, 1, u'+  assert(VD && Init && "Passed null params");'), (1335, 1, u'+  assert(VD->hasAttr<BlocksAttr>() &&'), (1353, 1, u'+    assert(DataSize == TypeLoc::getFullDataSizeForType(T) &&'), (1394, 1, u'+    assert(eq->getQualifiers() == quals);'), (1427, 1, u'+  assert(!Quals.hasAddressSpace() &&'), (1455, 1, u'+  assert(!Quals.hasObjCGCAttr() &&'), (1501, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1529, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1540, 1, u'+  assert(T->isFunctionType() && "block of function types only");'), (1560, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1573, 1, u'+  assert(getCanonicalType(T) != OverloadTy &&'), (1598, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1635, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1667, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1682, 1, u'+  assert((EltTy->isDependentType() ||'), (1712, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (1889, 1, u'+  assert((!numElements || numElements->isTypeDependent() ||'), (1976, 1, u'+    assert(!existing && "Shouldn\'t be in the map!"); (void) existing;'), (1991, 1, u'+  assert(vecType->isBuiltinType());'), (2009, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (2022, 1, u'+  assert(vecType->isBuiltinType() || vecType->isDependentType());'), (2040, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (2076, 1, u'+      assert(!CanonCheck && "Dependent-sized ext_vector canonical type broken");'), (2119, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (2181, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (2229, 1, u'+  assert(NeedsInjectedClassNameType(Decl));'), (2231, 1, u'+    assert(isa<InjectedClassNameType>(Decl->TypeForDecl));'), (2233, 1, u'+    assert(PrevDecl->TypeForDecl && "previous declaration has no type");'), (2235, 1, u'+    assert(isa<InjectedClassNameType>(Decl->TypeForDecl));'), (2248, 1, u'+  assert(Decl && "Passed null for Decl param");'), (2249, 1, u'+  assert(!Decl->TypeForDecl && "TypeForDecl present in slow case");'), (2254, 1, u'+  assert(!isa<TemplateTypeParmDecl>(Decl) &&'), (2258, 1, u'+    assert(!Record->getPreviousDecl() &&'), (2260, 1, u'+    assert(!NeedsInjectedClassNameType(Record));'), (2263, 1, u'+    assert(!Enum->getPreviousDecl() &&'), (2344, 1, u'+  assert(Replacement.isCanonical()'), (2371, 1, u'+    assert(P->getKind() == TemplateArgument::Type &&"Pack contains a non-type");'), (2372, 1, u'+    assert(P->getAsType().isCanonical() && "Pack contains non-canonical type");'), (2420, 1, u'+    assert(!TypeCheck && "Template type parameter canonical type broken");'), (2437, 1, u'+  assert(!Name.getAsDependentTemplateName() &&'), (2457, 1, u'+  assert(!Template.getAsDependentTemplateName() &&'), (2487, 1, u'+  assert(!Template.getAsDependentTemplateName() &&'), (2502, 1, u'+    assert((!IsTypeAlias || hasAnyPackExpansions(Args, NumArgs)) &&'), (2528, 1, u'+  assert(!Template.getAsDependentTemplateName() &&'), (2564, 1, u'+  assert(Spec->isDependentType() &&'), (2585, 1, u'+    assert(!CheckT && "Elaborated canonical type broken");'), (2609, 1, u'+    assert(!CheckT && "Paren canonical type broken");'), (2623, 1, u'+  assert(NNS->isDependent() && "nested-name-specifier must be dependent");'), (2672, 1, u'+  assert((!NNS || NNS->isDependent()) &&'), (2723, 1, u'+  assert(Pattern->containsUnexpandedParameterPack() &&'), (2868, 1, u'+    assert(PrevDecl->TypeForDecl && "previous decl has no TypeForDecl");'), (3022, 1, u'+    assert(NewIP == 0 && "Shouldn\'t be in the map!"); (void)NewIP;'), (3034, 1, u'+  assert(!AutoDeductTy.isNull() && "can\'t build \'auto\' pattern");'), (3042, 1, u'+  assert(!AutoRRefDeductTy.isNull() && "can\'t build \'auto &&\' pattern");'), (3049, 1, u'+  assert (Decl);'), (3138, 1, u'+    assert(quals.empty()); // from the recursive call'), (3280, 1, u'+    assert(DTN && "Non-dependent template names must refer to template decls.");'), (3511, 1, u'+  assert(PrettyArrayType && "Not an array type!");'), (3554, 1, u'+  assert(T->getAs<BuiltinType>() && "getFloatingRank(): not a floating type");'), (3580, 1, u'+  assert(Domain->isRealFloatingType() && "Unknown domain!");'), (3609, 1, u'+  assert(T->isCanonicalUnqualified() && "T should be canonicalized");'), (3675, 1, u'+  assert(!Promotable.isNull());'), (3676, 1, u'+  assert(Promotable->isPromotableIntegerType());'), (3711, 1, u'+  assert(Promotable->isUnsignedIntegerType() && PromotableSize <= IntSize);'), (3825, 1, u'+  assert(Rec && "Invalid CFConstantStringType");'), (3946, 1, u'+  assert(getIntWidth(IntTy) == 32 && "non-32bit int not supported");'), (4048, 1, u'+    assert (sz.isPositive() && "BlockExpr - Incomplete param type");'), (4091, 1, u'+    assert (sz.isPositive() &&'), (4160, 1, u'+    assert (sz.isPositive() &&'), (4373, 1, u'+  assert(FD->isBitField() && "not a bitfield - getObjCEncodingForTypeImpl");'), (4512, 1, u'+        assert((isa<VariableArrayType>(AT) || isa<IncompleteArrayType>(AT)) &&'), (4732, 1, u'+  assert(RDecl && "Expected non-null RecordDecl");'), (4733, 1, u'+  assert(!RDecl->isUnion() && "Should not be called for unions");'), (4793, 1, u'+    assert(CXXRec && CXXRec->isDynamicClass() &&'), (4814, 1, u'+    assert(CurOffs <= CurLayObj->first);'), (4838, 1, u'+      assert(!base->isEmpty());'), (4881, 1, u'+  assert(BuiltinVaListType.isNull() && "__builtin_va_list type already set!");'), (4940, 1, u'+  assert(ObjCConstantStringType.isNull() &&'), (4952, 1, u'+  assert(size > 1 && "set is not overloaded!");'), (4961, 1, u'+    assert(isa<FunctionTemplateDecl>(D) ||'), (4976, 1, u'+  assert(NNS && "Missing nested-name-specifier in qualified template name");'), (4998, 1, u'+  assert((!NNS || NNS->isDependent()) &&'), (5019, 1, u'+    assert(!CheckQTN && "Dependent type name canonicalization broken");'), (5032, 1, u'+  assert((!NNS || NNS->isDependent()) &&'), (5054, 1, u'+    assert(!CheckQTN && "Dependent template name canonicalization broken");'), (5131, 1, u'+  assert(getLangOpts().ObjC1);'), (5149, 1, u'+    assert(CT->isAnyPointerType() || CT->isBlockPointerType());'), (5163, 1, u'+  assert(LHS->isCanonicalUnqualified() && RHS->isCanonicalUnqualified());'), (5170, 1, u'+  assert(FirstVec->isVectorType() && "FirstVec should be a vector type");'), (5171, 1, u'+  assert(SecondVec->isVectorType() && "SecondVec should be a vector type");'), (5224, 1, u'+  assert ((lhsQID && rhsOPT) && "ObjCQualifiedClassTypesAreCompatible");'), (5317, 1, u'+  assert(rhsQID && "One of the LHS/RHS should be id<x>");'), (5456, 1, u'+  assert(LHS->getInterface() && "LHS must have an interface base");'), (5457, 1, u'+  assert(RHS->getInterface() && "RHS must have an interface base");'), (5523, 1, u'+  assert(LHS->getInterface() && "LHS is not an interface type");'), (5524, 1, u'+  assert(RHS->getInterface() && "RHS is not an interface type");'), (5753, 1, u'+    assert(!lproto->hasExceptionSpec() && !rproto->hasExceptionSpec() &&'), (5811, 1, u'+    assert(!proto->hasExceptionSpec() && "C++ shouldn\'t be here");'), (5854, 1, u'+  assert(!LHS->getAs<ReferenceType>() && "LHS is a reference type?");'), (5855, 1, u'+  assert(!RHS->getAs<ReferenceType>() && "RHS is a reference type?");'), (5887, 1, u'+    assert((GC_L != GC_R) && "unequal qualifier sets had only equal elements");'), (6195, 1, u'+    assert((GC_L != GC_R) && "unequal qualifier sets had only equal elements");'), (6233, 1, u'+  assert(T->hasSignedIntegerRepresentation() && "Unexpected type");'), (6245, 1, u'+  assert(BTy && "Unexpected signed integer type");'), (6298, 1, u'+      assert(!Unsigned && "Can\'t use both \'S\' and \'U\' modifiers!");'), (6299, 1, u'+      assert(!Signed && "Can\'t use \'S\' modifier multiple times!");'), (6303, 1, u'+      assert(!Signed && "Can\'t use both \'S\' and \'U\' modifiers!");'), (6304, 1, u'+      assert(!Unsigned && "Can\'t use \'S\' modifier multiple times!");'), (6308, 1, u'+      assert(HowLong <= 2 && "Can\'t have LLLL modifier");'), (6320, 1, u'+    assert(HowLong == 0 && !Signed && !Unsigned &&'), (6325, 1, u'+    assert(HowLong == 0 && !Signed && !Unsigned &&'), (6330, 1, u'+    assert(HowLong < 2 && !Signed && !Unsigned &&'), (6338, 1, u'+    assert(HowLong == 0 && "Bad modifiers used with \'s\'!");'), (6355, 1, u'+    assert(HowLong == 0 && "Bad modifiers used with \'c\'!");'), (6364, 1, u'+    assert(HowLong == 0 && !Signed && !Unsigned && "Bad modifiers for \'b\'!");'), (6368, 1, u'+    assert(HowLong == 0 && !Signed && !Unsigned && "Bad modifiers for \'z\'!");'), (6382, 1, u'+    assert(!Type.isNull() && "builtin va list type not initialized!");'), (6394, 1, u'+    assert(!Type.isNull() && "builtin va list type not initialized!");'), (6403, 1, u'+    assert(End != Str && "Missing vector size");'), (6408, 1, u'+    assert(!RequiresICE && "Can\'t require vector ICE");'), (6418, 1, u'+    assert(!RequiresICE && "Can\'t require complex ICE");'), (6445, 1, u'+    assert(HowLong == 0 && !Signed && !Unsigned && "Bad modifiers for \'K\'!");'), (6489, 1, u'+  assert((!RequiresICE || Type->isIntegralOrEnumerationType()) &&'), (6510, 1, u'+  assert(!RequiresICE && "Result of intrinsic cannot be required to be an ICE");'), (6529, 1, u"+  assert((TypeStr[0] != '.' || TypeStr[1] == 0) &&"), (6687, 1, u'+  assert(VD->isFileVarDecl() && "Expected file scoped var");'), (6768, 1, u'+  assert(I != ParamIndices.end() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(248, 1, u'+      assert(ModLen == 0 && ArgLen == 0 &&'), (267, 1, u'+        assert(ModLen == 0 && ArgLen == 0 &&'), (276, 1, u'+        assert(ModLen == 0 && ArgLen == 0 &&'), (293, 1, u'+      assert(DC && "Should never have a null declaration context");')]
===========================================
Class:  class ASTNodeImporter : public TypeVisitor<ASTNodeImporter, QualType>,   class ASTNodeImporter : public TypeVisitor<ASTNodeImporter, QualType>,
Class:  class FinalOverriderCollector {   class FinalOverriderCollector 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(24, 1, u'+  assert(NumDeclsFound == 0 && !DeclsFound &&'), (361, 1, u'+  assert(((Decl *)BaseRecord)->getCanonicalDecl() == BaseRecord &&'), (370, 1, u'+  assert(((Decl *)BaseRecord)->getCanonicalDecl() == BaseRecord &&'), (683, 1, u'+    assert(!I->getType()->isDependentType() &&'), (706, 1, u'+    assert(!I->getType()->isDependentType() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(198, 1, u'+  assert(D->getDeclContext()->getRedeclContext()->isFileContext() &&'), (638, 1, u'+    assert(Linkage(CachedLinkage) =='), (651, 1, u'+  assert(!HasCachedLinkage || Linkage(CachedLinkage) == LI.linkage());'), (911, 1, u'+  assert(getDeclName() == OldD->getDeclName() && "Declaration name mismatch");'), (1050, 1, u'+  assert(NumTPLists > 0);'), (1121, 1, u'+  assert((NumTPLists == 0 || TPLists != 0) &&'), (1171, 1, u'+  assert(isLegalForVariable(SC));'), (1415, 1, u'+  assert(!Init->isValueDependent());'), (1458, 1, u'+  assert(!Init->isValueDependent());'), (1483, 1, u'+  assert(getType()->isReferenceType() &&"Non-references never extend lifetime");'), (1516, 1, u'+  assert(MSI && "Not an instantiated static data member?");'), (1555, 1, u'+  assert(!hasUnparsedDefaultArg() && "Default argument is not yet parsed!");'), (1556, 1, u'+  assert(!hasUninstantiatedDefaultArg() &&'), (1685, 1, u'+  assert(getDeclName().getNameKind() == DeclarationName::CXXOperatorName);'), (1686, 1, u'+  assert(getDeclName().getCXXOverloadedOperator() == OO_New ||'), (1692, 1, u'+  assert(getDeclContext()->getRedeclContext()->isTranslationUnit());'), (1751, 1, u'+    assert((!PrevDecl || PrevFunTmpl) && "Function/function template mismatch");'), (1768, 1, u'+  assert(isLegalForFunction(SC));'), (1836, 1, u'+  assert(ParamInfo == 0 && "Already has param info!");'), (1837, 1, u'+  assert(NewParamInfo.size() == getNumParams() && "Parameter count mismatch!");'), (1847, 1, u'+  assert(DeclsInPrototypeScope.empty() && "Already has prototype decls!");'), (1946, 1, u'+  assert(!doesThisDeclarationHaveABody() &&'), (2016, 1, u'+  assert(doesThisDeclarationHaveABody() && "Must have the function definition");'), (2017, 1, u'+  assert(isInlined() && "Function must be inline");'), (2110, 1, u'+  assert(TemplateOrSpecialization.isNull() &&'), (2231, 1, u'+  assert(TSK != TSK_Undeclared &&'), (2248, 1, u'+  assert(TemplateOrSpecialization.isNull());'), (2471, 1, u'+  assert(isBitField() && "not a bitfield");'), (2498, 1, u'+  assert(CachedFieldIndex && "failed to find field in parent");'), (2509, 1, u'+  assert(!InitializerOrBitWidth.getPointer() &&'), (2552, 1, u'+  assert((!isa<CXXRecordDecl>(this) ||'), (2600, 1, u'+  assert(NumTPLists > 0);'), (2636, 1, u'+  assert(!isCompleteDefinition() && "Cannot redefine enums!");'), (2655, 1, u'+  assert(MSI && "Not an instantiated member enumeration?");'), (2672, 1, u'+  assert(!SpecializationInfo && "Member enum is already a specialization");'), (2688, 1, u'+  assert(classof(static_cast<Decl*>(this)) && "Invalid Kind!");'), (2721, 1, u'+  assert(!isCompleteDefinition() && "Cannot redefine record!");'), (2727, 1, u'+  assert(hasExternalLexicalStorage() && Source && "No external storage?");'), (2746, 1, u'+    assert(isa<FieldDecl>(Decls[i]));'), (2761, 1, u'+  assert(ParamInfo == 0 && "Already has param info!");'), (2827, 1, u'+  assert(GnuLabelL != IdentL && "Use this only for GNU local labels");'), (3001, 1, u'+  assert(getNumModuleIdentifiers(Imported) == IdentifierLocs.size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(238, 1, u'+  assert(DC && "This decl is not contained in a translation unit!");'), (242, 1, u'+    assert(DC && "This decl is not contained in a translation unit!");'), (522, 1, u'+    case StaticAssert:'), (543, 1, u'+  assert(!HasAttrs && "Decl already contains attrs.");'), (546, 1, u'+  assert(AttrBlank.empty() && "HasAttrs was wrong?");'), (560, 1, u'+  assert(HasAttrs && "No attrs to get!");'), (658, 1, u'+      isa<StaticAssertDecl>(this) ||'), (668, 1, u'+  assert(Access != AS_none &&'), (686, 1, u'+  assert(!DC->isClosure());'), (832, 1, u'+      assert(isa<TagType>(Tag->TypeForDecl) ||'), (849, 1, u'+    assert(DeclKind >= Decl::firstFunction && DeclKind <= Decl::lastFunction &&'), (899, 1, u'+  assert(hasExternalLexicalStorage() && Source && "No external storage?");'), (945, 1, u'+  assert(List.isNull());'), (1003, 1, u'+  assert(D->getLexicalDeclContext() == this &&'), (1005, 1, u'+  assert((D->NextInContextAndBits.getPointer() || D == LastDecl) &&'), (1016, 1, u'+      assert(I && "decl not found in linked list");'), (1039, 1, u'+    assert(Pos != Map->end() && "no lookup entry for decl");'), (1046, 1, u'+  assert(D->getLexicalDeclContext() == this &&'), (1048, 1, u'+  assert(!D->getNextDeclInContext() && D != LastDecl &&'), (1117, 1, u'+  assert(this == getPrimaryContext() && "buildLookup called on non-primary DC");'), (1159, 1, u'+  assert(DeclKind != Decl::LinkageSpec &&'), (1276, 1, u'+  assert(this == getPrimaryContext() && "expected a primary DC");'), (1378, 1, u'+  assert(!LookupPtr.getPointer() && "context already has a decls map");'), (1379, 1, u'+  assert(getPrimaryContext() == this &&'), (1419, 1, u'+  assert(Parent->isDependentContext()')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(426, 1, u'+    assert(FnType && "Overloaded operator has no prototype.");'), (1165, 1, u'+      assert(std::find(Convs.begin(), Convs.end(), ConvDecl) == Convs.end()'), (1188, 1, u'+  assert(TemplateOrInstantiation.isNull() &&'), (1190, 1, u'+  assert(!isa<ClassTemplateSpecializationDecl>(this));'), (1277, 1, u'+        assert(SO->second.size() > 0 &&'), (1421, 1, u'+  assert(MD->isCanonicalDecl() && "Method is not canonical!");'), (1422, 1, u'+  assert(!MD->getParent()->isDependentContext() &&'), (1424, 1, u'+  assert(MD->isVirtual() && "Method is not virtual!");'), (1451, 1, u'+  assert(isInstance() && "No \'this\' for static methods!");'), (1602, 1, u'+  assert(NameInfo.getName().getNameKind()'), (1611, 1, u'+  assert(isDelegatingConstructor() && "Not a delegating constructor!");'), (1729, 1, u'+  assert(getASTContext().overridden_methods_size(this) == 0 &&'), (1749, 1, u'+  assert(NameInfo.getName().getNameKind()'), (1773, 1, u'+  assert(NameInfo.getName().getNameKind()'), (1903, 1, u'+  assert(std::find(shadow_begin(), shadow_end(), S) == shadow_end() &&'), (1905, 1, u'+  assert(S->getUsingDecl() == this);'), (1913, 1, u'+  assert(std::find(shadow_begin(), shadow_end(), S) != shadow_end() &&'), (1915, 1, u'+  assert(S->getUsingDecl() == this);'), (1990, 1, u'+void StaticAssertDecl::anchor() { }'), (1992, 1, u'+StaticAssertDecl *StaticAssertDecl::Create(ASTContext &C, DeclContext *DC,'), (1993, 1, u'+                                           SourceLocation StaticAssertLoc,'), (1994, 1, u'+                                           Expr *AssertExpr,'), (1997, 1, u'+  return new (C) StaticAssertDecl(DC, StaticAssertLoc, AssertExpr, Message,'), (2001, 1, u'+StaticAssertDecl *StaticAssertDecl::CreateDeserialized(ASTContext &C,'), (2003, 1, u'+  void *Mem = AllocateDeserializedDecl(C, ID, sizeof(StaticAssertDecl));'), (2004, 1, u'+  return new (Mem) StaticAssertDecl(0, SourceLocation(), 0, 0,SourceLocation());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 1, u'+    assert(isa<FunctionDecl>(D) ||'), (35, 1, u'+    assert(D->getFriendObjectKind() ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(21, 1, u'+  assert(NumDecls > 1 && "Invalid DeclGroup");'), (29, 1, u'+  assert(numdecls > 0);'), (30, 1, u'+  assert(decls);')]
===========================================
Class:  class DeclPrinter : public DeclVisitor<DeclPrinter> {   class DeclPrinter : public DeclVisitor<DeclPrinter> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(63, 1, u'+    void VisitStaticAssertDecl(StaticAssertDecl *D);'), (657, 1, u'+void DeclPrinter::VisitStaticAssertDecl(StaticAssertDecl *D) {'), (659, 1, u'+  D->getAssertExpr()->printPretty(Out, Context, 0, Policy, Indentation);'), (730, 1, u'+    assert(D->getLanguage() == LinkageSpecDecl::lang_cxx &&'), (746, 1, u'+  assert(Params);'), (747, 1, u'+  assert(!Args || Params->size() == Args->size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(334, 1, u'+    assert(Existing->isCanonicalDecl() && "Non-canonical specialization?");'), (357, 1, u'+    assert(Existing->isCanonicalDecl() && "Non-canonical specialization?");'), (373, 1, u'+    assert(!PS[P->getSequenceNumber()]);')]
===========================================
Class:class CXXSpecialName class CXXSpecialName
Class:   class CXXOperatorIdName : public DeclarationNameExtra { class CXXOperatorIdName : public DeclarationNameExtra 
Class:       class CXXLiteralOperatorIdName   : public DeclarationNameExtra, public llvm::FoldingSetNode {   : public DeclarationNameExtra, public llvm::FoldingSetNode 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(147, 1, u'+    assert((Ptr & PtrMask) == 0 && "Improperly aligned IdentifierInfo");'), (153, 1, u'+    assert((Ptr & PtrMask) == 0 && "Improperly aligned IdentifierInfo");'), (159, 1, u'+    assert((Ptr & PtrMask) == 0 && "Improperly aligned MultiKeywordSelector");'), (254, 1, u'+    assert(OpName && "not an overloaded operator");'), (415, 1, u'+  assert(Kind >= DeclarationName::CXXConstructorName &&'), (425, 1, u'+    assert(!Ty.hasQualifiers() &&"Constructor type must be unqualified");'), (429, 1, u'+    assert(!Ty.hasQualifiers() && "Destructor type must be unqualified");')]
===========================================
Class:  class TemporaryContainer {   class TemporaryContainer 
Class:  template <class E, class T>   template <class E, class T>
Class:  class NonTrivialCallFinder : public EvaluatedExprVisitor<NonTrivialCallFinder>   class NonTrivialCallFinder : public EvaluatedExprVisitor<NonTrivialCallFinder>
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(460, 1, u'+      assert(Params->size() == Args.size());'), (476, 1, u'+      assert(Params->size() == Args->size());'), (598, 1, u'+  assert((CharByteWidth & 7) == 0 && "Assumes character size is byte multiple");'), (600, 1, u'+  assert((CharByteWidth==1 || CharByteWidth==2 || CharByteWidth==4)'), (646, 1, u'+  assert((Str.size()%CharByteWidth == 0)'), (670, 1, u'+      assert(false && "unsupported CharByteWidth");'), (684, 1, u'+  assert(Kind == StringLiteral::Ascii && "This only works for ASCII strings");'), (690, 1, u'+    assert(TokNo < getNumConcatenated() && "Invalid byte number!");'), (1043, 1, u'+  assert(getKind() == Field || getKind() == Identifier);'), (1144, 1, u'+    assert(!path_empty() && "Cast kind should have a base path!");'), (1148, 1, u'+    assert(getType()->isObjCObjectPointerType());'), (1149, 1, u'+    assert(getSubExpr()->getType()->isPointerType());'), (1153, 1, u'+    assert(getType()->isObjCObjectPointerType());'), (1154, 1, u'+    assert(getSubExpr()->getType()->isBlockPointerType());'), (1158, 1, u'+    assert(getType()->isMemberPointerType());'), (1159, 1, u'+    assert(getSubExpr()->getType()->isMemberPointerType());'), (1167, 1, u'+      assert(getType()->isObjCObjectPointerType() =='), (1169, 1, u'+      assert(getType()->isBlockPointerType() =='), (1175, 1, u'+    assert(getType()->isBlockPointerType());'), (1176, 1, u'+    assert(getSubExpr()->getType()->isAnyPointerType() &&'), (1181, 1, u'+    assert(getType()->isBlockPointerType());'), (1182, 1, u'+    assert(getSubExpr()->getType()->isBlockPointerType());'), (1214, 1, u'+    assert(!getType()->isBooleanType() && "unheralded conversion to bool");'), (1231, 1, u'+    assert(path_empty() && "Cast kind should not have a base path!");'), (1390, 1, u'+  assert(Path.size() == path_size());'), (1584, 1, u'+  assert(!hasArrayFiller() && "Filler already set!");'), (1976, 1, u'+  assert(expr->hasPlaceholderType(BuiltinType::BoundMember));'), (1984, 1, u'+    assert(isa<CXXMethodDecl>(mem->getMemberDecl()));'), (1991, 1, u'+    assert(type->isFunctionType());'), (1995, 1, u'+  assert(isa<UnresolvedMemberExpr>(expr));'), (2599, 1, u'+    assert((E->getValueKind() == VK_LValue &&'), (2844, 1, u'+  assert((!SelLocs.empty() || isImplicit) &&'), (2867, 1, u'+  assert((!SelLocs.empty() || isImplicit) &&'), (2890, 1, u'+  assert((!SelLocs.empty() || isImplicit) &&'), (3092, 1, u'+  assert(Kind == FieldDesignator && "Only valid on a field designator");'), (3163, 1, u'+  assert(IndexIdx == NumIndexExprs && "Wrong number of index expressions");'), (3219, 1, u'+  assert(D.Kind == Designator::ArrayDesignator && "Requires array designator");'), (3227, 1, u'+  assert(D.Kind == Designator::ArrayRangeDesignator &&'), (3236, 1, u'+  assert(D.Kind == Designator::ArrayRangeDesignator &&'), (3319, 1, u'+  assert(syntax && "no syntactic expression!");'), (3320, 1, u'+  assert(semantics.size() && "no semantic expressions!");'), (3328, 1, u'+    assert(resultIndex < semantics.size());'), (3331, 1, u'+    assert(semantics[resultIndex]->getObjectKind() == OK_Ordinary);'), (3363, 1, u'+      assert(cast<OpaqueValueExpr>(E)->getSourceExpr() != 0 &&'), (3529, 1, u'+  assert(nexpr == getNumSubExprs(op) && "wrong number of subexpressions");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 1, u'+  assert(!TR->isReferenceType() && "Expressions can\'t have reference type.");'), (71, 1, u'+  case Cl::CL_LValue: assert(getValueKind() == VK_LValue); break;'), (72, 1, u'+  case Cl::CL_XValue: assert(getValueKind() == VK_XValue); break;'), (81, 1, u'+  case Cl::CL_PRValue: assert(getValueKind() == VK_RValue); break;'), (371, 1, u'+    assert(cast<InitListExpr>(E)->getNumInits() == 1 &&'), (483, 1, u'+  assert(Ctx.getLangOpts().CPlusPlus &&'), (519, 1, u'+  assert(Ctx.getLangOpts().CPlusPlus &&'), (582, 1, u'+    assert((E->getObjectKind() == OK_ObjCProperty ||'), (630, 1, u'+  assert(VC.getKind() == Cl::CL_LValue && "Unhandled kind");')]
===========================================
Class:  class OptionalDiagnostic {   class OptionalDiagnostic 
Class:         class SpeculativeEvaluationRAII {   class SpeculativeEvaluationRAII 
Class:class HasSideEffect class HasSideEffect
Class: class OpaqueValueEvaluation { class OpaqueValueEvaluation 
Class:class ExprEvaluatorBase class ExprEvaluatorBase
Class:class LValueExprEvaluatorBase class LValueExprEvaluatorBase
Class:class LValueExprEvaluator class LValueExprEvaluator
Class:class PointerExprEvaluator class PointerExprEvaluator
Class:class MemberPointerExprEvaluator class MemberPointerExprEvaluator
Class:  class RecordExprEvaluator   class RecordExprEvaluator
Class:class TemporaryExprEvaluator class TemporaryExprEvaluator
Class:  class VectorExprEvaluator   class VectorExprEvaluator
Class:  class ArrayExprEvaluator   class ArrayExprEvaluator
Class:class IntExprEvaluator class IntExprEvaluator
Class:class DataRecursiveIntBinOpEvaluator { class DataRecursiveIntBinOpEvaluator 
Class:class FloatExprEvaluator class FloatExprEvaluator
Class:class ComplexExprEvaluator class ComplexExprEvaluator
Class:class VoidExprEvaluator class VoidExprEvaluator
Class:class InheritanceHierarchyWriter { class InheritanceHierarchyWriter 
Class:class ItaniumCXXABI : public CXXABI { class ItaniumCXXABI : public CXXABI 
Class: class ARMCXXABI : public ItaniumCXXABI { class ARMCXXABI : public ItaniumCXXABI 
Class:class ItaniumMangleContext : public MangleContext { class ItaniumMangleContext : public MangleContext 
Class:  class CXXNameMangler { class CXXNameMangler 
Class:   class FunctionTypeDepthState {   class FunctionTypeDepthState 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 1, u'+  assert(DC == ExpectedDC && "Given decl context did not match expected!");'), (93, 1, u'+  assert(!isa<CXXConstructorDecl>(DC) && !isa<CXXDestructorDecl>(DC));'), (124, 1, u'+  assert (CD && "Missing container decl in GetNameForMethod");')]
===========================================
Class:class MicrosoftCXXABI : public CXXABI { class MicrosoftCXXABI : public CXXABI 
Class:class MicrosoftCXXNameMangler { class MicrosoftCXXNameMangler 
Class:   class MicrosoftMangleContext : public MangleContext { class MicrosoftMangleContext : public MangleContext 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(46, 1, u'+  assert(II && "Identifier cannot be NULL");'), (47, 1, u'+  assert((!Prefix || Prefix->isDependent()) && "Prefix must be dependent");'), (59, 1, u'+  assert(NS && "Namespace cannot be NULL");'), (60, 1, u'+  assert((!Prefix ||'), (74, 1, u'+  assert(Alias && "Namespace alias cannot be NULL");'), (75, 1, u'+  assert((!Prefix ||'), (89, 1, u'+  assert(T && "Type cannot be NULL");'), (99, 1, u'+  assert(II && "Identifier cannot be NULL");'), (260, 1, u'+    assert(!isa<ElaboratedType>(T) &&'), (291, 1, u'+  assert(Qualifier && "Expected a non-NULL qualifier");'), (387, 1, u'+  assert((Qualifier->getKind() == NestedNameSpecifier::TypeSpec ||'), (549, 1, u'+  assert(!Representation && "Already have a nested-name-specifier!?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 1, u'+        assert(getVBaseClassOffset(PrimaryBase).isZero() &&'), (84, 1, u'+        assert(getBaseClassOffsetInBits(PrimaryBase) == 0 &&')]
===========================================
Class:class EmptySubobjectMap { class EmptySubobjectMap 
Class: class RecordLayoutBuilder { class RecordLayoutBuilder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 1, u'+    assert(Index == 0);'), (35, 1, u'+  assert(Index < NumSelArgs);')]
===========================================
Class:  template <class S, class T>   template <class S, class T>
Class:         template <class S, class T>   SourceLocation getLocEndImpl(const Stmt *stmt,                                SourceLocation (T::*v)() const) {                                SourceLocation (T::*v)() const) 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(141, 1, u'+#define ASSERT_IMPLEMENTS_children(type) \\'), (143, 1, u'+#define ASSERT_IMPLEMENTS_getSourceRange(type) \\'), (152, 1, u'+  ASSERT_IMPLEMENTS_children(type); \\'), (153, 1, u'+  ASSERT_IMPLEMENTS_getSourceRange(type);'), (656, 1, u'+  assert(RangeDecl &&& "for-range should have a single var decl");'), (666, 1, u'+  assert(LV && "No loop variable in CXXForRangeStmt");')]
===========================================
Class:  class StmtDumper : public StmtVisitor<StmtDumper> {   class StmtDumper : public StmtVisitor<StmtDumper> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(294, 1, u'+  } else if (StaticAssertDecl *SAD = dyn_cast<StaticAssertDecl>(D)) {'), (296, 1, u'+    DumpSubTree(SAD->getAssertExpr());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(34, 1, u'+  assert (getVAPtr());'), (58, 1, u'+    assert (inSizeOfTypeVA());'), (59, 1, u'+    assert(!decl);'), (65, 1, u'+  assert (getVAPtr() == NULL);'), (68, 1, u'+    assert(decl);'), (77, 1, u'+    assert(inDeclGroup());'), (135, 1, u'+    assert (VAPtr->SizeExpr);'), (139, 1, u'+  assert (inDecl() || inDeclGroup());'), (146, 1, u'+  assert (inDecl());'), (149, 1, u'+    assert (VD->Init);')]
===========================================
Class:  class StmtPrinter : public StmtVisitor<StmtPrinter> {   class StmtPrinter : public StmtVisitor<StmtPrinter> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(525, 1, u'+    assert(F && "Must have a finally block...");'), (1274, 1, u'+    assert(Args);')]
===========================================
Class:  class StmtProfiler : public ConstStmtVisitor<StmtProfiler> {   class StmtProfiler : public ConstStmtVisitor<StmtProfiler> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(447, 1, u'+      assert(D->isArrayRangeDesignator());'), (697, 1, u'+      assert(SC == Stmt::ArraySubscriptExprClass);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(208, 1, u'+  assert(Kind == TemplateExpansion);'), (292, 1, u'+  assert(isPackExpansion());'), (426, 1, u'+  assert(Argument.isPackExpansion());'), (616, 1, u'+  assert(TemplateKWLoc.isValid());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(96, 1, u'+  assert(!getAsOverloadedTemplate() &&')]
===========================================
Class:  class GetContainedAutoVisitor :   class GetContainedAutoVisitor :
Class:class CachedProperties { class CachedProperties 
Class:template <class Private> class TypePropertyCache { template <class Private> class TypePropertyCache 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(431, 1, u'+  assert(getNumProtocols() == NumProtocols &&'), (782, 1, u'+  assert(isScalarType());'), (800, 1, u'+    assert(cast<EnumType>(T)->getDecl()->isComplete());'), (835, 1, u'+  assert(!isIncompleteType() && "This doesn\'t make sense for incomplete types");'), (836, 1, u'+  assert(!isDependentType() && "This doesn\'t make sense for dependent types");'), (1085, 1, u'+  assert(BaseTy && "NULL element type");'), (1134, 1, u'+  assert(BaseTy && "NULL element type");'), (1188, 1, u'+  assert(BaseTy && "NULL element type");'), (1370, 1, u'+  assert((!NNS || NNS->isDependent()) &&'), (1585, 1, u'+  assert(isICE && "AST should not contain bad noexcept expressions.");'), (1626, 1, u'+  assert(!(unsigned(epi.Variadic) & ~1) &&'), (1838, 1, u'+  assert(!T.getAsDependentTemplateName() &&'), (1840, 1, u'+  assert((T.getKind() == TemplateName::Template ||'), (1846, 1, u'+  assert((!Canon.isNull() ||'), (1989, 1, u'+    assert(T->TypeBits.isCacheValid() &&'), (2015, 1, u'+    assert(T->isInstantiationDependentType());'), (2129, 1, u'+  assert(isObjCLifetimeType() &&')]
===========================================
Class:  class TypeLocRanger : public TypeLocVisitor<TypeLocRanger, SourceRange> {   class TypeLocRanger : public TypeLocVisitor<TypeLocRanger, SourceRange> 
Class:  class TypeSizer : public TypeLocVisitor<TypeSizer, unsigned> {   class TypeSizer : public TypeLocVisitor<TypeSizer, unsigned> 
Class:  class NextLoc : public TypeLocVisitor<NextLoc, TypeLoc> {   class NextLoc : public TypeLocVisitor<NextLoc, TypeLoc> 
Class:  class IncludeStrongLifetimeRAII {   class IncludeStrongLifetimeRAII 
Class:   class TypePrinter {   class TypePrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+    assert(!SecondaryVirtualPointerIndices.count(Base) &&')]
===========================================
Class:class FinalOverriders { class FinalOverriders 
Class:  class VCallAndVBaseOffsetBuilder { class VCallAndVBaseOffsetBuilder 
Class:  class VTableBuilder { class VTableBuilder 
Class:class FindBlockDeclRefExprsVals : public StmtVisitor<FindBlockDeclRefExprsVals>{ class FindBlockDeclRefExprsVals : public StmtVisitor<FindBlockDeclRefExprsVals>
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(122, 1, u'+  assert(forcedBlkExprs);'), (127, 1, u'+  assert(itr != forcedBlkExprs->end());'), (213, 1, u'+  assert(Manager &&')]
===========================================
Class:class CFGBuilder;
Class:              class AddStmtChoice { class AddStmtChoice 
Class:                      class LocalScope { class LocalScope 
Class:         class const_iterator {   class const_iterator 
Class:     class TryResult { class TryResult 
Class:               class CFGBuilder { class CFGBuilder 
Class:class StmtPrinterHelper : public PrinterHelper  { class StmtPrinterHelper : public PrinterHelper  
Class:class CFGBlockTerminatorPrint class CFGBlockTerminatorPrint
Class:class CGBuilder : public StmtVisitor<CGBuilder> { class CGBuilder : public StmtVisitor<CGBuilder> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 1, u'+  assert(D);'), (136, 1, u'+      assert(*CI != Root && "No one can call the root node.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 1, u'+    assert(Amt.getHowSpecified() == OptionalAmount::Constant);')]
===========================================
Class:class DataflowWorklist { class DataflowWorklist 
Class:class LiveVariablesImpl { class LiveVariablesImpl 
Class:class TransferFunctions : public StmtVisitor<TransferFunctions> { class TransferFunctions : public StmtVisitor<TransferFunctions> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(414, 1, u'+    assert(subEx->isLValue());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(236, 1, u'+  assert(I == E && "Format string not exhausted");')]
===========================================
Class:class DeadCodeScan { class DeadCodeScan 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(125, 1, u'+    assert(Amt.getHowSpecified() == OptionalAmount::Constant);'), (452, 1, u'+  assert(I == E && "Format string not exhausted");')]
===========================================
Class:class MutexID { class MutexID 
Class:                class LocalVariableMap { class LocalVariableMap 
Class:   class VarMapBuilder : public StmtVisitor<VarMapBuilder> { class VarMapBuilder : public StmtVisitor<VarMapBuilder> 
Class:  class ThreadSafetyAnalyzer { class ThreadSafetyAnalyzer 
Class:       class BuildLockset : public StmtVisitor<BuildLockset> { class BuildLockset : public StmtVisitor<BuildLockset> 
Class:class DeclToIndex { class DeclToIndex 
Class:class CFGBlockValues { class CFGBlockValues 
Class:class DataflowWorklist { class DataflowWorklist 
Class:class FindVarResult { class FindVarResult 
Class: class TransferFunctions : public StmtVisitor<TransferFunctions> { class TransferFunctions : public StmtVisitor<TransferFunctions> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+  assert(ID - Builtin::FirstTSBuiltin < NumTSRecords && "Invalid builtin ID!");'), (43, 1, u'+  assert(NumTSRecords == 0 && "Already initialized target?");'), (94, 1, u'+  assert(*Printf == \':\' && "p or P specifier must have be followed by a \':\'");'), (97, 1, u'+  assert(strchr(Printf, \':\') && "printf specifier must end with a \':\'");'), (113, 1, u'+  assert(*Scanf == \':\' && "s or S specifier must have be followed by a \':\'");'), (116, 1, u'+  assert(strchr(Scanf, \':\') && "printf specifier must end with a \':\'");')]
===========================================
Class:    class CustomDiagInfo {     class CustomDiagInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(99, 1, u'+      assert(StaticDiagInfo[i-1].DiagID != StaticDiagInfo[i].DiagID &&'), (103, 1, u'+      assert(StaticDiagInfo[i-1] < StaticDiagInfo[i] &&'), (131, 1, u'+      assert(Info.getMapping() == diag::MAP_WARNING &&'), (137, 1, u'+      assert(Info.getMapping() == diag::MAP_WARNING &&'), (248, 1, u'+        assert(this && DiagID-DIAG_UPPER_LIMIT < DiagInfo.size() &&'), (255, 1, u'+        assert(this && DiagID-DIAG_UPPER_LIMIT < DiagInfo.size() &&'), (360, 1, u'+  assert(DiagClass != CLASS_NOTE && "Cannot get diagnostic level of a note!");'), (583, 1, u'+  assert(Diag.getClient() && "DiagnosticClient not set!");')]
===========================================
Class: class FileManager::UniqueDirContainer { class FileManager::UniqueDirContainer 
Class: class FileManager::UniqueFileContainer { class FileManager::UniqueFileContainer 
Class: class FileManager::UniqueFileContainer { class FileManager::UniqueFileContainer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(69, 1, u'+    assert(absPathStrPtr && "_fullpath() returned NULL!");'), (183, 1, u'+  assert(statCache && "No stat cache provided?");'), (212, 1, u'+  assert(PrevCache && "Stat cache not found for removal");'), (427, 1, u'+  assert(DirInfo &&')]
===========================================
Class:  class EmptyLookupIterator : public IdentifierIterator   class EmptyLookupIterator : public IdentifierIterator
Class:class MultiKeywordSelector class MultiKeywordSelector
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+  assert(isValid());'), (79, 1, u'+  assert(isValid());'), (84, 1, u'+  assert(isValid());'), (89, 1, u'+  assert(isValid());'), (94, 1, u'+  assert(isValid());'), (99, 1, u'+  assert(isValid());'), (104, 1, u'+  assert(isValid());'), (109, 1, u'+  assert(isValid());'), (114, 1, u'+  assert(isValid());'), (123, 1, u'+  assert(isValid());'), (128, 1, u'+  assert(isValid());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 1, u'+  assert(Buffer.getPointer());'), (75, 1, u'+    assert(0 && "Replacing with the same buffer");'), (198, 1, u'+  assert((Entries.empty() || Entries.back().FileOffset < Offset) &&'), (229, 1, u'+  assert(FilenameID != -1 && "Unspecified filename should use other accessor");'), (233, 1, u'+  assert((Entries.empty() || Entries.back().FileOffset < Offset) &&'), (242, 1, u'+    assert(!Entries.empty() && Entries.back().IncludeOffset &&'), (262, 1, u'+  assert(!Entries.empty() && "No #line entries for this FID after all!");'), (322, 1, u'+    assert(!IsFileEntry && !IsFileExit && !IsSystemHeader && !IsExternCHeader &&'), (430, 1, u'+  assert(FileEnt && "Didn\'t specify a file entry to use?");'), (476, 1, u'+  assert(!SLocEntryLoaded[Index]);'), (496, 1, u'+  assert(ExternalSLocEntries && "Don\'t have an external sloc source");'), (500, 1, u'+  assert(CurrentLoadedOffset >= NextLocalOffset && "Out of source locations");'), (539, 1, u'+    assert(LoadedID != -1 && "Loading sentinel FileID");'), (541, 1, u'+    assert(Index < LoadedSLocEntryTable.size() && "FileID out of range");'), (542, 1, u'+    assert(!SLocEntryLoaded[Index] && "FileID already loaded");'), (552, 1, u'+  assert(NextLocalOffset + FileSize + 1 > NextLocalOffset &&'), (592, 1, u'+    assert(LoadedID != -1 && "Loading sentinel FileID");'), (594, 1, u'+    assert(Index < LoadedSLocEntryTable.size() && "FileID out of range");'), (595, 1, u'+    assert(!SLocEntryLoaded[Index] && "FileID already loaded");'), (601, 1, u'+  assert(NextLocalOffset + TokLength + 1 > NextLocalOffset &&'), (613, 1, u'+  assert(IR && "getOrCreateContentCache() cannot return NULL");'), (621, 1, u'+  assert(IR && "getOrCreateContentCache() cannot return NULL");'), (629, 1, u'+  assert(SourceFile->getSize() == NewFile->getSize() &&'), (632, 1, u'+  assert(FileInfos.count(SourceFile) == 0 &&'), (684, 1, u'+  assert(SLocOffset < NextLocalOffset && "Bad function choice");'), (777, 1, u'+    assert(0 && "Invalid SLocOffset or bad function choice");'), (923, 1, u'+  assert(Loc.isMacroID() && "Not a macro expansion loc!");'), (1281, 1, u'+  assert(!Loc.isInvalid() && "Can\'t get file characteristic of invalid loc!");'), (1295, 1, u'+  assert(LineTable && "Can\'t have linetable entries without a LineTable!");'), (1360, 1, u'+    assert(LineTable && "Can\'t have linetable entries without a LineTable!");'), (1433, 1, u'+  assert(SourceFile && "Null source file!");'), (1434, 1, u'+  assert(Line && Col && "Line and column should start from 1!");'), (1445, 1, u'+  assert(SourceFile && "Null source file!");'), (1624, 1, u'+  assert(!FID.isInvalid());'), (1625, 1, u'+  assert(!CachePtr);'), (1734, 1, u'+  assert(!MacroArgsCache->empty());'), (1772, 1, u'+  assert(LHS.isValid() && RHS.isValid() && "Passed invalid source location!");'), (1830, 1, u'+  assert(LIsBuiltins && RIsBuiltins &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(268, 1, u'+  assert(isValidGCCRegisterName(Name) && "Invalid register passed in");'), (282, 1, u'+      assert(n >= 0 && (unsigned)n < NumNames &&'), (378, 1, u'+  assert(*Name == \'[\' && "Symbolic name did not start with \'[\'");')]
===========================================
Class:class OSTargetInfo : public TgtInfo { class OSTargetInfo : public TgtInfo 
Class:class DarwinTargetInfo : public OSTargetInfo<Target> { class DarwinTargetInfo : public OSTargetInfo<Target> 
Class:class PPCTargetInfo : public TargetInfo { class PPCTargetInfo : public TargetInfo 
Class:class PPC32TargetInfo : public PPCTargetInfo { class PPC32TargetInfo : public PPCTargetInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 1, u'+  assert(Kind < tok::NUM_TOKENS);')]
===========================================
Class:class EmitAssemblyHelper { class EmitAssemblyHelper 
Class:class ObjectByrefHelpers : public CodeGenModule::ByrefHelpers { class ObjectByrefHelpers : public CodeGenModule::ByrefHelpers 
Class:  class ARCWeakByrefHelpers : public CodeGenModule::ByrefHelpers { class ARCWeakByrefHelpers : public CodeGenModule::ByrefHelpers 
Class:   class ARCStrongByrefHelpers : public CodeGenModule::ByrefHelpers { class ARCStrongByrefHelpers : public CodeGenModule::ByrefHelpers 
Class:   class ARCStrongBlockByrefHelpers : public CodeGenModule::ByrefHelpers { class ARCStrongBlockByrefHelpers : public CodeGenModule::ByrefHelpers 
Class:   class CXXByrefHelpers : public CodeGenModule::ByrefHelpers { class CXXByrefHelpers : public CodeGenModule::ByrefHelpers 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+  assert(Context.BuiltinInfo.isLibFunction(BuiltinID));'), (62, 1, u'+  assert(V->getType() == IntType);'), (73, 1, u'+  assert(V->getType() == ResultType);'), (83, 1, u'+  assert(E->getArg(0)->getType()->isPointerType());'), (84, 1, u'+  assert(CGF.getContext().hasSameUnqualifiedType(T,'), (86, 1, u'+  assert(CGF.getContext().hasSameUnqualifiedType(T, E->getArg(1)->getType()));'), (118, 1, u'+  assert(E->getArg(0)->getType()->isPointerType());'), (119, 1, u'+  assert(CGF.getContext().hasSameUnqualifiedType(T,'), (121, 1, u'+  assert(CGF.getContext().hasSameUnqualifiedType(T, E->getArg(1)->getType()));'), (150, 1, u'+  assert(ValTyP && "isn\'t scalar fp type!");'), (346, 1, u'+    assert(CI);'), (696, 1, u'+    assert((IntTy->getBitWidth() == 32 || IntTy->getBitWidth() == 64) &&'), (1307, 1, u'+    assert(Error == ASTContext::GE_None && "Should not codegen an error");'), (1322, 1, u'+        assert(IsConst && "Constant arg isn\'t actually constant?");'), (1331, 1, u'+        assert(PTy->canLosslesslyBitCastTo(FTy->getParamType(i)) &&'), (1347, 1, u'+      assert(V->getType()->canLosslesslyBitCastTo(RetTy) &&'), (1641, 1, u'+    assert(Type.getEltType() == NeonTypeFlags::Float16 && !quad &&'), (1647, 1, u'+    assert(Type.getEltType() == NeonTypeFlags::Float16 && !quad &&'), (1882, 1, u'+    assert(Type.isPoly() && "vmul builtin only supported for polynomial types");'), (2222, 1, u'+  assert((Ops.size() & (Ops.size() - 1)) == 0 &&'), (2254, 1, u'+  assert(Error == ASTContext::GE_None && "Should not codegen an error");'), (2267, 1, u'+    assert(IsConst && "Constant arg isn\'t actually constant?"); (void)IsConst;')]
===========================================
Class:class CGNVCUDARuntime : public CGCUDARuntime { class CGNVCUDARuntime : public CGCUDARuntime 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(88, 1, u'+    assert(isa<llvm::PointerType>(V->getType()) && "Arg type not PointerType");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(160, 1, u'+    assert(Entry->isDeclaration() && "definition already exists for alias");'), (161, 1, u'+    assert(Entry->getType() == AliasType &&'), (320, 1, u'+  assert((Qual->getKind() == NestedNameSpecifier::TypeSpec) &&'), (326, 1, u'+  assert(RT && "BuildAppleKextVirtualCall - Qual type must be record");'), (335, 1, u'+  assert(VTable && "BuildVirtualCall = kext vtbl pointer is null");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(136, 1, u'+  assert(getThisDecl(CGF) && "no \'this\' variable for function");'), (184, 1, u'+  assert(E->getCastKind() == CK_DerivedToBaseMemberPointer ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(147, 1, u'+  assert(!isa<CXXConstructorDecl>(MD) && "wrong method for contructors!");'), (148, 1, u'+  assert(!isa<CXXDestructorDecl>(MD) && "wrong method for destructors!");'), (195, 1, u'+  assert(FTP->getNumArgs() == 0 && "dtor with formal parameters");'), (211, 1, u'+  assert(isa<FunctionType>(FTy));'), (223, 1, u'+  assert(isa<FunctionProtoType>(FTy));'), (349, 1, u'+    assert(I->isCanonicalAsParam());'), (368, 1, u'+  assert(inserted && "Recursively being processed?");'), (386, 1, u'+  assert(erased && "Not in set?");'), (424, 1, u'+    assert(!RD->hasFlexibleArrayMember() &&'), (435, 1, u'+        assert(!FD->isBitField() &&'), (449, 1, u'+        assert(!FD->isBitField() &&'), (465, 1, u'+  assert(LV.isSimple() &&'), (487, 1, u'+        assert(!FD->isBitField() &&'), (782, 1, u'+  assert(Inserted && "Recursively being processed?");'), (798, 1, u'+    assert(!retAI.getIndirectAlign() && "Align unused on indirect return.");'), (853, 1, u'+  assert(Erased && "Not in set?");'), (1040, 1, u'+  assert((varType->isIntegerTy() || varType->isFloatingPointTy())'), (1078, 1, u'+  assert(FI.arg_size() == Args.size() &&'), (1140, 1, u'+        assert(AI != Fn->arg_end() && "Argument mismatch!");'), (1192, 1, u'+            assert(AI != Fn->arg_end() && "Argument mismatch!");'), (1204, 1, u'+            assert(AI != Fn->arg_end() && "Argument mismatch!");'), (1214, 1, u'+        assert(AI != Fn->arg_end() && "Argument mismatch!");'), (1262, 1, u'+  assert(AI == Fn->arg_end() && "Argument mismatch!");'), (1383, 1, u'+  assert(retainCall->use_empty());'), (1422, 1, u'+    assert(!store->isAtomic() && !store->isVolatile()); // see below'), (1432, 1, u'+  assert(!store->isAtomic() && !store->isVolatile());'), (1516, 1, u'+      assert(getLangOpts().ObjCAutoRefCount &&'), (1583, 1, u'+  assert(!isProvablyNull(srcAddr) &&'), (1689, 1, u'+    assert(srcRV.isScalar());'), (1711, 1, u'+    assert(getContext().getLangOpts().ObjCAutoRefCount);'), (1712, 1, u'+    assert(getContext().hasSameType(E->getType(), type));'), (1716, 1, u'+  assert(type->isReferenceType() == E->isGLValue() &&'), (1720, 1, u'+    assert(E->getObjectKind() == OK_Ordinary);'), (1729, 1, u'+    assert(L.isSimple());'), (1781, 1, u'+    assert(Elt->getType() == FTy->getParamType(ArgNo));'), (1783, 1, u'+    assert(FTy->isVarArg());'), (1809, 1, u'+    assert(RV.isAggregate() && "Unexpected rvalue during struct expansion");'), (1819, 1, u'+        assert(!FD->isBitField() &&'), (1845, 1, u'+    assert(RV.isScalar() &&'), (1889, 1, u'+  assert(CallInfo.arg_size() == CallArgs.size() &&')]
===========================================
Class:  class DestroyField  : public EHScopeStack::Cleanup {   class DestroyField  : public EHScopeStack::Cleanup 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 1, u'+  assert(rv.isAggregate());'), (115, 1, u'+  assert(StartOfBuffer + Size <= StartOfData);'), (150, 1, u'+  assert(((Size % sizeof(void*)) == 0) && "cleanup type is misaligned");'), (172, 1, u'+  assert(!empty() && "popping exception stack when not empty");'), (174, 1, u'+  assert(isa<EHCleanupScope>(*begin()));'), (197, 1, u'+  assert(getInnermostEHScope() == stable_end());'), (205, 1, u'+  assert(!empty() && "popping exception stack when not empty");'), (235, 1, u'+  assert(hasNormalCleanups());'), (239, 1, u'+  assert(BranchFixups.size() >= MinSize && "fixup stack out of order");'), (260, 1, u'+  assert(cleanup.getActiveFlag() == 0 && "cleanup already has active flag?");'), (314, 1, u'+  assert(Term && "can\'t transition block without terminator");'), (317, 1, u'+    assert(Br->isUnconditional());'), (330, 1, u'+  assert(Block && "resolving a null target block");'), (333, 1, u'+  assert(EHStack.hasNormalCleanups() &&'), (369, 1, u'+  assert(Old.isValid());'), (386, 1, u'+  assert(Scope.isNormalCleanup());'), (407, 1, u'+  assert(Br->getSuccessor(0) == Entry);'), (413, 1, u'+  assert(!WasInsertBlock || CGF.Builder.GetInsertPoint() == Entry->end());'), (455, 1, u'+  assert(CGF.HaveInsertPoint() && "cleanup ended with no insertion point?");'), (473, 1, u'+    assert(Br->isUnconditional() && Br->getSuccessor(0) == From);'), (516, 1, u'+      assert(condition->getOperand(0) == CGF.NormalCleanupDest);'), (517, 1, u'+      assert(condition->use_empty());'), (522, 1, u'+  assert(entry->use_empty());'), (530, 1, u'+  assert(!EHStack.empty() && "cleanup stack is empty!");'), (531, 1, u'+  assert(isa<EHCleanupScope>(*EHStack.begin()) && "top not a cleanup!");'), (533, 1, u'+  assert(Scope.getFixupDepth() <= EHStack.getNumBranchFixups());'), (545, 1, u'+  assert(Scope.hasEHBranches() == (EHEntry != 0));'), (572, 1, u'+  assert(!Scope.isNormalCleanup() || !HasPrebranchedFallthrough ||'), (605, 1, u'+    assert(normalEntry && !normalEntry->use_empty());'), (615, 1, u'+    assert(EHStack.getNumBranchFixups() == 0 ||'), (670, 1, u'+        assert(!IsActive && "source without fallthrough for active cleanup");'), (694, 1, u'+        assert(HasEnclosingCleanups);'), (706, 1, u'+        assert(!BranchThroughDest || !IsActive);'), (753, 1, u'+        assert(BranchThroughDest);'), (759, 1, u'+      assert(EHStack.hasNormalCleanups() == HasEnclosingCleanups);'), (790, 1, u'+        assert(!IsActive);'), (797, 1, u'+        assert(!FallthroughIsBranchThrough);'), (826, 1, u'+  assert(EHStack.hasNormalCleanups() || EHStack.getNumBranchFixups() == 0);'), (849, 1, u'+  assert(Dest.getScopeDepth().encloses(EHStack.stable_begin())'), (874, 1, u'+  assert(Dest.getScopeDepth().encloses(EHStack.stable_begin())'), (928, 1, u'+      assert(Scope.isNormalCleanup());'), (959, 1, u'+    assert(C.strictlyEncloses(I));'), (977, 1, u'+    assert(cleanup.strictlyEncloses(i));'), (1037, 1, u'+    assert(dominatingIP && "no existing variable and no dominating IP!");'), (1058, 1, u'+  assert(C != EHStack.stable_end() && "activating bottom of stack?");'), (1060, 1, u'+  assert(!Scope.isActive() && "double activation");'), (1070, 1, u'+  assert(C != EHStack.stable_end() && "deactivating bottom of stack?");'), (1072, 1, u'+  assert(Scope.isActive() && "double deactivation");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+  assert(LexicalBlockStack.empty() &&'), (118, 1, u'+  assert (FD && "Invalid FunctionDecl!");'), (468, 1, u'+    assert(Qc.empty() && "Unknown type qualifier for debug info");'), (786, 1, u'+          assert(SizeInBitsOverride && "found named 0-width bitfield");'), (824, 1, u'+        assert(SizeInBitsOverride && "found named 0-width bitfield");'), (850, 1, u'+  assert (Args.getNumElements() && "Invalid number of arguments!");'), (1637, 1, u'+    assert(T != LastT && "Type unwrapping failed to unwrap!");'), (1781, 1, u'+  assert(Diag && "Fall through without a diagnostic?");'), (2116, 1, u'+  assert(!LexicalBlockStack.empty() && "Region stack mismatch, stack empty!");'), (2126, 1, u'+  assert(!LexicalBlockStack.empty() && "Region stack mismatch, stack empty!");'), (2128, 1, u'+  assert(RCount <= LexicalBlockStack.size() && "Region stack mismatch");'), (2208, 1, u'+  assert(!LexicalBlockStack.empty() && "Region stack mismatch, stack empty!");'), (2330, 1, u'+  assert(!LexicalBlockStack.empty() && "Region stack mismatch, stack empty!");')]
===========================================
Class:  class RegularPartialArrayDestroy : public EHScopeStack::Cleanup {   class RegularPartialArrayDestroy : public EHScopeStack::Cleanup 
Class:            class IrregularPartialArrayDestroy : public EHScopeStack::Cleanup {   class IrregularPartialArrayDestroy : public EHScopeStack::Cleanup 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 1, u'+  assert(D.hasGlobalStorage() && "VarDecl must have global storage!");'), (26, 1, u'+  assert(!D.getType()->isReferenceType() &&'), (87, 1, u'+    assert(!record->hasTrivialDestructor());'), (141, 1, u'+  assert(PerformInit && "cannot have constant initializer which needs "'), (313, 1, u'+      assert(CXXGlobalInits[I->second] == 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(311, 1, u'+  assert(std::strcmp(ObjCXX.PersonalityFn, CXX.PersonalityFn) != 0 &&'), (661, 1, u'+  assert(EHStack.requiresLandingPad());'), (662, 1, u'+  assert(!EHStack.empty());'), (674, 1, u'+  assert(LP);'), (737, 1, u'+  assert(EHStack.requiresLandingPad());'), (790, 1, u'+      assert(I.next() == EHStack.end() && "EH filter is not end of EH stack");'), (791, 1, u'+      assert(!hasCatchAll && "EH filter reached after catch-all");'), (805, 1, u'+      assert(!hasCatchAll);'), (819, 1, u'+        assert(!hasCatchAll);'), (833, 1, u'+  assert(!(hasCatchAll && hasFilter));'), (866, 1, u'+  assert((LPadInst->getNumClauses() > 0 || LPadInst->isCleanup()) &&'), (1041, 1, u'+  assert(isa<RecordType>(CatchType) && "unexpected catch type!");'), (1143, 1, u'+  assert(dispatchBlock);'), (1149, 1, u'+    assert(dispatchBlock == catchScope.getHandler(0).Block);'), (1165, 1, u'+    assert(i < e && "ran off end of handlers!");'), (1169, 1, u'+    assert(typeValue && "fell into catch-all case!");'), (1223, 1, u'+  assert(CatchScope.getNumHandlers() == NumHandlers);'), (1394, 1, u'+  assert((beginCatchFn != 0) == (endCatchFn != 0) &&'), (1396, 1, u'+  assert(rethrowFn && "rethrow function is required");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(294, 1, u'+          assert(!ObjCARCReferenceLifetimeType->isArrayType());'), (305, 1, u'+          assert(!ObjCARCReferenceLifetimeType->isArrayType());'), (341, 1, u'+          assert(ME->getBase()->getType()->isRecordType());'), (468, 1, u'+      assert(!ObjCARCReferenceLifetimeType.isNull());'), (679, 1, u'+    assert(cast<InitListExpr>(E)->getNumInits() == 1 &&'), (749, 1, u'+  assert(type.isCanonical());'), (750, 1, u'+  assert(!type->isReferenceType());'), (847, 1, u'+    assert(isa<EnumConstantDecl>(value));'), (902, 1, u'+      assert(NumBits <= Bitwidth);'), (906, 1, u'+      assert(NumPositiveBits <= Bitwidth);'), (944, 1, u'+    assert(Value->getType()->isIntegerTy(8) && "value rep of bool not i1/i8");'), (953, 1, u'+    assert(Value->getType()->isIntegerTy(8) && "memory rep of bool not i8");'), (997, 1, u'+    assert(!LV.getType()->isFunctionType());'), (1016, 1, u'+  assert(LV.isBitField() && "Unknown LValue type!");'), (1149, 1, u'+    assert(Dst.isBitField() && "Unknown LValue type");'), (1192, 1, u'+      assert(Dst.getBaseIvarExp() && "BaseIvarExp is NULL");'), (1211, 1, u'+  assert(Src.isScalar() && "Can\'t emit an agg store with this method");'), (1498, 1, u'+  assert((VD->hasExternalStorage() || VD->isFileVarDecl()) &&'), (1546, 1, u'+  assert((ND->isUsed(false) || !isa<VarDecl>(ND) ||'), (1580, 1, u'+      assert(isa<BlockDecl>(CurCodeDecl) && E->refersToEnclosingLocal());'), (1586, 1, u'+    assert(V && "DeclRefExpr not entered in LocalDeclMap?");'), (1625, 1, u'+    assert(!T.isNull() && "CodeGenFunction::EmitUnaryOpLValue: Illegal type");'), (1643, 1, u'+    assert(LV.isSimple() && "real/imag on non-ordinary l-value");'), (1651, 1, u'+      assert(E->getSubExpr()->getType()->isArithmeticType());'), (1655, 1, u'+    assert(E->getSubExpr()->getType()->isAnyComplexType());'), (1788, 1, u'+    assert(LHS.isSimple() && "Can only subscript lvalue vectors here!");'), (1860, 1, u'+    assert(Array->getType()->isArrayType() &&'), (1884, 1, u'+  assert(!T.isNull() &&'), (1934, 1, u'+    assert(E->getBase()->getType()->isVectorType());'), (1938, 1, u'+    assert(E->getBase()->getType()->isVectorType() &&'), (1960, 1, u'+  assert(Base.isExtVectorElt() && "Can only subscript lvalue vec elts here!");'), (2025, 1, u'+    assert(LV.isSimple());'), (2052, 1, u'+    assert(!type->isReferenceType() && "union has reference member");'), (2123, 1, u'+  assert(!FieldType.getObjCGCAttr() && "fields cannot have GC attrs");'), (2162, 1, u'+    assert((hasAggregateLLVMType(expr->getType()) &&'), (2366, 1, u'+  assert(OpaqueValueMappingData::shouldBindAsLValue(e));'), (2490, 1, u'+  assert(E->getOpcode() == BO_Assign && "unexpected binary l-value");'), (2528, 1, u'+  assert(E->getCallReturnType()->isReferenceType() &&'), (2541, 1, u'+  assert(E->getType()->getAsCXXRecordDecl()->hasTrivialDestructor()'), (2575, 1, u'+  assert(E->getMethodDecl()->getResultType()->isReferenceType() &&'), (2639, 1, u'+  assert(CalleeType->isFunctionPointerType() &&'), (2744, 1, u'+    assert(!Dest && "Store does not return a value");'), (2863, 1, u'+    assert(!Dest && "Init does not return a value");'), (3165, 1, u'+  assert(Val->getType()->isFPOrFPVectorTy());')]
===========================================
Class:class AggExprEmitter : public StmtVisitor<AggExprEmitter> { class AggExprEmitter : public StmtVisitor<AggExprEmitter> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(240, 1, u'+  assert(Dest.getAddr() != Src.getAggregateAddr());'), (250, 1, u'+  assert(Src.isAggregate() && "value must be aggregate value!");'), (290, 1, u'+  assert(Src.isSimple() && "Can\'t have aggregate bitfield, vector, etc");'), (387, 1, u'+  assert(NumInitElements <= NumArrayElements);'), (458, 1, u'+    assert(cons->getConstructor()->isDefaultConstructor());'), (552, 1, u'+    assert(isa<CXXDynamicCastExpr>(E) && "CK_Dynamic without a dynamic_cast?");'), (591, 1, u'+    assert(CGF.getContext().hasSameUnqualifiedType(E->getSubExpr()->getType(),'), (685, 1, u'+  assert(CGF.getContext().hasSameUnqualifiedType(E->getLHS()->getType(),'), (735, 1, u'+  assert(CGF.HaveInsertPoint() && "expression evaluation ended with no IP!");'), (885, 1, u'+      assert(lv.isSimple());'), (940, 1, u'+  assert(E->getType()->isRecordType() && "Only support structs/unions here!");'), (961, 1, u'+        assert(Field->isUnnamedBitfield() && "Only unnamed bitfields allowed");'), (1026, 1, u'+      assert(LV.isSimple());'), (1172, 1, u'+  assert(E && hasAggregateLLVMType(E->getType()) &&'), (1174, 1, u'+  assert((Slot.getAddr() != 0 || Slot.isIgnored()) &&'), (1184, 1, u'+  assert(hasAggregateLLVMType(E->getType()) && "Invalid argument!");'), (1196, 1, u'+  assert(!Ty->isAnyComplexType() && "Shouldn\'t happen for complex");'), (1201, 1, u'+      assert((Record->hasTrivialCopyConstructor() ||')]
===========================================
Class:  class CallDeleteDuringNew : public EHScopeStack::Cleanup {   class CallDeleteDuringNew : public EHScopeStack::Cleanup 
Class:            class CallDeleteDuringConditionalNew : public EHScopeStack::Cleanup {   class CallDeleteDuringConditionalNew : public EHScopeStack::Cleanup 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+  assert(MD->isInstance() &&'), (333, 1, u'+  assert(MD->isInstance() &&'), (402, 1, u'+  assert(!Dest.isIgnored() && "Must have a destination!");'), (412, 1, u'+      assert(0 && "Delegating constructor should not need zeroing");'), (431, 1, u'+    assert(getContext().hasSameUnqualifiedType(E->getType(),'), (477, 1, u'+  assert(isa<CXXConstructExpr>(Exp) &&'), (490, 1, u'+  assert(!getContext().getAsConstantArrayType(E->getType())'), (534, 1, u'+  assert(isa<llvm::IntegerType>(numElements->getType()));'), (668, 1, u'+    assert(numElements->getType() == CGF.SizeTy);'), (716, 1, u'+          assert(arraySizeMultiplier == typeSizeMultiplier);'), (728, 1, u'+      assert(arraySizeMultiplier == 1);'), (763, 1, u'+    assert(sizeWithoutCookie && "didn\'t set sizeWithoutCookie?");'), (984, 1, u'+      assert(I < NumPlacementArgs && "index out of range");'), (991, 1, u'+      assert(FPT->getNumArgs() == NumPlacementArgs + 1 ||'), (1041, 1, u'+      assert(I < NumPlacementArgs && "index out of range");'), (1048, 1, u'+      assert(FPT->getNumArgs() == NumPlacementArgs + 1 ||'), (1157, 1, u'+    assert(getContext().hasSameUnqualifiedType(argType.getNonReferenceType(),'), (1166, 1, u'+  assert((placementArg == E->placement_arg_end() ||'), (1180, 1, u'+    assert(allocatorArgs.size() == 2);'), (1233, 1, u'+  assert((allocSize == allocSizeWithoutCookie) =='), (1236, 1, u'+    assert(E->isArray());'), (1284, 1, u'+  assert(DeleteFD->getOverloadedOperator() == OO_Delete);'), (1430, 1, u'+      assert(DeleteFTy->getNumArgs() == 1 || DeleteFTy->getNumArgs() == 2);'), (1483, 1, u'+  assert(allocatedPtr && "ReadArrayCookie didn\'t set allocated pointer");'), (1494, 1, u'+    assert(numElements && "no element count for a type with a destructor!");'), (1559, 1, u'+  assert(ConvertTypeForMem(DeleteTy) =='), (1720, 1, u'+  assert(SrcRecordTy->isRecordType() && "source type must be a record type!");'), (1721, 1, u'+  assert(DestRecordTy->isRecordType() && "dest type must be a record type!");')]
===========================================
Class:class ComplexExprEmitter class ComplexExprEmitter
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 1, u'+    assert(LV.isSimple() && "complex l-value must be simple");'), (78, 1, u'+    assert(LV.isSimple() && "complex l-value must be simple");'), (196, 1, u'+    assert(E->getType()->isAnyComplexType() && "Expected complex type!");'), (202, 1, u'+    assert(E->getType()->isAnyComplexType() && "Expected complex type!");'), (610, 1, u'+  assert(OpInfo.Ty->isAnyComplexType());'), (611, 1, u'+  assert(CGF.getContext().hasSameUnqualifiedType(OpInfo.Ty,'), (655, 1, u'+  assert(CGF.getContext().hasSameUnqualifiedType(E->getLHS()->getType(),'), (741, 1, u'+    assert (Ignore == false && "init list ignored");'), (744, 1, u'+    assert (Ignore == false && "init list ignored");'), (755, 1, u'+  assert(E->getNumInits() == 0 && "Unexpected number of inits");'), (786, 1, u'+  assert(E && E->getType()->isAnyComplexType() &&'), (798, 1, u'+  assert(E && E->getType()->isAnyComplexType() &&'), (819, 1, u'+  assert(E->getOpcode() == BO_Assign);')]
===========================================
Class:class ConstStructBuilder { class ConstStructBuilder 
Class:          class ConstExprEmitter :   public StmtVisitor<ConstExprEmitter, llvm::Constant*> {   public StmtVisitor<ConstExprEmitter, llvm::Constant*> 
Class:class ScalarExprEmitter class ScalarExprEmitter
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(522, 1, u'+  assert(SrcType.isCanonical() && "EmitScalarConversion strips typedefs");'), (530, 1, u'+  assert((SrcType->isIntegerType() || isa<llvm::PointerType>(Src->getType())) &&'), (536, 1, u'+  assert(isa<llvm::PointerType>(Src->getType()));'), (578, 1, u'+    assert(SrcType->isIntegerType() && "Not ptr->ptr or int->ptr conversion?");'), (591, 1, u'+    assert(isa<llvm::IntegerType>(DstTy) && "not ptr->int?");'), (636, 1, u'+    assert(SrcTy->isFloatingPointTy() && "Unknown real conversion");'), (642, 1, u'+    assert(SrcTy->isFloatingPointTy() && DstTy->isFloatingPointTy() &&'), (651, 1, u'+    assert(ResTy->isIntegerTy(16) && "Only half FP requires extra conversion");'), (844, 1, u'+  assert (Ignore == false && "init list ignored");'), (1082, 1, u'+    assert(E->getType()->isArrayType() &&'), (1090, 1, u'+      assert(isa<llvm::PointerType>(V->getType()) && "Expected pointer");'), (1091, 1, u'+      assert(isa<llvm::ArrayType>(cast<llvm::PointerType>(V->getType())'), (1159, 1, u'+    assert(CGF.getContext().hasSameUnqualifiedType(E->getType(), DestTy));'), (1160, 1, u'+    assert(E->isGLValue() && "lvalue-to-rvalue applied to r-value!");'), (1176, 1, u'+    assert(!DestTy->isBooleanType() && "bool should use PointerToBool");'), (1527, 1, u'+      assert(i < RL.getFieldCount() && "offsetof field in wrong type");'), (2186, 1, u'+    assert(E->getOpcode() == BO_EQ ||'), (2303, 1, u'+      assert(E->getOpcode() == BO_NE &&'), (2620, 1, u'+      assert(!RHS && "LHS and RHS types must match");'), (2742, 1, u'+  assert(E && !hasAggregateLLVMType(E->getType()) &&'), (2758, 1, u'+  assert(!hasAggregateLLVMType(SrcTy) && !hasAggregateLLVMType(DstTy) &&'), (2769, 1, u'+  assert(SrcTy->isAnyComplexType() && !hasAggregateLLVMType(DstTy) &&')]
===========================================
Class:  class PropertyImplStrategy {   class PropertyImplStrategy 
Class:class LazyRuntimeFunction { class LazyRuntimeFunction 
Class:     class CGObjCGNU : public CGObjCRuntime { class CGObjCGNU : public CGObjCRuntime 
Class:        class CGObjCGCC : public CGObjCGNU { class CGObjCGCC : public CGObjCGNU 
Class: class CGObjCGNUstep : public CGObjCGNU { class CGObjCGNUstep : public CGObjCGNU 
Class:class ObjCCommonTypesHelper { class ObjCCommonTypesHelper 
Class:   class ObjCTypesHelper : public ObjCCommonTypesHelper { class ObjCTypesHelper : public ObjCCommonTypesHelper 
Class:   class ObjCNonFragileABITypesHelper : public ObjCCommonTypesHelper { class ObjCNonFragileABITypesHelper : public ObjCCommonTypesHelper 
Class: class CGObjCCommonMac : public CodeGen::CGObjCRuntime { class CGObjCCommonMac : public CodeGen::CGObjCRuntime 
Class:   class SKIP_SCAN {   class SKIP_SCAN 
Class: class CGObjCMac : public CGObjCCommonMac { class CGObjCMac : public CGObjCCommonMac 
Class: class CGObjCNonFragileABIMac : public CGObjCCommonMac { class CGObjCNonFragileABIMac : public CGObjCCommonMac 
Class:  class FragileHazards {   class FragileHazards 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(62, 1, u'+  assert(Index < RL->getFieldCount() && "Ivar is not inside record layout!");')]
===========================================
Class:class RTTIBuilder { class RTTIBuilder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(459, 1, u'+    assert(isa<ObjCInterfaceType>(Ty));'), (543, 1, u'+  assert(TypeNameGV->hasAvailableExternallyLinkage() &&'), (731, 1, u'+  assert(isa<BuiltinType>(T) || isa<ObjCInterfaceType>(T));')]
===========================================
Class:class CGRecordLayoutBuilder { class CGRecordLayoutBuilder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(271, 1, u'+  assert(llvm::isPowerOf2_32(TypeSizeInBits) && "Unexpected type size!");'), (307, 1, u'+      assert(AccessWidth >= Types.getTarget().getCharWidth()'), (318, 1, u'+    assert(FieldOffset < AccessStart + AccessWidth && "Invalid access start!");'), (319, 1, u'+    assert(AccessStart < FieldOffset + FieldSize && "Invalid access start!");'), (325, 1, u'+    assert(NumComponents < 3 && "Unexpected number of components!");'), (352, 1, u'+  assert(AccessedTargetBits == FieldSize && "Invalid bit-field access!");'), (381, 1, u'+    assert(fieldOffset % charAlign == 0 &&'), (393, 1, u'+    assert(BitsAvailableInLastField && "Bitfield size mismatch!");'), (394, 1, u'+    assert(!NextFieldOffset.isZero() && "Must have laid out at least one byte");'), (401, 1, u'+    assert(fieldOffset % charAlign == 0 &&'), (411, 1, u'+    assert(!numBytesToAppend.isZero() && "No bytes to append!");'), (442, 1, u'+  assert(fieldOffset % Types.getTarget().getCharWidth() == 0'), (453, 1, u'+    assert(!Packed && "Alignment is wrong even with packed struct!");'), (481, 1, u'+    assert(!Packed && "Could not place field even with packed struct!");'), (525, 1, u'+  assert(D->isUnion() && "Can\'t call LayoutUnion on a non-union record!");'), (539, 1, u'+    assert(layout.getFieldOffset(fieldNo) == 0 &&'), (580, 1, u'+    assert(hasOnlyZeroSizedBitFields &&'), (619, 1, u'+    assert(IsZeroInitializable &&'), (725, 1, u'+    assert(NextFieldOffset.isZero() &&'), (777, 1, u'+    assert(!Packed && "cannot layout even as packed struct");'), (799, 1, u'+  assert(!D->isUnion() && "Can\'t call LayoutFields on a union!");'), (800, 1, u'+  assert(!Alignment.isZero() && "Did not set alignment!");'), (826, 1, u'+      assert(!Packed &&'), (836, 1, u'+      assert(!Packed && "Could not layout even with a packed LLVM struct!");'), (864, 1, u'+  assert(NextFieldOffset <= RecordSize && "Size mismatch!");'), (891, 1, u'+  assert(NextFieldOffset <= fieldOffset &&'), (903, 1, u'+    assert(alignedNextFieldOffset <= fieldOffset);'), (933, 1, u'+  assert(!numBytes.isZero() && "Empty byte arrays aren\'t allowed.");'), (1033, 1, u'+  assert(TypeSizeInBits == getTargetData().getTypeAllocSizeInBits(Ty) &&'), (1045, 1, u'+    assert(AlignedNonVirtualTypeSizeInBits =='), (1066, 1, u'+      assert(AST_RL.getFieldOffset(i) == SL->getElementOffsetInBits(FieldNo) &&'), (1096, 1, u'+      assert(AccessBitOffset + AI.AccessWidth <= TypeSizeInBits &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+  assert(S && "Null statement?");'), (60, 1, u'+      assert(!isa<DeclStmt>(*S) && "Unexpected DeclStmt!");'), (98, 1, u'+    assert(incoming && "expression emission must have an insertion point");'), (103, 1, u'+    assert(outgoing && "expression emission cleared block!");'), (321, 1, u'+    assert(!Dest.getScopeDepth().isValid() && "already emitted label!");'), (797, 1, u'+  assert(!BreakContinueStack.empty() && "break stmt not in a loop or switch!");'), (810, 1, u'+  assert(!BreakContinueStack.empty() && "continue stmt not in a loop!");'), (826, 1, u'+  assert(S.getRHS() && "Expected RHS value in CaseStmt");'), (950, 1, u'+  assert(DefaultBlock->empty() &&'), (1047, 1, u'+          assert(FoundCase && "Didn\'t find case but returned fallthrough?");'), (1273, 1, u'+      assert(OutCons &&'), (1279, 1, u'+      assert(result && "Could not resolve symbolic name"); (void)result;'), (1311, 1, u'+  assert(Target.isValidGCCRegisterName(Register));'), (1425, 1, u'+    assert(IsValid && "Failed to parse output constraint");'), (1434, 1, u'+    assert(IsValid && "Failed to parse input constraint"); (void)IsValid;'), (1488, 1, u'+        assert(InputNo != S.getNumInputs() && "Didn\'t find matching input!");'), (1575, 1, u'+          assert(OutputTy->isFloatingPointTy() && "Unexpected output type");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 1, u'+    assert(VTable.getBaseOffset().isZero() &&'), (69, 1, u'+      assert(AddressPoint != 0 && "Did not find vtable address point!");'), (72, 1, u'+      assert(AddressPoint != 0 && "Did not find ctor vtable address point!");'), (100, 1, u'+  assert(RD->getNumVBases() && "Only classes with virtual bases need a VTT");'), (161, 1, u'+  assert(I != SubVTTIndicies.end() && "Did not find index!");'), (188, 1, u'+  assert(I != SecondaryVirtualPointerIndices.end() && "Did not find index!");')]
===========================================
Class:  class BackendConsumer : public ASTConsumer {   class BackendConsumer : public ASTConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(137, 1, u'+      assert(TheModule.get() == M &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(112, 1, u'+    assert(!CurBB->getTerminator() && "Unexpected terminated block.");'), (156, 1, u'+  assert(BreakContinueStack.empty() &&'), (181, 1, u'+  assert(EHStack.empty() &&'), (266, 1, u'+  assert(CurFn->isDeclaration() && "Function already has body?");'), (398, 1, u'+  assert(FD->getBody());'), (892, 1, u'+    assert(isa<ConstantArrayType>(arrayType));'), (893, 1, u'+    assert(cast<ConstantArrayType>(arrayType)->getSize().getZExtValue()'), (904, 1, u'+    assert(arrayType && "LLVM and Clang types are out-of-synch");'), (925, 1, u'+  assert(vla && "type was not a variable array type!");'), (938, 1, u'+    assert(vlaSize && "no size for VLA!");'), (939, 1, u'+    assert(vlaSize->getType() == SizeTy);'), (953, 1, u'+  assert(type->isVariablyModifiedType() &&'), (961, 1, u'+    assert(type->isVariablyModifiedType());'), (1072, 1, u'+  assert (Init && "Invalid DeclRefExpr initializer!");'), (1088, 1, u'+  assert(HaveInsertPoint());'), (1118, 1, u'+  assert(D->hasAttr<AnnotateAttr>() && "no annotate attribute");'), (1131, 1, u'+  assert(D->hasAttr<AnnotateAttr>() && "no annotate attribute");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(324, 1, u'+    assert(II && "Attempt to mangle unnamed decl.");'), (457, 1, u'+  assert(Linkage == GVA_StrongExternal);'), (614, 1, u'+  assert(!GV->isDeclaration() &&'), (672, 1, u'+    assert(CGRef && "Deferred decl wasn\'t referenced?");'), (751, 1, u'+  assert(D->hasAttr<AnnotateAttr>() && "no annotate attribute");'), (769, 1, u'+  assert(AA && "No alias?");'), (838, 1, u'+    assert(VD->isFileVarDecl() && "Cannot emit local var decl as global.");'), (1027, 1, u'+  assert(F->getName() == MangledName && "name was uniqued!");'), (1060, 1, u'+          assert(FD->isUsed() && "Sema didn\'t mark implicit function as used!");'), (1074, 1, u'+    assert(F->getType()->getElementType() == Ty);'), (1218, 1, u'+      assert(GV->isDeclaration() && "Declaration has wrong type!");'), (1248, 1, u'+  assert(D->hasGlobalStorage() && "Not a global variable");'), (1270, 1, u'+  assert(!D->getInit() && "Cannot emit definite definitions here!");'), (1480, 1, u'+  assert(llvmInit && "failed to initialize as constant");'), (1504, 1, u'+    assert(!ASTTy->isIncompleteType() && "Unexpected incomplete type");'), (1542, 1, u'+    assert(CE->getOpcode() == llvm::Instruction::BitCast ||'), (1748, 1, u'+    assert(CE->getOpcode() == llvm::Instruction::BitCast);'), (1757, 1, u'+    assert(OldFn->isDeclaration() &&'), (1818, 1, u'+  assert(AA && "Not an alias?");'), (1847, 1, u'+    assert(Entry->isDeclaration());'), (2196, 1, u'+  assert(!E->getType()->isPointerType() && "Strings are always arrays");'), (2225, 1, u'+  assert(ElemTy->getPrimitiveSizeInBits() == 32);'), (2501, 1, u'+  case Decl::StaticAssert:'), (2578, 1, u'+    assert(isa<TypeDecl>(D) && "Unsupported decl kind");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(406, 1, u'+    assert(A->getIndexTypeCVRQualifiers() == 0 &&'), (415, 1, u'+    assert(A->getIndexTypeCVRQualifiers() == 0 &&'), (564, 1, u'+  assert(ResultType && "Didn\'t convert a type?");'), (599, 1, u'+  assert(InsertResult && "Recursively compiling a struct?");'), (617, 1, u'+  assert(EraseResult && "struct not in RecordsBeingLaidOut set?");'), (648, 1, u'+  assert(Layout && "Unable to find record layout information for type");')]
===========================================
Class:class ItaniumCXXABI : public CodeGen::CGCXXABI { class ItaniumCXXABI : public CodeGen::CGCXXABI 
Class: class ARMCXXABI : public ItaniumCXXABI { class ARMCXXABI : public ItaniumCXXABI 
Class:class MicrosoftCXXABI : public CGCXXABI { class MicrosoftCXXABI : public CGCXXABI 
Class:  class CodeGeneratorImpl : public CodeGenerator {   class CodeGeneratorImpl : public CodeGenerator 
Class:class DefaultABIInfo : public ABIInfo { class DefaultABIInfo : public ABIInfo 
Class: class DefaultTargetCodeGenInfo : public TargetCodeGenInfo { class DefaultTargetCodeGenInfo : public TargetCodeGenInfo 
Class:      class X86_32ABIInfo : public ABIInfo { class X86_32ABIInfo : public ABIInfo 
Class: class X86_32TargetCodeGenInfo : public TargetCodeGenInfo { class X86_32TargetCodeGenInfo : public TargetCodeGenInfo 
Class:class X86_64ABIInfo : public ABIInfo { class X86_64ABIInfo : public ABIInfo 
Class:  class WinX86_64ABIInfo : public ABIInfo { class WinX86_64ABIInfo : public ABIInfo 
Class: class X86_64TargetCodeGenInfo : public TargetCodeGenInfo { class X86_64TargetCodeGenInfo : public TargetCodeGenInfo 
Class: class WinX86_64TargetCodeGenInfo : public TargetCodeGenInfo { class WinX86_64TargetCodeGenInfo : public TargetCodeGenInfo 
Class:  Class &Current = OffsetBase < 64 ? Lo : Hi;
Class:      Class FieldLo, FieldHi;
Class:        Class FieldLo, FieldHi;
Class:      Class FieldLo, FieldHi;
Class:class PPC32TargetCodeGenInfo : public DefaultTargetCodeGenInfo { class PPC32TargetCodeGenInfo : public DefaultTargetCodeGenInfo 
Class:class ARMABIInfo : public ABIInfo { class ARMABIInfo : public ABIInfo 
Class: class ARMTargetCodeGenInfo : public TargetCodeGenInfo { class ARMTargetCodeGenInfo : public TargetCodeGenInfo 
Class:class PTXABIInfo : public ABIInfo { class PTXABIInfo : public ABIInfo 
Class: class PTXTargetCodeGenInfo : public TargetCodeGenInfo { class PTXTargetCodeGenInfo : public TargetCodeGenInfo 
Class:class MBlazeABIInfo : public ABIInfo { class MBlazeABIInfo : public ABIInfo 
Class: class MBlazeTargetCodeGenInfo : public TargetCodeGenInfo { class MBlazeTargetCodeGenInfo : public TargetCodeGenInfo 
Class:class MSP430TargetCodeGenInfo : public TargetCodeGenInfo { class MSP430TargetCodeGenInfo : public TargetCodeGenInfo 
Class:class MipsABIInfo : public ABIInfo { class MipsABIInfo : public ABIInfo 
Class: class MIPSTargetCodeGenInfo : public TargetCodeGenInfo { class MIPSTargetCodeGenInfo : public TargetCodeGenInfo 
Class:class TCETargetCodeGenInfo : public DefaultTargetCodeGenInfo { class TCETargetCodeGenInfo : public DefaultTargetCodeGenInfo 
Class:class HexagonABIInfo : public ABIInfo { class HexagonABIInfo : public ABIInfo 
Class: class HexagonTargetCodeGenInfo : public TargetCodeGenInfo { class HexagonTargetCodeGenInfo : public TargetCodeGenInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(277, 1, u'+  assert(Index0 + 1 == Index1 && "Unexpected non-consecutive indices!");')]
===========================================
Class:class CC1AsOptTable : public OptTable { class CC1AsOptTable : public OptTable 
Class:class CC1OptTable : public OptTable { class CC1OptTable : public OptTable 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(184, 1, u'+    assert(Res && "Error string set with 0 result code!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(972, 1, u'+        assert(InputTypeArg && "InputType set w/o InputTypeArg");'), (1050, 1, u'+    assert(NumSteps && "Invalid number of steps!");'), (1089, 1, u'+        assert(i + 1 == NumSteps && "linking must be final compilation step.");'), (1134, 1, u'+      assert(OutputTy != types::TY_INVALID &&'), (1445, 1, u'+    assert(Suffix && "All types used for output should have a suffix.");')]
===========================================
Class:class DriverOptTable : public OptTable { class DriverOptTable : public OptTable 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 1, u'+  assert(((A.Kind == Option::JoinedClass) ^ (B.Kind == Option::JoinedClass)) &&'), (93, 1, u'+      assert(!TheInputOption && "Cannot have multiple input options!");'), (96, 1, u'+      assert(!TheUnknownOption && "Cannot have multiple input options!");'), (103, 1, u'+  assert(FirstSearchableIndex != 0 && "No searchable options?");'), (110, 1, u'+    assert((Kind != Option::InputClass && Kind != Option::UnknownClass &&'), (173, 1, u'+    assert((info.Kind == Option::JoinedOrSeparateClass ||'), (178, 1, u'+    assert((info.Kind == Option::JoinedOrSeparateClass ||'), (249, 1, u'+    assert(Index > Prev && "Parser failed to consume argument.");'), (253, 1, u'+      assert(Index >= End && "Unexpected parser error.");'), (254, 1, u'+      assert(Index - Prev - 1 && "No missing arguments!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 1, u'+  assert((!Alias || (!Alias->Alias && !Group)) &&'), (218, 1, u'+  assert(NumArgs > 1  && "Invalid MultiArgOption!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(511, 1, u'+  assert(define.startswith(SimulatorVersionDefineName()));'), (654, 1, u'+    assert((!iOSVersion && !iOSSimVersion) && "Unknown target platform!");'), (662, 1, u'+    assert(Version && "Unknown target platform!");'), (1484, 1, u'+      assert(0 && "Invalid tool kind.");'), (1492, 1, u'+      assert(false && "Unsupported action for Hexagon target.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(35, 1, u'+  assert(id > 0 && id - 1 < numTypes && "Invalid Type ID.");'), (215, 1, u'+  assert(N < getNumCompilationPhases(Id) && "Invalid index.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(22, 1, u'+  assert(Loc.isFileID());'), (34, 1, u'+  assert(Loc.isFileID());'), (324, 1, u'+  assert(!text.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(242, 1, u'+  assert(!offs.getFID().isInvalid());'), (245, 1, u'+  assert(Loc.isFileID());'), (250, 1, u'+    assert(len);'), (279, 1, u'+    assert(offs >= CurEnd);'), (305, 1, u'+  assert(BeginOffs.getFID() == EndOffs.getFID());'), (306, 1, u'+  assert(BeginOffs <= EndOffs);'), (309, 1, u'+  assert(BLoc.isFileID());')]
===========================================
Class:  class ASTPrinter : public ASTConsumer {   class ASTPrinter : public ASTConsumer 
Class:  class ASTViewer : public ASTConsumer {   class ASTViewer : public ASTConsumer 
Class:class DeclContextPrinter : public ASTConsumer { class DeclContextPrinter : public ASTConsumer 
Class:class ASTDumpXML : public ASTConsumer { class ASTDumpXML : public ASTConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(84, 1, u'+  assert(AdaptedAction && "ASTMergeAction needs an action to adapt");')]
===========================================
Class:  class SimpleTimer {   class SimpleTimer 
Class:class ASTInfoCollector : public ASTReaderListener { class ASTInfoCollector : public ASTReaderListener 
Class: class StoredDiagnosticConsumer : public DiagnosticConsumer { class StoredDiagnosticConsumer : public DiagnosticConsumer 
Class:   class CaptureDroppedDiagnostics { class CaptureDroppedDiagnostics 
Class:class MacroDefinitionTrackerPPCallbacks : public PPCallbacks { class MacroDefinitionTrackerPPCallbacks : public PPCallbacks 
Class: class TopLevelDeclTrackerConsumer : public ASTConsumer { class TopLevelDeclTrackerConsumer : public ASTConsumer 
Class: class TopLevelDeclTrackerAction : public ASTFrontendAction { class TopLevelDeclTrackerAction : public ASTFrontendAction 
Class: class PrecompilePreambleConsumer : public PCHGenerator { class PrecompilePreambleConsumer : public PCHGenerator 
Class: class PrecompilePreambleAction : public ASTFrontendAction { class PrecompilePreambleAction : public ASTFrontendAction 
Class:  class AugmentedCodeCompleteConsumer : public CodeCompleteConsumer {   class AugmentedCodeCompleteConsumer : public CodeCompleteConsumer 
Class:class PTHEntry { class PTHEntry 
Class:  class PTHEntryKeyVariant { class PTHEntryKeyVariant 
Class: class FileEntryPTHEntryInfo { class FileEntryPTHEntryInfo 
Class: class OffsetOpt { class OffsetOpt 
Class:class PTHWriter { class PTHWriter 
Class:class StatListener : public FileSystemStatCache { class StatListener : public FileSystemStatCache 
Class:class PTHIdKey { class PTHIdKey 
Class: class PTHIdentifierTableTrait { class PTHIdentifierTableTrait 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(63, 1, u'+  assert(!includes.empty() && "No \'-chain-include\' in options!");'), (121, 1, u'+      assert(!serialBufs.empty());'), (156, 1, u'+  assert(!serialBufs.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(439, 1, u'+  assert(OutFile.OS && "Attempt to add empty stream to output list!");'), (522, 1, u'+  assert((!CreateMissingDirectories || UseTemporary) &&'), (627, 1, u'+  assert(!SourceMgr.getMainFileID().isInvalid() &&'), (635, 1, u'+  assert(hasDiagnostics() && "Diagnostics engine is not initialized!");'), (636, 1, u'+  assert(!getFrontendOpts().ShowHelp && "Client must handle \'-help\'!");'), (637, 1, u'+  assert(!getFrontendOpts().ShowVersion && "Client must handle \'-version\'!");'), (817, 1, u'+  assert(ImportingInstance.getInvocation().getModuleHash() ==')]
===========================================
Class:  class ToArgsList {   class ToArgsList 
Class:  class ModuleSignature {   class ModuleSignature 
Class:class DependencyFileCallback : public PPCallbacks { class DependencyFileCallback : public PPCallbacks 
Class:class DependencyGraphCallback : public PPCallbacks { class DependencyGraphCallback : public PPCallbacks 
Class:class FixitReceiver : public edit::EditsReceiver { class FixitReceiver : public edit::EditsReceiver 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 1, u'+   assert(Loc.isMacroID() && "Only reasonble to call this on macros");'), (298, 1, u'+  assert(!Loc.isInvalid() && "must have a valid source location here");'), (303, 1, u'+    assert(MacroDepth == 0 && "We shouldn\'t hit a leaf node twice!");')]
===========================================
Class:class DelegatingDeserializationListener : public ASTDeserializationListener { class DelegatingDeserializationListener : public ASTDeserializationListener 
Class:  class DeserializedDeclsDumper : public DelegatingDeserializationListener { class DeserializedDeclsDumper : public DelegatingDeserializationListener 
Class:         class DeserializedDeclsChecker : public DelegatingDeserializationListener {   class DeserializedDeclsChecker : public DelegatingDeserializationListener 
Class:class HeaderIncludesCallback : public PPCallbacks { class HeaderIncludesCallback : public PPCallbacks 
Class:class InitHeaderSearch { class InitHeaderSearch 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(105, 1, u'+  assert(!Path.isTriviallyEmpty() && "can\'t handle empty path here");'), (513, 1, u'+      assert(CurEntry.isHeaderMap() && "Not a headermap or normal dir?");'), (530, 1, u'+        assert(FirstDir != i && "Didn\'t find dupe?");'), (544, 1, u'+          assert(CurEntry.isHeaderMap() && "Not a headermap or normal dir?");'), (639, 1, u'+        assert(SearchList[i].isHeaderMap() && "Unknown DirectoryLookup");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 1, u'+  assert(Sem == (const llvm::fltSemantics*)&llvm::APFloat::IEEEquad);'), (448, 1, u'+  assert(TI.getCharWidth() == 8 && "Only support 8-bit char so far");')]
===========================================
Class:class MultiplexASTDeserializationListener class MultiplexASTDeserializationListener
Class:   class MultiplexASTMutationListener : public ASTMutationListener { class MultiplexASTMutationListener : public ASTMutationListener 
Class:class PrintPPOutputPPCallbacks : public PPCallbacks { class PrintPPOutputPPCallbacks : public PPCallbacks 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(585, 1, u'+    assert(Opts.ShowMacros && "Not yet implemented!");')]
===========================================
Class:class AbbreviationMap { class AbbreviationMap 
Class: class SDiagsRenderer : public DiagnosticNoteRenderer { class SDiagsRenderer : public DiagnosticNoteRenderer 
Class: class SDiagsWriter : public DiagnosticConsumer { class SDiagsWriter : public DiagnosticConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(109, 1, u'+        assert(DiagOpts.ShowCategories == 2 && "Invalid ShowCategories value");'), (155, 1, u'+  assert(LangOpts && "Unexpected diagnostic outside source file processing");'), (156, 1, u'+  assert(DiagOpts && "Unexpected diagnostic without options set");'), (157, 1, u'+  assert(Info.hasSourceManager() &&')]
===========================================
Class:class Directive { class Directive 
Class:   class StandardDirective : public Directive { class StandardDirective : public Directive 
Class:   class RegexDirective : public Directive { class RegexDirective : public Directive 
Class: class ParseHelper { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(195, 1, u'+  assert(isHeaderMap() && "Unknown DirectoryLookup");'), (247, 1, u'+  assert(isHeaderMap() && "Unknown directory lookup");'), (568, 1, u'+  assert(ContextFileEnt && "No context file?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+  assert(BufEnd[0] == 0 &&'), (189, 1, u'+  assert(L->BufferEnd[0] == 0 && "Buffer is not nul terminated!");'), (291, 1, u'+  assert((int)Tok.getLength() >= 0 && "Token character range is bogus!");'), (315, 1, u'+  assert(Result.size() != unsigned(Tok.getLength()) &&'), (333, 1, u'+  assert((int)Tok.getLength() >= 0 && "Token character range is bogus!");'), (375, 1, u'+  assert(unsigned(OutBuf-Buffer) != Tok.getLength() &&'), (424, 1, u'+  assert(Loc.isFileID());'), (495, 1, u'+ assert(FileLocInfo.first == BeginFileLocInfo.first &&'), (743, 1, u'+  assert(loc.isValid() && loc.isMacroID() && "Expected a valid macro loc");'), (769, 1, u'+  assert(loc.isValid() && loc.isMacroID() && "Expected a valid macro loc");'), (801, 1, u'+  assert(Begin.isFileID() && End.isFileID());'), (855, 1, u'+  assert(Begin.isMacroID() && End.isMacroID());'), (930, 1, u'+  assert(Loc.isMacroID() && "Only reasonble to call this on macros");'), (1062, 1, u"+  assert(CHAR_HORZ_WS == CharInfo[(int)' ']);"), (1063, 1, u"+  assert(CHAR_HORZ_WS == CharInfo[(int)'\\t']);"), (1064, 1, u"+  assert(CHAR_HORZ_WS == CharInfo[(int)'\\f']);"), (1065, 1, u"+  assert(CHAR_HORZ_WS == CharInfo[(int)'\\v']);"), (1066, 1, u"+  assert(CHAR_VERT_WS == CharInfo[(int)'\\n']);"), (1067, 1, u"+  assert(CHAR_VERT_WS == CharInfo[(int)'\\r']);"), (1068, 1, u"+  assert(CHAR_UNDER   == CharInfo[(int)'_']);"), (1069, 1, u"+  assert(CHAR_PERIOD  == CharInfo[(int)'.']);"), (1071, 1, u'+    assert(CHAR_LETTER == CharInfo[i]);'), (1072, 1, u"+    assert(CHAR_LETTER == CharInfo[i+'A'-'a']);"), (1075, 1, u'+    assert(CHAR_NUMBER == CharInfo[i]);'), (1141, 1, u'+  assert(FileLoc.isMacroID() && "Must be a macro expansion");'), (1165, 1, u'+  assert(Loc >= BufferStart && Loc <= BufferEnd &&'), (1176, 1, u'+  assert(PP && "This doesn\'t work on raw lexers");'), (1579, 1, u'+  assert(getLangOpts().CPlusPlus);'), (2035, 1, u'+  assert(Spelling[0] == \'/\' && Spelling[1] == \'/\' && "Not bcpl comment?");'), (2050, 1, u"+  assert(CurPtr[0] == '\\n' || CurPtr[0] == '\\r');"), (2290, 1, u'+  assert(ParsingPreprocessorDirective && ParsingFilename == false &&'), (2320, 1, u'+      assert(CurPtr[-1] == Char && "Trigraphs for newline?");'), (2330, 1, u'+      assert(Tmp.is(tok::eod) && "Unexpected token!");'), (2394, 1, u'+  assert(!LexingRawMode && "How can we expand a macro from a skipping buffer?");'), (2474, 1, u'+      assert(CurPtr != BufferEnd && "Didn\'t find end of line");'), (2584, 1, u'+      assert(PPCache && "Raw buffer::LexEndOfFile should return a token");'), (2612, 1, u'+      assert(PPCache && "Raw buffer::LexEndOfFile should return a token");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(272, 1, u'+  assert((CharByteWidth == 1 || CharByteWidth == 2 || CharByteWidth) &&'), (276, 1, u'+  assert((UcnLen== 4 || UcnLen== 8) && "only ucn length of 4 or 8 supported");'), (306, 1, u'+  assert(CharByteWidth == 1 && "UTF-8 encoding is only for 1 byte characters");'), (396, 1, u"+  assert(!isalnum(*end) && *end != '.' && *end != '_' &&"), (568, 1, u'+  assert(s[0] == \'0\' && "Invalid method call");'), (729, 1, u'+    assert(C < radix && "NumericLiteralParser ctor should have rejected this");'), (811, 1, u'+  assert(begin[0] == \'\\\'\' && "Invalid token lexed");'), (825, 1, u'+  assert(end != begin && "Invalid token lexed");'), (831, 1, u'+  assert(PP.getTargetInfo().getCharWidth() == 8 &&'), (833, 1, u'+  assert(PP.getTargetInfo().getIntWidth() <= 64 &&'), (836, 1, u'+  assert(PP.getTargetInfo().getWCharWidth() <= 64 &&'), (1049, 1, u'+  assert(NumStringToks && "expected at least one token");'), (1051, 1, u'+  assert(StringToks[0].getLength() >= 2 && "literal token is invalid!");'), (1067, 1, u'+    assert(StringToks[i].getLength() >= 2 && "literal token is invalid!");'), (1095, 1, u'+  assert((CharByteWidth & 7) == 0 && "Assumes character size is byte multiple");'), (1188, 1, u'+      assert(ThisTokEnd >= ThisTokBuf && "malformed raw string literal");'), (1195, 1, u'+      assert(ThisTokBuf[0] == \'"\' && "Expected quote, lexer broken?");'), (1252, 1, u'+          assert(CharByteWidth == 1 && "Unexpected char width");'), (1271, 1, u'+      assert(CharByteWidth == 1 && "Unexpected char width");'), (1303, 1, u'+  assert(CharByteWidth==1 || CharByteWidth==2 || CharByteWidth==4);'), (1335, 1, u'+  assert((result != targetExhausted)'), (1368, 1, u"+  assert(SpellingPtr[0] != 'L' && SpellingPtr[0] != 'u' &&"), (1376, 1, u'+  assert(SpellingPtr[0] == \'"\' && "Should be a string literal!");'), (1381, 1, u'+    assert(SpellingPtr < SpellingEnd && "Didn\'t find byte offset!");'), (1395, 1, u'+    assert(!HadError && "This method isn\'t valid on erroneous strings");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 1, u'+  assert(MI->isFunctionLike() &&'), (120, 1, u'+    assert(Result < Start+NumUnexpArgTokens && "Invalid arg #");'), (124, 1, u'+  assert(Result < Start+NumUnexpArgTokens && "Invalid arg #");'), (150, 1, u'+  assert(Arg < MI->getNumArgs() && "Invalid argument number!");'), (305, 1, u'+  assert(ArgNo < NumUnexpArgTokens && "Invalid argument number!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 1, u'+  assert(!IsDefinitionLengthCached);'), (70, 1, u'+  assert(macroStart.isValid() && macroEnd.isValid());'), (71, 1, u'+  assert((macroStart.isFileID() || firstToken.is(tok::comment)) &&'), (73, 1, u'+  assert((macroEnd.isFileID() || lastToken.is(tok::comment)) &&'), (79, 1, u'+  assert(startInfo.first == endInfo.first &&'), (81, 1, u'+  assert(startInfo.second <= endInfo.second);')]
===========================================
Class:  class ModuleMapParser {   class ModuleMapParser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+    assert(Unresolved.Wildcard && "Invalid unresolved export");'), (94, 1, u'+  assert((!this->Target || this->Target == &Target) &&'), (763, 1, u'+  assert(Tok.is(MMToken::ExplicitKeyword) || Tok.is(MMToken::ModuleKeyword) ||'), (994, 1, u'+  assert(Tok.is(MMToken::RequiresKeyword));'), (1066, 1, u'+  assert(Tok.is(MMToken::HeaderKeyword));'), (1240, 1, u'+  assert(Tok.is(MMToken::ExportKeyword));'), (1278, 1, u'+  assert(Tok.is(MMToken::Star));'), (1422, 1, u'+  assert(Target != 0 && "Missing target information");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+  assert(!BacktrackPositions.empty()'), (41, 1, u'+  assert(!BacktrackPositions.empty()'), (87, 1, u'+  assert(CachedLexPos + N > CachedTokens.size() && "Confused caching.");'), (98, 1, u'+  assert(Tok.isAnnotation() && "Expected annotation token");'), (99, 1, u'+  assert(CachedLexPos != 0 && "Expected to have some cached tokens");'), (100, 1, u'+  assert(CachedTokens[CachedLexPos-1].getLastLoc() == Tok.getAnnotationEndLoc()'), (108, 1, u'+      assert((BacktrackPositions.empty() || BacktrackPositions.back() < i) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 1, u'+    assert(MIChainHead == MIChain);'), (91, 1, u'+    assert(Tmp.isNot(tok::eof) && "EOF seen while discarding directive tokens");'), (207, 1, u'+  assert(CurTokenLexer == 0 && CurPPLexer && "Lexing a macro, not a file?");'), (325, 1, u'+        assert(!InCond && "Can\'t be skipping if not in a conditional!");'), (369, 1, u'+          assert(CurPPLexer->LexingRawMode && "We have to be skipping here!");'), (411, 1, u'+    assert(CurPTHLexer);'), (412, 1, u'+    assert(CurPTHLexer->LexingRawMode == false);'), (421, 1, u'+      assert(!InCond && "Can\'t be skipping if not in a conditional!");'), (458, 1, u'+    assert(K == tok::pp_elif);'), (685, 1, u'+    case tok::pp_assert:'), (688, 1, u'+    case tok::pp_unassert:'), (832, 1, u'+    assert(Literal.isAscii() && "Didn\'t allow wide strings in");'), (968, 1, u'+    assert(Literal.isAscii() && "Didn\'t allow wide strings in");'), (1146, 1, u'+  assert(!Buffer.empty() && "Can\'t have tokens with empty spellings!");'), (1462, 1, u'+  assert(!FID.isInvalid() && "Expected valid file ID");'), (1540, 1, u'+    assert(TmpTok.isNot(tok::eof) && "Didn\'t find end of -imacros!");'), (1687, 1, u'+    assert(Ident__VA_ARGS__->isPoisoned() && "__VA_ARGS__ should be poisoned!");'), (1829, 1, u'+  assert(!MI->isUsed());'), (1919, 1, u'+      assert(isIfndef && "#ifdef shouldn\'t reach here");'), (2006, 1, u'+  assert(!CondInfo.WasSkipping && !CurPPLexer->LexingRawMode &&')]
===========================================
Class:class PPValue { class PPValue 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 1, u'+  assert(IsFileLexer(IncludeMacroStack[0]) &&'), (73, 1, u'+  assert(CurTokenLexer == 0 && "Cannot #include a file inside a macro!");'), (234, 1, u'+  assert(!CurTokenLexer &&'), (272, 1, u'+        assert(CurPTHLexer && "Got EOF but no current lexer set!");'), (335, 1, u'+    assert(CurPTHLexer && "Got EOF but no current lexer set!");'), (397, 1, u'+  assert(CurTokenLexer && !CurPPLexer &&'), (418, 1, u'+  assert(!IncludeMacroStack.empty() && "Ran out of stack entries to load");'), (435, 1, u'+  assert(CurTokenLexer && !CurPPLexer &&'), (476, 1, u'+    assert(FoundLexer && "Can\'t get end of line without an active lexer");'), (493, 1, u'+  assert(!FoundLexer && "Lexer should return EOD before EOF in PP mode");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(35, 1, u'+  assert(II->hasMacroDefinition() && "Identifier is not a macro!");'), (44, 1, u'+  assert(Pos != Macros.end() && "Identifier macro info is missing!");'), (347, 1, u'+  assert(Tok.is(tok::l_paren) && "Error computing l-paren-ness?");'), (356, 1, u'+    assert((Tok.is(tok::l_paren) || Tok.is(tok::comma)) &&'), (449, 1, u'+    assert(NumFixedArgsLeft != 0 && "Too many arguments parsed");'), (519, 1, u'+  assert(tokLexer);'), (544, 1, u'+  assert(!MacroExpandingLexersStack.empty());'), (546, 1, u'+  assert(tokIndex < MacroExpandedTokens.size());'), (893, 1, u'+  assert(II && "Can\'t be a macro without id info!");'), (1054, 1, u'+      assert(II == Ident__has_feature && "Must be feature check");'), (1112, 1, u'+        assert(Literal.isAscii() && "Didn\'t allow wide strings in");')]
===========================================
Class:class PTHFileData { class PTHFileData 
Class:  class PTHFileLookupCommonTrait { class PTHFileLookupCommonTrait 
Class: class PTHFileLookupTrait : public PTHFileLookupCommonTrait { class PTHFileLookupTrait : public PTHFileLookupCommonTrait 
Class: class PTHStringLookupTrait { class PTHStringLookupTrait 
Class:class PTHStatData { class PTHStatData 
Class: class PTHStatLookupTrait : public PTHFileLookupCommonTrait { class PTHStatLookupTrait : public PTHFileLookupCommonTrait 
Class: class PTHStatCache : public FileSystemStatCache { class PTHStatCache : public FileSystemStatCache 
Class:class LexingFor_PragmaRAII { class LexingFor_PragmaRAII 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+  assert(!FID.isInvalid());'), (100, 1, u'+    assert(unsigned(-PPID-1) < LoadedPreprocessedEntities.size() &&'), (102, 1, u'+    assert(ExternalSource && "No external source to load from");'), (121, 1, u'+  assert(unsigned(PPID) < PreprocessedEntities.size() &&'), (131, 1, u'+  assert(Range.isValid());'), (132, 1, u'+  assert(!SourceMgr.isBeforeInTranslationUnit(Range.getEnd(),Range.getBegin()));'), (164, 1, u'+  assert(!SourceMgr.isBeforeInTranslationUnit(Range.getEnd(),Range.getBegin()));'), (249, 1, u'+  assert(Entity);'), (253, 1, u'+    assert((PreprocessedEntities.empty() ||'), (303, 1, u'+  assert(!ExternalSource &&'), (323, 1, u'+    assert(unsigned(-PPID-1) < LoadedPreprocessedEntities.size() &&'), (327, 1, u'+  assert(unsigned(PPID) < PreprocessedEntities.size() &&'), (335, 1, u'+  assert(Index < LoadedPreprocessedEntities.size() &&'), (337, 1, u'+  assert(ExternalSource && "No external source to load from");'), (468, 1, u'+  assert(CondDirectiveLocs.empty() ||'), (509, 1, u'+    assert(!CondDirectiveStack.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 1, u'+    assert(Target && "Must provide target information for PP initialization");'), (77, 1, u'+  assert(BacktrackPositions.empty() && "EnableBacktrack/Backtrack imbalance!");'), (111, 1, u'+  assert((!this->Target || this->Target == &Target) &&'), (287, 1, u'+  assert(File);'), (288, 1, u'+  assert(CompleteLine && CompleteColumn && "Starts from 1:1");'), (289, 1, u'+  assert(!CodeCompletionFile && "Already set");'), (404, 1, u'+  assert(NumEnteredSourceFiles == 0 && "Cannot reenter the main file!");'), (428, 1, u'+  assert(SB && "Cannot create predefined source buffer");'), (430, 1, u'+  assert(!FID.isInvalid() && "Could not create FileID for predefines?");'), (450, 1, u'+  assert(Identifier.getRawIdentifierData() != 0 && "No raw identifier data!");'), (477, 1, u'+  assert(Ident__exception_code && Ident__exception_info);'), (478, 1, u'+  assert(Ident___exception_code && Ident___exception_info);'), (491, 1, u'+  assert(Identifier.getIdentifierInfo() &&'), (510, 1, u'+  assert(Identifier.getIdentifierInfo() &&'), (626, 1, u'+  assert(Handler && "NULL comment handler");'), (627, 1, u'+  assert(std::find(CommentHandlers.begin(), CommentHandlers.end(), Handler) =='), (635, 1, u'+  assert(Pos != CommentHandlers.end() && "Comment handler not registered");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+  assert(ParsingPreprocessorDirective &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 1, u'+    assert(Tokens[0].getLocation().isValid());'), (50, 1, u'+    assert((Tokens[0].getLocation().isFileID() || Tokens[0].is(tok::comment)) &&'), (52, 1, u'+    assert(ExpandLocStart.isValid());'), (144, 1, u'+      assert(ArgNo != -1 && "Token following # is not an argument?");'), (317, 1, u'+    assert(PasteBefore && ResultToks.back().is(tok::hashhash));'), (345, 1, u'+    assert(!OwnsTokens && "This would leak if we already own the token list");'), (461, 1, u'+    assert(!isAtEnd() && "No token on the RHS of a paste operator!");'), (516, 1, u'+      assert(ResultTokLoc.isFileID() &&'), (643, 1, u'+  assert(Macro && "Token streams can\'t paste comments");'), (655, 1, u'+  assert(ExpandLocStart.isValid() && MacroExpansionStart.isValid() &&'), (657, 1, u'+  assert(loc.isValid() && loc.isFileID());'), (660, 1, u'+  assert(SM.isInSLocAddrSpace(loc, MacroDefStart, MacroDefLength) &&'), (681, 1, u'+  assert(begin_tokens < end_tokens);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+  assert(D.isFunctionDeclarator() && "This isn\'t a function declarator!");'), (32, 1, u'+  assert((Tok.is(tok::l_brace) || Tok.is(tok::colon) || Tok.is(tok::kw_try) ||'), (185, 1, u'+  assert((Tok.is(tok::l_brace) || Tok.is(tok::equal)) &&'), (313, 1, u'+      assert(Tok.is(tok::equal) && "Default argument not starting with \'=\'");'), (339, 1, u'+      assert(!PP.getSourceManager().isBeforeInTranslationUnit(origLoc,'), (385, 1, u'+  assert(!LM.Toks.empty() && "Empty body!");'), (393, 1, u'+  assert((Tok.is(tok::l_brace) || Tok.is(tok::colon) || Tok.is(tok::kw_try))'), (403, 1, u'+    assert(!PP.getSourceManager().isBeforeInTranslationUnit(origLoc,'), (648, 1, u'+        assert(kind == tok::l_brace && "Must be left paren or brace here.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(110, 1, u'+  assert(Tok.is(tok::kw___attribute) && "Not a GNU attribute list!");'), (180, 1, u'+  assert(Tok.is(tok::l_paren) && "Attribute arg list not starting with \'(\'");'), (292, 1, u'+  assert(Tok.is(tok::kw___declspec) && "Not a declspec!");'), (884, 1, u'+  assert(Tok.is(tok::l_paren) && "Attribute arg list not starting with \'(\'");'), (924, 1, u'+  assert(Tok.is(tok::l_square) && NextToken().is(tok::l_square));'), (940, 1, u'+    assert(Tok.is(tok::r_square) && "isCXX11AttributeSpecifier lied");'), (1005, 1, u'+  case tok::kw_static_assert:'), (1006, 1, u'+  case tok::kw__Static_assert:'), (1008, 1, u'+    SingleDecl = ParseStaticAssertDeclaration(DeclEnd);'), (1486, 1, u'+      assert(!Exprs.empty() && Exprs.size()-1 == CommaLocs.size() &&'), (1620, 1, u'+  assert(Tok.is(tok::identifier) && "should have identifier");'), (1635, 1, u'+  assert(!DS.hasTypeSpecifier() && "Type specifier checked above");'), (1780, 1, u'+  assert((Tok.is(tok::kw_alignas) || Tok.is(tok::kw__Alignas)) &&'), (1971, 1, u'+        assert(Tok.is(tok::annot_template_id) &&'), (2495, 1, u'+      assert(PrevSpec && "Method did not return previous specifier!");'), (2496, 1, u'+      assert(DiagID);'), (2945, 1, u'+    assert(TemplateInfo.TemplateParams && "no template parameters");'), (3401, 1, u'+  case tok::kw__Static_assert:'), (3639, 1, u'+      assert(PrevSpec && "Method did not return previous specifier!");'), (3964, 1, u'+    assert(!getLangOpts().CPlusPlus &&'), (3966, 1, u'+    assert(Tok.getIdentifierInfo() && "Not an identifier?");'), (4007, 1, u'+  assert(D.isPastIdentifier() &&'), (4060, 1, u'+  assert(!D.isPastIdentifier() && "Should be called before passing identifier");'), (4177, 1, u'+  assert(getCurScope()->isFunctionPrototypeScope() &&'), (4180, 1, u'+  assert(D.isPastIdentifier() && "Should not call before identifier!");'), (4704, 1, u'+  assert(Tok.is(tok::kw_typeof) && "Not a typeof specifier");'), (4766, 1, u'+  assert(Tok.is(tok::kw__Atomic) && "Not an atomic specifier");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+  assert(Tok.is(tok::kw_namespace) && "Not a namespace!");'), (226, 1, u'+  assert(Tok.is(tok::equal) && "Not equal token");'), (268, 1, u'+  assert(Tok.is(tok::string_literal) && "Not a string literal!");'), (331, 1, u'+  assert(Tok.is(tok::kw_using) && "Not using token");'), (378, 1, u'+  assert(Tok.is(tok::kw_namespace) && "Not \'namespace\' token");'), (592, 1, u'+Decl *Parser::ParseStaticAssertDeclaration(SourceLocation &DeclEnd){'), (593, 1, u'+  assert((Tok.is(tok::kw_static_assert) || Tok.is(tok::kw__Static_assert)) &&'), (596, 1, u'+  if (Tok.is(tok::kw__Static_assert) && !getLangOpts().C11)'), (597, 1, u'+    Diag(Tok, diag::ext_c11_static_assert);'), (598, 1, u'+  if (Tok.is(tok::kw_static_assert))'), (599, 1, u'+    Diag(Tok, diag::warn_cxx98_compat_static_assert);'), (601, 1, u'+  SourceLocation StaticAssertLoc = ConsumeToken();'), (609, 1, u'+  ExprResult AssertExpr(ParseConstantExpression());'), (610, 1, u'+  if (AssertExpr.isInvalid()) {'), (624, 1, u'+  ExprResult AssertMessage(ParseStringLiteralExpression());'), (625, 1, u'+  if (AssertMessage.isInvalid()) {'), (633, 1, u'+  ExpectAndConsumeSemi(diag::err_expected_semi_after_static_assert);'), (635, 1, u'+  return Actions.ActOnStaticAssertDeclaration(StaticAssertLoc,'), (636, 1, u'+                                              AssertExpr.take(),'), (637, 1, u'+                                              AssertMessage.take(),'), (646, 1, u'+  assert((Tok.is(tok::kw_decltype) || Tok.is(tok::annot_decltype))'), (736, 1, u'+  assert(Tok.is(tok::kw___underlying_type) &&'), (817, 1, u'+      assert(Tok.is(tok::annot_typename) && "template-id -> type failed");'), (954, 1, u'+    assert(TagTokKind == tok::kw_union && "Not a class specifier");'), (1221, 1, u'+        assert(TUK == Sema::TUK_Definition && "Expected a definition here");'), (1305, 1, u'+      assert(TUK == Sema::TUK_Reference || TUK == Sema::TUK_Friend);'), (1313, 1, u'+    assert(Tok.is(tok::l_brace) ||'), (1429, 1, u'+  assert(Tok.is(tok::colon) && "Not a base clause");'), (1742, 1, u'+  if (Tok.is(tok::kw_static_assert) || Tok.is(tok::kw__Static_assert)) {'), (1745, 1, u'+    ParseStaticAssertDeclaration(DeclEnd);'), (1750, 1, u'+    assert(!TemplateInfo.TemplateParams &&'), (2129, 1, u'+  assert((Tok.is(tok::equal) || Tok.is(tok::l_brace))'), (2174, 1, u'+  assert((TagType == DeclSpec::TST_struct ||'), (2218, 1, u'+    assert(isCXX0XFinalKeyword() && "not a class definition");'), (2238, 1, u'+  assert(Tok.is(tok::l_brace));'), (2394, 1, u'+  assert(Tok.is(tok::colon) && "Constructor initializer always starts with \':\'");'), (2462, 1, u'+      assert(Tok.is(tok::annot_typename) && "template-id -> type failed");'), (2556, 1, u'+    assert(DynamicExceptions.size() == DynamicExceptionRanges.size() &&'), (2624, 1, u'+  assert(Tok.is(tok::kw_throw) && "expected throw");'), (2679, 1, u'+  assert(Tok.is(tok::arrow) && "expected arrow");'), (2691, 1, u'+  assert((NonNestedClass || !ClassStack.empty()) &&'), (2715, 1, u'+  assert(!ClassStack.empty() && "Mismatched push/pop for class parsing");'), (2727, 1, u'+  assert(!ClassStack.empty() && "Missing top-level class?");'), (2741, 1, u'+  assert(getCurScope()->isClassScope() && "Nested class outside of class scope?");'), (2834, 1, u'+  assert(Tok.is(tok::l_square) && NextToken().is(tok::l_square)'), (2947, 1, u'+  assert(Tok.is(tok::l_square) && "Not a Microsoft attribute list");')]
===========================================
Class:class CastExpressionIdValidator : public CorrectionCandidateCallback { class CastExpressionIdValidator : public CorrectionCandidateCallback 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(320, 1, u'+          assert(FILoc.isFileID());'), (406, 1, u'+    assert(NextTokPrec <= ThisPrec && "Recursion didn\'t work!");'), (720, 1, u'+    assert(Res.get() == 0 && "Stray primary-expression annotation?");'), (1399, 1, u'+        assert((ArgExprs.size() == 0 ||'), (1523, 1, u'+  assert((OpTok.is(tok::kw_typeof)    || OpTok.is(tok::kw_sizeof) ||'), (1583, 1, u'+  assert((Tok.is(tok::kw_sizeof) || Tok.is(tok::kw___alignof)'), (1890, 1, u'+  assert(Tok.is(tok::l_paren) && "Not a paren expr!");'), (1955, 1, u'+      assert(tokenKind == tok::kw___bridge_retain);'), (2113, 1, u'+  assert(Tok.is(tok::l_brace) && "Not a compound literal!");'), (2129, 1, u'+  assert(isTokenStringLiteral() && "Not a string literal!");'), (2157, 1, u'+  assert(Tok.is(tok::kw__Generic) && "_Generic keyword expected");'), (2336, 1, u'+  assert(Tok.is(tok::caret) && "block literal starts with ^");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(141, 1, u'+  assert(getLangOpts().CPlusPlus &&'), (299, 1, u'+      assert(Tok.is(tok::coloncolon) && "NextToken() not working properly!");'), (371, 1, u'+      assert((Tok.is(tok::coloncolon) || Tok.is(tok::colon)) &&'), (581, 1, u'+  assert(getLangOpts().CPlusPlus0x'), (622, 1, u'+  assert(Tok.is(tok::l_square) && "Lambda expressions begin with \'[\'.");'), (971, 1, u'+  assert(Tok.is(tok::kw_typeid) && "Not \'typeid\'!");'), (1031, 1, u'+  assert(Tok.is(tok::kw___uuidof) && "Not \'__uuidof\'!");'), (1105, 1, u'+    assert(Tok.is(tok::coloncolon) &&"ParseOptionalCXXScopeSpecifier fail");'), (1113, 1, u'+    assert(Tok.is(tok::coloncolon) &&"ParseOptionalCXXScopeSpecifier fail");'), (1120, 1, u'+  assert(Tok.is(tok::tilde) && "ParseOptionalCXXScopeSpecifier fail");'), (1175, 1, u'+  assert(Tok.is(tok::kw_throw) && "Not throw!");'), (1203, 1, u'+  assert(Tok.is(tok::kw_this) && "Not \'this\'!");'), (1225, 1, u'+  assert((Tok.is(tok::l_paren) ||'), (1260, 1, u'+    assert((Exprs.size() == 0 || Exprs.size()-1 == CommaLocs.size())&&'), (1601, 1, u'+  assert((AssumeTemplateId || Tok.is(tok::less)) &&'), (1803, 1, u'+  assert(Tok.is(tok::kw_operator) && "Expected \'operator\' keyword");'), (2229, 1, u'+  assert(Tok.is(tok::kw_new) && "expected \'new\' token");'), (2423, 1, u'+  assert(Tok.is(tok::kw_delete) && "Expected \'delete\' keyword");'), (2727, 1, u'+  assert(getLangOpts().CPlusPlus && "Should only be called for C++!");'), (2728, 1, u'+  assert(ExprType == CastExpr && "Compound literals are not ambiguous!");'), (2729, 1, u'+  assert(isTypeIdInParens() && "Not a type-id!");'), (2816, 1, u'+    assert(ParseAs == CastExpr);'), (2830, 1, u'+  assert(ParseAs == SimpleExpr);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(164, 1, u'+    assert(Tok.is(tok::colon) && "MayBeDesignationStart not working properly!");'), (200, 1, u'+    assert(Tok.is(tok::l_square) && "Unexpected token!");'), (360, 1, u'+  assert(!Desig.empty() && "Designator is empty?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(26, 1, u'+  assert(Tok.is(tok::annot_pragma_unused));'), (33, 1, u'+  assert(Tok.is(tok::annot_pragma_vis));'), (49, 1, u'+  assert(Tok.is(tok::annot_pragma_pack));'), (402, 1, u'+  assert(RParenLoc.isValid() && "Valid \'#pragma unused\' must have \')\'");'), (403, 1, u'+  assert(!Identifiers.empty() && "Valid \'#pragma unused\' must have arguments");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 1, u'+  assert((Attrs.empty() || Res.isInvalid() || Res.isUsable()) &&'), (363, 1, u'+  assert(Tok.is(tok::kw___try) && "Expected \'__try\'");'), (472, 1, u'+  assert(Tok.is(tok::identifier) && Tok.getIdentifierInfo() &&'), (478, 1, u'+  assert(Tok.is(tok::colon) && "Not a label!");'), (510, 1, u'+  assert((MissingCase || Tok.is(tok::kw_case)) && "Not a case stmt!");'), (614, 1, u'+  assert(!TopLevelCase.isInvalid() && "Should have parsed at least one case!");'), (647, 1, u'+  assert(Tok.is(tok::kw_default) && "Not a default stmt!");'), (720, 1, u'+  assert(Tok.is(tok::l_brace) && "Not a compount stmt!");'), (910, 1, u'+  assert(Tok.is(tok::kw_if) && "Not an if stmt!");'), (1041, 1, u'+  assert(Tok.is(tok::kw_switch) && "Not a switch stmt!");'), (1129, 1, u'+  assert(Tok.is(tok::kw_while) && "Not a while stmt!");'), (1201, 1, u'+  assert(Tok.is(tok::kw_do) && "Not a do stmt!");'), (1282, 1, u'+  assert(Tok.is(tok::kw_for) && "Not a for stmt!");'), (1427, 1, u'+    assert(!SecondPart.get() && "Shouldn\'t have a second expression yet.");'), (1537, 1, u'+  assert(Tok.is(tok::kw_goto) && "Not a goto stmt!");'), (1590, 1, u'+  assert(Tok.is(tok::kw_return) && "Not a return stmt!");'), (1764, 1, u'+  assert(Tok.is(tok::kw_asm) && "Not an asm stmt");'), (1843, 1, u'+  assert(Names.size() == Constraints.size() &&'), (1948, 1, u'+  assert(Tok.is(tok::l_brace));'), (1981, 1, u'+  assert(Tok.is(tok::kw_try) && "Expected \'try\'");'), (2013, 1, u'+  assert(Tok.is(tok::l_brace));'), (2014, 1, u'+  assert(SkipFunctionBodies &&'), (2037, 1, u'+  assert(Tok.is(tok::kw_try) && "Expected \'try\'");'), (2126, 1, u'+  assert(Tok.is(tok::kw_catch) && "Expected \'catch\'");')]
===========================================
Class:  class TemplateParameterDepthCounter {   class TemplateParameterDepthCounter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 1, u'+  case tok::kw_static_assert:'), (61, 1, u'+  case tok::kw__Static_assert:'), (130, 1, u'+  assert(TPR == TPResult::True() || TPR == TPResult::False());'), (145, 1, u'+  assert(isCXXDeclarationSpecifier() == TPResult::Ambiguous());'), (156, 1, u'+  assert(Tok.is(tok::l_paren) && "Expected \'(\'");'), (264, 1, u'+  assert(Tok.is(tok::l_paren) && "Expected \'(\'");'), (287, 1, u'+  assert(TPR == TPResult::True() || TPR == TPResult::False());'), (342, 1, u'+  assert(Tok.is(tok::l_paren) && "Expected \'(\'");'), (373, 1, u'+  assert(TPR == TPResult::True() || TPR == TPResult::False());'), (1029, 1, u'+    assert(Tok.is(tok::annot_typename));'), (1185, 1, u'+  assert(Tok.is(tok::kw_typeof) && "Expected \'typeof\'!");'), (1188, 1, u'+  assert(Tok.is(tok::l_paren) && "Expected \'(\'");'), (1200, 1, u'+  assert(Tok.is(tok::less) && "Expected \'<\' for qualifier list");'), (1235, 1, u'+  assert(Tok.is(tok::l_paren) && "Expected \'(\'!");')]
===========================================
Class:  class DestroyTemplateIdAnnotationsRAIIObj {   class DestroyTemplateIdAnnotationsRAIIObj 
Class:  class DeltaTreeNode {   class DeltaTreeNode 
Class:  class DeltaTreeInteriorNode : public DeltaTreeNode {   class DeltaTreeInteriorNode : public DeltaTreeNode 
Class:class RewritesReceiver : public edit::EditsReceiver { class RewritesReceiver : public edit::EditsReceiver 
Class:class FixItRewriteInPlace : public FixItOptions { class FixItRewriteInPlace : public FixItOptions 
Class: class FixItActionSuffixInserter : public FixItOptions { class FixItActionSuffixInserter : public FixItOptions 
Class: class FixItRewriteToTemp : public FixItOptions { class FixItRewriteToTemp : public FixItOptions 
Class:  class HTMLPrinter : public ASTConsumer {   class HTMLPrinter : public ASTConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(39, 1, u'+  assert(SM.getFileID(E) == FID && "B/E not in the same file!");'), (114, 1, u'+  assert (C <= FileEnd);'), (236, 1, u'+  assert (C <= FileEnd);'), (247, 1, u'+    assert (FilePos <= LineEndPos);'), (248, 1, u'+    assert (C < FileEnd);'), (526, 1, u'+    assert(SM.getFileID(LLoc.second) == FID &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+  assert(CurTok < RawTokens.size() && "Overran eof!");')]
===========================================
Class:  class RewriteModernObjC : public ASTConsumer {   class RewriteModernObjC : public ASTConsumer 
Class:    class DisableReplaceStmtScope {     class DisableReplaceStmtScope 
Class:  class RewriteObjC : public ASTConsumer {   class RewriteObjC : public ASTConsumer 
Class:    class DisableReplaceStmtScope {     class DisableReplaceStmtScope 
Class:   class RewriteObjCFragileABI : public RewriteObjC {   class RewriteObjCFragileABI : public RewriteObjC 
Class:  class RopePieceBTreeNode {   class RopePieceBTreeNode 
Class:  class RopePieceBTreeLeaf : public RopePieceBTreeNode {   class RopePieceBTreeLeaf : public RopePieceBTreeNode 
Class:  class RopePieceBTreeInterior : public RopePieceBTreeNode {   class RopePieceBTreeInterior : public RopePieceBTreeNode 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+  assert(RealOffset+Size < Buffer.size() && "Invalid location");'), (209, 1, u'+  assert(Loc.isValid() && "Invalid location");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(62, 1, u'+  assert(MapIt != TokenAtLoc.end() && "iterator not in rewriter?");'), (75, 1, u'+  assert(InsertSuccess && "Token location already in rewriter!");')]
===========================================
Class:  class UnreachableCodeHandler : public reachable_code::Callback {   class UnreachableCodeHandler : public reachable_code::Callback 
Class:class ContainsReference : public EvaluatedExprVisitor<ContainsReference> { class ContainsReference : public EvaluatedExprVisitor<ContainsReference> 
Class:class UninitValsDiagReporter : public UninitVariablesHandler { class UninitValsDiagReporter : public UninitVariablesHandler 
Class:class ThreadSafetyReporter : public clang::thread_safety::ThreadSafetyHandler { class ThreadSafetyReporter : public clang::thread_safety::ThreadSafetyHandler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+  assert(size >= sizeof(AttributeList));'), (33, 1, u'+  assert((size % sizeof(void*)) == 0);'), (52, 1, u'+  assert(cur && "reclaiming empty pool!");'), (74, 1, u'+  assert(pool);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(202, 1, u'+  assert(NumChunks <= 0xffff);'), (203, 1, u'+  assert(NumAnnotations <= 0xffff);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(39, 1, u'+  assert(TemplateId && "NULL template-id annotation?");'), (47, 1, u'+  assert(TemplateId && "NULL template-id annotation?");'), (61, 1, u'+  assert(Range == Builder.getSourceRange() &&'), (74, 1, u'+  assert(Range == Builder.getSourceRange() &&'), (87, 1, u'+  assert(Range == Builder.getSourceRange() &&'), (100, 1, u'+  assert(Range == Builder.getSourceRange() &&'), (110, 1, u'+  assert(Range == Builder.getSourceRange() &&'), (451, 1, u'+        assert(!isInvalid && "auto SCS -> TST recovery failed");'), (466, 1, u'+  assert((unsigned)SC == StorageClassSpec && "SCS constants overflow bitfield");'), (538, 1, u'+  assert(isTypeRep(T) && "T does not store a type");'), (539, 1, u'+  assert(Rep && "no type provided!");'), (557, 1, u'+  assert(isExprRep(T) && "T does not store an expr");'), (558, 1, u'+  assert(Rep && "no expression provided!");'), (584, 1, u'+  assert(isDeclRep(T) && "T does not store a decl");'), (603, 1, u'+  assert(!isDeclRep(T) && !isTypeRep(T) && !isExprRep(T) &&'), (923, 1, u'+  assert(!TypeSpecOwned || isDeclRep((TST) TypeSpecType));')]
===========================================
Class:        class IdentifierResolver::IdDeclInfoMap { class IdentifierResolver::IdDeclInfoMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(137, 1, u'+      assert(S->getParent() && "No TUScope?");'), (217, 1, u'+  assert(D && "null param passed");'), (224, 1, u'+  assert(Ptr && "Didn\'t find this decl on its identifier\'s chain!");'), (227, 1, u'+    assert(D == Ptr && "Didn\'t find this decl on its identifier\'s chain!");'), (236, 1, u'+  assert(Old->getDeclName() == New->getDeclName() &&'), (436, 1, u'+  assert(!isDeclPtr(InfoPtr) && "Decl with wrong id ?");')]
===========================================
Class:class JumpScopeChecker { class JumpScopeChecker 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(110, 1, u'+      assert(Scopes[B].ParentScope < B);'), (113, 1, u'+      assert(Scopes[A].ParentScope < A);'), (499, 1, u'+      assert(LabelAndGotoScopes.count(SC) && "Case not visited?");'), (547, 1, u'+      assert(LabelAndGotoScopes.count(IG) &&'), (567, 1, u'+    assert(LabelAndGotoScopes.count(TheLabel->getStmt()) &&'), (673, 1, u'+  assert(!ToScopes.empty());'), (684, 1, u'+  assert(JumpScope != TargetScope);'), (721, 1, u'+  assert(LabelAndGotoScopes.count(From) && "Jump didn\'t get added to scopes?");'), (724, 1, u'+  assert(LabelAndGotoScopes.count(To) && "Jump didn\'t get added to scopes?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(252, 1, u'+      assert(0 && "can\'t implicitly cast lvalue to rvalue with this cast kind");'), (260, 1, u'+  assert((VK == VK_RValue || !E->isRValue()) && "can\'t cast rvalue to lvalue");'), (438, 1, u'+      assert(!(*I)->isDependentType() &&'), (629, 1, u'+  assert(ParsingInitForAutoVars.empty() &&'), (846, 1, u'+  assert(!FunctionScopes.empty() && "mismatched push/pop!");'), (872, 1, u'+  assert(!CurFunction->CompoundScopes.empty() && "mismatched push/pop");')]
===========================================
Class:  class SavedInstanceContext {   class SavedInstanceContext 
Class:  class PragmaPackStack {   class PragmaPackStack 
Class:class NestedNameSpecifierValidatorCCC : public CorrectionCandidateCallback { class NestedNameSpecifierValidatorCCC : public CorrectionCandidateCallback 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(152, 1, u'+    assert(Tag && "Non-tag type in nested-name-specifier");'), (190, 1, u'+  assert(getLangOpts().CPlusPlus && "Only callable in C++");'), (191, 1, u'+  assert(NNS->isDependent() && "Only dependent nested-name-specifier allowed");'), (211, 1, u'+  assert(DC != 0 && "given null context");'), (318, 1, u'+  assert(!Found.isAmbiguous() && "Cannot handle ambiguities here yet");'), (343, 1, u'+    assert(!SS.isSet() && "ObjectType and scope specifier cannot coexist");'), (430, 1, u'+    assert(!SS.isSet() && "ObjectType and scope specifier cannot coexist");'), (717, 1, u'+  assert(DS.getTypeSpecType() == DeclSpec::TST_decltype);'), (775, 1, u'+    assert(DTN->getQualifier()'), (881, 1, u'+  assert(SS.isSet() && "Parser passed invalid CXXScopeSpec.");'), (925, 1, u'+  assert(SS.isSet() && "Parser passed invalid CXXScopeSpec.");'), (952, 1, u'+  assert(SS.isSet() && "Parser passed invalid CXXScopeSpec.");'), (955, 1, u'+  assert(!SS.isInvalid() && computeDeclContext(SS, true) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(121, 1, u'+      assert(Self.getLangOpts().ObjCAutoRefCount);'), (219, 1, u'+  assert(!D.isInvalidType());'), (333, 1, u'+  assert(sequence.Failed() && "initialization succeeded on second try?");'), (472, 1, u'+  assert((SrcType->isAnyPointerType() || SrcType->isMemberPointerType() ||'), (475, 1, u'+  assert((DestType->isAnyPointerType() || DestType->isMemberPointerType() ||'), (561, 1, u'+    assert(DestPointer && "Reference to void is not possible");'), (609, 1, u'+  assert((DestPointer || DestReference) &&'), (611, 1, u'+  assert((DestRecord || DestPointee->isVoidType()) &&'), (613, 1, u'+  assert(SrcRecord && "Bad source pointee slipped through.");'), (649, 1, u'+  assert(SrcDecl && "Definition missing");'), (1235, 1, u'+    assert(StillOkay);'), (1581, 1, u'+    assert(!IsLValueCast);'), (1661, 1, u'+    assert(srcIsPtr && "One type must be a pointer");'), (1676, 1, u'+    assert(destIsPtr && "One type must be a pointer");'), (1805, 1, u'+    assert(Kind == CK_Dependent);'), (1872, 1, u'+      assert(!Fn && "cast failed but able to resolve overload expression!!");'), (1890, 1, u'+  assert(!Self.getLangOpts().CPlusPlus);'), (1922, 1, u'+  assert(!SrcType->isPlaceholderType());'), (2100, 1, u'+  assert(LPLoc.isValid() && "List-initialization shouldn\'t get here.");')]
===========================================
Class:class CheckFormatHandler : public analyze_format_string::FormatStringHandler { class CheckFormatHandler : public analyze_format_string::FormatStringHandler 
Class:class CheckPrintfHandler : public CheckFormatHandler { class CheckPrintfHandler : public CheckFormatHandler 
Class:class CheckScanfHandler : public CheckFormatHandler { class CheckScanfHandler : public CheckFormatHandler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 1, u'+    assert(TheCall->getNumArgs() == 1 &&'), (297, 1, u'+    assert(!shift && "cannot shift float types!");'), (300, 1, u'+    assert(!shift && "cannot shift float types!");'), (521, 1, u'+  assert(AtomicExpr::AO__c11_atomic_init == 0 &&'), (699, 1, u'+        assert(Form != Load);'), (787, 1, u'+  assert(Fn && "builtin call without direct callee!");'), (1302, 1, u'+      assert(Cast->getType()->isSpecificBuiltinType(BuiltinType::Double) &&'), (1962, 1, u'+      assert((unsigned)notCoveredArg < NumDataArgs);'), (2167, 1, u'+      assert(ATR.isValid());'), (2683, 1, u'+  assert(BId != 0);'), (3102, 1, u'+  assert((E->getType()->isAnyPointerType() ||'), (3155, 1, u'+    assert (Base->getType()->isPointerType());'), (3437, 1, u'+    assert(T->isCanonicalUnqualified());'), (3457, 1, u'+    assert(BT->isInteger());'), (3468, 1, u'+    assert(T->isCanonicalUnqualified());'), (3478, 1, u'+    assert(BT->isInteger());'), (3534, 1, u'+  assert(result.isLValue() || result.isAddrLabelDiff());'), (3797, 1, u'+  assert(value.isComplexFloat());'), (3868, 1, u'+  assert(S.Context.hasSameUnqualifiedType(T, E->getRHS()->getType())'), (3888, 1, u'+    assert(!RHS->getType()->hasSignedIntegerRepresentation() &&'), (3924, 1, u'+    assert(unsignedRange.NonNegative && "unsigned range includes negative?");'), (3940, 1, u'+  assert(Bitfield->isBitField());'), (4881, 1, u'+  assert(owner.Variable && owner.Loc.isValid());'), (4895, 1, u'+  assert(capturer);'), (4896, 1, u'+  assert(owner.Variable && owner.Loc.isValid());'), (4938, 1, u'+    assert(msg->getReceiverKind() == ObjCMessageExpr::SuperInstance);'), (5088, 1, u'+  assert(!CurrentInstantiationScope); // Ensured by caller')]
===========================================
Class:  class ResultBuilder {   class ResultBuilder 
Class:    class ShadowMapEntry {     class ShadowMapEntry 
Class:  class pointer {   class pointer 
Class:  class CodeCompletionDeclConsumer : public VisibleDeclConsumer {   class CodeCompletionDeclConsumer : public VisibleDeclConsumer 
Class:      Class = ObjCPtr->getInterfaceDecl();
Class:      Class = BaseType->getAs<ObjCObjectType>()->getInterface();
Class:      Class = Category->getClassInterface();
Class:      Class = Category->getClassInterface();
Class:    Class = Class->getSuperClass();
Class:    Class = ClassImpl->getClassInterface();
Class:class TypeNameValidatorCCC : public CorrectionCandidateCallback { class TypeNameValidatorCCC : public CorrectionCandidateCallback 
Class:      Class = Alias->getClassInterface();
Class:class DifferentNameValidatorCCC : public CorrectionCandidateCallback { class DifferentNameValidatorCCC : public CorrectionCandidateCallback 
Class:  class SelfReferenceChecker   class SelfReferenceChecker
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 1, u'+    assert(isa<ObjCMethodDecl>(D) || isa<BlockDecl>(D));'), (355, 1, u'+  assert(!Attr.isInvalid());'), (378, 1, u'+  assert(!Attr.isInvalid());'), (409, 1, u'+  assert(!Attr.isInvalid());'), (429, 1, u'+  assert(!Attr.isInvalid());'), (446, 1, u'+  assert(!Attr.isInvalid());'), (463, 1, u'+  assert(!Attr.isInvalid());'), (493, 1, u'+  assert(Size == Attr.getNumArgs());'), (506, 1, u'+  assert(!Attr.isInvalid());'), (523, 1, u'+  assert(Size == Attr.getNumArgs());'), (538, 1, u'+  assert(!Attr.isInvalid());'), (578, 1, u'+  assert(!Attr.isInvalid());'), (595, 1, u'+  assert(Size == Attr.getNumArgs());'), (610, 1, u'+  assert(!Attr.isInvalid());'), (626, 1, u'+  assert(Size == Attr.getNumArgs());'), (635, 1, u'+  assert(!Attr.isInvalid());'), (658, 1, u'+  assert(!Attr.isInvalid());'), (675, 1, u'+  assert(Size == Attr.getNumArgs());'), (1287, 1, u'+  assert(!Attr.isInvalid());'), (1296, 1, u'+  assert(!Attr.isInvalid());'), (3056, 1, u'+  assert(!Attr.isInvalid());'), (3462, 1, u'+    assert(type->isDependentType() &&'), (3886, 1, u'+  assert(isa<FunctionDecl>(ND) || isa<VarDecl>(ND));'), (4039, 1, u'+  assert(StackSize <= StackCapacity);'), (4055, 1, u'+  assert(StackSize < StackCapacity);'), (4064, 1, u'+  assert(DD.StackSize >= state.SavedStackSize);'), (4065, 1, u'+  assert(state.SavedStackSize >= DD.ActiveStackBase);'), (4066, 1, u'+  assert(DD.ParsingDepth > 0);')]
===========================================
Class:  class CheckDefaultArgumentVisitor   class CheckDefaultArgumentVisitor
Class:class MemInitializerValidatorCCC : public CorrectionCandidateCallback { class MemInitializerValidatorCCC : public CorrectionCandidateCallback 
Class:class NamespaceValidatorCCC : public CorrectionCandidateCallback { class NamespaceValidatorCCC : public CorrectionCandidateCallback 
Class:  class ImplicitlyDefinedFunctionScope {   class ImplicitlyDefinedFunctionScope 
Class:  Class = cast<CXXRecordDecl>(Class->getCanonicalDecl());
Class:  class FindCXXThisExpr : public RecursiveASTVisitor<FindCXXThisExpr> {   class FindCXXThisExpr : public RecursiveASTVisitor<FindCXXThisExpr> 
Class:class ObjCInterfaceValidatorCCC : public CorrectionCandidateCallback { class ObjCInterfaceValidatorCCC : public CorrectionCandidateCallback 
Class:class OverrideSearch { class OverrideSearch 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(347, 1, u'+  assert(OldEST != EST_Delayed && NewEST != EST_Delayed &&'), (465, 1, u'+  assert(OldEST == EST_Dynamic && NewEST == EST_Dynamic &&'), (545, 1, u'+  assert(SuperEST != EST_Delayed && SubEST != EST_Delayed &&'), (582, 1, u'+  assert(SuperEST == EST_Dynamic && SubEST == EST_Dynamic &&'), (704, 1, u'+  assert(Target->getNumArgs() == Source->getNumArgs() &&'), (811, 1, u'+    assert(isa<CXXConstructorDecl>(D) &&')]
===========================================
Class:  class TransformToPE : public TreeTransform<TransformToPE> {   class TransformToPE : public TreeTransform<TransformToPE> 
Class:  class MarkReferencedDecls : public RecursiveASTVisitor<MarkReferencedDecls> {   class MarkReferencedDecls : public RecursiveASTVisitor<MarkReferencedDecls> 
Class:  class EvaluatedExprMarker : public EvaluatedExprVisitor<EvaluatedExprMarker> {   class EvaluatedExprMarker : public EvaluatedExprVisitor<EvaluatedExprMarker> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(137, 1, u'+    assert((isDependent || !SearchType->isIncompleteType()) &&'), (274, 1, u'+    assert(DS.getTypeSpecType() == DeclSpec::TST_decltype'), (491, 1, u'+  assert((Kind == tok::kw_true || Kind == tok::kw_false) &&'), (817, 1, u'+  assert((!ListInitialization || (NumExprs == 1 && isa<InitListExpr>(Exprs[0])))'), (1030, 1, u'+    assert(isa<InitListExpr>(Init) &&'), (1053, 1, u'+    assert(Initializer && "Have parens but no initializer.");'), (1065, 1, u'+    assert((!Initializer || isa<ImplicitValueInitExpr>(Initializer) ||'), (1863, 1, u'+    assert(StdBadAlloc && "Must have std::bad_alloc declared");'), (1987, 1, u'+  assert(Operator && "Did not find a deallocation function!");'), (2328, 1, u'+    assert(!From->getType()->isPointerType() && "Arg can\'t have pointer type!");'), (2375, 1, u'+      assert(FD && "FIXME: aggregate initialization from init list");'), (2460, 1, u'+    assert(!ToType->isReferenceType());'), (2507, 1, u'+    assert(From->getObjectKind() != OK_ObjCProperty);'), (2510, 1, u'+    assert(!FromRes.isInvalid() && "Can\'t perform deduced conversion?!");'), (2710, 1, u'+        assert(From->getType()->isIntegerType());'), (2722, 1, u'+      assert(FromComplex);'), (2741, 1, u'+        assert(ToType->isIntegerType());'), (2762, 1, u'+    assert ((ConvTy == Sema::Compatible) &&'), (2929, 1, u'+  assert(!T->isDependentType() && "Cannot evaluate traits of dependent type");'), (3410, 1, u'+  assert(!LhsT->isDependentType() && !RhsT->isDependentType() &&'), (3426, 1, u'+    assert(Self.Context.hasSameUnqualifiedType(LhsT, RhsT)'), (3600, 1, u'+  assert(!T->isDependentType() && "Cannot evaluate traits of dependent type");'), (3717, 1, u'+  assert(!LHS.get()->getType()->isPlaceholderType() &&'), (4267, 1, u'+  assert(getLangOpts().CPlusPlus && "This function assumes C++");'), (4469, 1, u'+  assert(!isa<CXXBindTemporaryExpr>(E) && "Double-bound temporary?");'), (4504, 1, u'+      assert(FTy && "call to value not of function type?");'), (4621, 1, u'+  assert(SubExpr && "sub expression can\'t be null!");'), (4626, 1, u'+  assert(ExprCleanupObjects.size() >= FirstCleanup);'), (4627, 1, u'+  assert(ExprNeedsCleanups || ExprCleanupObjects.size() == FirstCleanup);'), (4642, 1, u'+  assert(SubStmt && "sub statement can\'t be null!");'), (4667, 1, u'+  assert(Rec.IsDecltype && "not in a decltype expression");'), (5005, 1, u'+  assert((FirstTypeName.getKind() == UnqualifiedId::IK_TemplateId ||'), (5008, 1, u'+  assert((SecondTypeName.getKind() == UnqualifiedId::IK_TemplateId ||')]
===========================================
Class:class RecordMemberExprValidatorCCC : public CorrectionCandidateCallback { class RecordMemberExprValidatorCCC : public CorrectionCandidateCallback 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 1, u'+  assert(!R.empty() && (*R.begin())->isCXXClassMember());'), (438, 1, u'+      assert(BaseExpr && "cannot happen with implicit member accesses");'), (445, 1, u'+  assert(BaseType->isDependentType() ||'), (497, 1, u'+    assert(BaseType->isDependentType());'), (576, 1, u'+    assert(DC && "Cannot handle non-computable dependent contexts in lookup");'), (691, 1, u'+    assert(baseVariable->getType()->isRecordType());'), (698, 1, u'+    assert(!baseObjectExpr && "anonymous struct/union is static data member?");'), (800, 1, u'+  assert((!isArrow || Base->isRValue()) && "-> base must be a pointer rvalue");'), (820, 1, u'+    assert(BaseType->isPointerType());'), (876, 1, u'+  assert(R.isSingleResult());'), (948, 1, u'+  assert(!isa<FunctionDecl>(MemberDecl) && "member function not C++ method?");'), (1037, 1, u'+  assert(BaseExpr.get() && "no base expression");'), (1045, 1, u'+  assert(!BaseType->isDependentType());'), (1151, 1, u'+        assert(!ClassDeclared);'), (1172, 1, u'+    assert(ClassDeclared);'), (1245, 1, u'+    assert(Context.hasSameUnqualifiedType(BaseType, BaseExpr.get()->getType()));'), (1559, 1, u'+    assert(!MemberQuals.hasAddressSpace());'), (1587, 1, u'+  assert(!R.empty() && !R.isAmbiguous());'), (1601, 1, u'+  assert(!ThisTy.isNull() && "didn\'t correctly pre-flight capture of \'this\'");')]
===========================================
Class:class ObjCInterfaceOrSuperCCC : public CorrectionCandidateCallback { class ObjCInterfaceOrSuperCCC : public CorrectionCandidateCallback 
Class:  class ARCCastChecker : public StmtVisitor<ARCCastChecker, ACCResult> {   class ARCCastChecker : public StmtVisitor<ARCCastChecker, ACCResult> 
Class:class InitListChecker { class InitListChecker 
Class:class FieldInitializerValidatorCCC : public CorrectionCandidateCallback { class FieldInitializerValidatorCCC : public CorrectionCandidateCallback 
Class:    Class = cast<CXXRecordDecl>(Record->getDecl());
Class:    Class = LSI->Lambda;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(249, 1, u'+    assert(ParamInfo.isFunctionDeclarator() &&'), (261, 1, u'+    assert(MethodTyInfo && "no type from lambda-declarator");'), (336, 1, u'+    assert(C->Id && "missing identifier for capture");'), (597, 1, u'+      assert(!From.isBlockCapture() && "Cannot capture __block variables");')]
===========================================
Class:  class UnqualUsingEntry {   class UnqualUsingEntry 
Class:         class UnqualUsingDirectiveSet {   class UnqualUsingDirectiveSet 
Class:    Class = Bases.back();
Class:class ShadowContextRAII;
Class: class VisibleDeclsRecord { class VisibleDeclsRecord 
Class:  class ShadowContextRAII { class ShadowContextRAII 
Class:class TypoCorrectionConsumer : public VisibleDeclConsumer { class TypoCorrectionConsumer : public VisibleDeclConsumer 
Class:class SpecifierInfo { class SpecifierInfo 
Class: class NamespaceSpecifierSet { class NamespaceSpecifierSet 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 1, u'+      assert(propertyLifetime == Qualifiers::OCL_ExplicitNone);'), (601, 1, u'+    assert(IDecl &&'), (681, 1, u'+      assert(!getLangOpts().ObjCAutoRefCount);'), (708, 1, u'+          assert(lifetime && "no lifetime for property?");'), (820, 1, u'+  assert (property && "ActOnPropertyImplDecl - property declaration missing");'), (1084, 1, u'+    assert (CatDecl && "MatchOneProtocolPropertiesInClass");'), (1125, 1, u'+    assert (CatDecl && "CompareProperties");')]
===========================================
Class:  class UnbridgedCastsSet {   class UnbridgedCastsSet 
Class:     class BuiltinCandidateTypeSet  { class BuiltinCandidateTypeSet  
Class:class BuiltinOperatorOverloadBuilder { class BuiltinOperatorOverloadBuilder 
Class:   class AddressOfFunctionResolver { 
Class:class RecoveryCallCCC : public CorrectionCandidateCallback { class RecoveryCallCCC : public CorrectionCandidateCallback 
Class:  class NoTypoCorrectionCCC : public CorrectionCandidateCallback { class NoTypoCorrectionCCC : public CorrectionCandidateCallback 
Class:  class PseudoOpBuilder {   class PseudoOpBuilder 
Class:      class ObjCPropertyOpBuilder : public PseudoOpBuilder {   class ObjCPropertyOpBuilder : public PseudoOpBuilder 
Class:    class ObjCSubscriptOpBuilder : public PseudoOpBuilder {  class ObjCSubscriptOpBuilder : public PseudoOpBuilder 
Class:class TypeWithHandler { class TypeWithHandler 
Class:  class UnnamedLocalNoLinkageFinder   class UnnamedLocalNoLinkageFinder
Class:  class CurrentInstantiationRebuilder   class CurrentInstantiationRebuilder
Class:  class SubstituteAutoTransform :   class SubstituteAutoTransform :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(293, 1, u'+  assert(NTTP->getDepth() == 0 &&'), (321, 1, u'+  assert(NTTP->getDepth() == 0 &&'), (323, 1, u'+  assert((Value->isTypeDependent() || Value->isValueDependent()) &&'), (352, 1, u'+  assert(NTTP->getDepth() == 0 &&'), (436, 1, u'+  assert(Arg.isCanonical() && "Argument type must be canonical");'), (751, 1, u'+    assert(!PackIndices.empty() && "Pack expansion without unexpanded packs?");'), (1002, 1, u'+    assert(TemplateTypeParm->getDepth() == 0 && "Can\'t deduce with depth > 0");'), (1003, 1, u'+    assert(Arg != S.Context.OverloadTy && "Unresolved overloaded function");'), (1245, 1, u'+      assert(NTTP->getDepth() == 0 &&'), (1307, 1, u'+      assert(isa<TemplateSpecializationType>(Param) &&'), (1385, 1, u'+              assert(Base->getType()->isRecordType() &&'), (1665, 1, u'+  assert(ArgIdx == NumArgs - 1 && "Pack not at the end of argument list?");'), (1772, 1, u'+    assert(!PackIndices.empty() && "Pack expansion without unexpanded packs?");'), (2307, 1, u'+  assert(Proto && "Function template does not have a prototype?");'), (2640, 1, u'+  assert(Specialization->getPrimaryTemplate()->getCanonicalDecl() =='), (3133, 1, u'+    assert(!PackIndices.empty() && "Pack expansion without unexpanded packs?");'), (3333, 1, u'+    assert(!A->isReferenceType() && "Reference types were handled above");'), (3510, 1, u'+  assert(FuncParamInfo && "substituting template parameter for \'auto\' failed");'), (3621, 1, u'+  assert(Proto1 && Proto2 && "Function templates must have prototypes");'), (3881, 1, u'+  assert(!(Better1 && Better2) && "Should have broken out in the loop above");'), (3972, 1, u'+  assert(BestTemplate && "Not a function template specialization?");'), (3976, 1, u'+    assert(Challenger && "Not a function template specialization?");')]
===========================================
Class:  class TemplateInstantiator : public TreeTransform<TemplateInstantiator> {   class TemplateInstantiator : public TreeTransform<TemplateInstantiator> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 1, u'+      assert(Spec->getSpecializedTemplate() && "No class template?");'), (113, 1, u'+        assert(Function->getPrimaryTemplate() && "No function template?");'), (298, 1, u'+  assert(!Inst.isInstantiationRecord());'), (352, 1, u'+  assert(!Inst.isInstantiationRecord());'), (379, 1, u'+  assert(!Inst.isInstantiationRecord());'), (407, 1, u'+  assert(!Inst.isInstantiationRecord());'), (414, 1, u'+      assert(SemaRef.NonInstantiationEntries > 0);'), (427, 1, u'+  assert(SemaRef.NonInstantiationEntries <='), (659, 1, u'+      assert(Active->DeductionInfo && "Missing deduction info pointer");'), (888, 1, u'+        assert(Arg.getKind() == TemplateArgument::Pack &&'), (891, 1, u'+        assert(getSema().ArgumentPackSubstitutionIndex >= 0);'), (892, 1, u'+        assert(getSema().ArgumentPackSubstitutionIndex < (int)Arg.pack_size());'), (897, 1, u'+      assert(!Template.isNull() && Template.getAsTemplateDecl() &&'), (932, 1, u'+        assert(Arg.getKind() == TemplateArgument::Pack &&'), (938, 1, u'+        assert(getSema().ArgumentPackSubstitutionIndex < (int)Arg.pack_size());'), (1033, 1, u'+        assert(Arg.getKind() == TemplateArgument::Pack &&'), (1043, 1, u'+        assert(getSema().ArgumentPackSubstitutionIndex < (int)Arg.pack_size());'), (1048, 1, u'+      assert(!Template.isNull() && "Null template template argument");'), (1067, 1, u'+    assert(getSema().ArgumentPackSubstitutionIndex < (int)ArgPack.pack_size() &&'), (1083, 1, u'+  assert(currentDecl && "Must have current function declaration when "'), (1112, 1, u'+    assert(Arg.getKind() == TemplateArgument::Pack &&'), (1131, 1, u'+    assert(getSema().ArgumentPackSubstitutionIndex < (int)Arg.pack_size());'), (1181, 1, u'+    assert(!type.isNull() && "type substitution failed for param type");'), (1182, 1, u'+    assert(!type->isDependentType() && "param type still dependent");'), (1212, 1, u'+  assert(Index < ArgPack.pack_size() && "Substitution index out-of-range");'), (1236, 1, u'+  assert(!cast<FunctionDecl>(E->getParam()->getDeclContext())->'), (1292, 1, u'+      assert(Arg.getKind() == TemplateArgument::Pack &&'), (1307, 1, u'+      assert(getSema().ArgumentPackSubstitutionIndex < (int)Arg.pack_size());'), (1311, 1, u'+    assert(Arg.getKind() == TemplateArgument::Type &&'), (1359, 1, u'+  assert(Index < ArgPack.pack_size() && "Substitution index out-of-range");'), (1402, 1, u'+  assert(!ActiveTemplateInstantiations.empty() &&'), (1418, 1, u'+  assert(!ActiveTemplateInstantiations.empty() &&'), (1448, 1, u'+  assert(!ActiveTemplateInstantiations.empty() &&'), (1499, 1, u'+  assert(!ActiveTemplateInstantiations.empty() &&'), (1623, 1, u'+  assert(!ActiveTemplateInstantiations.empty() &&'), (1766, 1, u'+    assert(PatternDef->isBeingDefined());'), (1916, 1, u'+          assert(MSInfo && "no spec info for member enum specialization");'), (1956, 1, u'+        assert(Init && "no-argument initializer in class");'), (1957, 1, u'+        assert(!isa<ParenListExpr>(Init) && "call-style init in class");'), (1968, 1, u'+    assert(CurrentInstantiationScope == Instantiator.getStartingScope());'), (2275, 1, u'+        assert(MSInfo && "No member specialization information?");'), (2311, 1, u'+        assert(MSInfo && "No member specialization information?");'), (2349, 1, u'+      assert(MSInfo && "No member specialization information?");'), (2364, 1, u'+      assert(Pattern && "Missing instantiated-from-template information");'), (2400, 1, u'+      assert(MSInfo && "No member specialization information?");'), (2417, 1, u'+      assert(Pattern && "Missing instantiated-from-template information");'), (2555, 1, u'+  assert(isa<LabelDecl>(D) && "declaration not instantiated in this scope");'), (2564, 1, u'+    assert(Stored.get<Decl *>() == Inst && "Already instantiated this local");'), (2578, 1, u'+  assert(Stored.isNull() && "Already instantiated this local");'), (2587, 1, u'+  assert((!PartiallySubstitutedPack || PartiallySubstitutedPack == Pack) &&'), (2589, 1, u'+  assert((!PartiallySubstitutedPack')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(175, 1, u'+      assert(!newTag->getIdentifier() && !newTag->getTypedefNameForAnonDecl());'), (522, 1, u'+  assert(ND && "friend decl must be a decl or a type!");'), (540, 1, u'+Decl *TemplateDeclInstantiator::VisitStaticAssertDecl(StaticAssertDecl *D) {'), (541, 1, u'+  Expr *AssertExpr = D->getAssertExpr();'), (547, 1, u'+  ExprResult InstantiatedAssertExpr'), (548, 1, u'+    = SemaRef.SubstExpr(AssertExpr, TemplateArgs);'), (549, 1, u'+  if (InstantiatedAssertExpr.isInvalid())'), (554, 1, u'+  return SemaRef.ActOnStaticAssertDeclaration(D->getLocation(),'), (555, 1, u'+                                              InstantiatedAssertExpr.get(),'), (587, 1, u'+      assert(!D->getIntegerType()->isDependentType()'), (943, 1, u'+  assert(InstTemplate &&'), (1084, 1, u'+    assert(D->getDeclContext()->isFileContext());'), (1101, 1, u'+    assert(Proto && "No function prototype in template instantiation?");'), (1172, 1, u'+    assert(isFriend && "non-friend has dependent specialization info?");'), (1310, 1, u'+  assert(!D->isDefaulted() && "only methods should be defaulted");'), (1377, 1, u'+    assert(!Params.size() && "Instantiating type could not yield parameters");'), (1554, 1, u'+    assert(!D->isDefaulted() &&'), (1582, 1, u'+  assert(D->getTypeForDecl()->isTemplateTypeParmType());'), (1965, 1, u'+  assert(Specialization && "Class scope Specialization is null");'), (2142, 1, u'+  assert(OldTInfo && "substituting function without type source info");'), (2143, 1, u'+  assert(Params.empty() && "parameter vector is non-empty at start");'), (2167, 1, u'+      assert(NewProtoLoc && "Missing prototype?");'), (2230, 1, u'+      assert(FParamIdx < Function->getNumParams());'), (2254, 1, u'+  assert(Proto->getExceptionSpecType() != EST_Uninstantiated);'), (2282, 1, u'+      assert(!Unexpanded.empty() &&'), (2366, 1, u'+  assert(NewProto && "Template instantiation without function prototype?");'), (2431, 1, u'+      assert(FunTmpl->getTemplatedDecl() == Tmpl &&'), (2441, 1, u'+  assert(Proto && "Function template without prototype?");'), (2459, 1, u'+      assert(NewProto && "Template instantiation without function prototype?");'), (2535, 1, u'+  assert(PatternDecl && "instantiating a non-template");'), (2538, 1, u'+  assert(PatternDecl && "template definition is not a template");'), (2543, 1, u'+  assert(PatternDecl && "template definition is not a template");'), (2678, 1, u'+    assert(VTableUses.empty() &&'), (2683, 1, u'+    assert(PendingInstantiations.empty() &&'), (2715, 1, u'+  assert(Def && "This data member was not instantiated from a template?");'), (2716, 1, u'+  assert(Def->isStaticDataMember() && "Not a static data member?");'), (2790, 1, u'+    assert(MSInfo && "Missing member specialization information?");'), (2807, 1, u'+    assert(VTableUses.empty() &&'), (2813, 1, u'+    assert(PendingInstantiations.empty() &&'), (2859, 1, u'+      assert(ShouldExpand && "Partial instantiation of base initializer?");'), (3118, 1, u'+  assert(Instance->isStaticDataMember());'), (3267, 1, u'+    assert(isa<LabelDecl>(D));'), (3270, 1, u'+    assert(Inst && "Failed to instantiate label??");'), (3348, 1, u'+        assert(Tag && "type of non-dependent record is not a RecordType");'), (3401, 1, u'+        assert(Spec->getTemplateSpecializationKind() =='), (3456, 1, u'+    assert(Var->isStaticDataMember() && "Not a static data member?");')]
===========================================
Class:  class CollectUnexpandedParameterPacksVisitor :   class CollectUnexpandedParameterPacksVisitor :
Class:class ParameterPackValidatorCCC : public CorrectionCandidateCallback { class ParameterPackValidatorCCC : public CorrectionCandidateCallback 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(217, 1, u'+  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");'), (232, 1, u'+  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");'), (249, 1, u'+  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");'), (286, 1, u'+  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");'), (301, 1, u'+  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");'), (315, 1, u'+  assert(!Unexpanded.empty() && "Unable to find unexpanded parameter packs");')]
===========================================
Class:  class TypeProcessingState {   class TypeProcessingState 
Class:  class TypeSpecLocFiller : public TypeLocVisitor<TypeSpecLocFiller> {   class TypeSpecLocFiller : public TypeLocVisitor<TypeSpecLocFiller> 
Class:   class DeclaratorLocFiller : public TypeLocVisitor<DeclaratorLocFiller> {   class DeclaratorLocFiller : public TypeLocVisitor<DeclaratorLocFiller> 
Class:  class MSP430AttributesSema : public TargetAttributesSema {   class MSP430AttributesSema : public TargetAttributesSema 
Class:  class MBlazeAttributesSema : public TargetAttributesSema {   class MBlazeAttributesSema : public TargetAttributesSema 
Class:  class X86AttributesSema : public TargetAttributesSema {   class X86AttributesSema : public TargetAttributesSema 
Class:class ASTStatData { class ASTStatData 
Class: class ASTStatLookupTrait { class ASTStatLookupTrait 
Class:     class ASTStatCache : public FileSystemStatCache { class ASTStatCache : public FileSystemStatCache 
Class:  class IdentifierLookupVisitor {   class IdentifierLookupVisitor 
Class:  class HeaderFileInfoVisitor {   class HeaderFileInfoVisitor 
Class: class clang::TypeLocReader : public TypeLocVisitor<TypeLocReader> { class clang::TypeLocReader : public TypeLocVisitor<TypeLocReader> 
Class:  class FindExternalLexicalDeclsVisitor {   class FindExternalLexicalDeclsVisitor 
Class:class DeclIDComp { class DeclIDComp 
Class:  class DeclContextNameLookupVisitor {   class DeclContextNameLookupVisitor 
Class:  class DeclContextAllNamesVisitor {   class DeclContextAllNamesVisitor 
Class:  class ASTIdentifierIterator : public IdentifierIterator {   class ASTIdentifierIterator : public IdentifierIterator 
Class:  class ReadMethodPoolVisitor {   class ReadMethodPoolVisitor 
Class:  class ASTDeclReader : public DeclVisitor<ASTDeclReader, void> {   class ASTDeclReader : public DeclVisitor<ASTDeclReader, void> 
Class:    class RedeclarableResult {     class RedeclarableResult 
Class:                              class FindExistingResult {     class FindExistingResult 
Class:  class RedeclChainVisitor {   class RedeclChainVisitor 
Class:  class ObjCCategoriesVisitor {   class ObjCCategoriesVisitor 
Class:  class ASTStmtReader : public StmtVisitor<ASTStmtReader> {   class ASTStmtReader : public StmtVisitor<ASTStmtReader> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(111, 1, u'+  assert(Idx == NumStmtFields && "Incorrect statement field count");'), (329, 1, u'+  assert(Idx == NumExprFields && "Incorrect expression field count");'), (387, 1, u'+  assert(Record[Idx] == E->getNumConcatenated() &&'), (439, 1, u'+  assert(E->getNumComponents() == Record[Idx]);'), (441, 1, u'+  assert(E->getNumExpressions() == Record[Idx]);'), (514, 1, u'+  assert(E->getStmtClass() == Stmt::MemberExprClass &&'), (542, 1, u'+  assert(NumBaseSpecs == E->path_size());'), (650, 1, u'+  assert(NumSubExprs == E->getNumSubExprs() && "Wrong number of subexprs");'), (787, 1, u'+  assert(numSemanticExprs + 1 == E->PseudoObjectExprBits.NumSubExprs);'), (830, 1, u'+  assert(NumElements == E->getNumElements() && "Wrong number of elements");'), (841, 1, u'+  assert(NumElements == E->getNumElements() && "Wrong number of elements");'), (843, 1, u'+  assert(HasPackExpansions == E->HasPackExpansions &&"Pack expansion mismatch");'), (926, 1, u'+  assert(Record[Idx] == E->getNumArgs());'), (952, 1, u'+  assert(Kind == E->getReceiverKind());'), (1001, 1, u'+  assert(Record[Idx] == S->getNumCatchStmts());'), (1045, 1, u'+  assert(Record[Idx] == S->getNumHandlers() && "NumStmtFields is wrong ?");'), (1104, 1, u'+  assert(NumCaptures == E->NumCaptures);(void)NumCaptures;'), (1204, 1, u'+  assert((bool)Record[Idx] == E->Param.getInt() && "We messed up at creation ?");'), (1278, 1, u'+  assert(NumObjects == E->getNumObjects());'), (1317, 1, u'+  assert(Record[Idx] == E->arg_size() && "Read wrong record during creation ?");'), (1613, 1, u'+      assert(StmtEntries.find(Record[0]) != StmtEntries.end() &&'), (1764, 1, u'+      assert(Idx == 0);'), (2217, 1, u'+    assert(Idx == Record.size() && "Invalid deserialization of statement");'), (2222, 1, u'+  assert(StmtStack.size() > PrevNumStmts && "Read too many sub stmts!");'), (2223, 1, u'+  assert(StmtStack.size() == PrevNumStmts + 1 && "Extra expressions on stack!");')]
===========================================
Class:  class ASTTypeWriter {   class ASTTypeWriter 
Class:class TypeLocWriter : public TypeLocVisitor<TypeLocWriter> { class TypeLocWriter : public TypeLocVisitor<TypeLocWriter> 
Class:class ASTStatCacheTrait { class ASTStatCacheTrait 
Class:  class HeaderFileInfoTrait {   class HeaderFileInfoTrait 
Class:class ASTMethodPoolTrait { class ASTMethodPoolTrait 
Class:class ASTIdentifierTableTrait { class ASTIdentifierTableTrait 
Class:class ASTDeclContextNameLookupTrait { class ASTDeclContextNameLookupTrait 
Class:  class ASTDeclWriter : public DeclVisitor<ASTDeclWriter, void> {   class ASTDeclWriter : public DeclVisitor<ASTDeclWriter, void> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 1, u'+    void VisitStaticAssertDecl(StaticAssertDecl *D);'), (424, 1, u'+    assert(Context.getObjCMethodRedeclaration(D));'), (730, 1, u'+  assert(!D->isARCPseudoStrong()); // can be true of ImplicitParamDecl'), (755, 1, u'+  assert(!D->isThreadSpecified() && "PARM_VAR_DECL can\'t be __thread");'), (756, 1, u'+  assert(D->getAccess() == AS_none && "PARM_VAR_DECL can\'t be public/private");'), (757, 1, u'+  assert(!D->isExceptionVariable() && "PARM_VAR_DECL can\'t be exception var");'), (758, 1, u'+  assert(D->getPreviousDecl() == 0 && "PARM_VAR_DECL can\'t be redecl");'), (759, 1, u'+  assert(!D->isStaticDataMember() &&'), (1061, 1, u'+      assert(I->isCanonicalDecl() && "Expected only canonical decls in set");'), (1069, 1, u'+      assert(I->isCanonicalDecl() && "Expected only canonical decls in set");'), (1152, 1, u'+      assert(I->Function->isCanonicalDecl() &&'), (1217, 1, u'+void ASTDeclWriter::VisitStaticAssertDecl(StaticAssertDecl *D) {'), (1219, 1, u'+  Writer.AddStmt(D->getAssertExpr());'), (1222, 1, u'+  Code = serialization::DECL_STATIC_ASSERT;')]
===========================================
Class:  class ASTStmtWriter : public StmtVisitor<ASTStmtWriter, void> {   class ASTStmtWriter : public StmtVisitor<ASTStmtWriter, void> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(651, 1, u'+      assert(D->isArrayRangeDesignator() && "Unknown designator");'), (1552, 1, u'+  assert(SwitchCaseIDs.find(S) == SwitchCaseIDs.end() &&'), (1560, 1, u'+  assert(SwitchCaseIDs.find(S) != SwitchCaseIDs.end() &&'), (1591, 1, u'+  assert(!ParentStmts.count(S) && "There is a Stmt cycle!");'), (1648, 1, u'+  assert(SubStmtEntries.empty() && "unexpected entries in sub stmt map");'), (1649, 1, u'+  assert(ParentStmts.empty() && "unexpected entries in parent stmt map");'), (1654, 1, u'+    assert(N == StmtsToEmit.size() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+  assert(SemaPtr && "No Sema?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 1, u'+      assert(Buffer && "Passed null buffer");')]
===========================================
Class:class AdjustedReturnValueChecker : class AdjustedReturnValueChecker :
Class:class AnalyzerStatsChecker : public Checker<check::EndAnalysis> { class AnalyzerStatsChecker : public Checker<check::EndAnalysis> 
Class:class ArrayBoundChecker : class ArrayBoundChecker :
Class:class ArrayBoundCheckerV2 : class ArrayBoundCheckerV2 :
Class:  class RegionRawOffsetV2 { class RegionRawOffsetV2 
Class:class AttrNonNullChecker class AttrNonNullChecker
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 1, u'+        assert(CSV_I != CSV->end());'), (78, 1, u'+        assert(++CSV_I == CSV->end());'), (123, 1, u'+    assert(stateNotNull);')]
===========================================
Class:class APIMisuse : public BugType { class APIMisuse : public BugType 
Class:  class NilArgChecker : public Checker<check::PreObjCMessage> {   class NilArgChecker : public Checker<check::PreObjCMessage> 
Class:class CFNumberCreateChecker : public Checker< check::PreStmt<CallExpr> > { class CFNumberCreateChecker : public Checker< check::PreStmt<CallExpr> > 
Class:  class Optional {   class Optional 
Class:class CFRetainReleaseChecker : public Checker< check::PreStmt<CallExpr> > { class CFRetainReleaseChecker : public Checker< check::PreStmt<CallExpr> > 
Class:class ClassReleaseChecker : public Checker<check::PreObjCMessage> { class ClassReleaseChecker : public Checker<check::PreObjCMessage> 
Class:class VariadicMethodTypeChecker : public Checker<check::PreObjCMessage> { class VariadicMethodTypeChecker : public Checker<check::PreObjCMessage> 
Class:  class BoolAssignmentChecker : public Checker< check::Bind > {   class BoolAssignmentChecker : public Checker< check::Bind > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(116, 1, u'+  assert(stateGE == state);'), (152, 1, u'+  assert(stateLE == state);')]
===========================================
Class:class BuiltinFunctionChecker : public Checker<eval::Call> { class BuiltinFunctionChecker : public Checker<eval::Call> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+    assert (CE->arg_begin() != CE->arg_end());')]
===========================================
Class:class CStringChecker : public Checker< eval::Call, class CStringChecker : public Checker< eval::Call,
Class: class CStringLength { class CStringLength 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(247, 1, u'+    assert(CurrentFunctionDescription);'), (262, 1, u'+  assert(stateNonNull);'), (284, 1, u'+  assert(ER->getValueType() == C.getASTContext().CharTy &&'), (315, 1, u'+      assert(CurrentFunctionDescription);'), (316, 1, u"+      assert(CurrentFunctionDescription[0] != '\\0');"), (460, 1, u'+  assert(stateFalse);'), (528, 1, u'+  assert(stateFalse);'), (617, 1, u'+    assert(stateOkay);'), (627, 1, u'+  assert(!strLength.isUndef() && "Attempt to set an undefined string length");'), (708, 1, u'+        assert(CurrentFunctionDescription);'), (769, 1, u'+      assert(CurrentFunctionDescription);'), (943, 1, u'+      assert(destRegVal && "Destination should be a known MemRegionVal here");'), (1243, 1, u'+  assert(!result.isUnknown() && "Should have conjured a value by now");'), (1422, 1, u'+      assert(!amountCopied.isUndef());'), (1457, 1, u'+  assert(state);'), (1494, 1, u'+      assert(!finalStrLength.isUndef());'), (1533, 1, u'+  assert(state);'), (1592, 1, u'+  assert(state);'), (1694, 1, u'+  assert(StNotSameBuf);'), (1816, 1, u'+  assert(!(CurrentFunctionDescription = NULL));'), (1859, 1, u'+    assert(StrVal.isValid() && "Initializer string is unknown or undefined");')]
===========================================
Class:class WalkAST: public StmtVisitor<WalkAST> { class WalkAST: public StmtVisitor<WalkAST> 
Class:class CStringSyntaxChecker: public Checker<check::ASTCodeBody> { class CStringSyntaxChecker: public Checker<check::ASTCodeBody> 
Class:class CallAndMessageChecker class CallAndMessageChecker
Class:    class FindUninitializedField {     class FindUninitializedField 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(144, 1, u'+          assert(RD && "Referred record has no definition");')]
===========================================
Class:class CastSizeChecker : public Checker< check::PreStmt<CastExpr> > { class CastSizeChecker : public Checker< check::PreStmt<CastExpr> > 
Class:class CastToStructChecker : public Checker< check::PreStmt<CastExpr> > { class CastToStructChecker : public Checker< check::PreStmt<CastExpr> > 
Class:class ObjCDeallocChecker : public Checker< class ObjCDeallocChecker : public Checker<
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 1, u'+  assert (LOpts.getGC() != LangOptions::GCOnly);')]
===========================================
Class:class ObjCMethSigsChecker : public Checker< class ObjCMethSigsChecker : public Checker<
Class:class WalkAST : public StmtVisitor<WalkAST> { class WalkAST : public StmtVisitor<WalkAST> 
Class:class SecuritySyntaxChecker : public Checker<check::ASTCodeBody> { class SecuritySyntaxChecker : public Checker<check::ASTCodeBody> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(438, 1, u'+  assert(ArgSuffix.first >= 0 && "Unsupported function");')]
===========================================
Class:class WalkAST : public StmtVisitor<WalkAST> { class WalkAST : public StmtVisitor<WalkAST> 
Class:class SizeofPointerChecker : public Checker<check::ASTCodeBody> { class SizeofPointerChecker : public Checker<check::ASTCodeBody> 
Class:class CheckerDocumentation : public Checker< check::PreStmt<DeclStmt>, class CheckerDocumentation : public Checker< check::PreStmt<DeclStmt>,
Class:class ChrootChecker : public Checker<eval::Call, check::PreStmt<CallExpr> > { class ChrootChecker : public Checker<eval::Call, check::PreStmt<CallExpr> > 
Class:class ReachableCode { class ReachableCode 
Class:class DeadStoreObs : public LiveVariables::Observer { class DeadStoreObs : public LiveVariables::Observer 
Class:class FindEscaped : public CFGRecStmtDeclVisitor<FindEscaped>{ class FindEscaped : public CFGRecStmtDeclVisitor<FindEscaped>
Class:class DeadStoresChecker : public Checker<check::ASTCodeBody> { class DeadStoresChecker : public Checker<check::ASTCodeBody> 
Class:class DominatorsTreeDumper : public Checker<check::ASTCodeBody> { class DominatorsTreeDumper : public Checker<check::ASTCodeBody> 
Class:class LiveVariablesDumper : public Checker<check::ASTCodeBody> { class LiveVariablesDumper : public Checker<check::ASTCodeBody> 
Class:class CFGViewer : public Checker<check::ASTCodeBody> { class CFGViewer : public Checker<check::ASTCodeBody> 
Class:class CFGDumper : public Checker<check::ASTCodeBody> { class CFGDumper : public Checker<check::ASTCodeBody> 
Class:class CallGraphViewer : public Checker< check::ASTDecl<TranslationUnitDecl> > { class CallGraphViewer : public Checker< check::ASTDecl<TranslationUnitDecl> > 
Class:class CallGraphDumper : public Checker< check::ASTDecl<TranslationUnitDecl> > { class CallGraphDumper : public Checker< check::ASTDecl<TranslationUnitDecl> > 
Class:class DereferenceChecker class DereferenceChecker
Class:class DivZeroChecker : public Checker< check::PreStmt<BinaryOperator> > { class DivZeroChecker : public Checker< check::PreStmt<BinaryOperator> > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(78, 1, u'+    assert(stateZero);')]
===========================================
Class:class FixedAddressChecker class FixedAddressChecker
Class:class GenericTaintChecker : public Checker< check::PostStmt<CallExpr>, class GenericTaintChecker : public Checker< check::PostStmt<CallExpr>,
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(501, 1, u'+    assert(ArgNum < CE->getNumArgs());'), (513, 1, u'+  assert(CE->getNumArgs() >= 2);'), (634, 1, u'+  assert(E);')]
===========================================
Class:class IdempotentOperationChecker class IdempotentOperationChecker
Class:  class VisitWL : public WorkList::Visitor {   class VisitWL : public WorkList::Visitor 
Class:class RefState { class RefState 
Class: class IteratorsChecker :     public Checker<check::PreStmt<CXXOperatorCallExpr>,                    check::PreStmt<DeclStmt>,                    check::PreStmt<CXXMemberCallExpr>,                    check::PreStmt<CallExpr> >   {   
Class: class IteratorState { class IteratorState 
Class:class StringRefCheckerVisitor : public StmtVisitor<StringRefCheckerVisitor> { class StringRefCheckerVisitor : public StmtVisitor<StringRefCheckerVisitor> 
Class:class ASTFieldVisitor { class ASTFieldVisitor 
Class:class LLVMConventionsChecker : public Checker< class LLVMConventionsChecker : public Checker<
Class:class MacOSKeychainAPIChecker : public Checker<check::PreStmt<CallExpr>, class MacOSKeychainAPIChecker : public Checker<check::PreStmt<CallExpr>,
Class:  class SecKeychainBugVisitor   class SecKeychainBugVisitor
Class:class MacOSXAPIChecker : public Checker< check::PreStmt<CallExpr> > { class MacOSXAPIChecker : public Checker< check::PreStmt<CallExpr> > 
Class:class RefState { class RefState 
Class: class MallocChecker : public Checker<check::DeadSymbols,                                      check::EndPath,                                      check::PreStmt<ReturnStmt>,                                      check::PreStmt<CallExpr>,                                      check::PostStmt<CallExpr>,                                      check::PostStmt<BlockExpr>,                                      check::Location,                                      check::Bind,                                      eval::Assume,                                      check::RegionChanges> { 
Class:            class MallocBugVisitor : public BugReporterVisitorImpl<MallocBugVisitor> {   class MallocBugVisitor : public BugReporterVisitorImpl<MallocBugVisitor> 
Class:class RegionState 
Class:class ReallocPairs 
Class:class StopTrackingCallback : public SymbolVisitor { class StopTrackingCallback : public SymbolVisitor 
Class:class MallocOverflowSecurityChecker : public Checker<check::ASTCodeBody> { class MallocOverflowSecurityChecker : public Checker<check::ASTCodeBody> 
Class:class CheckOverflowOps : class CheckOverflowOps :
Class:class CastedAllocFinder class CastedAllocFinder
Class: class SizeofFinder : public ConstStmtVisitor<SizeofFinder> { class SizeofFinder : public ConstStmtVisitor<SizeofFinder> 
Class: class MallocSizeofChecker : public Checker<check::ASTCodeBody> { class MallocSizeofChecker : public Checker<check::ASTCodeBody> 
Class:class NSAutoreleasePoolChecker class NSAutoreleasePoolChecker
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+    assert(0);')]
===========================================
Class:class NSErrorMethodChecker class NSErrorMethodChecker
Class:class CFErrorFunctionChecker class CFErrorFunctionChecker
Class:class NSErrorDerefBug : public BugType { class NSErrorDerefBug : public BugType 
Class: class CFErrorDerefBug : public BugType { class CFErrorDerefBug : public BugType 
Class:class NSOrCFErrorDerefChecker class NSOrCFErrorDerefChecker
Class:class NoReturnFunctionChecker : public Checker< check::PostStmt<CallExpr>, class NoReturnFunctionChecker : public Checker< check::PostStmt<CallExpr>,
Class:class OSAtomicChecker : public Checker<eval::InlineCall> { class OSAtomicChecker : public Checker<eval::InlineCall> 
Class:class ObjCAtSyncChecker class ObjCAtSyncChecker
Class:class WalkAST : public StmtVisitor<WalkAST> { class WalkAST : public StmtVisitor<WalkAST> 
Class:class ObjCContainersASTChecker : public Checker<check::ASTCodeBody> { class ObjCContainersASTChecker : public Checker<check::ASTCodeBody> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(129, 1, u'+    assert(ArgNum == 1 || ArgNum == 2);'), (133, 1, u'+    assert(ArgNum == 1 || ArgNum == 2);')]
===========================================
Class:class ObjCContainersChecker : public Checker< check::PreStmt<CallExpr>, class ObjCContainersChecker : public Checker< check::PreStmt<CallExpr>,
Class:class ObjCSelfInitChecker : public Checker<  check::PreObjCMessage, class ObjCSelfInitChecker : public Checker<  check::PreObjCMessage,
Class:class InitSelfBug : public BugType { class InitSelfBug : public BugType 
Class:class ObjCUnusedIvarsChecker : public Checker< class ObjCUnusedIvarsChecker : public Checker<
Class:class PointerArithChecker class PointerArithChecker
Class:class PointerSubChecker class PointerSubChecker
Class:class PthreadLockChecker : public Checker< check::PostStmt<CallExpr> > { class PthreadLockChecker : public Checker< check::PostStmt<CallExpr> > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(139, 1, u'+    assert(lockFail && lockSucc);'), (145, 1, u'+    assert(lockSucc);'), (149, 1, u'+    assert((semantics == XNUSemantics) && "Unknown locking semantics");')]
===========================================
Class:class GenericNodeBuilderRefCount { class GenericNodeBuilderRefCount 
Class:class RetEffect { class RetEffect 
Class:     class RefVal { class RefVal 
Class:class RetainSummary { class RetainSummary 
Class:class ObjCSummaryKey { class ObjCSummaryKey 
Class:class ObjCSummaryCache { class ObjCSummaryCache 
Class:class RetainSummaryManager { class RetainSummaryManager 
Class:      Class = msg.getReceiverInterface();
Class:     class RetainSummaryTemplate { class RetainSummaryTemplate 
Class:  class CFRefBug : public BugType {   class CFRefBug : public BugType 
Class:   class UseAfterRelease : public CFRefBug {   class UseAfterRelease : public CFRefBug 
Class:   class BadRelease : public CFRefBug {   class BadRelease : public CFRefBug 
Class:   class DeallocGC : public CFRefBug {   class DeallocGC : public CFRefBug 
Class:   class DeallocNotOwned : public CFRefBug {   class DeallocNotOwned : public CFRefBug 
Class:   class OverAutorelease : public CFRefBug {   class OverAutorelease : public CFRefBug 
Class:   class ReturnedNotOwnedForOwned : public CFRefBug {   class ReturnedNotOwnedForOwned : public CFRefBug 
Class:   class Leak : public CFRefBug {   class Leak : public CFRefBug 
Class:   class LeakAtReturn : public Leak {   class LeakAtReturn : public Leak 
Class:   class LeakWithinFunction : public Leak {   class LeakWithinFunction : public Leak 
Class:             class CFRefReportVisitor : public BugReporterVisitorImpl<CFRefReportVisitor> {   class CFRefReportVisitor : public BugReporterVisitorImpl<CFRefReportVisitor> 
Class:   class CFRefLeakReportVisitor : public CFRefReportVisitor {   class CFRefLeakReportVisitor : public CFRefReportVisitor 
Class:   class CFRefReport : public BugReport {   class CFRefReport : public BugReport 
Class:   class CFRefLeakReport : public CFRefReport {   class CFRefLeakReport : public CFRefReport 
Class:class RetainCountChecker class RetainCountChecker
Class:class StopTrackingCallback : public SymbolVisitor { class StopTrackingCallback : public SymbolVisitor 
Class:class ReturnPointerRangeChecker : class ReturnPointerRangeChecker :
Class:class ReturnUndefChecker : class ReturnUndefChecker :
Class:class StackAddrEscapeChecker : public Checker< check::PreStmt<ReturnStmt>, class StackAddrEscapeChecker : public Checker< check::PreStmt<ReturnStmt>,
Class:  class CallBack : public StoreManager::BindingsHandler {   class CallBack : public StoreManager::BindingsHandler 
Class:class StreamChecker : public Checker<eval::Call, class StreamChecker : public Checker<eval::Call,
Class:class TaintTesterChecker : public Checker< check::PostStmt<Expr> > { class TaintTesterChecker : public Checker< check::PostStmt<Expr> > 
Class:class UndefBranchChecker : public Checker<check::BranchCondition> { class UndefBranchChecker : public Checker<check::BranchCondition> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 1, u'+      assert (!N->pred_empty());')]
===========================================
Class:class UndefCapturedBlockVarChecker class UndefCapturedBlockVarChecker
Class:class UndefResultChecker class UndefResultChecker
Class:class UndefinedArraySubscriptChecker class UndefinedArraySubscriptChecker
Class:class UndefinedAssignmentChecker class UndefinedAssignmentChecker
Class:class UnixAPIChecker : public Checker< check::PreStmt<CallExpr> > { class UnixAPIChecker : public Checker< check::PreStmt<CallExpr> > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(260, 1, u'+  assert(trueState);'), (296, 1, u'+  assert(trueState);')]
===========================================
Class:class UnreachableCodeChecker : public Checker<check::EndAnalysis> { class UnreachableCodeChecker : public Checker<check::EndAnalysis> 
Class:class VLASizeChecker : public Checker< check::PreStmt<DeclStmt> > { class VLASizeChecker : public Checker< check::PreStmt<DeclStmt> > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(154, 1, u'+  assert(state);')]
===========================================
Class:class WalkAST : public StmtVisitor<WalkAST> { class WalkAST : public StmtVisitor<WalkAST> 
Class:class VirtualCallChecker : public Checker<check::ASTDecl<CXXRecordDecl> > { class VirtualCallChecker : public Checker<check::ASTDecl<CXXRecordDecl> > 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 1, u'+    assert(!WList.empty());'), (90, 1, u'+      assert(FD && FD->getBody());'), (106, 1, u'+      assert(VisitedFunctions[FD] == PostVisited);'), (177, 1, u'+    assert(FD);')]
===========================================
Class:class BasicConstraintManager class BasicConstraintManager
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(154, 1, u'+      assert (false && "Invalid Opcode.");')]
===========================================
Class:class CountKey { class CountKey 
Class:class NodeMapClosure : public BugReport::NodeResolver { class NodeMapClosure : public BugReport::NodeResolver 
Class: class PathDiagnosticBuilder : public BugReporterContext { class PathDiagnosticBuilder : public BugReporterContext 
Class:class ContextLocation : public PathDiagnosticLocation { class ContextLocation : public PathDiagnosticLocation 
Class: class EdgeBuilder { class EdgeBuilder 
Class:class DiagCacheItem : public llvm::FoldingSetNode { class DiagCacheItem : public llvm::FoldingSetNode 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(356, 1, u'+  assert(R && "The memory region is null.");'), (516, 1, u'+  assert(Cond);'), (517, 1, u'+  assert(srcBlk->succ_size() == 2);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 1, u'+    assert(I->second.HasDispatcher && "No dispatcher registered for an event");'), (57, 1, u'+  assert(D);'), (74, 1, u'+  assert(checkers);'), (82, 1, u'+  assert(D && D->hasBody());'), (476, 1, u'+    assert(InlineCallCheckers.size() <= 1 &&'), (486, 1, u'+      assert(!(evaluated && anyEvaluated)'), (519, 1, u'+      assert(!(evaluated && anyEvaluated)'), (651, 1, u'+  assert(S);'), (668, 1, u'+  assert(checkers);')]
===========================================
Class:class DFS : public WorkList { class DFS : public WorkList 
Class: class BFS : public WorkList { class BFS : public WorkList 
Class:  class BFSBlockDFSContents : public WorkList {   class BFSBlockDFSContents : public WorkList 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 1, u'+    assert (!Stack.empty());'), (129, 1, u'+      assert(!Queue.empty());'), (170, 1, u'+    assert (Entry->empty() &&'), (173, 1, u'+    assert (Entry->succ_size() == 1 &&'), (237, 1, u'+      assert (false && "BlockExit location never occur in forward analysis.");'), (256, 1, u'+      assert(Pred->hasSinglePred() &&'), (263, 1, u'+      assert(isa<PostStmt>(Loc) ||'), (296, 1, u'+    assert (L.getLocationContext()->getCFG()->getExit().size() == 0'), (401, 1, u'+        assert (B->succ_size() == 1);'), (440, 1, u'+  assert (B->succ_size() == 1 &&'), (449, 1, u'+  assert(B->succ_size() == 2);'), (460, 1, u'+  assert(B);'), (461, 1, u'+  assert(!B->empty());'), (483, 1, u'+    assert (IsNew);'), (493, 1, u'+  assert(Block);'), (494, 1, u'+  assert (!N->isSink());'), (667, 1, u'+  assert(Src->succ_rbegin() != Src->succ_rend());')]
===========================================
Class:class MarkLiveCallback : public SymbolVisitor { class MarkLiveCallback : public SymbolVisitor 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(119, 1, u'+  assert(node->pred_size() == 1 || node->succ_size() == 1);'), (137, 1, u'+  assert(reclaimCounter > 0);'), (160, 1, u'+  assert (!V->isSink());'), (169, 1, u'+  assert(getKind() == Size1);'), (171, 1, u'+  assert(getKind() == Size1);'), (175, 1, u'+  assert((reinterpret_cast<uintptr_t>(N) & Mask) == 0x0);'), (176, 1, u'+  assert(!getFlag());'), (185, 1, u'+      assert((reinterpret_cast<uintptr_t>(V) & Mask) == 0x0);'), (189, 1, u'+      assert(getPtr() == (void*) V);'), (190, 1, u'+      assert(getKind() == SizeOther);'), (194, 1, u'+      assert(getKind() == Size1);'), (198, 1, u'+    assert(getKind() == SizeOther);'), (282, 1, u'+  assert (NBeg < NEnd);'), (307, 1, u'+    assert(*I);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 1, u'+    assert (B->isCompoundAssignmentOp());'), (414, 1, u'+        assert(isa<nonloc::LazyCompoundVal>(InitVal));'), (441, 1, u'+  assert(B->getOpcode() == BO_LAnd ||'), (448, 1, u'+  assert(X.isUndef());'), (451, 1, u'+  assert(Ex);'), (524, 1, u'+    assert(IE->getNumInits() == 1);'), (544, 1, u'+  assert (X.isUndef());'), (546, 1, u'+  assert(SE);'), (559, 1, u'+    assert(IV.getBitWidth() == getContext().getTypeSize(OOE->getType()));'), (560, 1, u'+    assert(OOE->getType()->isIntegerType());'), (561, 1, u'+    assert(IV.isSigned() == OOE->getType()->isSignedIntegerOrEnumerationType());'), (581, 1, u'+      assert(T->isVariableArrayType() && "Unknown non-constant-sized type.");'), (627, 1, u'+      assert (U->getType() == Ex->getType());'), (651, 1, u'+      assert(!U->isLValue());'), (674, 1, u'+      assert (!U->isLValue());'), (729, 1, u'+  assert (U->isIncrementDecrementOp());'), (745, 1, u'+    assert(LCtx == (*I)->getLocationContext());'), (792, 1, u'+          assert(state);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(69, 1, u'+  assert(CD);')]
===========================================
Class:  class DefaultEval : public GraphExpander {   class DefaultEval : public GraphExpander 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+  assert(Entry->empty());'), (32, 1, u'+  assert(Entry->succ_size() == 1);'), (59, 1, u'+      assert(Node->pred_size() == 1);'), (276, 1, u'+    assert(MDecl->param_size() <= Call.getNumArgs());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 1, u'+    assert(elemD->getInit() == 0);'), (114, 1, u'+        assert(Loc::isLocType(T));'), (167, 1, u'+        assert(notNilState);'), (271, 1, u'+  assert(Bldr.hasGeneratedNodes());')]
===========================================
Class:class HTMLDiagnostics : public PathDiagnosticConsumer { class HTMLDiagnostics : public PathDiagnosticConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(576, 1, u'+  assert(STC);'), (589, 1, u'+  assert(STC);'), (608, 1, u'+    assert(K == MemRegion::GlobalInternalSpaceRegionKind);'), (612, 1, u'+  assert(K == MemRegion::StaticGlobalSpaceRegionKind);'), (689, 1, u'+        assert(D->isStaticLocal());'), (733, 1, u'+      assert(STC);'), (756, 1, u'+    assert(STC);'), (819, 1, u'+  assert(SFC);'), (833, 1, u'+  assert(STC);'), (835, 1, u'+  assert(PT);'), (843, 1, u'+  assert(STC);'), (970, 1, u'+  assert(superR && "super region cannot be NULL");'), (1074, 1, u'+    assert(VR);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+  assert(isFunctionCall());'), (49, 1, u'+  assert(!isCXXCall());'), (55, 1, u'+  assert(isCXXCall());'), (70, 1, u'+  assert(isObjCMessage());'), (78, 1, u'+    assert(CE);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(247, 1, u'+  assert(!LAC.isNull() && "A valid LocationContext or AnalysisDeclContext should "'), (349, 1, u'+  assert(N && "Cannot create a location with a null node.");'), (379, 1, u'+  assert(isValid());'), (404, 1, u'+  assert(isValid());'), (477, 1, u'+  assert(path.size() > 0 &&'), (484, 1, u'+      assert(!cp->path.empty());'), (671, 1, u'+  assert(CExit && "Stack Hints should be constructed at CallExit points.");'), (721, 1, u'+  assert(ValNo != 0 && "ValNo must be strictly positive!");')]
===========================================
Class:  class PlistDiagnostics : public PathDiagnosticConsumer {   class PlistDiagnostics : public PathDiagnosticConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+  assert(state->refCount > 0);'), (194, 1, u'+  assert(!isa<loc::MemRegionVal>(LV) && "Use invalidateRegion instead.");'), (641, 1, u'+  assert(NewState);'), (688, 1, u'+    assert(isa<SymbolData>(*SI));')]
===========================================
Class:class Range : public std::pair<const llvm::APSInt*, class Range : public std::pair<const llvm::APSInt*,
Class:  class RangeTrait : public llvm::ImutContainerInfo<Range> { class RangeTrait : public llvm::ImutContainerInfo<Range> 
Class:    class RangeSet { class RangeSet 
Class:class RangeConstraintManager : public SimpleConstraintManager{ class RangeConstraintManager : public SimpleConstraintManager
Class:class BindingKey { class BindingKey 
Class:class RegionStoreFeatures { class RegionStoreFeatures 
Class:class RegionStoreSubRegionMap : public SubRegionMap { class RegionStoreSubRegionMap : public SubRegionMap 
Class: class RegionStoreManager : public StoreManager { class RegionStoreManager : public StoreManager 
Class:class ClusterAnalysis  { class ClusterAnalysis  
Class:class invalidateRegionsWorker : public ClusterAnalysis<invalidateRegionsWorker> class invalidateRegionsWorker : public ClusterAnalysis<invalidateRegionsWorker>
Class:class removeDeadBindingsWorker : class removeDeadBindingsWorker :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+  assert(lhs);'), (49, 1, u'+  assert(!Loc::isLocType(type));'), (56, 1, u'+  assert(rhs);'), (57, 1, u'+  assert(!Loc::isLocType(type));'), (63, 1, u'+  assert(lhs && rhs);'), (64, 1, u'+  assert(haveSameType(lhs->getType(Context), rhs->getType(Context)) == true);'), (65, 1, u'+  assert(!Loc::isLocType(type));'), (71, 1, u'+  assert(operand);'), (72, 1, u'+  assert(!Loc::isLocType(toTy));'), (156, 1, u'+  assert(SymbolManager::canSymbolicate(type) && "Invalid metadata symbol type");'), (244, 1, u'+    assert(op == BO_Add);'), (316, 1, u'+    assert(Loc::isLocType(castTy));'), (332, 1, u'+    assert(castTy->isIntegerType());'), (373, 1, u'+    assert(Loc::isLocType(originalTy) || originalTy->isFunctionType() ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(217, 1, u'+  assert (Op == BO_Add || Op == BO_Sub ||'), (296, 1, u'+      assert (false && "Pretty-printed not implemented for this NonLoc.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(79, 1, u'+    assert (false && "\'Assume\' not implemented for this Loc.");'), (171, 1, u'+    assert(sym);'), (246, 1, u'+  assert(BinaryOperator::isComparisonOp(op) &&'), (267, 1, u'+  assert(T->isIntegerType() || Loc::isLocType(T));')]
===========================================
Class:class SimpleSValBuilder : public SValBuilder { class SimpleSValBuilder : public SValBuilder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 1, u'+  assert(!T.isNull());'), (231, 1, u'+    assert(svalBuilder.getContext().hasSameUnqualifiedType(castTy, T));'), (329, 1, u'+  assert(BaseIdxI.isSigned());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(124, 1, u'+  assert(!itr.empty() && "attempting to iterate on an \'end\' iterator");'), (125, 1, u'+  assert(isa<SymbolData>(itr.back()));'), (133, 1, u'+  assert(!itr.empty() && "attempting to dereference an \'end\' iterator");'), (391, 1, u'+  assert(LI != TheLiving.end() && "The primary symbol is not live.");')]
===========================================
Class:class TextPathDiagnostics : public PathDiagnosticConsumer { class TextPathDiagnostics : public PathDiagnosticConsumer 
Class:class AnalysisConsumer : public ASTConsumer, class AnalysisConsumer : public ASTConsumer,
Class:class UbigraphViz : public ExplodedNode::Auditor { class UbigraphViz : public ExplodedNode::Auditor 
Class:class ClangCheckerRegistry : public CheckerRegistry { class ClangCheckerRegistry : public CheckerRegistry 
Class:class CommandLineArgumentParser { class CommandLineArgumentParser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 1, u'+  assert(!CC1Args.empty() && "Must at least contain the program name!");'), (123, 1, u'+  assert(llvm::sys::path::is_absolute(BaseDirectory));')]
===========================================
Class:    class A { class A 
Class:   class A { class A 
Class: class B : public A { class B : public A 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+#define Assert(condition)if (!(condition)) { DebugStop("Assertion failure: %s [File: %s, Line: %lu]", #condition, __FILE__, __LINE__); }'), (38, 1, u'+#define AssertMsg(condition, message)if (!(condition)) { DebugStop("Assertion failure: %s (%s) [File: %s, Line: %lu]", #condition, message, __FILE__, __LINE__); }'), (42, 1, u'+#define AssertNoErr(err){ DebugDisplayOSStatusMsg((err), #err, __FILE__, __LINE__); }')]
===========================================
Class:     class Test2 { class Test2 
Class:  class pencil {   class pencil 
Class:  class A { class A 
Class: class B : public A { class B : public A 
Class:  class A { class A 
Class:   class A { class A 
Class: class B : public virtual A { class B : public virtual A 
Class: class C : public virtual A { class C : public virtual A 
Class: class TestOrder : public C, public B, public virtual A { class TestOrder : public C, public B, public virtual A 
Class: class TestArray { class TestArray 
Class:  class A { class A 
Class:class B : public A{ class B : public A
Class:class C : public A
Class:class BB: public B
Class:class M : public B, public C 
Class:  class A { class A 
Class:   class A { class A 
Class: class B : public virtual A { class B : public virtual A 
Class: class C : public virtual A { class C : public virtual A 
Class: class TestOrder : public C, public B, public A { class TestOrder : public C, public B, public A 
Class: class TestControlFlow { class TestControlFlow 
Class:  class A { class A 
Class:class Test3_Base 
Class:class Test3_Derived : public Test3_Base 
Class:     class TestHandleThis { class TestHandleThis 
Class:   class String8419 { class String8419 
Class: template <class T> class Foo { template <class T> class Foo 
Class:class Dummy 
Class: template <typename T> class Foo2 { class Foo2 
Class:   template <typename T> class Foo3 { class Foo3 
Class:   class RDar9203355 { class RDar9203355 
Class:class Rdar9212495_B : public Rdar9212495_C 
Class:class Rdar9212495_A : public Rdar9212495_B 
Class: class PR9645_SideEffect { 
Class:  class RDar9267815 { class RDar9267815 
Class:  class TestInvalidateClass { class TestInvalidateClass 
Class:  class TestInvalidateInCtor { class TestInvalidateInCtor 
Class:   class ClassWithStatic { class ClassWithStatic 
Class:    class PR11146 { class PR11146 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(6, 1, u'+extern void __assert_fail (__const char *__assertion, __const char *__file,'), (10, 1, u'+#define assert(expr) \\'), (11, 1, u'+  ((expr)  ? (void)(0)  : __assert_fail (#expr, __FILE__, __LINE__, __func__))'), (194, 1, u'+  assert (len != 0);'), (205, 1, u"+  assert (len > 0);  // note use of '>'")]
===========================================
Class:   class A { class A 
Class: class B { class B 
Class: class TestCtorInits { class TestCtorInits 
Class:  class A { class A 
Class: class B : public A { class B : public A 
Class: class C : public B { class C : public B 
Class:  class type_info;
Class:    class Foo {     class Foo 
Class:   class Test {   class Test 
Class:  class A {   class A 
Class:  class B {   class B 
Class:  class D 
Class:  class C 
Class:  template <class T> class A {   template <class T> class A 
Class:  class X 
Class:  class Ident<int> AIdent; 
Class:   class C { class C 
Class:    class C 
Class:  class C : C 
Class:    class C;
Class:  class bad_alloc 
Class:class foo 
Class:  class bad_alloc 
Class:  class Base {   class Base 
Class:   class Test : public Base {   class Test : public Base 
Class:  class Base {    class Base 
Class:   class Test : protected Base {    class Test : protected Base 
Class:  class Base {    class Base 
Class:   class Test : private Base {    class Test : private Base 
Class:  class A {   class A 
Class:  class B : private A 
Class:  class C : private A {   class C : private A 
Class:  class A {   class A 
Class:  class B : public A 
Class:  class C : private A {   class C : private A 
Class:  class Test0 {   class Test0 
Class:  class A {   class A 
Class:  class E {   class E 
Class:    class B 
Class:     class I {     class I 
Class:  class ClassFriend {   class ClassFriend 
Class:   class MemberFriend {   class MemberFriend 
Class:   class Class {   class Class 
Class:   class UndeclaredClassFriend {   class UndeclaredClassFriend 
Class:   class ClassNonFriend {   class ClassNonFriend 
Class:  class ilist_half_node {   class ilist_half_node 
Class:   class ilist_node : private ilist_half_node {    class ilist_node : private ilist_half_node 
Class:  class A 
Class:   class B : public A {   class B : public A 
Class:  class A 
Class:   class B : public A {   class B : public A 
Class:  template <class T> class Holder {   template <class T> class Holder 
Class:    class A;
Class:   class ns::A {   class ns::A 
Class:    class B {     class B 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class B {   class B 
Class:    class C {     class C 
Class:  class A {   class A 
Class:   class B {   class B 
Class:  class B : private A {   class B : private A 
Class:    class A {     class A 
Class:    class A {     class A 
Class:class X1 
Class:class Y1 
Class:  class A {   class A 
Class:  class B : public A 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {    class C : protected A 
Class:  class D : private B {    class D : private B 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class B;
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class C;
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {    class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class D;
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {    class D : private B 
Class:  class Static 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class Static 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class Static 
Class:  class A {   class A 
Class:  class B : public A {   class B : public A 
Class:  class C : protected A {   class C : protected A 
Class:  class D : private B {   class D : private B 
Class:  class A {    class A 
Class:   class B : public A {    class B : public A 
Class:   class C : protected B {    class C : protected B 
Class:   class D : public A {   class D : public A 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:   class C {   class C 
Class:  class A 
Class:  class B : public virtual A 
Class:  class C : private B 
Class:  class D : private C, public virtual A 
Class:  class A 
Class:  class B : private virtual A 
Class:  class C : private B 
Class:  class D : public virtual A 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:  class A {   class A 
Class:   class B : public virtual A {   class B : public virtual A 
Class:   class C : public B {   class C : public B 
Class:class Public 
Class:class Protected 
Class:class Private 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class B : A 
Class:   class C : virtual A {   class C : virtual A 
Class:  class D : C 
Class:  class A {   class A 
Class:  class Base2 : virtual Base<2> 
Class:  class Base3 : virtual Base<3> 
Class:  class Derived0 : Base<0> 
Class:  class Derived1 : Base<1> 
Class:   class Derived2 :                          Base<0>,       virtual Base<1>,      Base2,      virtual Base3   {   
Class:  class Base {   class Base 
Class:   class Derived1 : private Base {    class Derived1 : private Base 
Class:                                               class Derived2 : public Base {   class Derived2 : public Base 
Class:   class Derived3 : private Base {    class Derived3 : private Base 
Class:                                              class Derived4 : public Base {   class Derived4 : public Base 
Class:  class A {   class A 
Class:  class Test1 
Class:  class Test2 : A 
Class:  class A {   class A 
Class:  class Test1 
Class:  class Test2 : A 
Class:  class A {   class A 
Class:  class B : A {   class B : A 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class B : private A {    class B : private A 
Class:  class C : public B {   class C : public B 
Class:  class A {   class A 
Class:   class B {   class B 
Class:   class C {   class C 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:  class A {   class A 
Class:      class Local {       class Local 
Class:  class A {   class A 
Class:   class X {   class X 
Class:  template <class T> class A {   template <class T> class A 
Class:   template <class T> class B : public A<T> {   template <class T> class B : public A<T> 
Class:  class A 
Class:  class A {   class A 
Class:  template <class T> class A 
Class:  class B : A<int> {   class B : A<int> 
Class:            class C : B {   class C : B 
Class:  class A 
Class:  class Foo {   class Foo 
Class:  template <class T> class A {   template <class T> class A 
Class:    class Inner; 
Class:  template <class T> class A<T>::Inner 
Class:  class B {   class B 
Class:  template <typename T> class A {   template <typename T> class A 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class A {   class A 
Class:   class B {   class B 
Class:  class Green 
Class:    template <class T, class Nat> class A {     template <class T, class Nat> class A 
Class:   template <class T> class Outer::A<T, typename T::nature> {   template <class T> class Outer::A<T, typename T::nature> 
Class:   class B {   class B 
Class:  template <class T> class A {   template <class T> class A 
Class:  class A {   class A 
Class:   class B {   class B 
Class:  class A {   class A 
Class:   class B : A {   class B : A 
Class:  class A {   class A 
Class:  class B {   class B 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  class V { class V 
Class: class W { class W 
Class: class B : public virtual V, public W { 
Class:class C : public virtual V, public W 
Class:class D : public B, public C 
Class:  class ClsA {   class ClsA 
Class:   class ClsB : virtual private ClsA {   class ClsB : virtual private ClsA 
Class:   class ClsF : virtual private ClsA {   class ClsF : virtual private ClsA 
Class:   class ClsE : public ClsB, public ClsF {   class ClsE : public ClsB, public ClsF 
Class: class foo { class foo 
Class:  class A { class A 
Class:  class AInner {   class AInner 
Class: class A { class A 
Class:  class AInner {   class AInner 
Class:  class facet 
Class: class A { class A 
Class:  class A { class A 
Class:  class X {   class X 
Class:    class Inner {     class Inner 
Class:   class Y {   class Y 
Class:    class Inner {     class Inner 
Class:       class A { class A 
Class:   class B {   class B 
Class:  class A {   class A 
Class:  class Outer { class Outer 
Class:      class Inner {   class Inner 
Class:  class Outer { class Outer 
Class:      class Inner {   class Inner 
Class:  class E {   class E 
Class:    class I1;
Class:    class I1 
Class:  class E::I2 
Class:  class X { class X 
Class:  class Y 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+static_assert(U<int>::a == 0, "");')]
===========================================
Class: class Okay { class Okay 
Class: class Virtual { class Virtual 
Class: class VirtualBase : virtual Okay {  class VirtualBase : virtual Okay 
Class: class Ctor { class Ctor 
Class:class Ctor2 { class Ctor2 
Class:class CtorTmpl { class CtorTmpl 
Class: class CopyCtor { class CopyCtor 
Class:  class CopyAssign {  class CopyAssign 
Class: class Dtor { class Dtor 
Class: template <class A, class B> struct Either { template <class A, class B> struct Either 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+static_assert(U2<int>::k1 == sizeof(int), "");'), (31, 1, u'+static_assert(U2<char>::k1 == sizeof(char), "");')]
===========================================
Class:class A final 
Class:class A final 
Class:class B : A 
Class:class Trivial 
Class:class NonTrivial1 
Class:class NonTrivial2 
Class:class NonTrivial3 
Class:class NonTrivial4 
Class:class NonTrivial5 
Class:class NonTrivial6 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(10, 1, u'+static_assert(__is_trivial(Trivial), "Trivial is not trivial");'), (11, 1, u'+static_assert(!__is_trivial(NonTrivial1), "NonTrivial1 is trivial");'), (12, 1, u'+static_assert(!__is_trivial(NonTrivial2), "NonTrivial2 is trivial");'), (13, 1, u'+static_assert(!__is_trivial(NonTrivial3), "NonTrivial3 is trivial");'), (14, 1, u'+static_assert(!__is_trivial(NonTrivial4), "NonTrivial4 is trivial");'), (15, 1, u'+static_assert(!__is_trivial(NonTrivial5), "NonTrivial5 is trivial");'), (30, 1, u'+static_assert(!__is_trivial(NonTrivial6), "NonTrivial6 is trivial");')]
===========================================
Class:  class Y {   class Y 
Class:    class A {     class A 
Class:  class Test3 
Class:  class Test3 
Class:    class Test4 
Class:    class Test4 
Class:  class A 
Class:  template <class Tp> class allocator;
Class:  class allocator<void>   class allocator<void>
Class:   template <class Tp>   class allocator   {   
Class:class foo 
Class:  class foo 
Class:      class foo a;
Class:      class foo a;
Class:      class ::foo a;
Class:    class a 
Class:  class A {   class A 
Class:   class B : private A {   class B : private A 
Class:  class A {   class A 
Class:   class B {   class B 
Class:   class C : public B {   class C : public B 
Class:    class tag;
Class:  class Test0 {   class Test0 
Class:   class Test1 {   class Test1 
Class:  template <typename> class Test0 {   template <typename> class Test0 
Class:   template <typename> class Test1 {   template <typename> class Test1 
Class:  template <typename T> class Test0 {   template <typename T> class Test0 
Class:   template <typename T> class Test1 {   template <typename T> class Test1 
Class:  class Base {   class Base 
Class: class C { class C 
Class: class D2 : public B { class D2 : public B 
Class:  class Test0 {   class Test0 
Class:  class B {   class B 
Class:   class test5 { class test5 
Class:class C2 
Class:class C4 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 1, u'+  static_assert(true, "the impossible happened!");')]
===========================================
Class:  class C : public B {   class C : public B 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(19, 1, u'+static_assert(f(0) == 0, "");'), (20, 1, u'+static_assert(f(\'0\') == 1, "");'), (21, 1, u'+static_assert(g1() == 0, "");'), (22, 1, u'+static_assert(g2(0) == 1, "");'), (23, 1, u'+static_assert(g2(1) == 1, "");'), (24, 1, u'+static_assert(g3(0) == 1, "");'), (25, 1, u'+static_assert(g3(1) == 1, "");'), (26, 1, u'+static_assert(N::h() == 5, "");'), (27, 1, u'+static_assert(g4() == 5, "");'), (85, 1, u'+static_assert(BcpCall(0), "");')]
===========================================
Class:  class debug_flag {    class debug_flag 
Class:  class A { class A 
Class:  class type_info;
Class: class X { class X 
Class:  class type_info;
Class:class A 
Class: class A1 { class A1 
Class:  class Member 
Class: template <> class B<int> { template <> class B<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(18, 1, u'+static_assert(is_same<decltype(foo()), const int&&>::value, "");'), (19, 1, u'+static_assert(is_same<decltype(i), int>::value, "");'), (20, 1, u'+static_assert(is_same<decltype(a->x), double>::value, "");'), (21, 1, u'+static_assert(is_same<decltype((a->x)), const double&>::value, "");'), (22, 1, u'+static_assert(is_same<decltype(static_cast<int&&>(i)), int&&>::value, "");')]
===========================================
Class: class PD { class PD 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+  static_assert(swappable<int>(), "");'), (77, 1, u'+  static_assert(!swappable<const int>(), "");'), (82, 1, u'+    static_assert(OK, "boom!"); // expected-error 2{{boom!}}')]
===========================================
Class: class K { class K 
Class:  class C0 {   class C0 
Class:  class C1 {   class C1 
Class:  class C2 {   class C2 
Class:  class C5 {   class C5 
Class:  class C6 {   class C6 
Class:    class c 
Class:  class C0 {   class C0 
Class:  class C1 {   class C1 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(16, 1, u'+static_assert(S(true), "");'), (17, 1, u'+static_assert(S(false), "not so fast"); // expected-error {{not so fast}}'), (18, 1, u'+static_assert(T(), "");'), (19, 1, u'+static_assert(U(), ""); // expected-error {{ambiguous}}'), (21, 1, u'+static_assert(false, L"\\x14hi" "!" R"x(")x"); // expected-error {{static_assert failed L"\\024hi!\\""}}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 1, u'+static_assert(S5().m == 4, "");')]
===========================================
Class:   class C { class C 
Class: template <typename T> class E { class E 
Class: class NonCopyable { class NonCopyable 
Class: class NonCopyableDerived : public NonCopyable { class NonCopyableDerived : public NonCopyable 
Class:  class map {   class map 
Class:  class Value {   class Value 
Class:class Private { class Private 
Class:class Friend { class Friend 
Class:  class S { class S 
Class:  class C { class C 
Class: class A { class A 
Class: class A { class A 
Class: template <class T> class RefMem {  template <class T> class RefMem 
Class:  template <class T> class PtrMem { template <class T> class PtrMem 
Class: template <class T> class ArrMem { template <class T> class ArrMem 
Class:template <class T, unsigned N> class DepArrMem { template <class T, unsigned N> class DepArrMem 
Class:   class foo { class foo 
Class:class basic_string class basic_string
Class: template <class T, class Value, class _Compare> __map_value_compare<T, Value, _Compare>::__map_value_compare()   noexcept(__is_nothrow_constructible<_Compare>::value) {}   noexcept(__is_nothrow_constructible<_Compare>::value) 
Class:  class Class {   class Class 
Class:  class CA1 {   class CA1 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 1, u'+static_assert(noexcept(IC0()), "IC0() does not throw");'), (41, 1, u'+static_assert(!noexcept(IC1()), "IC1() throws");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+static_assert((T() = {4, 9}) == 4, "");'), (31, 1, u'+static_assert((T() += {4, 9}) == 9, "");')]
===========================================
Class:  class B {   class B 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(115, 1, u'+  static_assert(p, "");'), (124, 1, u'+  static_assert(!q, "");'), (202, 1, u'+    static_assert((A*)nb == 0, "");'), (203, 1, u'+    static_assert((B*)na == 0, "");'), (219, 1, u'+    static_assert(&a[2][0] == &a[1][3], "");'), (260, 1, u'+    static_assert(65536u * 65536u == 0u, ""); // ok'), (261, 1, u'+    static_assert(4294967295u + 1u == 0u, ""); // ok'), (262, 1, u'+    static_assert(0u - 1u == 4294967295u, ""); // ok'), (263, 1, u'+    static_assert(~0u * ~0u == 1u, ""); // ok'), (292, 1, u'+  static_assert(vi, ""); // expected-error {{constant expression}} expected-note {{read of volatile-qualified type}}'), (293, 1, u'+  static_assert(const_cast<int&>(vi), ""); // expected-error {{constant expression}} expected-note {{read of volatile object \'vi\'}}'), (294, 1, u'+  static_assert(vrci, ""); // expected-error {{constant expression}} expected-note {{read of volatile-qualified type}}'), (313, 1, u'+  static_assert(s.i, "");'), (314, 1, u'+  static_assert(s.v, ""); // expected-error {{constant expression}} expected-note {{read of volatile-qualified type}}'), (315, 1, u'+  static_assert(const_cast<int&>(s.v), ""); // expected-error {{constant expression}} expected-note {{read of volatile object \'vi\'}}'), (316, 1, u'+  static_assert(vs.i, ""); // expected-error {{constant expression}} expected-note {{read of volatile-qualified type}}'), (317, 1, u'+  static_assert(const_cast<int&>(vs.i), ""); // expected-error {{constant expression}} expected-note {{read of volatile object \'vs\'}}'), (318, 1, u'+  static_assert(vrs.i, ""); // expected-error {{constant expression}} expected-note {{read of volatile-qualified type}}'), (324, 1, u'+  static_assert(f().i, ""); // ok! there\'s no lvalue-to-rvalue conversion here!'), (325, 1, u'+  static_assert(((volatile const S&&)(S)0).i, ""); // expected-error {{constant expression}}'), (342, 1, u'+  static_assert(u.a == 0, "");'), (595, 1, u'+static_assert(and_value == false, "");'), (596, 1, u'+static_assert(or_value == true, "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(26, 1, u'+    static_assert(!vowels[5], "unexpected number of vowels");'), (78, 1, u'+static_assert(Val<bool, E1>::value == 1, ""); // ok'), (79, 1, u'+static_assert(Val<bool, \'\\0\'>::value == 0, ""); // ok'), (80, 1, u'+static_assert(Val<bool, U\'\\1\'>::value == 1, ""); // ok'), (81, 1, u'+static_assert(Val<bool, E5>::value == 1, ""); // expected-error {{5, which cannot be narrowed to type \'bool\'}}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+static_assert(test_ok == 8, "");'), (42, 1, u'+static_assert(test_explicit == 4, "");'), (43, 1, u'+static_assert(test_ambiguous == 2, "");')]
===========================================
Class:  class type_info;
Class:class Poly 
Class:  class A   class A
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(15, 1, u'+  static_assert(!noexcept(a.g1()), "exception-specification failure");'), (16, 1, u'+  static_assert(noexcept(a.g2()), "exception-specification failure");'), (41, 1, u'+  static_assert(!noexcept(ci.g1()), "exception-specification failure");'), (42, 1, u'+  static_assert(noexcept(ci.g2()), "exception-specification failure");')]
===========================================
Class: class X0 { class X0 
Class: class NonCopyable { class NonCopyable 
Class: class NonConstCopy { class NonConstCopy 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 1, u'+  static_assert(sizeof(x) == sizeof(ExpectedArrayLayout), "layout mismatch");'), (66, 1, u'+  static_assert(sizeof(x) == sizeof(ExpectedLayout), "Layout mismatch!");'), (73, 1, u'+    static_assert(sizeof(x) == sizeof(ExpectedThisLayout), "Layout mismatch!");')]
===========================================
Class:  class NonCopyable { class NonCopyable 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(20, 1, u'+    static_assert(is_same<decltype(((r))), float const&>::value,'), (22, 1, u'+    static_assert(is_same<decltype(x), float>::value, "should be float");'), (23, 1, u'+    static_assert(is_same<decltype((x)), const float&>::value,'), (25, 1, u'+    static_assert(is_same<decltype(r), float&>::value, "should be float&");'), (26, 1, u'+    static_assert(is_same<decltype(ir), int&>::value, "should be int&");'), (27, 1, u'+    static_assert(is_same<decltype((ir)), int&>::value, "should be int&");'), (28, 1, u'+    static_assert(is_same<decltype(irc), const int&>::value,'), (30, 1, u'+    static_assert(is_same<decltype((irc)), const int&>::value,'), (36, 1, u'+      static_assert(is_same<decltype(x), float>::value, "should be float");'), (37, 1, u'+      static_assert(is_same<decltype((x)), float&>::value,'), (43, 1, u'+    static_assert(is_same<decltype((i)), int&>::value, "should be int&");')]
===========================================
Class:  class type_info;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+  static_assert(!noexcept(tl1()), "lambda can throw");'), (55, 1, u'+  static_assert(!noexcept(tl2()), "lambda can throw");'), (60, 1, u'+  static_assert(noexcept(ntl1()), "lambda cannot throw");'), (61, 1, u'+  static_assert(noexcept(ntl2()), "lambda cannot throw");'), (62, 1, u'+  static_assert(noexcept(ntl3()), "lambda cannot throw");')]
===========================================
Class:  class X0 { class X0 
Class:  class type_info;
Class:class T0 
Class:class T2_A 
Class:class T3_A { class T3_A 
Class:template < typename T > class templ { template < typename T > class templ 
Class:  class ctor { class ctor 
Class: class dtor { class dtor 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 1, u'+#define P(e) static_assert(noexcept(e), "expected nothrow")'), (4, 1, u'+#define N(e) static_assert(!noexcept(e), "expected throw")'), (5, 1, u'+#define B(b, e) static_assert(b == noexcept(e), "expectation failed")')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(18, 1, u'+static_assert(123456789012345678901234567890123456789012345678901234567890_x3 == 60, "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(18, 1, u'+static_assert(1e1000000_x3 == 9, "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(10, 1, u'+static_assert(streq(s, "foobarbazquux"), "");'), (16, 1, u'+static_assert(streq(t, "foo"), "");')]
===========================================
Class:        class Y { class Y 
Class: class C { class C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 1, u'+static_assert(operator "" _a("foo") == \'f\', "");')]
===========================================
Class:  template <class T, class U> T& f(U); 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 1, u'+  static_assert(!noexcept(HasCopyConstructor((HasCopyConstructor()))), "");'), (49, 1, u'+  static_assert(!noexcept(hcc = HasCopyConstructor()), "");'), (51, 1, u'+  static_assert(!noexcept(HasCopyAssignment((HasCopyAssignment()))), "");'), (53, 1, u'+  static_assert(!noexcept(hca = HasCopyAssignment()), "");'), (55, 1, u'+  static_assert(noexcept(HasMoveConstructor((HasMoveConstructor()))), "");'), (61, 1, u'+  static_assert(noexcept(hma = HasMoveAssignment()), "");'), (63, 1, u'+  static_assert(!noexcept(HasDestructor((HasDestructor()))), "");'), (65, 1, u'+  static_assert(!noexcept(hd = HasDestructor()), "");'), (127, 1, u'+  static_assert(!noexcept(InheritsPrivateMove(InheritsPrivateMove())), "");'), (128, 1, u'+  static_assert(!noexcept(ContainsPrivateMove(ContainsPrivateMove())), "");'), (130, 1, u'+  static_assert(!noexcept(ipm = InheritsPrivateMove()), "");'), (132, 1, u'+  static_assert(!noexcept(cpm = ContainsPrivateMove()), "");'), (137, 1, u'+  static_assert(!noexcept(InheritsNonTrivialCopyOnly(InheritsNonTrivialCopyOnly())), "");'), (138, 1, u'+  static_assert(!noexcept(ContainsNonTrivialCopyOnly(ContainsNonTrivialCopyOnly())), "");'), (140, 1, u'+  static_assert(!noexcept(intco = InheritsNonTrivialCopyOnly()), "");'), (142, 1, u'+  static_assert(!noexcept(cntco = ContainsNonTrivialCopyOnly()), "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(38, 1, u'+  static_assert(noexcept(declval<X>()), "noexcept isn\'t working at all");'), (39, 1, u'+  static_assert(noexcept(X(declval<X&>())), "copy constructor can\'t throw");'), (40, 1, u'+  static_assert(noexcept(X(declval<X>())), "move constructor can\'t throw");')]
===========================================
Class: class X { class X 
Class:class PrivateDefCtor 
Class:class PrivateDtor 
Class:class Friend { class Friend 
Class:   class Deleted2a { class Deleted2a 
Class:class NotDeleted2a 
Class:class NotDeleted2b 
Class:class NotDeleted2c 
Class:class Deleted3a 
Class:class Deleted3b 
Class:class Deleted3c 
Class:class NotDeleted3a 
Class:class NotDeleted3b 
Class:class NotDeleted3c 
Class:class Trivial 
Class:class NonTrivialDefCtor1 
Class:class NonTrivialDefCtor2 
Class:class NonTrivialDefCtor3 : virtual Trivial 
Class:class NonTrivialDefCtor4 
Class:class NonTrivialDefCtor5 : NonTrivialDefCtor1 
Class:class NonTrivialDefCtor6 
Class:class Trivial2 
Class:class Trivial3 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(146, 1, u'+static_assert(__has_trivial_constructor(Trivial), "Trivial is nontrivial");'), (150, 1, u'+static_assert(!__has_trivial_constructor(NonTrivialDefCtor1), "NonTrivialDefCtor1 is trivial");'), (154, 1, u'+static_assert(!__has_trivial_constructor(NonTrivialDefCtor2), "NonTrivialDefCtor2 is trivial");'), (156, 1, u'+static_assert(!__has_trivial_constructor(NonTrivialDefCtor3), "NonTrivialDefCtor3 is trivial");'), (160, 1, u'+static_assert(!__has_trivial_constructor(NonTrivialDefCtor4), "NonTrivialDefCtor4 is trivial");'), (164, 1, u'+static_assert(!__has_trivial_constructor(NonTrivialDefCtor5), "NonTrivialDefCtor5 is trivial");'), (169, 1, u'+static_assert(!__has_trivial_constructor(NonTrivialDefCtor6), "NonTrivialDefCtor5 is trivial");'), (173, 1, u'+static_assert(__has_trivial_constructor(Trivial2), "Trivial2 is trivial");'), (176, 1, u'+static_assert(__has_trivial_constructor(Trivial3), "Trivial3 is trivial");'), (179, 1, u'+static_assert(__has_trivial_constructor(Trivial4<int>), "Trivial4 is trivial");'), (182, 1, u'+static_assert(__has_trivial_constructor(Trivial5<int>), "Trivial5 is trivial");')]
===========================================
Class:class InaccessibleDtor { class InaccessibleDtor 
Class:   class D1 { class D1 
Class:  class A {   class A 
Class:   class B : protected A {   class B : protected A 
Class:   class C : protected B {   class C : protected B 
Class:  class A {   class A 
Class:   class B : protected A {   class B : protected A 
Class:   class C : protected B {   class C : protected B 
Class:  class ADL 
Class:  class NoADL 
Class:  class X {   class X 
Class:template <class T> class X 
Class: class Access { class Access 
Class:   class S {   class S 
Class: class X { class X 
Class:  class Bar {   class Bar 
Class: template <template <class> class T> template <class F> void X2<T>::Bar<F>::Func() {} void X2<T>::Bar<F>::Func() 
Class:  class Representation 
Class: class A { class A 
Class:template <class T> class B { template <class T> class B 
Class:  class A {   class A 
Class:  class A {   class A 
Class:  template <typename T> class HasChecker {   template <typename T> class HasChecker 
Class:  template <typename T> class HasNotChecker {   template <typename T> class HasNotChecker 
Class:  class Bool;
Class:   class Bool {   class Bool 
Class:   template <class T> class User {   template <class T> class User 
Class:  template <class T> class A {   template <class T> class A 
Class:    template <class T0> friend class B;
Class:   template <class T> class B {   template <class T> class B 
Class:  template <class T, class U=int> class A 
Class:  template <class T> class B {   template <class T> class B 
Class:  template <class T> class A {    template <class T> class A 
Class:   class B {   class B 
Class:   class C {   class C 
Class:      template <class T> class D {   template <class T> class D 
Class:  template <class N> class A {   template <class N> class A 
Class:  template <class T> class A {   template <class T> class A 
Class:    class B; class C;
Class:     class B {     class B 
Class:     class C {     class C 
Class:  template <class T> class A;
Class:  template <class T> class A {   template <class T> class A 
Class:  template <typename T> class Foo {   template <typename T> class Foo 
Class:  template <int N, template <int> class Temp>   template <int N, template <int> class Temp>
Class:  class Role : public Temp<N> {   class Role : public Temp<N> 
Class:   template <int N> class Foo {   template <int N> class Foo 
Class:  template <class T> class B;
Class:  template <class T> class A {   template <class T> class A 
Class:   template <class T> class B {   template <class T> class B 
Class:  template <class T> class B;
Class:  template <class T> class A {   template <class T> class A 
Class:   template <class T> class B {   template <class T> class B 
Class:   template <> class B<float> {   template <> class B<float> 
Class:  template <class T> class A { template <class T> class A 
Class: class B { class B 
Class:  template <class T> class A {   template <class T> class A 
Class:    class Member 
Class:   class B {   class B 
Class:  class C {   class C 
Class:  class C {   class C 
Class:  template <class U> class C {   template <class U> class C 
Class: class X { class X 
Class:  class Foo { class Foo 
Class:  class X0 
Class:  class X0 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 1, u'+  static_assert(is_same<X1<int, int>::type,'), (33, 1, u'+  static_assert(is_same<X1<int, int, float>::type,'), (37, 1, u'+  static_assert(is_same<X1<int, int, float, double>::type,'), (55, 1, u'+  static_assert(is_same<X1<int>::type,'), (59, 1, u'+  static_assert(is_same<X1<int, float>::type,'), (63, 1, u'+  static_assert(is_same<X1<int, float, double>::type,')]
===========================================
Class:  class type_info;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(172, 1, u'+  static_assert(static_cast<Types>(0), "Boom"); // expected-error{{static assertion contains unexpanded parameter pack \'Types\'}}')]
===========================================
Class:    template <class Get, class Set>     template <class Get, class Set>
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+static_assert(member_pointer_kind<int (X::*)(int)>::value == 1, "");'), (43, 1, u'+static_assert(member_pointer_kind<int (X::*)(int) &>::value == 2, "");'), (44, 1, u'+static_assert(member_pointer_kind<int (X::*)(int) &&>::value == 3, "");'), (45, 1, u'+static_assert(member_pointer_kind<int (X::*)(int) const>::value == 4, "");'), (46, 1, u'+static_assert(member_pointer_kind<int (X::*)(int) const&>::value == 5, "");'), (47, 1, u'+static_assert(member_pointer_kind<int (X::*)(int) const&&>::value == 6, "");')]
===========================================
Class:  class C {   class C 
Class:class X0 
Class:  class C1 
Class:class X1 
Class:class T 
Class: class X1 { class X1 
Class:  class WebVector {   class WebVector 
Class:    class Bar     class Bar
Class:    class Foo;
Class:  class S<A>::F
Class:  template <class> class A {   template <class> class A 
Class:   template <> class A<double> {   template <> class A<double> 
Class:class A<long>::B 
Class:    template <class T, class U> class Inner;
Class:  class X { class X 
Class: class A { class A 
Class:  class B 
Class:  class C 
Class:  template <class T> class foo {   template <class T> class foo 
Class: class Foo { class Foo 
Class: class Proxy { class Proxy 
Class:class T 
Class:class X 
Class:  class A;
Class:  class Y;
Class:    class     class
Class:  class allocator {   class allocator 
Class:  class B0 { class B0 
Class: class D0 : public B0 { class D0 : public B0 
Class: class B1 { class B1 
Class: class D1 : public B1 { class D1 : public B1 
Class: class D2 : public B0 { class D2 : public B0 
Class:  class B { class B 
Class: class D : public B { class D : public B 
Class:  class exception 
Class:   class type_info {   class type_info 
Class:  class __si_class_type_info : public std::type_info {   class __si_class_type_info : public std::type_info 
Class:class nsISupports { 
Class:  template < class T > struct nsCOMTypeInfo   template < class T > struct nsCOMTypeInfo
Class:class nsIDOMEventListener:public nsISupports { 
Class:class nsIDOMMouseListener:public nsIDOMEventListener { 
Class: class L { class L 
Class:  class CallbackHandle   class CallbackHandle
Class:  class __normal_iterator   class __normal_iterator
Class:  class vector:protected _Vector_base < _Tp,_Alloc >   class vector:protected _Vector_base < _Tp,_Alloc >
Class:  class MantaInterface   {   
Class:  class RTRT   {   
Class:template <class T> class K2PtrVectorBase 
Class:template <class T> class K2Vector 
Class:template <class U > class K2Vector<U*> : public K2PtrVectorBase<U*> 
Class:class ScriptInfoManager { class ScriptInfoManager 
Class: class X { class X 
Class:     class MO { class MO 
Class:  class Foo { 
Class:     class A { class A 
Class:class Pointer32 { class Pointer32 
Class:class Pointer64 { class Pointer64 
Class:class BigEndian 
Class:class LittleEndian 
Class:template <typename _SIZE, typename _ENDIANNESS> class SizeAndEndianness { template <typename _SIZE, typename _ENDIANNESS> class SizeAndEndianness 
Class:template <typename SIZE> class TRange { template <typename SIZE> class TRange 
Class:template <typename SIZE, typename T> class TRangeValue : public TRange<SIZE> { template <typename SIZE, typename T> class TRangeValue : public TRange<SIZE> 
Class:class CSCppSymbolOwner
Class:class CSCppSymbolOwnerData
Class:class E 
Class:  class D {   class D 
Class:   class foo { class foo 
Class:  class SMLoc { class SMLoc 
Class: class foo { class foo 
Class: class bar : public foo { class bar : public foo 
Class: class xpto { class xpto 
Class:  class x { class x 
Class: class C { class C 
Class: class Zone { class Zone 
Class: class X : public virtual Zone { class X : public virtual Zone 
Class:  template <typename T> class A {   template <typename T> class A 
Class:  class C 
Class:  class B : public C {   class B : public C 
Class:  class E : public B 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(232, 1, u'+  static_assert(!__is_literal(NonTrivialDtor), "");'), (240, 1, u'+  static_assert(!__is_literal(VolatileMember), "");')]
===========================================
Class:class C { class C 
Class: class X {  class X 
Class:   class Twine { class Twine 
Class: class X {  class X 
Class:  class Test1 { class Test1 
Class: class Test2 { class Test2 
Class:    class Test3 { class Test3 
Class:   template <typename T> class List { template <typename T> class List 
Class: template <typename T> class Node { template <typename T> class Node 
Class: class X {  class X 
Class: class Y {  class Y 
Class:class O {  class O 
Class:  class XB { class XB 
Class: class Yb : public XB { class Yb : public XB 
Class: class ioapic_redir_t { class ioapic_redir_t 
Class: class X {  class X 
Class:                   class foo { class foo 
Class: class A { class A 
Class:  class initializer_list   class initializer_list
Class:  class initializer_list   class initializer_list
Class:  class initializer_list   class initializer_list
Class: class A { 
Class:   class DAG { class DAG 
Class: class EVT { class EVT 
Class: class VAL { class VAL 
Class:   class locale { class locale 
Class:class ios_base { class ios_base 
Class:   class MyClass { 
Class:  class Test { 
Class: class SomeClass { 
Class:   class B { class B 
Class: class A { class A 
Class:    class A { class A 
Class: class A { class A 
Class:  class A { class A 
Class: class A { class A 
Class:     class A { class A 
Class:          class G { class G 
Class:  class MyClass { 
Class:class base 
Class: template <class T> class foo : public base  { template <class T> class foo : public base  
Class:class bar : public foo<void> 
Class: class TheTemplateTest : public TheTemplate<42> { class TheTemplateTest : public TheTemplate<42> 
Class:  class Class { 
Class:template < template < typename > class T1, template < typename > class > struct Templates2 { 
Class:template < template < typename > class T1,   template < typename > class T2 > struct Templates <T1, T2 > { 
Class:template < template < typename > class, class TestSel,   typename Types > class TypeParameterizedTest { 
Class:  template < typename gtest_TypeParam_ > class A:TypedTestP1 <   template < typename gtest_TypeParam_ > class A:TypedTestP1 <
Class:  template < typename gtest_TypeParam_ > class A:TypedTestP2 <   template < typename gtest_TypeParam_ > class A:TypedTestP2 <
Class:template < class SSS, class = EEE < SSS > >class FFF 
Class:template < class SSS, class GGG = EEE < SSS > >class AAA:FFF <GGG> 
Class:class BBB:virtual CCC { class BBB:virtual CCC 
Class:class ZZZ:AAA < Data >, BBB 
Class:template < typename _Tp > class allocator:__gnu_cxx::new_allocator < _Tp > { template < typename _Tp > class allocator:__gnu_cxx::new_allocator < _Tp > 
Class:      class > struct hash;
Class:class class
Class:  class   class
Class:class class
Class:        class         class
Class:  class   class
Class:  class       C4:         n1::Test {         n1::Test 
Class:  class       C6:         C4,         n1::C7 <         C5 > {         C5 > 
Class:  class       C8:         C6 {         C6 
Class:  class       C9:         C8 {         C8 
Class:template <typename T> class A { template <typename T> class A 
Class: class Cls { class Cls 
Class: class X {  class X 
Class:class obj
Class:   class A { class A 
Class:class B { class B 
Class:class B::C : public A { class B::C : public A 
Class:  template <typename T> class A { class A 
Class:class A 
Class:class B { class B 
Class:  class err 
Class:  class A 
Class:  class B 
Class:  class C 
Class:  class D 
Class:      class A { class A 
Class:               class A { class A 
Class:  template <typename T> class ClassTemplate {   template <typename T> class ClassTemplate 
Class:       class C {   class C 
Class:  class Rdar9445102 {   class Rdar9445102 
Class:  template <typename T> class klass { template <typename T> class klass 
Class:      class StringRef { class StringRef 
Class:  class initializer_list   class initializer_list
Class:  template <class T, class U> void a(T x, U y, decltype(x.*y) z) {}   template <class T, class U> void a(T x, U y, decltype(x.*y) z) 
Class:  class foo { class foo 
Class:    class C {     class C 
Class:   template <class T>   class D {   class D 
Class:  class C;
Class:  class B 
Class:  template <class zaz, class zed>   template <class zaz, class zed>
Class:  template <template <class> class T> class A 
Class:  template <class U> class B 
Class:   template <template<class> class T> void foo(const A<T> &a) {}   template <template<class> class T> void foo(const A<T> &a) 
Class:  template <template <class> class T> void foo(decltype(T<float>::object) &object) {}   template <template <class> class T> void foo(decltype(T<float>::object) &object) 
Class:  template <template <class> class T> struct A {   template <template <class> class T> struct A 
Class:     class t { class t 
Class:  class foo {   class foo 
Class:  class MyClass;
Class:class CoinModel { class CoinModel 
Class:    class X { class X 
Class:      class teste { class teste 
Class:  class nsOggCodecState { class nsOggCodecState 
Class:class nsVorbisState : public nsOggCodecState { class nsVorbisState : public nsOggCodecState 
Class: class ClassInTopLevelNamespace { class ClassInTopLevelNamespace 
Class:  class ClassInAnonymousNamespace {   class ClassInAnonymousNamespace 
Class:class ClassTemplate { class ClassTemplate 
Class: class Base { class Base 
Class: class Derived : public Base { class Derived : public Base 
Class: class Constructor { class Constructor 
Class: class Destructor { class Destructor 
Class: class ContainerForAnonymousRecords { class ContainerForAnonymousRecords 
Class:  class LocalClass {   class LocalClass 
Class:  class MiddleClass   class MiddleClass
Class:    class InnerClass     class InnerClass
Class: template <typename T, template <typename> class Param = NS::ClassTemplate> class ClassWithTemplateTemplateParam { 
Class: class A  : public B, public B1 { class A  : public B, public B1 
Class:  class A { class A 
Class:  class X {   class X 
Class:class __class_type_info : public std::type_info 
Class: class __si_class_type_info : public __class_type_info { class __si_class_type_info : public __class_type_info 
Class: class __vmi_class_type_info : public __class_type_info { class __vmi_class_type_info : public __class_type_info 
Class: template <unsigned N> class T { template <unsigned N> class T 
Class: class C { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 1, u'+static_assert(true, "");'), (6, 1, u'+  static_assert(true, "");')]
===========================================
Class:class A 
Class:class B : public A 
Class:  class C {   class C 
Class:  class basic_fstreamXX  {   class basic_fstreamXX  
Class:  class B {   class B 
Class:template <int i> class A { template <int i> class A 
Class:  class B* g;
Class:class B { class B 
Class:  class X { class X 
Class: class C { class C 
Class:   class A { class A 
Class:class B : public A { class B : public A 
Class:template < class SSS, class = EEE < SSS > >class FFF 
Class:template < class SSS, class GGG = EEE < SSS > >class AAA:FFF <GGG> 
Class:class BBB:virtual CCC { class BBB:virtual CCC 
Class:class ZZZ:AAA < Data >, BBB 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:   class C : public A  {   class C : public A  
Class:   class D : public B,             public C {             public C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 1, u'+  Foo() { static_assert(b, "Foo::Foo used"); }'), (8, 1, u'+  ~Foo() { static_assert(b, "Foo::~Foo used"); }')]
===========================================
Class: class enum_holder { 
Class:class C;
Class:  class Base { class Base 
Class: class Foo : public Base { class Foo : public Base 
Class:    class Foo { class Foo 
Class:  class foo { class foo 
Class:class B : A<int> { class B : A<int> 
Class:  template <class T> class B 
Class:  class Foo {   class Foo 
Class:  class DEFAULT A 
Class:  class DEFAULT foo {   class DEFAULT foo 
Class:  class C {   class C 
Class:    class __attribute__((visibility())) D {     class __attribute__((visibility())) D 
Class:  class HIDDEN A 
Class:  class B : public A 
Class:  class DEFAULT B {   class DEFAULT B 
Class:  class A1 
Class:  class A2 
Class:      class bar {       class bar 
Class:    class bar;
Class:    class zed {     class zed 
Class:  class DEFAULT A;
Class:  class DEFAULT Version 
Class:  class DEFAULT A 
Class:  class C {   class C 
Class:class C0 class C0
Class:class C1  :  virtual public C0 { 
Class:class C2  :  public C0  ,  virtual public C1 { 
Class:class C3  :  virtual public C0  ,  virtual public C1  ,  public C2 { 
Class:class C4  :  public C2  ,  virtual public C3  ,  public C0 { 
Class:class C5  :  public C0  ,  virtual public C4  ,  public C2  ,  public C1  ,  virtual public C3 { 
Class:class C6  :  virtual public C3  ,  public C0  ,  public C5  ,  public C4  ,  public C1 { 
Class:class C7  :  virtual public C5  ,  virtual public C6  ,  virtual public C3  ,  public C4  ,  virtual public C2 { 
Class:class C8  :  public C7  ,  public C5  ,  public C3  ,  virtual public C4  ,  public C1  ,  public C2 { 
Class:                                                                                                                       class C9  :  virtual public C6  ,  public C2  ,  public C4  ,  virtual public C8 { 
Class:class E : virtual D { class E : virtual D 
Class:class C : virtual B 
Class:class D : virtual C 
Class:class E : virtual C 
Class:                               class F : virtual D, virtual E { class F : virtual D, virtual E 
Class:class D : virtual B, virtual C { class D : virtual B, virtual C 
Class:  class B : virtual public A {   class B : virtual public A 
Class:                                                                                           template <typename T> class G { class G 
Class:      template <typename T> class H { class H 
Class:  class A1 
Class:  class A2 
Class:  class V1 : public A1, public A2 
Class:  class B1 
Class:  class B2 
Class:  class V2 : public B1, public B2, public virtual V1 
Class:  class V3 
Class:  class C1 : public virtual V1 
Class:  class C2 : public virtual V3, virtual V2 
Class:  class X1 
Class:  class C3 : public X1 
Class:  class D : public C1, public C2, public C3 
Class:  class A1 
Class:  class A2 
Class:  class V1 : public A1, public virtual A2 
Class:  class B1 
Class:  class B2 
Class:  class V2 : public B1, public B2, public virtual V1 
Class:  class V3 
Class:  class C1 : public virtual V1 
Class:  class C2 : public virtual V3, virtual V2 
Class:  class X1 
Class:  class C3 : public X1 
Class:  class D : public C1, public C2, public C3 
Class: class B : public A { class B : public A 
Class:class T 
Class:class T1 
Class: class C : public T1, public B, public T { class C : public T1, public B, public T 
Class: class V1 : public virtual A { class V1 : public virtual A 
Class: class V2 : public virtual V1 { class V2 : public virtual V1 
Class:          class _Traits = char_traits<_CharT>,           class _Traits = char_traits<_CharT>,
Class: class _LIBCPP_EXCEPTION_ABI exception { 
Class: class _LIBCPP_EXCEPTION_ABI runtime_error     : public exception { 
Class:  class C { class C 
Class:  class A 
Class:  class A {   class A 
Class:  class B : public A 
Class:class C : A 
Class: class C3 { class C3 
Class:  class A { class A 
Class: class B : public A { class B : public A 
Class:  class A 
Class: template <class A> class F1 { class F1 
Class:class AD 
Class:class BD: public AD 
Class:  class Test { class Test 
Class:class Base { class Base 
Class: class Derived final : public Base { class Derived final : public Base 
Class: class Z { class Z 
Class:                         class P { class P 
Class: class Q : public P { class Q : public P 
Class:class MyCls { class MyCls 
Class: class OtherClass : public MyCls { class OtherClass : public MyCls 
Class:  class string { class string 
Class:  class C {   class C 
Class: class Foo { 
Class:class X { class X 
Class:  class Cls { class Cls 
Class:  class C {   class C 
Class:class vector<T*> 
Class:  class A { class A 
Class: class B { class B 
Class: class C : public A, private B { class C : public A, private B 
Class:class D : virtual public C, virtual private A 
Class:  class type_info 
Class:class ClassTmpl 
Class:  template < class _T1, class _T2 > struct pair 
Class:  class IdentifierInfo;
Class:  class AttributeList {   class AttributeList 
Class:class StringRef { class StringRef 
Class:class IdentifierInfo { class IdentifierInfo 
Class:template < typename T, typename R = T > class StringSwitch { template < typename T, typename R = T > class StringSwitch 
Class: class ClsA { class ClsA 
Class:  class ClsB : public ClsA {   class ClsB : public ClsA 
Class:  class ClsC : public foo::ClsB 
Class:  class ClsD : public foo::ClsB {   class ClsD : public foo::ClsB 
Class:class RDar9371763_Foo { class RDar9371763_Foo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(13, 1, u'+  static_assert((unsigned char)\'\xe9\' == 0xE9, ""); // expected-warning {{illegal character encoding in character literal}}'), (14, 1, u'+  static_assert(\'\xe9\xe9\' == 0xE9E9, ""); // expected-warning {{illegal character encoding in character literal}} expected-warning {{multi-character character constant}}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(2, 1, u'+int static_assert; /* expected-error {{expected unqualified-id}} */')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(21, 1, u'+#define static_assert(b, s) int CONCAT(check, __LINE__)[(b) ? 1 : 0];'), (22, 1, u'+static_assert(1 > 0, "hello"); // ok'), (35, 1, u"+int static_assert; // expected-warning {{'static_assert' is a keyword in C++11}}")]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(17, 1, u'+#if __has_extension(c_static_assert)'), (18, 1, u'+int has_c_static_assert();'), (20, 1, u'+int no_c_static_assert();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+#if __has_extension(c_static_assert)'), (5, 1, u'+int c_static_assert();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(13, 1, u'+#if __has_feature(c_static_assert)'), (14, 1, u'+int has_static_assert();'), (16, 1, u'+int no_static_assert();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 1, u'+#if __has_feature(cxx_static_assert)'), (84, 1, u'+int has_static_assert();'), (86, 1, u'+int no_static_assert();')]
===========================================
Class:  class foo 
Class:    class foo;
Class:  class basic_string;
Class:    template <class X, class Y> TClass<X> problematic(X * ptr, const TClass<Y> &src);
Class:     template <class T>     class TBaseClass     {     
Class:    template <class X, class T>     template <class X, class T>
Class:class s 
Class:       class F { class F 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(12, 1, u'+    static_assert(N == 2, "N is not 2!"); // expected-error {{static_assert failed "N is not 2!"}}')]
===========================================
Class: class quux { class quux 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 1, u'+static_assert(D(4).k == 9, "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(14, 1, u'+static_assert(!noexcept(f<false>()), "");'), (15, 1, u'+static_assert(noexcept(f<true>()), "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+static_assert(true_value, "true_value is true");'), (32, 1, u'+static_assert(!false_value, "false_value is false");')]
===========================================
Class:  class C;
Class:    class C;
Class:  class Foo { 
Class:      class BarTypes 
Class:      class BarImpl 
Class:  template <class T> class A { class A 
Class: template <class T> class B { class B 
Class:class Outmost { class Outmost 
Class:    class Inner {     class Inner 
Class:class Callback { class Callback 
Class: class T { class T 
Class: class class_attr { class class_attr 
Class:class COM_CLASS_TEMPLATE  
Class:class COM_CLASS_TEMPLATE_REF  
Class:  class CtorCall { class CtorCall 
Class: template <class A> class C1 { class C1 
Class:class AAAA 
Class:class IF_EXISTS { class IF_EXISTS 
Class:  class IF_EXISTS_CLASS_TEST { class IF_EXISTS_CLASS_TEST 
Class: class inline_definition_pure_spec { class inline_definition_pure_spec 
Class:class A { class A 
Class: class B : public A{ class B : public A
Class:   class tuple<> { 
Class:   class vc__v { class vc__v 
Class: class c_v { class c_v 
Class:  class VectorClassNonPod { 
Class:  class VectorClassMultipleMembers { 
Class:  class c { class c 
Class:  template <class T> class A 
Class:template <class T> class D 
Class:class F 
Class:class C { class C 
Class:   class D { class D 
Class:   class E { class E 
Class: class F { class F 
Class:  class Foo 
Class:   class Ctor {    class Ctor 
Class: template <typename T> class someclass { class someclass 
Class: class asm_class_test { class asm_class_test 
Class: class Class2 { class Class2 
Class:   class C { class C 
Class:  class C { class C 
Class: class A { class A 
Class: class B { class B 
Class:  class Test { class Test 
Class:  class type_info;
Class: class Foo::Bar {  class Foo::Bar 
Class:class A 
Class:  class C {   class C 
Class:  class C;
Class:class [[]] class_attr 
Class:class foo { class foo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+[[]] static_assert(true, ""); //expected-error {{an attribute list cannot appear here}}')]
===========================================
Class: class C { class C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(24, 1, u'+static_assert(true, "foo"_bar); // expected-error {{user-defined suffix cannot be used here}}')]
===========================================
Class: class outer { class outer 
Class:  class inner1 
Class:  class inner2 
Class:  class inner3 
Class:  class inner4 
Class:  class inner5 
Class:  class inner6 
Class:  class inner7 
Class:  class inner8 
Class:  class inner9 
Class:  class inner10 
Class:  class inner11 
Class:  class inner12 
Class:  class inner13 
Class:  class inner14 
Class:  class inner15 
Class:  class inner16 
Class:  class inner17 
Class:  class inner18 
Class:  class inner19 
Class:  class inner20 
Class:  class inner21 
Class:  class inner22 
Class:  class inner23 
Class:  class inner24 
Class:  class inner25 
Class:  class inner26 
Class:  class inner27 
Class:  class inner28 
Class:  class inner29 
Class:  class inner30 
Class:  class inner31 
Class:  class inner32 
Class:  class inner33 
Class:  class inner34 
Class:  class inner35 
Class:  class inner36 
Class:  class inner37 
Class:  class inner38 
Class:  class inner39 
Class:  class inner40 
Class:  class inner41 
Class:  class inner42 
Class:  class inner43 
Class:  class inner44 
Class:  class inner45 
Class:  class inner46 
Class:  class inner47 
Class:  class inner48 
Class:  class inner49 
Class:  class inner50 
Class:  class inner51 
Class:  class inner52 
Class:  class inner53 
Class:  class inner54 
Class:  class inner55 
Class:  class inner56 
Class:  class inner57 
Class:  class inner58 
Class:  class inner59 
Class:  class inner60 
Class:  class inner61 
Class:  class inner62 
Class:  class inner63 
Class:  class inner64 
Class:  class inner65 
Class:  class inner66 
Class:  class inner67 
Class:  class inner68 
Class:  class inner69 
Class:  class inner70 
Class:  class inner71 
Class:  class inner72 
Class:  class inner73 
Class:  class inner74 
Class:  class inner75 
Class:  class inner76 
Class:  class inner77 
Class:  class inner78 
Class:  class inner79 
Class:  class inner80 
Class:  class inner81 
Class:  class inner82 
Class:  class inner83 
Class:  class inner84 
Class:  class inner85 
Class:  class inner86 
Class:  class inner87 
Class:  class inner88 
Class:  class inner89 
Class:  class inner90 
Class:  class inner91 
Class:  class inner92 
Class:  class inner93 
Class:  class inner94 
Class:  class inner95 
Class:  class inner96 
Class:  class inner97 
Class:  class inner98 
Class:  class inner99 
Class:  class inner100 
Class:  class inner101 
Class:  class inner102 
Class:  class inner103 
Class:  class inner104 
Class:  class inner105 
Class:  class inner106 
Class:  class inner107 
Class:  class inner108 
Class:  class inner109 
Class:  class inner110 
Class:  class inner111 
Class:  class inner112 
Class:  class inner113 
Class:  class inner114 
Class:  class inner115 
Class:  class inner116 
Class:  class inner117 
Class:  class inner118 
Class:  class inner119 
Class:  class inner120 
Class:  class inner121 
Class:  class inner122 
Class:  class inner123 
Class:  class inner124 
Class:  class inner125 
Class:  class inner126 
Class:  class inner127 
Class:  class inner128 
Class:  class inner129 
Class:  class inner130 
Class:  class inner131 
Class:  class inner132 
Class:  class inner133 
Class:  class inner134 
Class:  class inner135 
Class:  class inner136 
Class:  class inner137 
Class:  class inner138 
Class:  class inner139 
Class:  class inner140 
Class:  class inner141 
Class:  class inner142 
Class:  class inner143 
Class:  class inner144 
Class:  class inner145 
Class:  class inner146 
Class:  class inner147 
Class:  class inner148 
Class:  class inner149 
Class:  class inner150 
Class:  class inner151 
Class:  class inner152 
Class:  class inner153 
Class:  class inner154 
Class:  class inner155 
Class:  class inner156 
Class:  class inner157 
Class:  class inner158 
Class:  class inner159 
Class:  class inner160 
Class:  class inner161 
Class:  class inner162 
Class:  class inner163 
Class:  class inner164 
Class:  class inner165 
Class:  class inner166 
Class:  class inner167 
Class:  class inner168 
Class:  class inner169 
Class:  class inner170 
Class:  class inner171 
Class:  class inner172 
Class:  class inner173 
Class:  class inner174 
Class:  class inner175 
Class:  class inner176 
Class:  class inner177 
Class:  class inner178 
Class:  class inner179 
Class:  class inner180 
Class:  class inner181 
Class:  class inner182 
Class:  class inner183 
Class:  class inner184 
Class:  class inner185 
Class:  class inner186 
Class:  class inner187 
Class:  class inner188 
Class:  class inner189 
Class:  class inner190 
Class:  class inner191 
Class:  class inner192 
Class:  class inner193 
Class:  class inner194 
Class:  class inner195 
Class:  class inner196 
Class:  class inner197 
Class:  class inner198 
Class:  class inner199 
Class:  class inner200 
Class:  class inner201 
Class:  class inner202 
Class:  class inner203 
Class:  class inner204 
Class:  class inner205 
Class:  class inner206 
Class:  class inner207 
Class:  class inner208 
Class:  class inner209 
Class:  class inner210 
Class:  class inner211 
Class:  class inner212 
Class:  class inner213 
Class:  class inner214 
Class:  class inner215 
Class:  class inner216 
Class:  class inner217 
Class:  class inner218 
Class:  class inner219 
Class:  class inner220 
Class:  class inner221 
Class:  class inner222 
Class:  class inner223 
Class:  class inner224 
Class:  class inner225 
Class:  class inner226 
Class:  class inner227 
Class:  class inner228 
Class:  class inner229 
Class:  class inner230 
Class:  class inner231 
Class:  class inner232 
Class:  class inner233 
Class:  class inner234 
Class:  class inner235 
Class:  class inner236 
Class:  class inner237 
Class:  class inner238 
Class:  class inner239 
Class:  class inner240 
Class:  class inner241 
Class:  class inner242 
Class:  class inner243 
Class:  class inner244 
Class:  class inner245 
Class:  class inner246 
Class:  class inner247 
Class:  class inner248 
Class:  class inner249 
Class:  class inner250 
Class:  class inner251 
Class:  class inner252 
Class:  class inner253 
Class:  class inner254 
Class:  class inner255 
Class:  class inner256 
Class:      class foo{       class foo
Class:  class A { class A 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(72, 1, u'+#define static_assert'), (157, 1, u'+static_assert')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(14, 1, u'+_Static_assert(__alignof(align_big) == __alignof(int), "k\'s alignment is wrong");'), (15, 1, u'+_Static_assert(__alignof(align_small) == 1, "j\'s alignment is wrong");'), (16, 1, u'+_Static_assert(__alignof(align_multiple) == 8, "l\'s alignment is wrong");'), (17, 1, u'+_Static_assert(__alignof(struct align_member) == 8, "quuux\'s alignment is wrong");'), (18, 1, u'+_Static_assert(sizeof(struct align_member) == 8, "quuux\'s size is wrong");'), (19, 1, u'+_Static_assert(__alignof(align_typedef) == 8, "typedef\'s alignment is wrong");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(12, 1, u'+_Static_assert(__GCC_ATOMIC_BOOL_LOCK_FREE == 2, "");'), (13, 1, u'+_Static_assert(__GCC_ATOMIC_CHAR_LOCK_FREE == 2, "");'), (14, 1, u'+_Static_assert(__GCC_ATOMIC_CHAR16_T_LOCK_FREE == 2, "");'), (15, 1, u'+_Static_assert(__GCC_ATOMIC_CHAR32_T_LOCK_FREE == 2, "");'), (16, 1, u'+_Static_assert(__GCC_ATOMIC_WCHAR_T_LOCK_FREE == 2, "");'), (17, 1, u'+_Static_assert(__GCC_ATOMIC_SHORT_LOCK_FREE == 2, "");'), (18, 1, u'+_Static_assert(__GCC_ATOMIC_INT_LOCK_FREE == 2, "");'), (19, 1, u'+_Static_assert(__GCC_ATOMIC_LONG_LOCK_FREE == 2, "");'), (20, 1, u'+_Static_assert(__GCC_ATOMIC_LLONG_LOCK_FREE == 1, "");'), (21, 1, u'+_Static_assert(__GCC_ATOMIC_POINTER_LOCK_FREE == 2, "");'), (23, 1, u'+_Static_assert(__c11_atomic_is_lock_free(1), "");'), (24, 1, u'+_Static_assert(__c11_atomic_is_lock_free(2), "");'), (25, 1, u'+_Static_assert(__c11_atomic_is_lock_free(3), ""); // expected-error {{not an integral constant expression}}'), (26, 1, u'+_Static_assert(__c11_atomic_is_lock_free(4), "");'), (27, 1, u'+_Static_assert(__c11_atomic_is_lock_free(8), "");'), (28, 1, u'+_Static_assert(__c11_atomic_is_lock_free(16), ""); // expected-error {{not an integral constant expression}}'), (29, 1, u'+_Static_assert(__c11_atomic_is_lock_free(17), ""); // expected-error {{not an integral constant expression}}'), (31, 1, u'+_Static_assert(__atomic_is_lock_free(1, 0), "");'), (32, 1, u'+_Static_assert(__atomic_is_lock_free(2, 0), "");'), (33, 1, u'+_Static_assert(__atomic_is_lock_free(3, 0), ""); // expected-error {{not an integral constant expression}}'), (34, 1, u'+_Static_assert(__atomic_is_lock_free(4, 0), "");'), (35, 1, u'+_Static_assert(__atomic_is_lock_free(8, 0), "");'), (36, 1, u'+_Static_assert(__atomic_is_lock_free(16, 0), ""); // expected-error {{not an integral constant expression}}'), (37, 1, u'+_Static_assert(__atomic_is_lock_free(17, 0), ""); // expected-error {{not an integral constant expression}}'), (45, 1, u'+_Static_assert(__atomic_is_lock_free(1, &i8), "");'), (46, 1, u'+_Static_assert(__atomic_is_lock_free(1, &i64), "");'), (47, 1, u'+_Static_assert(__atomic_is_lock_free(2, &i8), ""); // expected-error {{not an integral constant expression}}'), (48, 1, u'+_Static_assert(__atomic_is_lock_free(2, &i16), "");'), (49, 1, u'+_Static_assert(__atomic_is_lock_free(2, &i64), "");'), (50, 1, u'+_Static_assert(__atomic_is_lock_free(4, &i16), ""); // expected-error {{not an integral constant expression}}'), (51, 1, u'+_Static_assert(__atomic_is_lock_free(4, &i32), "");'), (52, 1, u'+_Static_assert(__atomic_is_lock_free(4, &i64), "");'), (53, 1, u'+_Static_assert(__atomic_is_lock_free(8, &i32), ""); // expected-error {{not an integral constant expression}}'), (54, 1, u'+_Static_assert(__atomic_is_lock_free(8, &i64), "");'), (56, 1, u'+_Static_assert(__atomic_always_lock_free(1, 0), "");'), (57, 1, u'+_Static_assert(__atomic_always_lock_free(2, 0), "");'), (58, 1, u'+_Static_assert(!__atomic_always_lock_free(3, 0), "");'), (59, 1, u'+_Static_assert(__atomic_always_lock_free(4, 0), "");'), (60, 1, u'+_Static_assert(__atomic_always_lock_free(8, 0), "");'), (61, 1, u'+_Static_assert(!__atomic_always_lock_free(16, 0), "");'), (62, 1, u'+_Static_assert(!__atomic_always_lock_free(17, 0), "");'), (64, 1, u'+_Static_assert(__atomic_always_lock_free(1, incomplete), "");'), (65, 1, u'+_Static_assert(!__atomic_always_lock_free(2, incomplete), "");'), (66, 1, u'+_Static_assert(!__atomic_always_lock_free(4, incomplete), "");'), (68, 1, u'+_Static_assert(__atomic_always_lock_free(1, &i8), "");'), (69, 1, u'+_Static_assert(__atomic_always_lock_free(1, &i64), "");'), (70, 1, u'+_Static_assert(!__atomic_always_lock_free(2, &i8), "");'), (71, 1, u'+_Static_assert(__atomic_always_lock_free(2, &i16), "");'), (72, 1, u'+_Static_assert(__atomic_always_lock_free(2, &i64), "");'), (73, 1, u'+_Static_assert(!__atomic_always_lock_free(4, &i16), "");'), (74, 1, u'+_Static_assert(__atomic_always_lock_free(4, &i32), "");'), (75, 1, u'+_Static_assert(__atomic_always_lock_free(4, &i64), "");'), (76, 1, u'+_Static_assert(!__atomic_always_lock_free(8, &i32), "");'), (77, 1, u'+_Static_assert(__atomic_always_lock_free(8, &i64), "");')]
===========================================
Class:    Class isa;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 1, u'+#define ASSERT(...) { int arr[(__VA_ARGS__) ? 1 : -1]; }'), (118, 1, u'+#define T(...) ASSERT(__builtin_constant_p(__VA_ARGS__))'), (119, 1, u'+#define F(...) ASSERT(!__builtin_constant_p(__VA_ARGS__))'), (150, 1, u'+  ASSERT(OPT("abc"));'), (151, 1, u'+  ASSERT(!OPT("abcd"));'), (154, 1, u'+  ASSERT(!OPT(test17_c));        // expected-warning {{folded}}'), (155, 1, u'+  ASSERT(!OPT(&test17_c[0]));    // expected-warning {{folded}}'), (156, 1, u'+  ASSERT(!OPT((char*)test17_c)); // expected-warning {{folded}}'), (157, 1, u'+  ASSERT(!OPT(test17_d));        // expected-warning {{folded}}'), (158, 1, u'+  ASSERT(!OPT(&test17_d[0]));    // expected-warning {{folded}}'), (159, 1, u'+  ASSERT(!OPT((char*)test17_d)); // expected-warning {{folded}}')]
===========================================
Class: class A : public B { class A : public B 
Class: class D { class D 
Class: class C : public virtual A,           public D, public B {           public D, public B 
Class:	Class *object;
Class:	Class *obj;
Class:	Class *object;
Class:	Class obj;
Class: class Stream { class Stream 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(3, 1, u'+_Static_assert("foo", "string is nonzero"); // expected-error {{static_assert expression is not an integral constant expression}}'), (5, 1, u'+_Static_assert(1, "1 is nonzero");'), (6, 1, u'+_Static_assert(0, "0 is nonzero"); // expected-error {{static_assert failed "0 is nonzero"}}'), (9, 1, u'+  _Static_assert(1, "1 is nonzero");'), (10, 1, u'+  _Static_assert(0, "0 is nonzero"); // expected-error {{static_assert failed "0 is nonzero"}}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(118, 1, u'+void __myassert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));'), (120, 1, u'+#define myassert(e) \\'), (121, 1, u'+    (__builtin_expect(!(e), 0) ? __myassert_rtn(__func__, __FILE__, __LINE__, #e) : (void)0)'), (123, 1, u'+void test_assert() {'), (124, 1, u'+  myassert(0 && "unreachable");')]
===========================================
Class:class A { class A 
Class: class B : public A { class B : public A 
Class: class C : public B { class C : public B 
Class:class C : private A<T>, public B<U> { class C : private A<T>, public B<U> 
Class: class D { class D 
Class:class A { class A 
Class: class B : public A { class B : public A 
Class:  class AAA { class AAA 
Class:   template <class T> class BB { class BB 
Class:class A { class A 
Class:  class Nested {   class Nested 
Class:  class X {   class X 
Class:    class iterator 
Class:  class hash_map {   class hash_map 
Class:    class const_iterator 
Class:    class iterator 
Class:class C1 
Class:class C2 
Class:class FooTable { class FooTable 
Class:  class C { class C 
Class:class baz { class baz 
Class:  class A <T> ::iterator foo;  
Class:  class bar {   class bar 
Class: class Base { class Base 
Class: class Base { class Base 
Class:  class Derived : public Base { class Derived : public Base 
Class:  template <class _Tp, class _Up, bool = false> struct __allocator_traits_rebind { 
Class:  template <class _Tp, class _Up> struct __allocator_traits_rebind { 
Class: class D : C { class D : C 
Class: class E : D { class E : D 
Class: class F { class F 
Class:   class D {   class D 
Class: class Abstract { class Abstract 
Class:  class foo { class foo 
Class: class bar : public foo { class bar : public foo 
Class:  class A { class A 
Class: class B : public A { class B : public A 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 1, u'+#define static_assert(__b, __m) \\'), (15, 1, u'+static_assert(__is_abstract(C), "C has a pure virtual function");'), (20, 1, u'+static_assert(__is_abstract(D), "D inherits from an abstract class");'), (26, 1, u'+static_assert(!__is_abstract(E), "E inherits from an abstract class but implements f");')]
===========================================
Class:class A 
Class:class B : private A 
Class:class A 
Class:class B : A 
Class:class A 
Class:class B : public A 
Class:class A 
Class:class B : private virtual A 
Class:class C : public virtual A 
Class:class D : public B, public C 
Class:  class A 
Class:   class B : private A {   class B : private A 
Class:  class C;
Class:  class A 
Class:   class B : private A {    class B : private A 
Class:   class C : public B {   class C : public B 
Class:  class A 
Class:  class B : public A 
Class:  class C : private B {   class C : private B 
Class:  class M { class M 
Class: class P { class P 
Class: class N : M,P { class N : M,P 
Class:class A 
Class:class B : private A 
Class:  class C { class C 
Class:    class C; 
Class:    class C 
Class: class T { class T 
Class:  class A {   class A 
Class:    class X; 
Class:    class X 
Class:  class Foo {   class Foo 
Class: class c { class c 
Class: class NonAggr3 {  class NonAggr3 
Class: class Agg { class Agg 
Class: class AggAgg { class AggAgg 
Class:  class C0 {   class C0 
Class:  class C1 {   class C1 
Class:  class C2 {   class C2 
Class:  class C5 {   class C5 
Class:  class C6 {   class C6 
Class:    class c 
Class:  class C0 {   class C0 
Class:  class C1 {   class C1 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 1, u'+  static_assert(alignof(r) == 1, "bad alignment");'), (8, 1, u'+  static_assert(sizeof(r) == 1, "bad size");')]
===========================================
Class:  class y 
Class:  class A {   class A 
Class:  class Foo {   class Foo 
Class:   template <char *sz> class Qux { template <char *sz> class Qux 
Class:  class baz {   class baz 
Class:class Point 
Class:class Line_Segment
Class:class Node 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(21, 1, u'+static_assert(alignof(align_big) == alignof(int), "k\'s alignment is wrong");'), (22, 1, u'+static_assert(alignof(align_small) == 1, "j\'s alignment is wrong");'), (23, 1, u'+static_assert(alignof(align_multiple) == 8, "l\'s alignment is wrong");'), (24, 1, u'+static_assert(alignof(align_member) == 8, "quuux\'s alignment is wrong");'), (25, 1, u'+static_assert(sizeof(align_member) == 8, "quuux\'s size is wrong");'), (26, 1, u'+static_assert(alignof(align_typedef) == 8, "typedef\'s alignment is wrong");'), (27, 1, u'+static_assert(alignof(align_class_template<8>) == 8, "template\'s alignment is wrong");'), (28, 1, u'+static_assert(alignof(align_class_template<16>) == 16, "template\'s alignment is wrong");'), (32, 1, u'+static_assert(alignof(align_alias_template<int>) == 8, "alias template\'s alignment is wrong");')]
===========================================
Class: class A { class A 
Class:  class xpto { class xpto 
Class:  class c { class c 
Class:  class Power {   class Power 
Class:  class C { class C 
Class:  class S { class S 
Class:  class A {   class A 
Class:class A 
Class:class B : A 
Class:class C : virtual A 
Class:class F : virtual E 
Class:class C 
Class:class D 
Class:class B 
Class: class C { class C 
Class:   class NestedC {   class NestedC 
Class: class C2 { class C2 
Class:    class LC1 {     class LC1 
Class:    class LC2 {     class LC2 
Class:  class EnclosingClass {   class EnclosingClass 
Class:  class C {   class C 
Class:class Base 
Class:class Derived1 : public Base 
Class:class Derived2 : public Base 
Class:  class X {   class X 
Class:class complex { class complex 
Class: class complex_wrap : public complex { class complex_wrap : public complex 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(34, 1, u'+static_assert(recurse(5), "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(65, 1, u'+static_assert(q8.check(')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(39, 1, u'+static_assert(test_printing(12, 39.762, 3 + 4i, 12.9 + 3.6i, &u2.arr[4], u2.another.arr[2], (vector_int){5, 1, 2, 3}, u1) == 0, ""); // \\'), (53, 1, u'+static_assert(passLargeArray(v) == 0, ""); // expected-error {{constant expression}} expected-note {{in call to \'passLargeArray({{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...}})\'}}'), (63, 1, u'+static_assert(badness(myUnion), ""); // expected-error {{constant expression}} \\'), (74, 1, u'+static_assert(MemPtr(&MemPtrTest::n, &MemPtrTest::f, mpt.*&MemPtrTest::n), ""); // expected-error {{constant expression}} \\'), (96, 1, u'+  static_assert(mulBy3((LabelDiffTy)&&a-(LabelDiffTy)&&b) == 3, ""); // expected-error {{constant expression}} expected-note {{call to \'mulBy3(&&a - &&b)\'}}')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 1, u'+static_assert(run(bb3, Tape(), 0) == 14, "");'), (55, 1, u'+static_assert(run(bb4, Tape(), 0) == 108, "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(19, 1, u'+static_assert(b2.a.a == 1, "");'), (20, 1, u'+static_assert(b2.a.b == 2, "");'), (30, 1, u'+static_assert(D().c == 0, "");'), (31, 1, u'+static_assert(D().d == 0, "");')]
===========================================
Class: class A { class A 
Class: class B : public A { class B : public A 
Class:  class C : public virtual B { class C : public virtual B 
Class: class D : public C { class D : public C 
Class: class E : public D, public B { class E : public D, public B 
Class: class F : public B { class F : public B 
Class: class G : A { class G : A 
Class: class H : A { class H : A 
Class:class  X 
Class:class Y 
Class: class U { class U 
Class:class TwoInOne 
Class:class InitializeUsingSelfTest { class InitializeUsingSelfTest 
Class:class InitializeUsingSelfExceptions { class InitializeUsingSelfExceptions 
Class: class CopyConstructorTest { class CopyConstructorTest 
Class:  class A : public std::exception 
Class:  class B : public A {   class B : public A 
Class:  class Class   class Class
Class: class Foo { class Foo 
Class:class a { class a 
Class: class X { class X 
Class: class Y { class Y 
Class: class Z { class Z 
Class:class A 
Class: class B : public A { class B : public A 
Class:  class XB { class XB 
Class: class Yb : public XB { class Yb : public XB 
Class:class AutoPtrRef 
Class: class AutoPtr { class AutoPtr 
Class:  class Y {   class Y 
Class:    class YRef 
Class:class Z 
Class: class Y { class Y 
Class: class X { class X 
Class:  class FromShort { class FromShort 
Class: class FromShortExplicitly {  class FromShortExplicitly 
Class: class X { class X 
Class:class Y : public X 
Class:  class Bar;
Class:class callback class callback
Class:  class InfallibleTArray {   class InfallibleTArray 
Class:  class CompVariant {   class CompVariant 
Class:  class Variant {   class Variant 
Class: class C { class C 
Class:  class Foo;
Class:  class Foo {   class Foo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+static_assert(__is_trivial(foo), "foo should be trivial");'), (33, 1, u'+static_assert(!__has_trivial_destructor(bar), "bar\'s destructor isn\'t trivial");'), (34, 1, u'+static_assert(!__has_trivial_constructor(bar),'), (36, 1, u'+static_assert(!__has_trivial_copy(bar), "bar has no trivial copy");'), (37, 1, u'+static_assert(!__has_trivial_assign(bar), "bar has no trivial assign");')]
===========================================
Class: class inaccessible_default { class inaccessible_default 
Class: class friend_default { class friend_default 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 1, u'+    static_assert(sizeof(overloaded({1, 2})) == sizeof(one), "bad overload");'), (68, 1, u'+    static_assert(sizeof(overloaded({1, "two"})) == sizeof(two),'), (71, 1, u'+    static_assert(sizeof(overloaded({1})) == sizeof(one), "bad overload");')]
===========================================
Class:  class initializer_list   class initializer_list
Class:  class ArrayRef; 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+    static_assert(sizeof(arrayRef) == 3 * sizeof(int), "bad array size");'), (61, 1, u'+    static_assert(sizeof(f({1})) == sizeof(one), "bad overload resolution");'), (66, 1, u'+    static_assert(sizeof(g({1})) == sizeof(two), "bad overload resolution");'), (71, 1, u'+    static_assert(sizeof(h({1, 2})) == sizeof(two), "bad overload resolution");')]
===========================================
Class:  class initializer_list   class initializer_list
Class:  class initializer_list   class initializer_list
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(22, 1, u'+static_assert(\'x\'_kind == LitKind::Char, "");'), (23, 1, u'+static_assert(L\'x\'_kind == LitKind::WideChar, "");'), (24, 1, u'+static_assert(u\'x\'_kind == LitKind::Char16, "");'), (25, 1, u'+static_assert(U\'x\'_kind == LitKind::Char32, "");'), (26, 1, u'+static_assert("foo"_kind == LitKind::CharStr, "");'), (27, 1, u'+static_assert(u8"foo"_kind == LitKind::CharStr, "");'), (28, 1, u'+static_assert(L"foo"_kind == LitKind::WideStr, "");'), (29, 1, u'+static_assert(u"foo"_kind == LitKind::Char16Str, "");'), (30, 1, u'+static_assert(U"foo"_kind == LitKind::Char32Str, "");'), (31, 1, u'+static_assert(194_kind == LitKind::Integer, "");'), (32, 1, u'+static_assert(0377_kind == LitKind::Integer, "");'), (33, 1, u'+static_assert(0x5ffc_kind == LitKind::Integer, "");'), (34, 1, u'+static_assert(.5954_kind == LitKind::Floating, "");'), (35, 1, u'+static_assert(1._kind == LitKind::Floating, "");'), (36, 1, u'+static_assert(1.e-2_kind == LitKind::Floating, "");'), (37, 1, u'+static_assert(4e6_kind == LitKind::Floating, "");'), (38, 1, u'+static_assert(4e6_kind2 == LitKind::Raw, "");'), (39, 1, u'+static_assert(4e6_kind3 == LitKind::Template, "");'), (51, 1, u'+static_assert(streq(143.97_fractional_digits, "97"), "");'), (52, 1, u'+static_assert(streq(0x786_fractional_digits, "0x786"), "");'), (53, 1, u'+static_assert(streq(.4_fractional_digits, "4"), "");'), (54, 1, u'+static_assert(streq(4._fractional_digits, ""), "");'), (55, 1, u'+static_assert(streq(1e+97_fractional_digits, "1e+97"), "");'), (56, 1, u'+static_assert(streq(0377_fractional_digits, "0377"), "");'), (57, 1, u'+static_assert(streq(0377.5_fractional_digits, "5"), "");'), (127, 1, u'+static_assert(0x1234_hash == 0x103eff5e, "");'), (128, 1, u'+static_assert(hash<\'0\', \'x\', \'1\', \'2\', \'3\', \'4\'>(0) == 0x103eff5e, "");')]
===========================================
Class:class Variadic1 
Class:class Variadic2 
Class:class Variadic3 
Class: class PrivateMember { class PrivateMember 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(115, 1, u'+static_assert(true, "!"); // expected-warning {{static_assert declarations are incompatible with C++98}}')]
===========================================
Class:class C7 
Class:class C 
Class: class B : public BASE , public BASE1 { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(12, 1, u'+  void f() { static_assert(is_same<decltype(this), S*>::value, ""); }'), (13, 1, u'+  void g() const { static_assert(is_same<decltype(this), const S*>::value, ""); }'), (14, 1, u'+  void h() volatile { static_assert(is_same<decltype(this), volatile S*>::value, ""); }'), (15, 1, u'+  void i() const volatile { static_assert(is_same<decltype(this), const volatile S*>::value, ""); }')]
===========================================
Class:  class A{   class A
Class:   class foo { class foo 
Class:  class Base {  class Base 
Class: class X  : Base {   class X  : Base 
Class:class Z : Y 
Class:class T 
Class:  class V { class V 
Class:class W : V 
Class:   class B1 { class B1 
Class:class D1 : B1 
Class:   class E1 {  class E1 
Class: class X { class X 
Class:  class C { class C 
Class:    class Z { class Z 
Class:  class C2 { class C2 
Class:  class XX { class XX 
Class:  class BadDtor { class BadDtor 
Class: class K : BadDtor { class K : BadDtor 
Class:class A 
Class:class B : public A 
Class:class C : public A 
Class:class D : public B, public C 
Class:class Object2 
Class:class A2 : public Object2 
Class:class B2 : public virtual A2 
Class:class C2 : virtual public A2 
Class:class D2 : public B2, public C2 
Class:class E2 : public D2, public C2, public virtual A2 
Class:class F2 : public E2, public A2 
Class: class A { class A 
Class: class B { class B 
Class: class C { class C 
Class:  class T; 
Class:   class QGenericArgument    {   
Class:  template <class T> class A {   template <class T> class A 
Class:  class B : A<int> 
Class:class simple_ptr { class simple_ptr 
Class: template <typename T> class simple_ptr2 { class simple_ptr2 
Class:  class B 
Class:  class C : virtual B 
Class: class Y { class Y 
Class: class X {  class X 
Class: class Z {  class Z 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 1, u'+static_assert(icd1.get<int>() == 4, "");'), (107, 1, u'+static_assert(icd2.get<char>() == \'x\', "");'), (108, 1, u'+static_assert(icd3.get<double>() == 6.5, "");'), (117, 1, u'+static_assert(icd4.get<const icd*>()->get<char>() == \'x\', "");'), (118, 1, u'+static_assert(icd5.get<non_triv>().n == 5, "");')]
===========================================
Class:  class X {   class X 
Class:class B 
Class:class C : A, virtual B 
Class:class F : D, E 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(14, 1, u'+static_assert(sizeof(E1) == sizeof(int), "bad size");'), (15, 1, u'+static_assert(sizeof(E1::Val1) == sizeof(int), "bad size");'), (16, 1, u'+static_assert(sizeof(E2) == sizeof(int), "bad size");'), (17, 1, u'+static_assert(sizeof(E2::Val1) == sizeof(int), "bad size");'), (29, 1, u'+static_assert(sizeof(E3) == 1, "bad size");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(20, 1, u'+static_assert(S<char>().f() == 1, "");'), (21, 1, u'+static_assert(S<int>().f() == 1, "");'), (26, 1, u'+static_assert(S<char>().g() == 1, ""); // expected-note {{here}} expected-error {{not an integral constant expression}} expected-note {{undefined}}'), (27, 1, u'+static_assert(S<short>().g() == 2, "");'), (28, 1, u'+static_assert(S<long>().g() == 8, "");'), (34, 1, u'+  static_assert(b != 8, "");'), (35, 1, u'+  static_assert(sizeof(c) != 8, "");')]
===========================================
Class:  template <class A, class B> struct is_same 
Class:  class foo { class foo 
Class:    class Y 
Class:   template <class Key, class T> struct QMap { 
Class:  template <class Key, class T> void QMap<Key, T>::insert(const Key &, const T &avalue) { 
Class: class A { class A 
Class:  class value_range_iter {   class value_range_iter 
Class:  class vector {   class vector 
Class:  class A {   class A 
Class:  class Foo { class Foo 
Class:      class A { class A 
Class:  class X;
Class: class N::X { class N::X 
Class:class C 
Class:class D 
Class:  class Bar {   class Bar 
Class:  class Foo {   class Foo 
Class:  class T4A {   class T4A 
Class:  class T4B 
Class:  class A {   class A 
Class:  class vectorA {   class vectorA 
Class:  class vector {   class vector 
Class:  class A {   class A 
Class:  class vector {   class vector 
Class:  class A {   class A 
Class:    class X {     class X 
Class:  class A { class A 
Class: class A { class A 
Class:    class A {     class A 
Class:  class Inner 
Class: class Crash { class Crash 
Class:                                        class TestConst { class TestConst 
Class: class C { class C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(13, 1, u'+static_assert(A<int>::id == 1, "fail");'), (14, 1, u'+static_assert(A<float>::id == 2, "fail");'), (15, 1, u'+static_assert(A<double, double>::id == 3, "fail");'), (44, 1, u'+static_assert(TypeMask<int, long, short>::result == 7, "fail");'), (45, 1, u'+static_assert(TypeMask<float, short>::result == 12, "fail");'), (46, 1, u'+static_assert(TypeMask<int, float, float>::result == 9, "fail");')]
===========================================
Class: class X { class X 
Class:  class Foo {   class Foo 
Class:  class A 
Class:   class B {   class B 
Class:class A 
Class:class B1 : A 
Class:class B2 : virtual A 
Class:class B3 : virtual virtual A 
Class:class C : public B1, private B2 
Class:class E : public D 
Class:class F : public I 
Class:class G : public U2 
Class:  class Two { class Two 
Class:  template <typename T> class SmallVectorImpl  { class SmallVectorImpl  
Class: template <typename T, unsigned N> class SmallVector : public SmallVectorImpl<T> { class SmallVector : public SmallVectorImpl<T> 
Class:class InlineFunctionInfo { class InlineFunctionInfo 
Class:class X 
Class:  template <class A, class B> struct pair 
Class:    class iterator 
Class:template <class X> class Y { template <class X> class Y 
Class:  class C {   class C 
Class:class NonAggregate 
Class: class HasConstExprCtor { class HasConstExprCtor 
Class:template <typename T> class HasConstExprCtorTemplate { template <typename T> class HasConstExprCtorTemplate 
Class:template <typename T> class HasConstExprCtorT { template <typename T> class HasConstExprCtorT 
Class:  class String;
Class: class _IOConfigThread { class _IOConfigThread 
Class:  class X{ class X
Class:  class X {   class X 
Class:   class Y : public X {   class Y : public X 
Class:class NoWarning { class NoWarning 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+static_assert(!noexcept(Throw()), "incorrect exception specification");'), (44, 1, u'+static_assert(noexcept(NoThrow()), "incorrect exception specification");')]
===========================================
Class:  class A { class A 
Class:  class X { class X 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(12, 1, u'+  typedef int assert1[sizeof(dataMember) == sizeof(ptrdiff_t) ? 1 : -1];'), (13, 1, u'+  typedef int assert2[sizeof(memberFunction) == sizeof(ptrdiff_t) * 2 ? 1 : -1];')]
===========================================
Class:  template <class F, class T> void bindmem(F (T::*f)()); 
Class:   template <class T> class B {   template <class T> class B 
Class:class AnalysisDeclContext 
Class:    class C 
Class:  class B 
Class:  class dummy {    class dummy 
Class:    class myvector 
Class:    class mylinkedlist 
Class:  class linkedlist 
Class:class Message 
Class:  class C1;
Class:  class C1;
Class:    class C2;
Class:    class C2;
Class:class B 
Class:  class D 
Class: class C2 { class C2 
Class:  class Operators { class Operators 
Class: template <typename T> class foo { class foo 
Class:    class Counter 
Class:   class Test {   class Test 
Class:  class A; 
Class:    class Foo;
Class:  class B 
Class:   class A {   class A 
Class:  class A 
Class:  class X3 { class X3 
Class: class X4 { class X4 
Class: class X5 { class X5 
Class: class Base { class Base 
Class:class Tier 
Class:class Comp : public Tier 
Class: class Thai : public Base { class Thai : public Base 
Class: class X6 { class X6 
Class: class X7 { class X7 
Class: class X8 : public X6, public X7 { class X8 : public X6, public X7 
Class: class X9 { class X9 
Class: class X14 { class X14 
Class: class X15 { class X15 
Class:class S2 { class S2 
Class:  class Bar 
Class:  class Bar2 
Class:   class MessageLoop {   class MessageLoop 
Class:  template <class CookieStoreTestTraits>   class CookieStoreTest {   class CookieStoreTest 
Class:  class DeferredCookieTaskTest : public CookieStoreTest<CookieMonsterTestTraits>   {   
Class:  class Foo {   class Foo 
Class:  class X;
Class:  class X;
Class:    class C1 
Class:class X 
Class: class A { class A 
Class:class B : public A 
Class:class C : public B 
Class:class A 
Class:class B : public A 
Class:class C : public B 
Class:class D : public C 
Class:class string 
Class:class opt : public string 
Class:  class qrgb666 {   class qrgb666 
Class:  class A;
Class:  class B {   class B 
Class:  class A 
Class:  class B : public A 
Class:  class A {   class A 
Class: class X { class X 
Class:  class A {   class A 
Class:  class C { class C 
Class:  class X {   class X 
Class:class X 
Class:   class pr5244_foo { 
Class: class pr5244_baz { 
Class:class RegAlloc { class RegAlloc 
Class:class StringRef { class StringRef 
Class:class A 
Class:class B : virtual A 
Class:class C : B 
Class:class F : virtual A, virtual C 
Class:  class X0 
Class:  template <typename T> class ClassChecker {   template <typename T> class ClassChecker 
Class:    class X {     class X 
Class:   class Z {   class Z 
Class: class Test6 {  class Test6 
Class:  class string { class string 
Class:class A;
Class:  class B 
Class:  class Test   class Test
Class:  class type_info;
Class:class Poly 
Class:class A 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(5, 1, u'+static_assert(f(), "f"); // expected-error {{static_assert expression is not an integral constant expression}} expected-note {{non-constexpr function \'f\' cannot be used in a constant expression}}'), (6, 1, u'+static_assert(true, "true is not false");'), (7, 1, u'+static_assert(false, "false is false"); // expected-error {{static_assert failed "false is false"}}'), (10, 1, u'+    static_assert(false, "false is false"); // expected-error {{static_assert failed "false is false"}}'), (14, 1, u'+    static_assert(false, "false is false"); // expected-error {{static_assert failed "false is false"}}'), (18, 1, u'+    static_assert(N == 2, "N is not 2!"); // expected-error {{static_assert failed "N is not 2!"}}'), (25, 1, u'+    static_assert(sizeof(T) > sizeof(char), "Type not big enough!"); // expected-error {{static_assert failed "Type not big enough!"}}'), (31, 1, u'+static_assert(false, L"\\xFFFFFFFF"); // expected-error {{static_assert failed L"\\xFFFFFFFF"}}'), (32, 1, u'+static_assert(false, u"\\U000317FF"); // expected-error {{static_assert failed u"\\U000317FF"}}'), (34, 1, u'+static_assert(false, u8"\xce\xa9"); // expected-error {{static_assert failed u8"\\316\\251"}}'), (35, 1, u'+static_assert(false, L"\\u1234"); // expected-error {{static_assert failed L"\\x1234"}}'), (36, 1, u'+static_assert(false, L"\\x1ff" "0\\x123" "fx\\xfffff" "goop"); // expected-error {{static_assert failed L"\\x1FF""0\\x123""fx\\xFFFFFgoop"}}')]
===========================================
Class:class C 
Class:class D 
Class:class E 
Class:  class Point;
Class: class Test { 
Class: class C { class C 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(11, 1, u'+        static_assert(sizeof(U) == 0, "expected type failure");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+static_assert(__has_trivial_constructor(T1), "T1 has trivial constructor!");'), (9, 1, u'+static_assert(!__has_trivial_constructor(T2), "T2 has a user-declared constructor!");'), (14, 1, u'+static_assert(!__has_trivial_constructor(T3), "T3 has a virtual function!");'), (18, 1, u'+static_assert(!__has_trivial_constructor(T4), "T4 has a virtual base class!");'), (22, 1, u'+static_assert(__has_trivial_constructor(T5), "All the direct base classes of T5 have trivial constructors!");'), (29, 1, u'+static_assert(__has_trivial_constructor(T6), "All nonstatic data members of T6 have trivial constructors!");'), (34, 1, u'+static_assert(!__has_trivial_constructor(T7), "t4 does not have a trivial constructor!");'), (38, 1, u'+static_assert(!__has_trivial_constructor(T8), "The base class T2 does not have a trivial constructor!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+static_assert(__has_trivial_destructor(T1), "T1 has trivial destructor!");'), (9, 1, u'+static_assert(!__has_trivial_destructor(T2), "T2 has a user-declared destructor!");'), (14, 1, u'+static_assert(__has_trivial_destructor(T3), "T3 has a virtual function (but still a trivial destructor)!");'), (18, 1, u'+static_assert(__has_trivial_destructor(T4), "T4 has a virtual base class! (but still a trivial destructor)!");'), (22, 1, u'+static_assert(__has_trivial_destructor(T5), "All the direct base classes of T5 have trivial destructors!");'), (29, 1, u'+static_assert(__has_trivial_destructor(T6), "All nonstatic data members of T6 have trivial destructors!");'), (34, 1, u'+static_assert(!__has_trivial_destructor(T7), "t2 does not have a trivial destructor!");'), (38, 1, u'+static_assert(!__has_trivial_destructor(T8), "The base class T2 does not have a trivial destructor!");')]
===========================================
Class: class X { class X 
Class:class Statics 
Class:class  HasPriv 
Class:class  HasProt 
Class: class AllPrivate { class AllPrivate 
Class: class PR11110 { class PR11110 
Class: class UsingAssignBase { class UsingAssignBase 
Class: class UsingAssign : public UsingAssignBase { class UsingAssign : public UsingAssignBase 
Class:class Base 
Class:class Derived : Base 
Class:class Derived2a : Derived 
Class:class Derived2b : Derived 
Class:class Derived3 : virtual Derived2a, virtual Derived2b 
Class:template <class T> class DerivedTemp : Base 
Class:template <class T> class NonderivedTemp 
Class:class TemplateClass 
Class:class PrivateCopy { class PrivateCopy 
Class:  class type_info;
Class:  class type_info;
Class: class error_condition { 
Class:class some_name 
Class:  class string 
Class:  class StreamOut 
Class:class Message 
Class:    class Parent { class Parent 
Class:class Child: public Parent 
Class:class ConstructExpr 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(18, 1, u'+static_assert(is_same_type<char, __underlying_type(f)>::value,'), (22, 1, u'+static_assert(is_same_type<int, __underlying_type(g)>::value,'), (26, 1, u'+static_assert(is_same_type<char, decltype(h)>::value,'), (34, 1, u'+static_assert(is_same_type<underlying_type<f>::type, char>::value,'), (42, 1, u'+static_assert(is_same_type<underlying_type<foo>::type, unsigned>::value,')]
===========================================
Class:  class Foo { class Foo 
Class:  class Rdar9188004A { class Rdar9188004A 
Class:class Rdar9188004C : public Rdar9188004B<Rdar9188004A> { class Rdar9188004C : public Rdar9188004B<Rdar9188004A> 
Class:   class A { class A 
Class:  class FooBase 
Class:  class Foo : public FooBase {   class Foo : public FooBase 
Class:  template <typename T> class FooImpl : public Foo {   template <typename T> class FooImpl : public Foo 
Class:class BaseEx 
Class:class Ex1: public BaseEx 
Class:   class PR6130 { class PR6130 
Class:  class APInt { class APInt 
Class:class APSInt : public APInt { class APSInt : public APInt 
Class:  class A {   class A 
Class:class C : B 
Class:    class Foo 
Class:  class B : A {   class B : A 
Class:  class Class1; 
Class:  class Class2   {   
Class:  class Base {   class Base 
Class:   template <typename T>   class Derived : public Base<T> {   class Derived : public Base<T> 
Class:  class K1 {   class K1 
Class: class X {  class X 
Class:  template <unsigned I> class C0 { class C0 
Class: class C { class C 
Class: class D { class D 
Class: class E { class E 
Class:  class Foo { class Foo 
Class:  class type_info 
Class:class NoDestroy 
Class:class A { class A 
Class: class B : A { class B : A 
Class:class A { class A 
Class: class B : A { class B : A 
Class:class A { class A 
Class: class B : A { class B : A 
Class:class A { class A 
Class: class B : A { class B : A 
Class:class A { class A 
Class: class B : A { class B : A 
Class:class A { class A 
Class: class B : A { class B : A 
Class:  class A {   class A 
Class:   class B : A {   class B : A 
Class:  class A {   class A 
Class:   class B : A {   class B : A 
Class:  class A {   class A 
Class:   class B : A {   class B : A 
Class:class X1 : public X0 { class X1 : public X0 
Class:  class Base 
Class:  class Derived : public Base 
Class:   class Foo {   class Foo 
Class:   class Bar : public Foo {   class Bar : public Foo 
Class:  class Base 
Class:  class Derived : public Base 
Class:  class X 
Class:  class X1 : public X 
Class:  class A {   class A 
Class:   class B : public A {   class B : public A 
Class:  class A { class A 
Class: class B : public A { class B : public A 
Class:  class Target   class Target
Class: class C1 { class C1 
Class:    class PR12271 { class PR12271 
Class: template <class Dest, class Source> inline Dest bit_cast(const Source& source) { inline Dest bit_cast(const Source& source) 
Class:  class I { class I 
Class:class Test { class Test 
Class:class A { class A 
Class: class B : public A { class B : public A 
Class: class complex : public BB, BB1 { class complex : public BB, BB1 
Class: class Anon { class Anon 
Class:class Anon2 { class Anon2 
Class:class Anon3 { class Anon3 
Class:  class A {   class A 
Class: class A { class A 
Class:  class B : A { class B : A 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(5, 1, u'+void assert(bool condition);'), (10, 1, u'+  assert("error"); // expected-warning{{implicit conversion turns string literal into bool: \'const char [6]\' to \'bool\'}}'), (11, 1, u'+  assert(0 && "error");')]
===========================================
Class: class __attribute__((scoped_lockable)) MutexLock { class __attribute__((scoped_lockable)) MutexLock 
Class: class __attribute__((scoped_lockable)) ReaderMutexLock { class __attribute__((scoped_lockable)) ReaderMutexLock 
Class: class MutexWrapper { class MutexWrapper 
Class: class GlobalLocker { class GlobalLocker 
Class:  class WeirdMethods { class WeirdMethods 
Class: class PGBFoo { class PGBFoo 
Class: class GBFoo { class GBFoo 
Class:     class LateFoo { class LateFoo 
Class: class LateBar { class LateBar 
Class:  class LRBar { class LRBar 
Class: class LRFoo { class LRFoo 
Class:class Bar { class Bar 
Class:class Bar { class Bar 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class: class FooBar { class FooBar 
Class:class Foo { class Foo 
Class: class Bar { class Bar 
Class:class Foo { class Foo 
Class:class Bar { class Bar 
Class: template <typename T> class Foo { class Foo 
Class:class Bar { class Bar 
Class:  class FooBar {   class FooBar 
Class:class Base { class Base 
Class: class Child : public Base { class Child : public Base 
Class:class Foo { class Foo 
Class:  class Bar {   class Bar 
Class:class Bar { class Bar 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:class Base { class Base 
Class: class Child : public Base { class Child : public Base 
Class:class Foo { class Foo 
Class:  class MyData  {   class MyData  
Class:    class DataLocker {   class DataLocker 
Class:    class Foo {   class Foo 
Class:  class Foo {   class Foo 
Class:class LOCKABLE MyLockable { class LOCKABLE MyLockable 
Class:class Foo { class Foo 
Class:class Foo1 { class Foo1 
Class: class Foo2 { class Foo2 
Class:  class Bar { class Bar 
Class:  template <class T> class BarT { class BarT 
Class: template <class T> class Cell { class Cell 
Class:  template <class T> class CellDelayed { class CellDelayed 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:class LOCKABLE MyLock { class LOCKABLE MyLock 
Class:  class LOCKABLE MyLock2 { class LOCKABLE MyLock2 
Class:class Foo;
Class: class Foo { class Foo 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class: class Bar { class Bar 
Class: class UnlockableMu{ class UnlockableMu
Class: class MuWrapper { class MuWrapper 
Class:  class MuDoubleWrapper { class MuDoubleWrapper 
Class:     class Foo { class Foo 
Class: class Foo2 { class Foo2 
Class: class Bar { class Bar 
Class:    class NoanalFoo { class NoanalFoo 
Class: class __attribute__((no_thread_safety_analysis)) NoanalTestClass {  class __attribute__((no_thread_safety_analysis)) NoanalTestClass 
Class:    class GVFoo { class GVFoo 
Class: class __attribute__((guarded_var)) GV {  class __attribute__((guarded_var)) GV 
Class:      class PGVFoo { class PGVFoo 
Class: class __attribute__((pt_guarded_var)) PGV {  class __attribute__((pt_guarded_var)) PGV 
Class: class __attribute__((lockable (1))) LTestClass_args {  class __attribute__((lockable (1))) LTestClass_args 
Class:    class LFoo { class LFoo 
Class: class __attribute__((scoped_lockable (1))) SLTestClass_args {  class __attribute__((scoped_lockable (1))) SLTestClass_args 
Class:    class SLFoo { class SLFoo 
Class:    class GBFoo { class GBFoo 
Class: class __attribute__((guarded_by(mu1))) GB {  class __attribute__((guarded_by(mu1))) GB 
Class:    class PGBFoo { class PGBFoo 
Class: class __attribute__((pt_guarded_by(mu1))) PGB {  class __attribute__((pt_guarded_by(mu1))) PGB 
Class:    class AAFoo { class AAFoo 
Class: class __attribute__((acquired_after(mu1))) AA {  class __attribute__((acquired_after(mu1))) AA 
Class:    class ABFoo { class ABFoo 
Class: class __attribute__((acquired_before(mu1))) AB {  class __attribute__((acquired_before(mu1))) AB 
Class:    class ElfFoo { class ElfFoo 
Class: class __attribute__((exclusive_lock_function)) ElfTestClass {  class __attribute__((exclusive_lock_function)) ElfTestClass 
Class:    class SlfFoo { class SlfFoo 
Class: class __attribute__((shared_lock_function)) SlfTestClass {  class __attribute__((shared_lock_function)) SlfTestClass 
Class:    class EtfFoo { class EtfFoo 
Class: class __attribute__((exclusive_trylock_function(1))) EtfTestClass {  class __attribute__((exclusive_trylock_function(1))) EtfTestClass 
Class:     class StfFoo { class StfFoo 
Class: class __attribute__((shared_trylock_function(1))) StfTestClass {  class __attribute__((shared_trylock_function(1))) StfTestClass 
Class:    class UfFoo { class UfFoo 
Class: class __attribute__((no_thread_safety_analysis)) UfTestClass {  class __attribute__((no_thread_safety_analysis)) UfTestClass 
Class:    class LrFoo { class LrFoo 
Class: class __attribute__((lock_returned(mu1))) LrTestClass {  class __attribute__((lock_returned(mu1))) LrTestClass 
Class:    class LeFoo { class LeFoo 
Class: class __attribute__((locks_excluded(mu1))) LeTestClass {  class __attribute__((locks_excluded(mu1))) LeTestClass 
Class:    class ElrFoo { class ElrFoo 
Class: class __attribute__((exclusive_locks_required(mu1))) ElrTestClass {  class __attribute__((exclusive_locks_required(mu1))) ElrTestClass 
Class:    class SlrFoo { class SlrFoo 
Class: class __attribute__((shared_locks_required(mu1))) SlrTestClass {  class __attribute__((shared_locks_required(mu1))) SlrTestClass 
Class:  class UnFoo { class UnFoo 
Class: class StaticMu { class StaticMu 
Class: class FooLate { class FooLate 
Class:     class __attribute__((lockable)) EmptyArgListsTest { class __attribute__((lockable)) EmptyArgListsTest 
Class:class Foo { class Foo 
Class: template <class T> class Bar { class Bar 
Class:class Foo { class Foo 
Class:class Foo { class Foo 
Class:  class Bar {   class Bar 
Class:  class X   class X
Class:  class Box {   class Box 
Class:  class Parent { class Parent 
Class: class Derived : public Parent { class Derived : public Parent 
Class: class VeryDerived : public Derived {  class VeryDerived : public Derived 
Class:   class Foo { class Foo 
Class: class Bar { class Bar 
Class:  class Base {   class Base 
Class:   template <class ParentClass>   class Derived : public ParentClass {   class Derived : public ParentClass 
Class:   class Final : public Derived<Base> {   class Final : public Derived<Base> 
Class: class X { class X 
Class:  template <unsigned, class _Tp> class tuple_element;
Class:   template <class _T1, class _T2>   class tuple_element<0, pair<_T1, _T2> >   {   
Class:  class B : public A<int> 
Class:class C1 : public N::A<int> 
Class:class C2 : public N::A<float> 
Class:class Wibble<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 1, u'+  static_assert(w == 1, "");'), (32, 1, u'+  static_assert(sizeof(arr) == \'x\', "");'), (76, 1, u'+  static_assert(n == 5, "");')]
===========================================
Class:  class wxObject;
Class:  class __attribute__ ((visibility())) wxGDIObject : public wxObject { \   class __attribute__ ((visibility())) wxGDIObject : public wxObject 
Class:  class Class {   class Class 
Class:  class X0  {   class X0  
Class:    class Inner1;
Class:     class Inner2  {     class Inner2  
Class:  class X {   class X 
Class:  class X<XT>::Inner 
Class:  class Bar {   class Bar 
Class:  class bar {   class bar 
Class:class C 
Class:  class ExternallyImplementedClass;
Class:   class MyClass {   class MyClass 
Class:  class string   class string
Class:    class Nested 
Class:      class HasDepBase::Nested nested;
Class:      class NoDepBase::Nested nested; 
Class:  class B : public A<T>   class B : public A<T>
Class:  class Base_B 
Class:  class A1 { class A1 
Class:class A2 
Class:template <class C> class B2 { template <class C> class B2 
Class:template <class C> class B3 { template <class C> class B3 
Class:  class A : public T::type   class A : public T::type
Class:  class A {   class A 
Class:  class A   class A
Class:  template <typename T> class chained_map {   template <typename T> class chained_map 
Class:  template <class T> class Base {   template <class T> class Base 
Class:    class Inner {     class Inner 
Class:   template <class T> class Derived1 : Base<T> {   template <class T> class Derived1 : Base<T> 
Class:   template <class T> class Derived2 : Base<T>::Inner {   template <class T> class Derived2 : Base<T>::Inner 
Class:  class MyClassCore   class MyClassCore
Class:   template <class T>   class MyClass : public MyClassCore<T>   {   
Class:  class B {   class B 
Class:  class D {   class D 
Class:    class X 
Class:    class T::bar;  
Class:    class T::bar 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 1, u'+  assert(di.size() == 5);'), (136, 1, u'+    assert(*I == I - di.begin());'), (139, 1, u'+    assert(di[I] == I);'), (142, 1, u'+  assert(di.size() == 4);'), (146, 1, u'+  assert(di2.size() == 5);'), (147, 1, u'+  assert(di.begin() != di2.begin());'), (150, 1, u'+    assert(*I == I - di2.begin());'), (153, 1, u'+  assert(di3.size() == 5);'), (154, 1, u'+  assert(di.begin() != di3.begin());'), (157, 1, u'+    assert(*I == I - di3.begin());'), (160, 1, u'+  assert(di4.size() == 0);'), (162, 1, u'+  assert(di4.size() == 5);'), (163, 1, u'+  assert(di.begin() != di4.begin());'), (166, 1, u'+    assert(*I == I - di4.begin());'), (168, 1, u'+  assert(di4 == di);'), (170, 1, u'+  assert(di4 != di);'), (174, 1, u'+  assert(dp.size() == 1);')]
===========================================
Class:  class TC1 { class TC1 
Class:  class TC2 {   class TC2 
Class:  class numpunct : public locale::facet    class numpunct : public locale::facet 
Class:    class X {     class X 
Class:  class X {   class X 
Class:  template <typename T> class Foo {   template <typename T> class Foo 
Class:  class outer {   class outer 
Class:    class foo;
Class:  class outer::foo {   class outer::foo 
Class:  template <class T1, class T2 , class T3  > class A;
Class:    template <class U> class B;
Class:    template <class S> template <class U> friend class A<S>::B;
Class:   template <class S> template <class U> class A<S>::B {   template <class S> template <class U> class A<S>::B 
Class:  template <class T> class A {   template <class T> class A 
Class: template <typename T> class TenElementArray { template <typename T> class TenElementArray 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(7, 1, u'+#define static_assert(__b, __m) \\'), (15, 1, u'+static_assert(sizeof(IntArray<10>) == sizeof(int) * 10, "Array size mismatch");'), (16, 1, u'+static_assert(sizeof(IntArray<1>) == sizeof(int) * 1, "Array size mismatch");'), (22, 1, u'+static_assert(sizeof(TenElementArray<int>) == sizeof(int) * 10, "Array size mismatch");'), (28, 1, u'+static_assert(sizeof(Array<int, 10>) == sizeof(int) * 10, "Array size mismatch");')]
===========================================
Class: class Base { class Base 
Class:class Derived : public Base 
Class:  template <class T, class U>   template <class T, class U>
Class:  class X   {   
Class:    class false_t 
Class:  template <class T> class A; 
Class:  template <class T> class B {   template <class T> class B 
Class:  class BaseT 
Class:  class DerivedT : public BaseT<T> 
Class:   template <typename T>   class FromT {   class FromT 
Class:  template <typename T> class Foo { class Foo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(23, 1, u'+static_assert(noexcept(A<int>::B<char>::f()), "");')]
===========================================
Class:  class A {   class A 
Class:  class A{   class A
Class:  class type_info;
Class:    class D; 
Class:  class B {   class B 
Class:   template <class T> class X { 
Class:  template <class T> class A 
Class:  class SomeClass {   class SomeClass 
Class:    class scanline_u8 {}     class scanline_u8 
Class:class the_application : public agg::platform_support class the_application : public agg::platform_support
Class:    class X;
Class:    class X : public T 
Class:  template <typename T> class A {   template <typename T> class A 
Class:    class Foo;
Class:    class Foo {     class Foo 
Class:   template <typename T> class B {   template <typename T> class B 
Class:    class Foo {     class Foo 
Class:   template <typename T> class C {   template <typename T> class C 
Class:  template <typename T> class C<T>::Foo {   template <typename T> class C<T>::Foo 
Class:    class A<N>::B::C X; 
Class: class ExprEngine { class ExprEngine 
Class:class RetainReleaseChecker 
Class:  template <class T> class B {   template <class T> class B 
Class:template <class T> class BB : public AA<T> { template <class T> class BB : public AA<T> 
Class:    class type {     class type 
Class:  class C {   class C 
Class:    template <class _Tp, class _Up>     template <class _Tp, class _Up>
Class:  template <class T, class U> struct D1 
Class:   template <class T, class U>   struct D   {   
Class:  template <class T> class A 
Class:  template <class T> class B {   template <class T> class B 
Class:  class type_info 
Class: class Y3 { class Y3 
Class: template <typename T, template <T, T> class TT, class R = TT<1, 2> > struct Comp { struct Comp 
Class:  class Templated {   class Templated 
Class:  class Knot : public JoinVisitor<Knot> {   class Knot : public JoinVisitor<Knot> 
Class:  template <class T, class Trt,   template <class T, class Trt,
Class:  template <class X, template<class> class = less> struct interval_type_default {   template <class X, template<class> class = less> struct interval_type_default 
Class:   template <class T,             template<class _T, template<class> class Compare = PR9016::less,                      class = typename interval_type_default<_T,Compare>::type,                      template<class> class = allocator> class IntervalSet>   struct ZZZ   {   
Class:  class C { class C 
Class:template <class T> class A { class A 
Class: template <class T> class B : public A<T> { class B : public A<T> 
Class:   class A { 
Class: class B { 
Class: class Base { 
Class:class Derived1 : public Base 
Class:class Derived2 : public Base 
Class: class X : public B, public Derived2, public Derived1 { 
Class:  class X3 { class X3 
Class:  template <class T> class Base;
Class:  template <class T> class Derived : public Base<T> {   template <class T> class Derived : public Base<T> 
Class:class A 
Class:  template <typename T1> template <template <typename> class TC>   template <typename T1> template <template <typename> class TC>
Class:  class Outer   class Outer
Class:class G 
Class:class Bar 
Class:   class A { class A 
Class:    template <class T> class B { class B 
Class:   template <class T> class A { class A 
Class:  template <class T> class B : public A<T> { class B : public A<T> 
Class:class B : public A<T> { class B : public A<T> 
Class:class A { class A 
Class:  template <class T> class B : public A<T> { class B : public A<T> 
Class:class A { class A 
Class:class B { class B 
Class: template <class T> class A : public B<T> { class A : public B<T> 
Class:class C { class C 
Class: template <class T> class A : public T { class A : public T 
Class: class S { class S 
Class:  class Inner0;
Class:  class Foo {   class Foo 
Class:  class ReferenceElement< Topology, ctype > :: BaryCenterArray    class ReferenceElement< Topology, ctype > :: BaryCenterArray 
Class:    class It     class It
Class:  class Y;
Class:  template <class T> class Base 
Class:  template <class T> class Derived : public Base<T> {   template <class T> class Derived : public Base<T> 
Class:  class Impl {   class Impl 
Class:  template <class T> class Magic : public Impl {   template <class T> class Magic : public Impl 
Class:  class Outer2 {   class Outer2 
Class:    class Outer2<V>::Inner; 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(4, 1, u'+template< bool C > struct assert { };'), (5, 1, u'+template< bool > struct assert_arg_pred_impl { }; // expected-note 3 {{declared here}}'), (6, 1, u'+template< typename Pred > assert<false> assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type ); // expected-error 5 {{}}')]
===========================================
Class:  class type_info 
Class:  template <class t> class foo 
Class:  template <class t> class bar {   template <class t> class bar 
Class: class X { class X 
Class:        class basic;
Class:        class basic         class basic
Class:  template <template<typename,int> class TT, typename T, int N>   template <template<typename,int> class TT, typename T, int N>
Class:  class X 
Class:  class a;
Class:   template <class U>   class a<s>    {   
Class:  class BasicGeometry   class BasicGeometry
Class: class A { 
Class:  class type_info;
Class:  class A 
Class:    class Inner : public A 
Class:class PrintTransforms : public MigrationProcess::RewriteListener { class PrintTransforms : public MigrationProcess::RewriteListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 1, u'+    assert(Ctx);'), (97, 1, u'+    assert(Ctx);'), (177, 1, u'+  assert(!transforms.empty());'), (224, 1, u'+  assert(!resultFiles.empty());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(285, 1, u'+  assert(MAI && "Unable to create target asm info!");'), (288, 1, u'+  assert(MRI && "Unable to create target register info!");'), (343, 1, u'+    assert(Opts.OutputType == AssemblerInvocation::FT_Obj &&')]
===========================================
Class:class NAME : public VisitorJob {\ class NAME : public VisitorJob 
Class:class TypeLocVisit : public VisitorJob { class TypeLocVisit : public VisitorJob 
Class: class LabelRefVisit : public VisitorJob { class LabelRefVisit : public VisitorJob 
Class: class NestedNameSpecifierLocVisit : public VisitorJob { class NestedNameSpecifierLocVisit : public VisitorJob 
Class: class DeclarationNameInfoVisit : public VisitorJob { class DeclarationNameInfoVisit : public VisitorJob 
Class:class MemberRefVisit : public VisitorJob { class MemberRefVisit : public VisitorJob 
Class:class EnqueueVisitor : public StmtVisitor<EnqueueVisitor, void> { class EnqueueVisitor : public StmtVisitor<EnqueueVisitor, void> 
Class:class AnnotateTokensWorker { class AnnotateTokensWorker 
Class:class MarkMacroArgTokensVisitor { class MarkMacroArgTokensVisitor 
Class:  class CaptureCompletionResults : public CodeCompleteConsumer {   class CaptureCompletionResults : public CodeCompleteConsumer 
Class:class CXDiagnosticCustomNoteImpl : public CXDiagnosticImpl { class CXDiagnosticCustomNoteImpl : public CXDiagnosticImpl 
Class: class CXDiagnosticRenderer : public DiagnosticNoteRenderer { class CXDiagnosticRenderer : public DiagnosticNoteRenderer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(135, 1, u'+  assert(Loc.isMacroID());'), (214, 1, u'+  assert(clang_isDeclaration(declCursor.kind));')]
===========================================
Class:class USRGenerator : public DeclVisitor<USRGenerator> { class USRGenerator : public DeclVisitor<USRGenerator> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(436, 1, u'+  assert(Buf.size() > 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(34, 1, u'+  assert(K >= CXCursor_FirstInvalid && K <= CXCursor_LastInvalid);'), (40, 1, u'+  assert(A && "Invalid arguments!");'), (57, 1, u'+  assert(A && Parent && TU && "Invalid arguments!");'), (65, 1, u'+  assert(D && TU && "Invalid arguments!");'), (93, 1, u'+  assert(S && TU && "Invalid arguments!");'), (489, 1, u'+  assert(Super && TU && "Invalid arguments!");'), (497, 1, u'+  assert(C.kind == CXCursor_ObjCSuperClassRef);'), (506, 1, u'+  assert(Proto && TU && "Invalid arguments!");'), (514, 1, u'+  assert(C.kind == CXCursor_ObjCProtocolRef);'), (526, 1, u'+  assert(TU && "Invalid arguments!");'), (534, 1, u'+  assert(C.kind == CXCursor_ObjCClassRef);'), (542, 1, u'+  assert(Type && TU && "Invalid arguments!");'), (550, 1, u'+  assert(C.kind == CXCursor_TypeRef);'), (559, 1, u'+  assert(Template && TU && "Invalid arguments!");'), (567, 1, u'+  assert(C.kind == CXCursor_TemplateRef);'), (577, 1, u'+  assert(NS && (isa<NamespaceDecl>(NS) || isa<NamespaceAliasDecl>(NS)) && TU &&'), (586, 1, u'+  assert(C.kind == CXCursor_NamespaceRef);'), (595, 1, u'+  assert(Var && TU && "Invalid arguments!");'), (603, 1, u'+  assert(C.kind == CXCursor_VariableRef);'), (612, 1, u'+  assert(Field && TU && "Invalid arguments!");'), (620, 1, u'+  assert(C.kind == CXCursor_MemberRef);'), (633, 1, u'+  assert(C.kind == CXCursor_CXXBaseSpecifier);'), (648, 1, u'+  assert(C.kind == CXCursor_PreprocessingDirective);'), (664, 1, u'+  assert(C.kind == CXCursor_MacroDefinition);'), (675, 1, u'+  assert(C.kind == CXCursor_MacroExpansion);'), (686, 1, u'+  assert(C.kind == CXCursor_InclusionDirective);'), (693, 1, u'+  assert(Label && TU && "Invalid arguments!");'), (701, 1, u'+  assert(C.kind == CXCursor_LabelRef);'), (709, 1, u'+  assert(E && TU && "Invalid arguments!");'), (722, 1, u'+  assert(D && TU && "Invalid arguments!");'), (735, 1, u'+  assert(Name.getAsOverloadedTemplate() && TU && "Invalid arguments!");'), (747, 1, u'+  assert(C.kind == CXCursor_OverloadedDeclRef);'), (869, 1, u'+  assert(clang_isDeclaration(cursor.kind));'), (1013, 1, u'+  assert(clang_isDeclaration(C.kind));')]
===========================================
Class:class CXLoadedDiagnosticSetImpl : public CXDiagnosticSetImpl { class CXLoadedDiagnosticSetImpl : public CXDiagnosticSetImpl 
Class:class DiagLoader { class DiagLoader 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(95, 1, u'+  assert(Diag.getLocation().isValid());')]
===========================================
Class:class BodyIndexer : public RecursiveASTVisitor<BodyIndexer> { class BodyIndexer : public RecursiveASTVisitor<BodyIndexer> 
Class:class IndexingDeclVisitor : public DeclVisitor<IndexingDeclVisitor, bool> { class IndexingDeclVisitor : public DeclVisitor<IndexingDeclVisitor, bool> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(209, 1, u'+    assert(D->getPropertyImplementation() == ObjCPropertyImplDecl::Synthesize);')]
===========================================
Class:class TypeIndexer : public RecursiveASTVisitor<TypeIndexer> { class TypeIndexer : public RecursiveASTVisitor<TypeIndexer> 
Class:class IndexPPCallbacks : public PPCallbacks { class IndexPPCallbacks : public PPCallbacks 
Class:     class IndexingConsumer : public ASTConsumer { class IndexingConsumer : public ASTConsumer 
Class:     class CaptureDiagnosticConsumer : public DiagnosticConsumer { class CaptureDiagnosticConsumer : public DiagnosticConsumer 
Class:     class IndexingFrontendAction : public ASTFrontendAction { class IndexingFrontendAction : public ASTFrontendAction 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(728, 1, u'+  assert(D);')]
===========================================
Class:class FakeStatCache : public FileSystemStatCache { class FakeStatCache : public FileSystemStatCache 
Class:  class FileManagerTest : public ::testing::Test { class FileManagerTest : public ::testing::Test 
Class:class SourceManagerTest : public ::testing::Test { class SourceManagerTest : public ::testing::Test 
Class: class VoidModuleLoader : public ModuleLoader { class VoidModuleLoader : public ModuleLoader 
Class:class MacroTracker : public PPCallbacks { class MacroTracker : public PPCallbacks 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 1, u'+  ASSERT_EQ(3U, toks.size());'), (87, 1, u'+  ASSERT_EQ(tok::l_square, toks[0].getKind());'), (88, 1, u'+  ASSERT_EQ(tok::identifier, toks[1].getKind());'), (89, 1, u'+  ASSERT_EQ(tok::r_square, toks[2].getKind());'), (97, 1, u'+  ASSERT_TRUE(macroExpStartLoc.isFileID());'), (98, 1, u'+  ASSERT_TRUE(macroExpEndLoc.isFileID());'), (101, 1, u'+  ASSERT_EQ("M", PP.getSpelling(macroExpStartLoc, str));'), (102, 1, u'+  ASSERT_EQ(")", PP.getSpelling(macroExpEndLoc, str));'), (153, 1, u'+  ASSERT_EQ(4U, toks.size());'), (154, 1, u'+  ASSERT_EQ(tok::numeric_constant, toks[0].getKind());'), (155, 1, u'+  ASSERT_EQ(tok::numeric_constant, toks[1].getKind());'), (156, 1, u'+  ASSERT_EQ(tok::numeric_constant, toks[2].getKind());'), (157, 1, u'+  ASSERT_EQ(tok::numeric_constant, toks[3].getKind());'), (254, 1, u'+  ASSERT_EQ(0U, toks.size());'), (256, 1, u'+  ASSERT_EQ(9U, Macros.size());'), (258, 1, u'+  ASSERT_TRUE(Macros[0].isDefinition);'), (259, 1, u'+  ASSERT_EQ("M", Macros[0].Name);'), (261, 1, u'+  ASSERT_TRUE(Macros[1].isDefinition);'), (262, 1, u'+  ASSERT_EQ("INC", Macros[1].Name);'), (264, 1, u'+  ASSERT_FALSE(Macros[2].isDefinition);'), (265, 1, u'+  ASSERT_EQ("M", Macros[2].Name);'), (267, 1, u'+  ASSERT_FALSE(Macros[3].isDefinition);'), (268, 1, u'+  ASSERT_EQ("INC", Macros[3].Name);'), (270, 1, u'+  ASSERT_TRUE(Macros[4].isDefinition);'), (271, 1, u'+  ASSERT_EQ("MACRO_IN_INCLUDE", Macros[4].Name);'), (273, 1, u'+  ASSERT_TRUE(Macros[5].isDefinition);'), (274, 1, u'+  ASSERT_EQ("INC2", Macros[5].Name);'), (276, 1, u'+  ASSERT_FALSE(Macros[6].isDefinition);'), (277, 1, u'+  ASSERT_EQ("M", Macros[6].Name);'), (279, 1, u'+  ASSERT_FALSE(Macros[7].isDefinition);'), (280, 1, u'+  ASSERT_EQ("INC2", Macros[7].Name);'), (282, 1, u'+  ASSERT_TRUE(Macros[8].isDefinition);'), (283, 1, u'+  ASSERT_EQ("MACRO_IN_INCLUDE", Macros[8].Name);')]
===========================================
Class:class TestASTFrontendAction : public ASTFrontendAction { class TestASTFrontendAction : public ASTFrontendAction 
Class:  class Visitor : public ASTConsumer, public RecursiveASTVisitor<Visitor> {   class Visitor : public ASTConsumer, public RecursiveASTVisitor<Visitor> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 1, u'+  ASSERT_TRUE(compiler.ExecuteAction(test_action));'), (68, 1, u'+  ASSERT_EQ(3U, test_action.decl_names.size());')]
===========================================
Class:class LexerTest : public ::testing::Test { class LexerTest : public ::testing::Test 
Class: class VoidModuleLoader : public ModuleLoader { class VoidModuleLoader : public ModuleLoader 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 1, u'+  ASSERT_EQ(10U, toks.size());'), (92, 1, u'+  ASSERT_EQ(tok::l_square, toks[0].getKind());'), (93, 1, u'+  ASSERT_EQ(tok::identifier, toks[1].getKind());'), (94, 1, u'+  ASSERT_EQ(tok::r_square, toks[2].getKind());'), (95, 1, u'+  ASSERT_EQ(tok::l_square, toks[3].getKind());'), (96, 1, u'+  ASSERT_EQ(tok::identifier, toks[4].getKind());'), (97, 1, u'+  ASSERT_EQ(tok::r_square, toks[5].getKind());'), (98, 1, u'+  ASSERT_EQ(tok::identifier, toks[6].getKind());'), (99, 1, u'+  ASSERT_EQ(tok::identifier, toks[7].getKind());'), (100, 1, u'+  ASSERT_EQ(tok::identifier, toks[8].getKind());'), (101, 1, u'+  ASSERT_EQ(tok::identifier, toks[9].getKind());')]
===========================================
Class:class PreprocessingRecordTest : public ::testing::Test { class PreprocessingRecordTest : public ::testing::Test 
Class: class VoidModuleLoader : public ModuleLoader { class VoidModuleLoader : public ModuleLoader 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 1, u'+  ASSERT_EQ(10U, toks.size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 1, u'+  ASSERT_EQ(4u, FoundCommand.CommandLine.size()) << ErrorMessage;'), (82, 1, u'+  ASSERT_EQ(2u, FoundCommand.CommandLine.size());'), (118, 1, u'+  ASSERT_EQ(1u, FoundCommand.CommandLine.size()) << ErrorMessage;'), (140, 1, u'+  ASSERT_EQ(3ul, Result.size());'), (148, 1, u'+  ASSERT_EQ(2ul, Result.size());'), (155, 1, u'+  ASSERT_EQ(1ul, Backslash.size());'), (158, 1, u'+  ASSERT_EQ(1ul, Quote.size());'), (164, 1, u'+  ASSERT_EQ(1ul, Result.size());'), (171, 1, u'+  ASSERT_EQ(2ul, Result.size());'), (179, 1, u'+  ASSERT_EQ(1ul, Result.size());'), (186, 1, u'+  ASSERT_EQ(1ul, Result.size());'), (193, 1, u'+  ASSERT_EQ(4ul, Result.size());'), (203, 1, u'+  ASSERT_EQ(1ul, QuotedNoSpaces.size());'), (208, 1, u'+  ASSERT_EQ(1ul, MixedNoSpaces.size());'), (214, 1, u'+  ASSERT_EQ(1ul, Unclosed.size());'), (218, 1, u'+  ASSERT_EQ(1ul, Empty.size());'), (229, 1, u'+  ASSERT_EQ(1ul, Result.size());'), (260, 1, u'+  ASSERT_TRUE(Database);'), (263, 1, u'+  ASSERT_EQ(1ul, Result.size());'), (264, 1, u'+  ASSERT_EQ(".", Result[0].Directory);'), (270, 1, u'+  ASSERT_EQ(CommandLine, Result[0].CommandLine);'), (279, 1, u'+  ASSERT_TRUE(Database);'), (282, 1, u'+  ASSERT_EQ(1ul, Result.size());'), (283, 1, u'+  ASSERT_EQ(".", Result[0].Directory);'), (287, 1, u'+  ASSERT_EQ(CommandLine, Result[0].CommandLine);')]
===========================================
Class:class TestAction : public clang::ASTFrontendAction { class TestAction : public clang::ASTFrontendAction 
Class:class FindTopLevelDeclConsumer : public clang::ASTConsumer { class FindTopLevelDeclConsumer : public clang::ASTConsumer 
Class:class FindClassDeclXConsumer : public clang::ASTConsumer { class FindClassDeclXConsumer : public clang::ASTConsumer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(245, 1, u'+  assert(__ashldi3(1, 1) == 2);'), (246, 1, u'+  assert(__ashrdi3(2, 1) == 1);'), (247, 1, u'+  assert(__lshrdi3(2, 1) == 1);'), (248, 1, u'+  assert(__clzsi2(1) == 31);'), (249, 1, u'+  assert(__clzdi2(1) == 63);'), (250, 1, u'+  assert(__ctzsi2(2) == 1);'), (251, 1, u'+  assert(__ctzdi2(2) == 1);'), (252, 1, u'+  assert(__ffsdi2(12) == 3);'), (253, 1, u'+  assert(__paritysi2(13) == 1);'), (254, 1, u'+  assert(__paritydi2(13) == 1);'), (255, 1, u'+  assert(__popcountsi2(13) == 3);'), (256, 1, u'+  assert(__popcountdi2(13) == 3);'), (257, 1, u'+  assert(__negdi2(3) == -3);'), (258, 1, u'+  assert(__muldi3(2,2) == 4);'), (259, 1, u'+  assert(__divdi3(-4,2) == -2);'), (260, 1, u'+  assert(__udivdi3(4,2) == 2);'), (261, 1, u'+  assert(__moddi3(3,2) == 1);'), (262, 1, u'+  assert(__umoddi3(3,2) == 1);'), (263, 1, u'+  assert(__udivmoddi4(5,2,&du_tmp) == 2 && du_tmp == 1);'), (264, 1, u'+  assert(__absvsi2(-2) == 2);'), (265, 1, u'+  assert(__absvdi2(-2) == 2);'), (266, 1, u'+  assert(__negvsi2(2) == -2);'), (267, 1, u'+  assert(__negvdi2(2) == -2);'), (268, 1, u'+  assert(__addvsi3(2, 3) == 5);'), (269, 1, u'+  assert(__addvdi3(2, 3) == 5);'), (270, 1, u'+  assert(__subvsi3(2, 3) == -1);'), (271, 1, u'+  assert(__subvdi3(2, 3) == -1);'), (272, 1, u'+  assert(__mulvsi3(2, 3) == 6);'), (273, 1, u'+  assert(__mulvdi3(2, 3) == 6);'), (274, 1, u'+  assert(__cmpdi2(3, 2) == 2);'), (275, 1, u'+  assert(__ucmpdi2(3, 2) == 2);'), (276, 1, u'+  assert(__fixsfdi(2.0) == 2);'), (277, 1, u'+  assert(__fixdfdi(2.0) == 2);'), (278, 1, u'+  assert(__fixunssfsi(2.0) == 2);'), (279, 1, u'+  assert(__fixunsdfsi(2.0) == 2);'), (280, 1, u'+  assert(__fixunssfdi(2.0) == 2);'), (281, 1, u'+  assert(__fixunsdfdi(2.0) == 2);'), (282, 1, u'+  assert(__floatdisf(2) == 2.0);'), (283, 1, u'+  assert(__floatdidf(2) == 2.0);'), (284, 1, u'+  assert(__floatundisf(2) == 2.0);'), (285, 1, u'+  assert(__floatundidf(2) == 2.0);'), (286, 1, u'+  assert(__powisf2(2.0, 2) == 4.0);'), (287, 1, u'+  assert(__powidf2(2.0, 2) == 4.0);'), (298, 1, u'+  assert(__mulsc3(1.0, 2.0, 4.0, 8.0) == (-12.0 + 16.0j));'), (299, 1, u'+  assert(__muldc3(1.0, 2.0, 4.0, 8.0) == (-12.0 + 16.0j));'), (300, 1, u'+  assert(__divsc3(1.0, 2.0, 4.0, 8.0) == (0.25 + 0j));'), (301, 1, u'+  assert(__divdc3(1.0, 2.0, 4.0, 8.0) == (0.25 + 0j));'), (305, 1, u'+  assert(__divxc3(1.0, 2.0, 4.0, 8.0) == (0.25 + 0j));'), (306, 1, u'+  assert(__fixunsxfdi(2.0) == 2);'), (307, 1, u'+  assert(__fixunsxfsi(2.0) == 2);'), (308, 1, u'+  assert(__fixxfdi(2.0) == 2);'), (309, 1, u'+  assert(__floatdixf(2) == 2.0);'), (310, 1, u'+  assert(__floatundixf(2) == 2);'), (311, 1, u'+  assert(__mulxc3(1.0, 2.0, 4.0, 8.0) == (-12.0 + 16.0j));'), (312, 1, u'+  assert(__powixf2(2.0, 2) == 4.0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 1, u'+    assert (Last && "Got a first node but not a last node for a range!");')]
===========================================
Class:  class Argument {   class Argument 
Class:   class SimpleArgument : public Argument {   class SimpleArgument : public Argument 
Class:   class StringArgument : public Argument {   class StringArgument : public Argument 
Class:   class AlignedArgument : public Argument {   class AlignedArgument : public Argument 
Class:   class VariadicArgument : public Argument {   class VariadicArgument : public Argument 
Class:   class EnumArgument : public Argument {   class EnumArgument : public Argument 
Class:   class VersionArgument : public Argument {   class VersionArgument : public Argument 
Class:   class ExprArgument : public SimpleArgument {   class ExprArgument : public SimpleArgument 
Class:   class VariadicExprArgument : public VariadicArgument {   class VariadicExprArgument : public VariadicArgument 
Class:class DiagGroupParentMap { class DiagGroupParentMap 
Class:  class DiagCategoryIDMap {   class DiagCategoryIDMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(1014, 1, u'+  assert(!proto.empty() && "");'), (1437, 1, u'+        assert(immPos > 0 && "unexpected immediate operand");'), (1478, 1, u'+  assert(!proto.empty() && "");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(53, 1, u'+  assert(APrec != BPrec && "Options are equivalent!");')]
===========================================
Class:class ClangTableGenAction : public TableGenAction { class ClangTableGenAction : public TableGenAction 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 1, u'+CAMLprim value llvm_assert_valid_module(LLVMModuleRef M) {'), (57, 1, u'+CAMLprim value llvm_assert_valid_function(LLVMValueRef Fn) {')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(139, 1, u'+  assert(LLVMGenericValueIntWidth(Genericvalue_val(GenVal)) <= 8 * sizeof(value)'), (147, 1, u'+  assert(LLVMGenericValueIntWidth(Genericvalue_val(GenVal)) <= 32'), (155, 1, u'+  assert(LLVMGenericValueIntWidth(Genericvalue_val(GenVal)) <= 64'), (163, 1, u'+  assert(LLVMGenericValueIntWidth(Genericvalue_val(GenVal)) <= 8 * sizeof(value)')]
===========================================
Class:   class OurCppRunException : public std::runtime_error { class OurCppRunException : public std::runtime_error 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 1, u"+  assert(Add1F->arg_begin() != Add1F->arg_end()); // Make sure there's an arg")]
===========================================
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:    class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:    class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:    class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:  class IfExprAST : public ExprAST { class IfExprAST : public ExprAST 
Class:  class ForExprAST : public ExprAST { class ForExprAST : public ExprAST 
Class:    class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class UnaryExprAST : public ExprAST { class UnaryExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:  class IfExprAST : public ExprAST { class IfExprAST : public ExprAST 
Class:  class ForExprAST : public ExprAST { class ForExprAST : public ExprAST 
Class:    class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:      class ExprAST { class ExprAST 
Class:  class NumberExprAST : public ExprAST { class NumberExprAST : public ExprAST 
Class:  class VariableExprAST : public ExprAST { class VariableExprAST : public ExprAST 
Class:  class UnaryExprAST : public ExprAST { class UnaryExprAST : public ExprAST 
Class:  class BinaryExprAST : public ExprAST { class BinaryExprAST : public ExprAST 
Class:  class CallExprAST : public ExprAST { class CallExprAST : public ExprAST 
Class:  class IfExprAST : public ExprAST { class IfExprAST : public ExprAST 
Class:  class ForExprAST : public ExprAST { class ForExprAST : public ExprAST 
Class:  class VarExprAST : public ExprAST { class VarExprAST : public ExprAST 
Class:   class PrototypeAST { class PrototypeAST 
Class:  class FunctionAST { class FunctionAST 
Class:    class WaitForThreads { 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (54, 1, u'+  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (59, 1, u'+  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (64, 1, u'+  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (69, 1, u'+  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (77, 1, u'+  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (122, 1, u'+  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (195, 1, u'+  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (214, 1, u'+  assert(AA && "AA didn\'t call InitializeAliasAnalysis in its run method!");'), (404, 1, u'+  assert(I1.getParent() == I2.getParent() &&')]
===========================================
Class:  class AliasAnalysisCounter : public ModulePass, public AliasAnalysis {   class AliasAnalysisCounter : public ModulePass, public AliasAnalysis 
Class:  class AAEval : public FunctionPass {   class AAEval : public FunctionPass 
Class:  class AliasDebugger : public ModulePass, public AliasAnalysis {   class AliasDebugger : public ModulePass, public AliasAnalysis 
Class:  class AliasSetPrinter : public FunctionPass {   class AliasSetPrinter : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(181, 1, u'+  assert(V->getType()->isIntegerTy() && "Not an integer value");'), (478, 1, u'+      assert(AliasCache.empty() && "AliasCache must be cleared after use!");'), (479, 1, u'+      assert(notDifferentParent(LocA.Ptr, LocB.Ptr) &&'), (574, 1, u'+  assert(Visited.empty() && "Visited must be cleared after use!");'), (682, 1, u'+  assert(notDifferentParent(CS.getInstruction(), Loc.Ptr) &&'), (887, 1, u'+      assert(TD == 0 &&'), (923, 1, u'+      assert(TD == 0 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(175, 1, u'+  assert(Weights.size() == TI->getNumSuccessors() && "Checked above");'), (199, 1, u'+  assert(CI->getOperand(1)->getType()->isPointerTy());'), (382, 1, u'+  assert(PostDominatedByUnreachable.empty());'), (411, 1, u'+  assert(LastF && "Cannot print prior to running over a function");'), (430, 1, u'+    assert(Sum > PrevSum); (void) PrevSum;'), (454, 1, u'+    assert(Sum > PrevSum); (void) PrevSum;')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(58, 1, u'+  assert(!isa<GlobalValue>(V) &&'), (78, 1, u'+  assert(V->getType()->isPointerTy() && "Capture is for pointers only!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(278, 1, u'+  assert(ByteOffset <= TD.getTypeAllocSize(C->getType()) &&'), (625, 1, u'+        assert((CE == 0 || CE->getType() == IntPtrTy) &&'), (684, 1, u'+  assert(Ty->isPointerTy() && "Forming regular GEP of non-pointer type");'), (746, 1, u'+  assert(cast<PointerType>(C->getType())->getElementType() == Ty &&'), (1166, 1, u'+  assert(ResultWidth <= 64 &&'), (1305, 1, u'+        assert(status == APFloat::opOK && !lost &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 1, u'+  assert((Tag & LLVMDebugVersionMask) == 0 &&'), (80, 1, u'+  assert(((Lang <= dwarf::DW_LANG_Python && Lang >= dwarf::DW_LANG_C89) ||'), (83, 1, u'+  assert(!Filename.empty() &&'), (129, 1, u'+  assert(TheCU && "Unable to create DW_TAG_file_type without CompileUnit");'), (130, 1, u'+  assert(!Filename.empty() && "Unable to create file without name");'), (142, 1, u'+  assert(!Name.empty() && "Unable to create enumerator without name");'), (153, 1, u'+  assert(!Name.empty() && "Unable to create type without name");'), (176, 1, u'+  assert(!Name.empty() && "Unable to create type without name");'), (234, 1, u'+  assert(RTy.Verify() && "Unable to create reference type");'), (255, 1, u'+  assert(Ty.Verify() && "Invalid typedef type!");'), (274, 1, u'+  assert(Ty.Verify() && "Invalid type!");'), (275, 1, u'+  assert(FriendTy.Verify() && "Invalid friend type!");'), (295, 1, u'+  assert(Ty.Verify() && "Unable to create inheritance");'), (623, 1, u'+  assert (N && "Unexpected input DIType!");'), (960, 1, u'+  assert(Storage && "no storage passed to dbg.declare");'), (961, 1, u'+  assert(VarInfo.Verify() && "empty DIVariable passed to dbg.declare");'), (972, 1, u'+  assert(Storage && "no storage passed to dbg.declare");'), (973, 1, u'+  assert(VarInfo.Verify() && "invalid DIVariable passed to dbg.declare");'), (991, 1, u'+  assert(V && "no value passed to dbg.value");'), (992, 1, u'+  assert(VarInfo.Verify() && "invalid DIVariable passed to dbg.value");'), (1006, 1, u'+  assert(V && "no value passed to dbg.value");'), (1007, 1, u'+  assert(VarInfo.Verify() && "invalid DIVariable passed to dbg.value");')]
===========================================
Class:  class PrintDbgInfo : public FunctionPass {   class PrintDbgInfo : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(536, 1, u'+  assert(CurFn && "Invalid function");'), (547, 1, u'+  assert(F && "Invalid function");'), (559, 1, u'+  assert (DbgNode && "Invalid subprogram descriptor!");')]
===========================================
Class:  class DFCalculateWorkObject {   class DFCalculateWorkObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(52, 1, u'+    assert (currentW && "Missing work object.");'), (58, 1, u'+    assert (currentBB && "Invalid work object. Missing current Basic Block");'), (59, 1, u'+    assert (currentNode && "Invalid work object. Missing current Node");')]
===========================================
Class:class BasicCallGraph : public ModulePass, public CallGraph { class BasicCallGraph : public ModulePass, public CallGraph 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(216, 1, u'+  assert(CGN->empty() && "Cannot remove function from call "'), (232, 1, u'+  assert(FunctionMap.count(From) && "No CallGraphNode for function!");'), (233, 1, u'+  assert(!FunctionMap.count(To) &&'), (248, 1, u'+  assert((!F || F->getParent() == Mod) && "Function not in current module!");'), (277, 1, u'+    assert(I != CalledFunctions.end() && "Cannot find callsite to remove!");'), (304, 1, u'+    assert(I != CalledFunctions.end() && "Cannot find callee to remove!");'), (321, 1, u'+    assert(I != CalledFunctions.end() && "Cannot find callsite to remove!");')]
===========================================
Class:class CGPassManager : public ModulePass, public PMDataManager { class CGPassManager : public ModulePass, public PMDataManager 
Class:  class PrintCallGraphPass : public CallGraphSCCPass {   class PrintCallGraphPass : public CallGraphSCCPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 1, u'+    assert(N < PassVector.size() && "Pass number out of range!");'), (135, 1, u'+  assert(PM->getPassManagerType() == PMT_FunctionPassManager &&'), (213, 1, u'+        assert(!CheckingMode &&'), (236, 1, u'+      assert(!CallSites.count(I->first) &&'), (274, 1, u'+          assert(!CheckingMode &&'), (299, 1, u'+        assert(!CheckingMode &&'), (333, 1, u'+    assert(CallSites.empty() && "Dangling pointers found in call sites map");'), (476, 1, u'+      assert(PM->getPassManagerType() == PMT_FunctionPassManager &&'), (491, 1, u'+      assert(PM->getPassManagerType() == PMT_FunctionPassManager &&'), (508, 1, u'+  assert(Old != New && "Should not replace node with self");'), (510, 1, u'+    assert(i != Nodes.size() && "Node not in SCC");'), (535, 1, u'+  assert(!PMS.empty() && "Unable to handle Call Graph Pass");'), (542, 1, u'+    assert(!PMS.empty() && "Unable to create Call Graph Pass Manager");')]
===========================================
Class:  class GlobalsModRef : public ModulePass, public AliasAnalysis {   class GlobalsModRef : public ModulePass, public AliasAnalysis 
Class:class CallAnalyzer : public InstVisitor<CallAnalyzer, bool> { class CallAnalyzer : public InstVisitor<CallAnalyzer, bool> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(242, 1, u'+  assert(IntPtrWidth == Offset.getBitWidth());'), (793, 1, u'+    assert(V->getType()->isPointerTy() && "Unexpected operand type!");'), (823, 1, u'+    assert(NumInstructions == 0);'), (824, 1, u'+    assert(NumVectorInstructions == 0);'), (868, 1, u'+    assert(CAI != CS.arg_end());')]
===========================================
Class:  class InstCount : public FunctionPass, public InstVisitor<InstCount> {   class InstCount : public FunctionPass, public InstVisitor<InstCount> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(65, 1, u'+  assert(Ty->getScalarType()->isIntegerTy(1) &&'), (73, 1, u'+  assert(Ty->getScalarType()->isIntegerTy(1) &&'), (262, 1, u'+  assert(Instruction::isAssociative(Opcode) && "Not an associative operation!");'), (368, 1, u'+    assert(isa<SelectInst>(RHS) && "No select instruction operand!");'), (442, 1, u'+  assert(isa<SelectInst>(LHS) && "Not comparing with a select instruction!");'), (525, 1, u'+    assert(isa<PHINode>(RHS) && "No PHI instruction operand!");'), (566, 1, u'+  assert(isa<PHINode>(LHS) && "Not comparing with a phi instruction!");'), (670, 1, u'+  assert(IntPtrWidth == Offset.getBitWidth());'), (725, 1, u'+    assert(V->getType()->isPointerTy() && "Unexpected operand type!");'), (1639, 1, u'+  assert(CmpInst::isIntPredicate(Pred) && "Not an integer compare!");'), (2408, 1, u'+  assert(CmpInst::isFPPredicate(Pred) && "Not an FP compare!");'), (2443, 1, u'+        assert(FCmpInst::isUnordered(Pred) &&'), (2943, 1, u'+  assert(I != SimpleV && "replaceAndRecursivelySimplify(X,X) is not valid!");'), (2944, 1, u'+  assert(SimpleV && "Must provide a simplified value.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 1, u'+  assert(I != intervals_end(&F) && "No intervals in function!?!?!");'), (95, 1, u'+  assert(IP.getRootInterval() && "Cannot operate on empty IntervalPartitions!");'), (99, 1, u'+  assert(I != intervals_end(IP) && "No intervals in interval partition!?!?!");')]
===========================================
Class:class LVILatticeVal { class LVILatticeVal 
Class:  class LazyValueInfoCache;
Class:  class LazyValueInfoCache {   class LazyValueInfoCache 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 1, u'+  assert(FI->DetailsType == LibCallFunctionInfo::DoesOnly);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+  assert(LocID < NumLocations && "Invalid location ID!");')]
===========================================
Class:  class Lint : public FunctionPass, public InstVisitor<Lint> {   class Lint : public FunctionPass, public InstVisitor<Lint> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(78, 1, u'+    assert(V->getType()->isPointerTy() && "Unexpected operand type!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(171, 1, u'+  assert(isZIVPair(A, B) && "Attempted to ZIV-test non-ZIV SCEVs!");'), (294, 1, u'+  assert(isDependencePair(A, B) && "Values form no dependence pair!");')]
===========================================
Class:class UnloopUpdater { class UnloopUpdater 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(138, 1, u'+  assert(PI != pred_end(H) &&'), (244, 1, u'+  assert(hasDedicatedExits() &&'), (361, 1, u'+        assert((NL != Unloop && (!NL || NL->contains(Unloop))) &&'), (368, 1, u'+        assert((FoundIB || Unloop->contains(L)) && "uninitialized successor");'), (376, 1, u'+    assert(NIters < Unloop->getNumBlocks() && "runaway iterative algorithm");'), (387, 1, u'+        assert(NL != Unloop && (!NL || NL->contains(Unloop)) &&'), (413, 1, u'+      assert(OldParent && "new loop is not an ancestor of the original");'), (426, 1, u'+    assert(SubloopParents.count(Subloop) && "DFS failed to visit subloop");'), (451, 1, u'+      assert(Subloop && "subloop is not an ancestor of the original loop");'), (461, 1, u'+    assert(!Subloop && "subloop blocks must have a successor");'), (472, 1, u'+      assert((FoundIB || !DFS.hasPostorder(*I)) && "should have seen IB");'), (481, 1, u'+      assert(L->getParentLoop() == Unloop && "cannot skip into nested loops");'), (540, 1, u'+      assert(I != LI.end() && "Couldn\'t find loop");'), (568, 1, u'+    assert(I != ParentLoop->end() && "Couldn\'t find loop");'), (587, 1, u'+    assert(!(*I)->getParentLoop() && "Top-level loop has a parent!");'), (597, 1, u'+    assert(Loops.count(I->second) && "orphaned loop");'), (598, 1, u'+    assert(I->second->contains(I->first) && "orphaned block");')]
===========================================
Class:class PrintLoopPass : public LoopPass { class PrintLoopPass : public LoopPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(96, 1, u'+  assert (CurrentLoop != L && "Cannot insert CurrentLoop");'), (132, 1, u'+  assert (CurrentLoop == L && "Can redo only CurrentLoop");'), (338, 1, u'+    assert (!PMS.empty() && "Unable to create Loop Pass Manager");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 1, u'+      assert(dep.isUnknown() && "unexptected dependence type");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(137, 1, u'+  assert(isMalloc(CI) && "getMallocType and not malloc call");'), (179, 1, u'+  assert(isMalloc(CI) && "getMallocArraySize and not malloc call");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(109, 1, u'+  assert(InstIt != ReverseMap.end() && "Reverse map out of sync?");'), (111, 1, u'+  assert(Found && "Invalid reverse map!"); (void)Found;'), (655, 1, u'+static void AssertSorted(MemoryDependenceAnalysis::NonLocalDepInfo &Cache,'), (661, 1, u'+    assert(!(Cache[i] < Cache[i-1]) && "Cache isn\'t sorted!");'), (679, 1, u'+  assert(getDependency(QueryCS.getInstruction()).isNonLocal() &&'), (725, 1, u'+  DEBUG(AssertSorted(Cache));'), (738, 1, u'+    DEBUG(AssertSorted(Cache, NumSortedEntries));'), (819, 1, u'+  assert(Loc.Ptr->getType()->isPointerTy() &&'), (872, 1, u'+    assert(ExistingResult->getResult().getInst()->getParent() == BB &&'), (903, 1, u'+  assert(Inst && "Didn\'t depend on anything?");'), (1080, 1, u'+  DEBUG(AssertSorted(*Cache));'), (1089, 1, u'+      assert(Visited.count(BB) && "Should check \'visited\' before adding to WL");'), (1093, 1, u'+      DEBUG(AssertSorted(*Cache, NumSortedEntries));'), (1280, 1, u'+      assert(I != Cache->rend() && "Didn\'t find current block??");'), (1284, 1, u'+      assert(I->getResult().isNonLocal() &&'), (1295, 1, u'+  DEBUG(AssertSorted(*Cache));'), (1314, 1, u'+    assert(Target->getParent() == PInfo[i].getBB());'), (1404, 1, u'+    assert(!ReverseDeps.empty() && !isa<TerminatorInst>(RemInst) &&'), (1410, 1, u'+      assert(InstDependingOnRemInst != RemInst &&'), (1416, 1, u'+      assert(NewDirtyVal.getInst() && "There is no way something else can have "'), (1438, 1, u'+      assert(*I != RemInst && "Already removed NonLocalDep info for RemInst");'), (1477, 1, u'+      assert(P.getPointer() != RemInst &&'), (1512, 1, u'+  assert(!NonLocalDeps.count(RemInst) && "RemInst got reinserted?");'), (1521, 1, u'+    assert(I->first != D && "Inst occurs in data structures");'), (1522, 1, u'+    assert(I->second.getInst() != D &&'), (1528, 1, u'+    assert(I->first.getPointer() != D && "Inst occurs in NLPD map key");'), (1532, 1, u'+      assert(II->getResult().getInst() != D && "Inst occurs as NLPD value");'), (1537, 1, u'+    assert(I->first != D && "Inst occurs in data structures");'), (1541, 1, u'+      assert(II->getResult().getInst() != D && "Inst occurs in data structures");'), (1546, 1, u'+    assert(I->first != D && "Inst occurs in data structures");'), (1549, 1, u'+      assert(*II != D && "Inst occurs in data structures");'), (1555, 1, u'+    assert(I->first != D && "Inst occurs in data structures");'), (1558, 1, u'+      assert(*II != D && "Inst occurs in data structures");'), (1564, 1, u'+    assert(I->first != D && "Inst occurs in rev NLPD map");'), (1568, 1, u'+      assert(*II != ValueIsLoadPair(D, false) &&')]
===========================================
Class:  class ModuleDebugInfoPrinter : public ModulePass {   class ModuleDebugInfoPrinter : public ModulePass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 1, u'+  assert(!isa<PHINode>(I) && "Error, removing something that isn\'t an input");'), (322, 1, u'+  assert(Verify() && "Invalid PHITransAddr!");'), (324, 1, u'+  assert(Verify() && "Invalid PHITransAddr!");')]
===========================================
Class:  class PathProfileLoaderPass : public ModulePass, public PathProfileInfo {   class PathProfileLoaderPass : public ModulePass, public PathProfileInfo 
Class:  class PathProfileVerifier : public ModulePass {   class PathProfileVerifier : public ModulePass 
Class:  class ProfileEstimatorPass : public FunctionPass, public ProfileInfo {   class ProfileEstimatorPass : public FunctionPass, public ProfileInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(185, 1, u'+  assert (oldw != MissingValue && "Adding weight to Edge with no previous weight");'), (195, 1, u'+  assert (oldw != MissingValue && "Adding weight to Block with no previous weight");'), (954, 1, u'+            assert(0 && "Edge should not have value already!");'), (991, 1, u'+    assert(0 && "could not repair function");')]
===========================================
Class:  class LoaderPass : public ModulePass, public ProfileInfo {   class LoaderPass : public ModulePass, public ProfileInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(215, 1, u'+          assert(0 && "No edge calculated!");')]
===========================================
Class:  class ProfileVerifierPassT : public FunctionPass {   class ProfileVerifierPassT : public FunctionPass 
Class:class PrintRegionPass : public RegionPass { class PrintRegionPass : public RegionPass 
Class:  class SCEVComplexityCompare {   class SCEVComplexityCompare 
Class:  class ScalarEvolutionAliasAnalysis : public FunctionPass,   class ScalarEvolutionAliasAnalysis : public FunctionPass,
Class:class LoopCompare { class LoopCompare 
Class:class PostIncTransform { class PostIncTransform 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 1, u'+      assert(S == TransformSubExpr(Result, User, OperandValToReplace) &&'), (147, 1, u'+      assert(S == TransformSubExpr(Result, User, OperandValToReplace) &&')]
===========================================
Class:  class TBAANode {   class TBAANode 
Class:  class TypeBasedAliasAnalysis : public ImmutablePass,   class TypeBasedAliasAnalysis : public ImmutablePass,
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+  assert(isa<PointerType>(Ty) && "Expected a pointer type!");'), (82, 1, u'+  assert((LHSKnownZero & LHSKnownOne) == 0 &&'), (87, 1, u'+  assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (139, 1, u'+  assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (140, 1, u'+  assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (197, 1, u'+  assert(NumRanges >= 1);'), (230, 1, u'+  assert(V && "No Value?");'), (231, 1, u'+  assert(Depth <= MaxDepth && "Limit Search Depth");'), (234, 1, u'+  assert((V->getType()->isIntOrIntVectorTy() ||'), (237, 1, u'+  assert((!TD ||'), (339, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (340, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (351, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (352, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (363, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (364, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (401, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (402, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (460, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (477, 1, u'+      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (492, 1, u'+      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (508, 1, u'+      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (555, 1, u'+        assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (578, 1, u'+        assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (992, 1, u'+  assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1008, 1, u'+  assert((TD || V->getType()->isIntOrIntVectorTy()) &&'), (1181, 1, u'+  assert(V && "No Value?");'), (1182, 1, u'+  assert(Depth <= MaxDepth && "Limit Search Depth");'), (1183, 1, u'+  assert(V->getType()->isIntegerTy() && "Not integer or pointer type!");'), (1481, 1, u'+  assert(InsertBefore && "Must have someplace to insert!");'), (1504, 1, u'+  assert((V->getType()->isStructTy() || V->getType()->isArrayTy()) &&'), (1506, 1, u'+  assert(ExtractValueInst::getIndexedType(V->getType(), idx_range) &&'), (1571, 1, u'+    assert(Idxs.size() == size'), (1628, 1, u'+  assert(V);'), (1794, 1, u'+    assert(V->getType()->isPointerTy() && "Unexpected operand type!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 1, u'+    assert(Buffer != End);'), (106, 1, u'+    assert(Buffer != End);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(230, 1, u'+  assert(Lex.getKind() == lltok::kw_module);'), (245, 1, u'+  assert(Lex.getKind() == lltok::kw_target);'), (270, 1, u'+  assert(Lex.getKind() == lltok::kw_deplibs);'), (351, 1, u'+  assert(Lex.getKind() == lltok::kw_declare);'), (361, 1, u'+  assert(Lex.getKind() == lltok::kw_define);'), (421, 1, u'+  assert(Lex.getKind() == lltok::GlobalVar);'), (486, 1, u'+  assert(Lex.getKind() == lltok::MetadataVar);'), (515, 1, u'+  assert(Lex.getKind() == lltok::exclaim);'), (542, 1, u'+    assert(NumberedMetadata[MetadataID] == Init && "Tracking VH didn\'t work");'), (566, 1, u'+  assert(Lex.getKind() == lltok::kw_alias);'), (631, 1, u'+  assert(GA->getName() == Name && "Should not be a name conflict!");'), (1083, 1, u'+      assert(ID.Kind == ValID::t_MDNode);'), (1385, 1, u'+  assert(Lex.getKind() == lltok::lparen);'), (1449, 1, u'+  assert(Lex.getKind() == lltok::lparen);'), (1550, 1, u'+  assert(Lex.getKind() == lltok::lbrace);'), (2163, 1, u'+      assert(Opc == Instruction::ICmp && "Unexpected opcode for CmpInst!");'), (2329, 1, u'+      assert(Opc == Instruction::InsertElement && "Unknown opcode");'), (2389, 1, u'+  assert(Lex.getKind() == lltok::lbrace);'), (2407, 1, u'+  assert(Lex.getKind() == lltok::exclaim);'), (3336, 1, u'+    assert(Opc == Instruction::ICmp && "Unknown opcode for CmpInst!");')]
===========================================
Class:  class ConstantPlaceHolder : public ConstantExpr {   class ConstantPlaceHolder : public ConstantExpr 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(252, 1, u'+    assert(Ty == V->getType() && "Type mismatch in constant table!");'), (267, 1, u'+    assert((Ty == 0 || Ty == V->getType()) && "Type mismatch in value table!");'), (331, 1, u'+          assert(It != ResolveConstants.end() && It->first == *I);'), (347, 1, u'+        assert(isa<ConstantExpr>(UserC) && "Must be a ConstantExpr.");'), (391, 1, u'+    assert(V->getType()->isMetadataTy() && "Type mismatch in value table!");'), (749, 1, u'+    assert(ResultTy && "Didn\'t read a type?");'), (750, 1, u'+    assert(TypeList[NumRecords] == 0 && "Already read type?");'), (864, 1, u'+      assert(NextBitCode == bitc::METADATA_NAMED_NODE); (void)NextBitCode;'), (2424, 1, u'+        assert((CT != LandingPadInst::Catch ||'), (2427, 1, u'+        assert((CT != LandingPadInst::Filter ||'), (2732, 1, u'+  assert(DFII != DeferredFunctionInfo.end() && "Deferred function not found!");'), (2774, 1, u'+  assert(DeferredFunctionInfo.count(F) && "No info to read function later?");'), (2782, 1, u'+  assert(M == TheModule &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(846, 1, u'+        assert (0 && "Unknown FP type!");'), (889, 1, u'+        assert(EltTy->isDoubleTy() && "Unknown ConstantData element type");'), (912, 1, u'+          assert(CE->getNumOperands() == 2 && "Unknown constant expr!");'), (1041, 1, u'+      assert(isa<BinaryOperator>(I) && "Unknown instruction!");'), (1815, 1, u'+  assert(Buffer.size() >= DarwinBCHeaderSize &&')]
===========================================
Class:  class WriteBitcodePass : public ModulePass {   class WriteBitcodePass : public ModulePass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(114, 1, u'+  assert(I != InstructionMap.end() && "Instruction is not mapped!");'), (125, 1, u'+    assert(I != MDValueMap.end() && "Value not in slotcalculator!");'), (130, 1, u'+  assert(I != ValueMap.end() && "Value not in slotcalculator!");'), (242, 1, u'+  assert((isa<MDNode>(MD) || isa<MDString>(MD)) && "Invalid metadata kind");'), (274, 1, u'+  assert(N->isFunctionLocal() && N->getFunction() &&'), (306, 1, u'+  assert(!V->getType()->isVoidTy() && "Can\'t insert void values!");'), (307, 1, u'+  assert(!isa<MDNode>(V) && !isa<MDString>(V) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(115, 1, u'+    assert(GV->hasInitializer() &&'), (122, 1, u'+  assert((GV || isa<ConstantPointerNull>(V)) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(109, 1, u'+  assert(DD == 0 && DE == 0 && "Debug/EH info didn\'t get finalized");'), (176, 1, u'+  assert(MI && "AsmPrinter didn\'t require GCModuleInfo?");'), (537, 1, u'+    assert(Op.isReg() && "KILL instruction must have only register operands");'), (584, 1, u'+    assert(MI->getOperand(0).isReg() && "Unknown operand type");'), (644, 1, u'+  assert(FoundOne);'), (918, 1, u'+        assert(I->hasLocalLinkage() && "Invalid alias linkage");'), (929, 1, u'+  assert(MI && "AsmPrinter didn\'t require GCModuleInfo?");'), (1144, 1, u'+  assert(MBB && MBB->getNumber() >= 0 && "Invalid basic block");'), (1202, 1, u'+  assert(Value && "Unknown entry kind!");'), (1226, 1, u'+  assert(GV->hasInitializer() && "Not a special LLVM global!");'), (1575, 1, u'+  assert(!Data.empty() && "Empty aggregates should be CAZ node");'), (1611, 1, u'+    assert(CA->getNumOperands() != 0 && "Should be a CAZ");'), (1658, 1, u'+    assert(CDS->getElementType()->isFloatTy());'), (1671, 1, u'+    assert(CDS->getElementType()->isDoubleTy());'), (1747, 1, u'+  assert(SizeSoFar == Layout->getSizeInBytes() &&'), (1821, 1, u'+  assert(CFP->getType()->isPPC_FP128Ty() &&'), (1840, 1, u'+  assert((BitWidth & 63) == 0 && "only support multiples of 64-bits");'), (2045, 1, u'+  assert(Header && "No header for loop");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(158, 1, u'+  assert((!Label->isInSection() || &Label->getSection() == &Section) &&'), (193, 1, u'+    assert(Dst.isReg() && "Machine move not supported yet.");'), (196, 1, u'+    assert(!Dst.isReg() && "Machine move not supported yet.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 1, u'+  assert(DiagInfo && "Diagnostic context not passed down?");'), (72, 1, u'+  assert(!Str.empty() && "Can\'t emit empty inline asm block");'), (142, 1, u'+  assert(MI->isInlineAsm() && "printInlineAsm only works on inline asms");'), (150, 1, u'+    assert(NumDefs != NumOperands-2 && "No asm string?");'), (152, 1, u'+  assert(MI->getOperand(NumDefs).isSymbol() && "No asm string?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+  assert(Data.empty() && "Already finalized!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(132, 1, u'+  assert(FileID && "Invalid file id");'), (148, 1, u'+  assert(FileID && "Invalid file id");'), (167, 1, u'+  assert(FileID && "Invalid file id");'), (184, 1, u'+  assert(FileID && "Invalid file id");'), (202, 1, u'+  assert(FileID && "Invalid file id");'), (220, 1, u'+  assert(FileID && "Invalid file id");'), (488, 1, u'+  assert(MO.isImm() && "Invalid machine operand!");'), (509, 1, u'+  assert (MO.isFPImm() && "Invalid machine operand!");'), (625, 1, u'+    assert(Ty.isDerivedType() && "Unknown kind of DIType");')]
===========================================
Class:    Class = In.slice(In.find('[') + 1, In.find(' '));
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(272, 1, u'+  assert(SPDie && "Unable to find subprogram DIE!");'), (365, 1, u'+  assert(Start->isDefined() && "Invalid starting label for an inlined scope!");'), (366, 1, u'+  assert(End->isDefined() && "Invalid end label for an inlined scope!");'), (380, 1, u'+  assert(Ranges.empty() == false &&'), (400, 1, u'+  assert(StartLabel->isDefined() &&'), (402, 1, u'+  assert(EndLabel->isDefined() &&'), (761, 1, u'+        assert(SPCU && "Unable to find Compile Unit!");'), (934, 1, u'+  assert(MI->isDebugValue() && "Invalid DBG_VALUE machine instruction!");'), (1009, 1, u'+    assert(MInsn->isDebugValue() && "History must begin with debug value");'), (1030, 1, u'+      assert(Begin->isDebugValue() && "Invalid History entry");'), (1054, 1, u'+          assert(SLabel && "Forgot label after clobber instruction");'), (1081, 1, u'+  assert(Label && "Didn\'t insert label before instruction");'), (1183, 1, u'+      assert(RI->first && "InsnRange does not have first instruction!");'), (1184, 1, u'+      assert(RI->second && "InsnRange does not have second instruction!");'), (1228, 1, u'+  assert(UserVariables.empty() && DbgValues.empty() && "Maps weren\'t cleaned");'), (1242, 1, u'+        assert(MI->getNumOperands() > 1 && "Invalid machine instruction!");'), (1410, 1, u'+  assert(TheCU && "Unable to find compile unit!");'), (1528, 1, u'+    assert(Abbrev->getChildrenFlag() == dwarf::DW_CHILDREN_yes &&'), (1609, 1, u'+    assert(Form && "Too many attributes for DIE (check abbreviation)");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 1, u'+        assert(Actions.size());'), (141, 1, u'+          assert(PrevAction != (unsigned)-1 && "PrevAction is invalid!");'), (152, 1, u'+        assert(-1 - TypeID < (int)FilterOffsets.size() && "Unknown filter id!");'), (188, 1, u'+  assert(MI->isCall() && "This should be a call instruction!");'), (265, 1, u'+      assert(BeginLabel == LandingPad->BeginLabels[P.RangeIndex] &&'), (279, 1, u'+      assert(BeginLabel && LastLabel && "Invalid landing pad!");'), (377, 1, u'+      assert(!PadMap.count(BeginLabel) && "Duplicate landing pad labels!");'), (552, 1, u'+    assert(Asm->MAI->isExceptionHandlingDwarf());')]
===========================================
Class:  class OcamlGCMetadataPrinter : public GCMetadataPrinter {   class OcamlGCMetadataPrinter : public GCMetadataPrinter 
Class:  class BranchFolderPass : public MachineFunctionPass {   class BranchFolderPass : public MachineFunctionPass 
Class:  class CodePlacementOpt : public MachineFunctionPass {   class CodePlacementOpt : public MachineFunctionPass 
Class:class DefaultVLIWScheduler : public ScheduleDAGInstrs { class DefaultVLIWScheduler : public ScheduleDAGInstrs 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(84, 1, u'+  assert(CachedTable.count(StateTrans) != 0);'), (184, 1, u'+  assert(MBB->end() == EndItr && "Bad EndIndex");'), (209, 1, u'+    assert(SUI && "Missing SUnit Info!");'), (219, 1, u'+        assert(SUJ && "Missing SUnit Info!");')]
===========================================
Class:  class DeadMachineInstructionElim : public MachineFunctionPass {   class DeadMachineInstructionElim : public MachineFunctionPass 
Class:  class DwarfEHPrepare : public FunctionPass {   class DwarfEHPrepare : public FunctionPass 
Class:class ExeDepsFix : public MachineFunctionPass { class ExeDepsFix : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(196, 1, u'+  assert(Reg < AliasMap.size() && "Invalid register");'), (206, 1, u'+  assert(dv->Refs == 0 && "Reference count wasn\'t cleared");'), (207, 1, u'+  assert(!dv->Next && "Chained DomainValue shouldn\'t have been recycled");'), (215, 1, u'+    assert(DV->Refs && "Bad DomainValue");'), (251, 1, u'+  assert(unsigned(rx) < NumRegs && "Invalid index");'), (252, 1, u'+  assert(LiveRegs && "Must enter basic block first.");'), (263, 1, u'+  assert(unsigned(rx) < NumRegs && "Invalid index");'), (264, 1, u'+  assert(LiveRegs && "Must enter basic block first.");'), (274, 1, u'+  assert(unsigned(rx) < NumRegs && "Invalid index");'), (275, 1, u'+  assert(LiveRegs && "Must enter basic block first.");'), (285, 1, u'+      assert(LiveRegs[rx].Value && "Not live after collapse?");'), (297, 1, u'+  assert(dv->hasDomain(domain) && "Cannot collapse");'), (314, 1, u'+  assert(!A->isCollapsed() && "Cannot merge into collapsed");'), (315, 1, u'+  assert(!B->isCollapsed() && "Cannot merge from collapsed");'), (378, 1, u'+    assert(fi->second && "Can\'t have NULL entries");'), (413, 1, u'+  assert(LiveRegs && "Must enter basic block first.");'), (454, 1, u'+  assert(!MI->isDebugValue() && "Won\'t process debug values");'), (605, 1, u'+      assert(dv->AvailableDomains && "Domain should have been filtered");'), (647, 1, u'+  assert(NumRegs == RC->getNumRegs() && "Bad regclass");')]
===========================================
Class:  class ExpandISelPseudos : public MachineFunctionPass {   class ExpandISelPseudos : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 1, u'+    assert(MII != MI->getParent()->begin() &&'), (98, 1, u'+  assert((MI->getOperand(0).isReg() && MI->getOperand(0).isDef()) &&'), (105, 1, u'+  assert(!MI->getOperand(2).getSubReg() && "SubIdx on physreg?");'), (108, 1, u'+  assert(SubIdx != 0 && "Invalid index for insert_subreg");'), (111, 1, u'+  assert(TargetRegisterInfo::isPhysicalRegister(DstReg) &&'), (113, 1, u'+  assert(TargetRegisterInfo::isPhysicalRegister(InsReg) &&')]
===========================================
Class:  class Printer : public FunctionPass {   class Printer : public FunctionPass 
Class:   class Deleter : public FunctionPass {   class Deleter : public FunctionPass 
Class:  class LowerIntrinsics : public FunctionPass {   class LowerIntrinsics : public FunctionPass 
Class:                class GCMachineCodeAnalysis : public MachineFunctionPass {   class GCMachineCodeAnalysis : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(166, 1, u'+  assert(MI && "LowerIntrinsics didn\'t require GCModuleInfo!?");'), (388, 1, u'+  assert(TFI && "TargetRegisterInfo not available!");')]
===========================================
Class:  class IfConverter : public MachineFunctionPass {   class IfConverter : public MachineFunctionPass 
Class:class InlineSpiller : public Spiller { class InlineSpiller : public Spiller 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 1, u'+  assert(!hasRefs() && "Cannot reset cache entry with references");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(167, 1, u'+  assert(V->getType()->isIntegerTy() && "Can\'t bswap a non-integer type!");'), (263, 1, u'+  assert(V->getType()->isIntegerTy() && "Can\'t ctpop a non-integer type!");'), (345, 1, u'+  assert(Callee && "Cannot lower an indirect call!");'), (539, 1, u'+  assert(CI->use_empty() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+  assert(AsmInfo && "MCAsmInfo not initialized."')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(134, 1, u'+  assert(!Queue.empty() && "Queue is empty!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(191, 1, u'+  assert(N && "Invalid Scope encoding!");'), (215, 1, u'+  assert (Scope && "Unable to calculate scop edominance graph!");'), (252, 1, u'+    assert (S && "Lost LexicalScope for a machine instruction!");')]
===========================================
Class:class UserValueScopes { class UserValueScopes 
Class:class LDVImpl;
Class:class UserValue { class UserValue 
Class:class LDVImpl { class LDVImpl 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 1, u'+  assert(!empty() && "empty interval");'), (92, 1, u'+  assert((StartPos->start <= i->start || StartPos == other.begin()) &&'), (101, 1, u'+      assert(StartPos < other.end() && i < end());'), (128, 1, u'+  assert(Start < End && "Invalid range");'), (156, 1, u'+    assert(!VNI->isUnused() && "Unused valno used by live range");'), (167, 1, u'+  assert(I != ranges.end() && "Not a valid interval!");'), (173, 1, u'+    assert(MergeTo->valno == ValNo && "Cannot merge with differing values!");'), (197, 1, u'+  assert(I != ranges.end() && "Not a valid interval!");'), (208, 1, u'+    assert(MergeTo->valno == ValNo && "Cannot merge with differing values!");'), (244, 1, u'+      assert(B->end <= Start &&'), (266, 1, u'+      assert(it->start >= End &&'), (299, 1, u'+  assert(I != ranges.end() && "Range is not in interval!");'), (300, 1, u'+  assert(I->containsRange(Start, End) && "Range is not entirely in interval!");'), (399, 1, u'+      assert(nextValNo != 0 && "Huh?");'), (448, 1, u'+    assert(I->valno && "Adding a dead range?");'), (498, 1, u'+  assert(V1 != V2 && "Identical value#\'s are always equivalent!");'), (594, 1, u'+    assert(0 && "Joining to spilled interval");'), (600, 1, u'+    assert(0 && "Joining from spilled interval");'), (624, 1, u'+      assert(I->valno == getValNumInfo(I->valno->id) && "Bad VNInfo");'), (680, 1, u'+      assert(MBB && "Phi-def has no defining MBB");'), (706, 1, u'+  assert(LIV[0] && "LIV[0] must be set");'), (721, 1, u'+    assert(VNI && "Interval not live at use.");'), (731, 1, u'+      assert((LIV[eq]->empty() || LIV[eq]->expiredAt(I->start)) &&')]
===========================================
Class:      class LiveIntervals::HMEditor { class LiveIntervals::HMEditor 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(146, 1, u'+      assert(MI.getOperand(MOIdx).getSubReg() != MO.getSubReg() &&'), (191, 1, u'+    assert(!MO.readsReg() && "First def cannot also read virtual register "'), (195, 1, u'+    assert(ValNo->id == 0 && "First value in interval is not 0?");'), (212, 1, u'+        assert(vi.AliveBlocks.empty() &&'), (234, 1, u'+      assert(vi.AliveBlocks.empty() && "Phi join can\'t pass through blocks");'), (260, 1, u'+        assert(getInstructionFromIndex(Start) == 0 &&'), (420, 1, u'+  assert(!isAllocatable(interval.reg) && "Physregs shouldn\'t be live out!");'), (428, 1, u'+    assert(isRegLiveIntoSuccessor(MBB, interval.reg) &&'), (433, 1, u'+  assert(start < end && "did not find end of interval?");'), (461, 1, u'+  assert(TargetRegisterInfo::isPhysicalRegister(interval.reg) &&'), (463, 1, u'+  assert((!isAllocatable(interval.reg) || MBB->getParent()->begin() ||'), (532, 1, u'+  assert(getInstructionFromIndex(defIdx) == 0 &&'), (582, 1, u'+      assert(indexes_->getInstructionFromIndex(MIIndex) == MI &&'), (643, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(li->reg)'), (675, 1, u'+      assert(VNI && "Early-clobber tied value not available");'), (704, 1, u'+      assert(ExtVNI == VNI && "Unexpected existing value number");'), (731, 1, u'+      assert(li->getVNInfoBefore(Stop) == VNI &&'), (745, 1, u'+    assert(LII != NewLI.end() && "Missing live range for PHI");'), (757, 1, u'+      assert(MI && "No instruction defining live value");'), (986, 1, u'+    assert(*SlotI >= LiveI->start);'), (1045, 1, u'+    assert(NewIdx != OldIdx && "No-op move? That\'s a bit strange.");'), (1074, 1, u'+    assert(validator.rangesOk() && "moveAllOperandsFrom broke liveness.");'), (1086, 1, u'+    assert(LIS.getSlotIndexes()->getInstructionFromIndex(OldIdx) == MI &&'), (1094, 1, u'+    assert(!hasRegMaskOp && "Can\'t have RegMask operand in bundle.");'), (1099, 1, u'+      assert(!hasRegMaskOp && "Can\'t have RegMask operand in bundle.");'), (1105, 1, u'+    assert(!hasRegMaskOp && "Can\'t have RegMask operand in bundle.");'), (1121, 1, u'+    assert(validator.rangesOk() && "moveAllOperandsInto broke liveness.");'), (1193, 1, u'+          assert(LR != 0 && "No EC range?");'), (1200, 1, u'+          assert(LR != 0 && "No dead-def range?");'), (1204, 1, u'+          assert(LR && LR->end > OldIdx.getDeadSlot() &&'), (1220, 1, u'+      assert(!MO.isRegMask() && "Can\'t have RegMasks in bundles.");'), (1241, 1, u'+        assert(!MO.isEarlyClobber() && "Early clobbers not allowed in bundles.");'), (1242, 1, u'+        assert(!MO.isDead() && "Dead-defs not allowed in bundles.");'), (1244, 1, u'+        assert(LR != 0 && "Internal ranges not allowed in bundles.");'), (1286, 1, u'+    assert(OldKillMI->killsRegister(reg) && "Old \'kill\' instr isn\'t a kill.");'), (1287, 1, u'+    assert(!NewKillMI->killsRegister(reg) && "New kill instr is already a kill.");'), (1296, 1, u'+    assert(*RI == OldIdx && "No RegMask at OldIdx.");'), (1298, 1, u'+    assert(*prior(RI) < *RI && *RI < *next(RI) &&'), (1337, 1, u'+        assert(LR->end > OldIdx && "LiveRange does not cover original slot");'), (1361, 1, u'+    assert(OldIdx < LR->start && LR->start < OldIdx.getDeadSlot() &&'), (1380, 1, u'+    assert(OldIdx < LR->start && LR->start < OldIdx.getDeadSlot() &&'), (1382, 1, u'+    assert(LR->end > OldIdx.getDeadSlot() && "Range should exit OldIdx.");'), (1400, 1, u'+      assert((LR->start < NewIdx || BR[LI->reg].Def == LR) &&'), (1402, 1, u'+      assert((BR[LI->reg].Use == 0 || BR[LI->reg].Use == LR) &&'), (1413, 1, u'+      assert(BR[LI->reg].Dead == 0 && BR[LI->reg].Def == 0 &&'), (1415, 1, u'+      assert((BR[LI->reg].Use == 0 || BR[LI->reg].Use == LR) &&'), (1421, 1, u'+      assert(LR->start == NewIdx.getRegSlot(LR->start.isEarlyClobber()) &&'), (1423, 1, u'+      assert(BR[LI->reg].Def == LR && "Reg should have def range.");'), (1424, 1, u'+      assert(BR[LI->reg].Dead == 0 &&'), (1439, 1, u'+      assert(BR[LI->reg].Use == 0 &&'), (1445, 1, u'+      assert(BR[LI->reg].Use != 0 &&'), (1482, 1, u'+    assert(LR->start.isRegister() &&'), (1492, 1, u'+      assert(BR[LI->reg].Def == 0 &&'), (1499, 1, u'+      assert(LR->end == NewIdx.getRegSlot() &&'), (1508, 1, u'+        assert(BR[LI->reg].Use == LR &&'), (1531, 1, u'+  assert(getMBBStartIdx(MI->getParent()) <= OldIndex &&'), (1534, 1, u'+  assert(!MI->isBundled() && "Can\'t handle bundled instructions yet.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 1, u'+    assert(SegPos.value() == &VirtReg && "Inconsistent LiveInterval");'), (146, 1, u'+    assert(VirtRegI != VirtRegEnd && "Reached end of VirtReg");'), (168, 1, u'+    assert(VirtRegI->end <= LiveUnionI.start() && "Expected non-overlap");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(38, 1, u'+    assert(VNI && "No live-in value found");'), (49, 1, u'+      assert(Seen.test(MBB->getNumber()));'), (62, 1, u'+  assert(LI && "Missing live range");'), (63, 1, u'+  assert(Kill.isValid() && "Invalid SlotIndex");'), (64, 1, u'+  assert(Indexes && "Missing SlotIndexes");'), (65, 1, u'+  assert(DomTree && "Missing dominator tree");'), (68, 1, u'+  assert(KillMBB && "No MBB at Kill");'), (94, 1, u'+  assert(Indexes && "Missing SlotIndexes");'), (95, 1, u'+  assert(DomTree && "Missing dominator tree");'), (116, 1, u'+    assert(!MBB->pred_empty() && "Value live-in to entry block?");'), (162, 1, u'+  assert(LiveIn.back().DomNode->getBlock() == KillMBB);'), (174, 1, u'+  assert(Indexes && "Missing SlotIndexes");'), (175, 1, u'+  assert(DomTree && "Missing dominator tree");'), (237, 1, u'+        assert(Alloc && "Need VNInfo allocator to create PHI-defs");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+  assert(DefMI && "Missing instruction");'), (104, 1, u'+  assert(scannedRemattable_ && "Call anyRematerializable first");'), (117, 1, u'+    assert(RM.OrigMI && "No defining instruction for remattable value");'), (137, 1, u'+  assert(RM.OrigMI && "Invalid remat");'), (205, 1, u'+      assert(MI->allDefsAreDead() && "Def isn\'t really dead");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 1, u'+  assert(Slot >= 0 && "Spill slot indice must be >= 0");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(84, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(RegIdx) &&'), (112, 1, u'+  assert(MBB != &MF->front() && "Can\'t find reaching def for virtreg");'), (131, 1, u'+  assert(MRI->getVRegDef(reg) && "Register use before def!");'), (147, 1, u'+    assert(VRInfo.Kills[i]->getParent() != MBB && "entry should be at end!");'), (379, 1, u'+          assert(!MO->isDead());'), (541, 1, u'+      assert(TargetRegisterInfo::isPhysicalRegister(*II) &&'), (637, 1, u'+        assert(TargetRegisterInfo::isPhysicalRegister(*I) &&'), (690, 1, u'+    assert(Visited.count(&*i) != 0 && "unreachable basic block found");'), (718, 1, u'+        assert(removed && "kill not in register\'s VarInfo?");')]
===========================================
Class:  class FrameRef {   class FrameRef 
Class:   class LocalStackSlotPass: public MachineFunctionPass {   class LocalStackSlotPass: public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(285, 1, u'+        assert(MFI->isObjectPreAllocated(FrameIdx) &&'), (342, 1, u'+          assert(BaseReg != 0 && "Unable to allocate virtual base register!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 1, u'+  assert(N->getParent() == 0 && "machine instruction already in a basic block");'), (109, 1, u'+  assert(N->getParent() != 0 && "machine instruction not in a basic block");'), (126, 1, u'+  assert(Parent->getParent() == fromList.Parent->getParent() &&'), (139, 1, u'+  assert(!MI->getParent() && "MI is still in a block!");'), (147, 1, u'+  assert(!I->isInsideBundle() && "First non-phi MI cannot be inside a bundle!");'), (158, 1, u'+  assert(!I->isInsideBundle() &&'), (352, 1, u'+  assert(!B && "UpdateTerminators requires analyzable predecessors!");'), (366, 1, u'+        assert(!TBB && "Found more than one non-landing-pad successor!");'), (402, 1, u'+        assert(!FallthroughBB && "Found more than one fallthrough successor.");'), (455, 1, u'+  assert(I != Successors.end() && "Not a current successor!");'), (468, 1, u'+  assert(I != Successors.end() && "Not a current successor!");'), (502, 1, u'+  assert(I != Predecessors.end() && "Pred is not a predecessor of this block!");'), (741, 1, u'+          assert(DestLoop->getHeader() == Succ &&'), (791, 1, u'+  assert(getParent() && "Not embedded in a function!");'), (800, 1, u'+  assert(getParent() && "Not embedded in a function!");'), (809, 1, u'+  assert(Old != New && "Cannot replace self with self!");'), (867, 1, u'+    assert(DestA && DestB && isCond &&'), (921, 1, u'+  assert(Weights.size() == Successors.size() && "Async weight list!");'), (923, 1, u'+  assert(index < Weights.size() && "Not a current successor!");'), (931, 1, u'+  assert(Weights.size() == Successors.size() && "Async weight list!");'), (933, 1, u'+  assert(index < Weights.size() && "Not a current successor!");')]
===========================================
Class:class BlockChain;
Class:class BlockChain { class BlockChain 
Class:class MachineBlockPlacement : public MachineFunctionPass { class MachineBlockPlacement : public MachineFunctionPass 
Class:class IsBlockPlaced { class IsBlockPlaced 
Class:class MachineBlockPlacementStats : public MachineFunctionPass { class MachineBlockPlacementStats : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+  assert(MBB->succ_size() < UINT32_MAX);'), (51, 1, u'+  assert((Sum / UINT32_MAX) < UINT32_MAX);'), (59, 1, u'+  assert(Sum <= UINT32_MAX);')]
===========================================
Class:  class MachineCSE : public MachineFunctionPass {   class MachineCSE : public MachineFunctionPass 
Class:  class MachineCopyPropagation : public MachineFunctionPass {   class MachineCopyPropagation : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(129, 1, u'+        assert(MBBNumbering[MBBI->getNumber()] == &*MBBI &&'), (145, 1, u'+  assert(BlockNo <= MBBNumbering.size() && "Mismatch!");'), (190, 1, u'+  assert(MBB->getParent() == this && "MBB parent mismatch!");'), (400, 1, u'+    assert(MRI.getRegClass(VReg) == RC && "Register class mismatch!");'), (413, 1, u'+  assert(JumpTableInfo && "No jump tables");'), (415, 1, u'+  assert(JTI < JumpTableInfo->getJumpTables().size() && "Invalid JTI!");'), (445, 1, u'+  assert(Size != 0 && "Cannot allocate zero size fixed stack objects!");'), (460, 1, u'+  assert(MBB && "MBB must be valid");'), (462, 1, u'+  assert(MF && "MBB must be part of a MachineFunction");'), (576, 1, u'+  assert(!DestBBs.empty() && "Cannot create an empty jump table!");'), (585, 1, u'+  assert(Old != New && "Not making a change?");'), (597, 1, u'+  assert(Old != New && "Not making a change?");'), (704, 1, u'+  assert(Alignment && "Alignment must be specified!");'), (724, 1, u'+  assert(Alignment && "Alignment must be specified!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 1, u'+  assert(!MF && "MachineFunctionAnalysis left initialized!");'), (39, 1, u'+  assert(MMI && "MMI not around yet??");'), (47, 1, u'+  assert(!MF && "MachineFunctionAnalysis already initialized!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+  assert(isReg() && "Can only add reg operand to use lists");'), (75, 1, u'+    assert(getReg() == Contents.Reg.Next->getReg() &&'), (87, 1, u'+  assert(isOnRegUseList() && "Reg operand is not on a use list");'), (92, 1, u'+    assert(NextOp->getReg() == getReg() && "Corrupt reg use/def chain!");'), (120, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(Reg));'), (129, 1, u'+  assert(TargetRegisterInfo::isPhysicalRegister(Reg));'), (162, 1, u'+    assert(!isEarlyClobber());'), (389, 1, u'+  assert((PtrInfo.V == 0 || isa<PointerType>(PtrInfo.V->getType())) &&'), (391, 1, u'+  assert(getBaseAlignment() == a && "Alignment is not a power of 2!");'), (392, 1, u'+  assert((isLoad() || isStore()) && "Not a load/store!");'), (407, 1, u'+  assert(MMO->getFlags() == getFlags() && "Flags mismatch!");'), (408, 1, u'+  assert(MMO->getSize() == getSize() && "Size mismatch!");'), (427, 1, u'+  assert((MMO.isLoad() || MMO.isStore()) &&'), (538, 1, u'+  assert(MBB && "Cannot use inserting ctor with null basic block!");'), (554, 1, u'+  assert(MBB && "Cannot use inserting ctor with null basic block!");'), (589, 1, u'+    assert(Operands[i].ParentMI == this && "ParentMI mismatch!");'), (590, 1, u'+    assert((!Operands[i].isReg() || !Operands[i].isOnRegUseList()) &&'), (631, 1, u'+  assert(MCID && "Cannot add operands before providing an instr descriptor");'), (659, 1, u'+  assert((isImpReg || MCID->isVariadic() || OpNo < MCID->getNumOperands()) &&'), (694, 1, u'+      assert(Operands[i].isReg() && "Should only be an implicit reg!");'), (704, 1, u'+  assert(OpNo < Operands.size() && "Invalid operand number");'), (838, 1, u'+  assert(getParent() && "Not embedded in a basic block!");'), (859, 1, u'+  assert(getParent() && "Not embedded in a basic block!");'), (911, 1, u'+  assert(isInlineAsm() && "Expected an inline asm instruction");'), (912, 1, u'+  assert(OpIdx < getNumOperands() && "OpIdx out of range");'), (972, 1, u'+  assert(isBundle() && "Expecting a bundle");'), (979, 1, u'+  assert(Size > 1 && "Malformed bundle");'), (1091, 1, u'+    assert(DefOpIdx > InlineAsm::MIOp_FirstOperand);'), (1122, 1, u'+  assert(getOperand(DefOpIdx).isDef() && "DefOpIdx is not a def!");'), (1162, 1, u'+        assert(FMO.isImm());'), (1219, 1, u'+  assert(!isBundle() && "MachineInstr::copyPredicates() can\'t handle bundles");'), (1384, 1, u'+  assert(getNumOperands() >= 3 &&')]
===========================================
Class:  class UnpackMachineBundles : public MachineFunctionPass {   class UnpackMachineBundles : public MachineFunctionPass 
Class:  class FinalizeMachineBundles : public MachineFunctionPass {   class FinalizeMachineBundles : public MachineFunctionPass 
Class:  class MachineLICM : public MachineFunctionPass {   class MachineLICM : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(436, 1, u'+    assert(TargetRegisterInfo::isPhysicalRegister(Reg) &&'), (700, 1, u'+    assert(Node != 0 && "Null dominator tree node?");'), (879, 1, u'+  assert (MI.mayLoad() && "Expected MI that loads!");'), (955, 1, u'+    assert(MRI->getVRegDef(Reg) &&'), (1274, 1, u'+  assert(Success &&'), (1277, 1, u'+  assert(NewMIs.size() == 2 &&'), (1343, 1, u'+      assert((!MO.isReg() || MO.getReg() == 0 ||')]
===========================================
Class:class MMIAddrLabelMapCallbackPtr : CallbackVH { class MMIAddrLabelMapCallbackPtr : CallbackVH 
Class: class MMIAddrLabelMap { class MMIAddrLabelMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+    assert(!PhysRegUseDefLists[i] &&'), (99, 1, u'+  assert(RegClass && "Cannot create register without RegClass!");'), (100, 1, u'+  assert(RegClass->isAllocatable() &&'), (123, 1, u'+    assert(VRegInfo[TargetRegisterInfo::index2VirtReg(i)].second == 0 &&'), (148, 1, u'+  assert(FromReg != ToReg && "Cannot replace a reg with itself");'), (268, 1, u'+  assert(TargetRegisterInfo::isPhysicalRegister(PhysReg));')]
===========================================
Class:  class MachinePHIiter {   class MachinePHIiter 
Class:class SSAUpdaterTraits<MachineSSAUpdater> { class SSAUpdaterTraits<MachineSSAUpdater> 
Class:class MachineScheduler : public MachineSchedContext, class MachineScheduler : public MachineSchedContext,
Class:class ScheduleDAGMI;
Class:      class MachineSchedStrategy { class MachineSchedStrategy 
Class:class ScheduleDAGMI : public ScheduleDAGInstrs { class ScheduleDAGMI : public ScheduleDAGInstrs 
Class:class ConvergingScheduler : public MachineSchedStrategy { class ConvergingScheduler : public MachineSchedStrategy 
Class:class InstructionShuffler : public MachineSchedStrategy { class InstructionShuffler : public MachineSchedStrategy 
Class:  class MachineSinking : public MachineFunctionPass {   class MachineSinking : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(329, 1, u'+  assert(MF);'), (341, 1, u'+  assert(MBB);'), (353, 1, u'+  assert(MI);'), (363, 1, u'+  assert(MO);'), (563, 1, u'+  assert(MFI && "Function has no frame info");'), (848, 1, u'+          assert(VNI && "NULL valno is not allowed");'), (1044, 1, u'+  assert(LiveVars && "Don\'t call verifyLiveVariables without LiveVars");'), (1071, 1, u'+  assert(LiveInts && "Don\'t call verifyLiveIntervals without LiveInts");'), (1085, 1, u'+    assert(LVI->first == LI.reg && "Invalid reg to interval mapping");'), (1177, 1, u'+      assert(VNI && "Live range has no valno");'), (1301, 1, u'+        assert(LiveInts->isLiveInToMBB(LI, MFI));')]
===========================================
Class:  class OcamlGC : public GCStrategy {   class OcamlGC : public GCStrategy 
Class:  class OptimizePHIs : public MachineFunctionPass {   class OptimizePHIs : public MachineFunctionPass 
Class:  class PHIElimination : public MachineFunctionPass {   class PHIElimination : public MachineFunctionPass 
Class:class PassConfigImpl { class PassConfigImpl 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(243, 1, u'+  assert(!Initialized && "PassConfig is immutable");'), (262, 1, u'+  assert(!Initialized && "PassConfig is immutable");')]
===========================================
Class:  class PeepholeOptimizer : public MachineFunctionPass {   class PeepholeOptimizer : public MachineFunctionPass 
Class:  class PostRAScheduler : public MachineFunctionPass {   class PostRAScheduler : public MachineFunctionPass 
Class:   class SchedulePostRATDList : public ScheduleDAGInstrs {   class SchedulePostRATDList : public ScheduleDAGInstrs 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(72, 1, u'+  assert(!Fn.getRegInfo().getNumVirtRegs() && "Regalloc must assign all vregs");'), (175, 1, u'+        assert(I->getNumOperands() >= 1 && "Call Frame Setup/Destroy Pseudo"'), (347, 1, u'+          assert(I != MBB->begin() &&'), (378, 1, u'+    assert(blockCSI.size() > 0 &&'), (412, 1, u'+    assert(blockCSI.size() > 0 &&'), (446, 1, u'+      assert(I != MBB->begin() &&'), (506, 1, u'+  assert(LocalAreaOffset >= 0'), (715, 1, u'+  assert(TM.getRegisterInfo() && "TM::getRegisterInfo() must be implemented!");'), (803, 1, u'+    assert((SPAdjCount || SPAdj == 0) &&'), (844, 1, u'+            assert(MI->getOperand(i).isDef() &&'), (854, 1, u'+          assert (ScratchReg && "Missing scratch register!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(64, 1, u'+    assert(!VisitedVRegs.intersects(VRegs) && "vreg in multiple unions");'), (149, 1, u'+  assert(!VRM->hasPhys(VirtReg.reg) && "Duplicate VirtReg assignment");'), (159, 1, u'+  assert(VRM->getPhys(VirtReg.reg) == PhysReg && "Inconsistent unassign");'), (172, 1, u'+    assert(!VRM->hasPhys(VirtReg->reg) && "Register already assigned");'), (219, 1, u'+      assert(!VRM->hasPhys(SplitVirtReg->reg) && "Register already assigned");'), (226, 1, u'+      assert(TargetRegisterInfo::isVirtualRegister(SplitVirtReg->reg) &&')]
===========================================
Class:class RABasic : public MachineFunctionPass, public RegAllocBase class RABasic : public MachineFunctionPass, public RegAllocBase
Class:  class RAFast : public MachineFunctionPass {   class RAFast : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(235, 1, u'+  assert(PhysRegState[LRI->PhysReg] == LRI->VirtReg &&'), (245, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(VirtReg) &&'), (255, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(VirtReg) &&'), (258, 1, u'+  assert(LRI != LiveVirtRegs.end() && "Spilling unmapped virtual register");'), (266, 1, u'+  assert(PhysRegState[LR.PhysReg] == LRI->VirtReg && "Broken RegState mapping");'), (337, 1, u'+  assert(TargetRegisterInfo::isPhysicalRegister(PhysReg) &&'), (363, 1, u'+      assert(TRI->isSuperRegister(PhysReg, Alias) &&'), (451, 1, u'+    assert(I != LiveVirtRegs.end() && "Missing VirtReg entry");'), (473, 1, u'+      assert(I != LiveVirtRegs.end() && "Missing VirtReg entry");'), (491, 1, u'+  assert(!LR.PhysReg && "Already assigned a physreg");'), (498, 1, u'+  assert(LRI != LiveVirtRegs.end() && "VirtReg disappeared");'), (509, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(VirtReg) &&'), (578, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(VirtReg) &&'), (599, 1, u'+  assert(LRI->PhysReg && "Register not assigned");'), (611, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(VirtReg) &&'), (650, 1, u'+  assert(LRI->PhysReg && "Register not assigned");'), (797, 1, u'+    assert(TargetRegisterInfo::isPhysicalRegister(Reg) &&'), (834, 1, u'+  assert(LiveVirtRegs.empty() && "Mapping not cleared from last block?");'), (865, 1, u'+            assert(I != LiveVirtRegs.end() && "Missing VirtReg entry");'), (868, 1, u'+            assert(I->PhysReg == Reg && "Bad inverse map");'), (877, 1, u'+           assert(TargetRegisterInfo::isVirtualRegister(i->VirtReg) &&'), (879, 1, u'+           assert(TargetRegisterInfo::isPhysicalRegister(i->PhysReg) &&'), (881, 1, u'+           assert(PhysRegState[i->PhysReg] == i->VirtReg && "Bad inverse map");'), (1125, 1, u'+  assert(!MRI->isSSA() && "regalloc requires leaving SSA");')]
===========================================
Class:class RAGreedy : public MachineFunctionPass, class RAGreedy : public MachineFunctionPass,
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(409, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(Reg) &&'), (602, 1, u'+    assert(Q.seenAllInterferences() && "Didn\'t check all interfererences.");'), (606, 1, u'+      assert((ExtraRegInfo[Intf->reg].Cascade < Cascade ||'), (751, 1, u'+      assert(T < GroupSize && "Array overflow");'), (760, 1, u'+    assert(B < GroupSize && "Array overflow");'), (960, 1, u'+  assert(NumGlobalIntvs && "No global intervals configured");'), (1207, 1, u'+    assert(!Cand.PhysReg && "Compact region has no physreg");'), (1231, 1, u'+  assert(&SA->getParent() == &VirtReg && "Live range wasn\'t analyzed");'), (1280, 1, u'+  assert(SA->getUseBlocks().size() == 1 && "Not a local interval");'), (1333, 1, u'+  assert(SA->getUseBlocks().size() == 1 && "Not a local interval");'), (1368, 1, u'+      assert(!SlotIndex::isEarlierInstr(RMS[ri], Uses[i]));'), (1534, 1, u'+    assert(!ProgressRequired && "Didn\'t make progress when it was required.");'), (1623, 1, u'+  assert(NewVRegs.empty() && "Cannot append to existing NewVRegs");')]
===========================================
Class:class RegAllocPBQP : public MachineFunctionPass { class RegAllocPBQP : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(166, 1, u'+  assert(vregItr != node2VReg.end() && "No vreg for node.");'), (172, 1, u'+  assert(nodeItr != vreg2Node.end() && "No node for vreg.");'), (180, 1, u'+  assert(allowedSetItr != allowedSets.end() && "No pregs for vreg.");'), (186, 1, u'+  assert(isPRegOption(vreg, option) && "Not a preg option.");'), (189, 1, u'+  assert(option <= allowedSet.size() && "Option outside allowed set.");'), (270, 1, u'+        assert(regMask != 0 && "Couldn\'t find register mask.");'), (332, 1, u'+      assert(!l2.empty() && "Empty interval in vreg set?");'), (356, 1, u'+  assert(costMat.getRows() == vr1Allowed.size() + 1 && "Matrix height mismatch.");'), (357, 1, u'+  assert(costMat.getCols() == vr2Allowed.size() + 1 && "Matrix width mismatch.");'), (467, 1, u'+  assert(costMat.getRows() == vr1Allowed.size() + 1 && "Size mismatch.");'), (468, 1, u'+  assert(costMat.getCols() == vr2Allowed.size() + 1 && "Size mismatch.");'), (548, 1, u'+      assert(preg != 0 && "Invalid preg selected.");'), (563, 1, u'+        assert(!(*itr)->empty() && "Empty spill range.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 1, u'+  assert (RCI.NumRegs <= NumRegs && "Allocation order larger than regclass");')]
===========================================
Class:  class RegisterCoalescer : public MachineFunctionPass {   class RegisterCoalescer : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 1, u'+  assert((NumPhysRegs == 0 || NumPhysRegs == TRI->getNumRegs()) &&'), (88, 1, u'+  assert(MRI->tracksLiveness() &&'), (127, 1, u'+    assert(MBBI != MBB->end() && "Already past the end of the basic block!");'), (130, 1, u'+  assert(MBBI != MBB->end() && "Already at the end of the basic block!");'), (168, 1, u'+      assert(MO.isDef());'), (211, 1, u'+      assert(MO.isDef());'), (215, 1, u'+      assert((KillRegs.test(Reg) || isUnused(Reg) ||'), (270, 1, u'+  assert(Survivor > 0 && "No candidates for scavenging");'), (273, 1, u'+  assert(StartMI != ME && "MI already at terminator");'), (323, 1, u'+  assert (RestorePointMI != StartMI &&'), (365, 1, u'+  assert(ScavengedReg == 0 &&'), (375, 1, u'+    assert(ScavengingFrameIndex >= 0 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(344, 1, u'+    assert(!mapsPopulated && prWorst.empty() && vrWorst.empty() &&'), (413, 1, u'+      assert(prwItr != prWorst.end() && "Missing prWorst entry.");'), (418, 1, u'+      assert(vrwItr != vrWorst.end() && "Missing vrWorst entry.");'), (430, 1, u'+    assert(!mapsPopulated && capacityMap.empty() &&'), (447, 1, u'+    assert(cmItr != capacityMap.end() &&'), (729, 1, u'+    assert(ctsItr != cellTypeStrs.end() && "No string for given cell type.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 1, u'+    assert(NumPreds < UINT_MAX && "NumPreds will overflow!");'), (78, 1, u'+    assert(N->NumSuccs < UINT_MAX && "NumSuccs will overflow!");'), (83, 1, u'+    assert(NumPredsLeft < UINT_MAX && "NumPredsLeft will overflow!");'), (87, 1, u'+    assert(N->NumSuccsLeft < UINT_MAX && "NumSuccsLeft will overflow!");'), (119, 1, u'+      assert(FoundSucc && "Mismatching preds / succs lists!");'), (124, 1, u'+        assert(NumPreds > 0 && "NumPreds will underflow!");'), (125, 1, u'+        assert(N->NumSuccs > 0 && "NumSuccs will underflow!");'), (130, 1, u'+        assert(NumPredsLeft > 0 && "NumPredsLeft will underflow!");'), (134, 1, u'+        assert(N->NumSuccsLeft > 0 && "NumSuccsLeft will underflow!");'), (370, 1, u'+  assert(!AnyNotSched);'), (422, 1, u'+      assert(SU->Succs.empty() && "SUnit should have no successors");'), (451, 1, u'+      assert(Node2Index[SU->NodeNum] > Node2Index[I->getSUnit()->NodeNum] &&'), (470, 1, u'+    assert(!HasLoop && "Inserted edge creates a loop!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+  assert((IsPostRA || LIS) && "PreRA scheduling requires LiveIntervals");'), (46, 1, u'+  assert(!(IsPostRA && MRI.getNumVirtRegs()) &&'), (73, 1, u'+    assert(V->getType()->isIntegerTy() && "Unexpected operand type!");'), (205, 1, u'+        assert(!IsPostRA && "Virtual register encountered after regalloc.");'), (212, 1, u'+    assert(Uses.empty() && "Uses in set before adding deps?");'), (228, 1, u'+  assert(MO.isDef() && "expect physreg def");'), (254, 1, u'+        assert(RegUseIndex >= 0 && "UseMI doesn\'t use register!");'), (438, 1, u'+  assert(LIS && "vreg dependencies requires LiveIntervals");'), (527, 1, u'+  assert(Defs.empty() && Uses.empty() &&'), (532, 1, u'+  assert(VRegDefs.empty() && "Only BuildSchedGraph may access VRegDefs");'), (557, 1, u'+    assert((!MI->isTerminator() || CanHandleTerminators) && !MI->isLabel() &&'), (561, 1, u'+    assert(SU && "No SUnit mapped to this MI");'), (573, 1, u'+        assert(!IsPostRA && "Virtual register encountered!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(135, 1, u'+        assert((StageCycle - Stalls) < (int)RequiredScoreboard.getDepth() &&'), (175, 1, u'+  assert(MCID && "The scheduler must filter non-machineinstrs");'), (190, 1, u'+      assert(((cycle + i) < RequiredScoreboard.getDepth()) &&')]
===========================================
Class:  class DAGCombiner {   class DAGCombiner 
Class:class WorkListRemover : public SelectionDAG::DAGUpdateListener { class WorkListRemover : public SelectionDAG::DAGUpdateListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(308, 1, u'+  assert (I && E && std::distance(I, E) > 0 && "Invalid iterator!");'), (1346, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(Op0) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 1, u'+    assert(isNew && "Node emitted out of order - early");'), (144, 1, u'+    assert(UseRC->hasType(VT) && "Incompatible phys register def and uses!");'), (166, 1, u'+  assert(isNew && "Node emitted out of order - early");'), (191, 1, u'+  assert(Node->getMachineOpcode() != TargetOpcode::IMPLICIT_DEF &&'), (204, 1, u'+      assert(TargetRegisterInfo::isPhysicalRegister(VRBase));'), (230, 1, u'+      assert(RC && "Isn\'t a register operand!");'), (240, 1, u'+    assert(isNew && "Node emitted out of order - early");'), (264, 1, u'+  assert(I != VRBaseMap.end() && "Node emitted out of order - late");'), (278, 1, u'+  assert(Op.getValueType() != MVT::Other &&'), (283, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(VReg) && "Not a vreg?");'), (297, 1, u'+    assert((DstRC || (MI->isVariadic() && IIOpNum >= MCID.getNumOperands())) &&'), (394, 1, u'+    assert(Op.getValueType() != MVT::Other &&'), (419, 1, u'+  assert(RC && "No legal register class for VT supports that SubIdx");'), (509, 1, u'+    assert(SRC && "No register class supports VT and SubIdx for INSERT_SUBREG");'), (537, 1, u'+  assert(isNew && "Node emitted out of order - early");'), (559, 1, u'+  assert(isNew && "Node emitted out of order - early");'), (573, 1, u'+  assert((NumOps & 1) == 1 &&'), (602, 1, u'+  assert(isNew && "Node emitted out of order - early");'), (699, 1, u'+    assert(NumMIOperands >= II.getNumOperands() &&'), (702, 1, u'+    assert(NumMIOperands >= II.getNumOperands() &&'), (718, 1, u'+  assert((!HasOptPRefs || !HasPhysRegOuts) &&')]
===========================================
Class:class SelectionDAGLegalize : public SelectionDAG::DAGUpdateListener { class SelectionDAGLegalize : public SelectionDAG::DAGUpdateListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(185, 1, u'+  assert(NumEltsGrowth && "Cannot promote to vector type with fewer elts!");'), (200, 1, u'+  assert(NewMask.size() == NumDestElts && "Non-integer NumEltsGrowth?");'), (201, 1, u'+  assert(TLI.isShuffleMaskLegal(NewMask, NVT) && "Shuffle not legal?");'), (254, 1, u'+    assert((VT == MVT::f64 || VT == MVT::f32) && "Invalid type expansion");'), (296, 1, u'+  assert(ST->getAddressingMode() == ISD::UNINDEXED &&'), (381, 1, u'+  assert(ST->getMemoryVT().isInteger() &&'), (418, 1, u'+  assert(LD->getAddressingMode() == ISD::UNINDEXED &&'), (504, 1, u'+  assert(LoadedVT.isInteger() && !LoadedVT.isVector() &&'), (700, 1, u'+    assert(TLI.getTypeAction(*DAG.getContext(), Node->getValueType(i)) =='), (705, 1, u'+    assert((TLI.getTypeAction(*DAG.getContext(),'), (940, 1, u'+        assert(VT.isVector() && "Cannot promote this load!");'), (953, 1, u'+        assert(Tmp3.getNode() != Node && "Load must be completely replaced");'), (1003, 1, u'+        Result = DAG.getNode(ISD::AssertZext, dl,'), (1011, 1, u'+      assert(!SrcVT.isVector() && "Unsupported extload!");'), (1013, 1, u'+      assert(RoundWidth < SrcWidth);'), (1015, 1, u'+      assert(ExtraWidth < RoundWidth);'), (1016, 1, u'+      assert(!(RoundWidth % 8) && !(ExtraWidth % 8) &&'), (1137, 1, u'+        assert(!SrcVT.isVector() &&'), (1144, 1, u'+        assert(ExtType != ISD::EXTLOAD &&'), (1168, 1, u'+      assert(Tmp1.getNode() != Node && "Load must be completely replaced");'), (1211, 1, u'+          assert(VT.isVector() && "Unknown legal promote case!");'), (1243, 1, u'+        assert(!StVT.isVector() && "Unsupported truncstore!");'), (1245, 1, u'+        assert(RoundWidth < StWidth);'), (1247, 1, u'+        assert(ExtraWidth < RoundWidth);'), (1248, 1, u'+        assert(!(RoundWidth % 8) && !(ExtraWidth % 8) &&'), (1314, 1, u'+          assert(!StVT.isVector() &&'), (1318, 1, u'+          assert(TLI.isTypeLegal(StVT) && "Do not know how to expand this store!");'), (1365, 1, u'+  assert(Op.getValueType().isVector() && "Non-vector insert subvector!");'), (1482, 1, u'+      assert(FloatVT.isByteSized() && "Unsupported floating point type!");'), (1500, 1, u'+      assert(BitShift < LoadTy.getSizeInBits() && "Pointer advanced wrong?");'), (1523, 1, u'+  assert(SPReg && "Target cannot require DYNAMIC_STACKALLOC expansion and"'), (1630, 1, u'+    assert(SrcSize == SlotSize && "Invalid store");'), (1640, 1, u'+  assert(SlotSize < DestSize && "Unknown extension!");'), (1725, 1, u'+        assert(Node->getOperand(i).getOpcode() == ISD::UNDEF);'), (2074, 1, u'+  assert(!isSigned && "Legalize cannot Expand SINT_TO_FP for i64 yet");'), (2223, 1, u'+    assert(NewInTy.isInteger() && "Ran out of possibilities!");'), (2265, 1, u'+    assert(NewOutTy.isInteger() && "Ran out of possibilities!");'), (2359, 1, u'+    assert(VT.isInteger() && Len <= 128 && Len % 8 == 0 &&'), (2642, 1, u'+      assert(VT.isFloatingPoint() && "Unknown value type!");'), (2742, 1, u'+      assert(((Align & (Align-1)) == 0) && "Expected Align to be a power of 2");'), (2830, 1, u'+        assert(NewVT.bitsEq(VT));'), (2840, 1, u'+        assert(factor > 0);'), (3031, 1, u'+    assert(Reg && "Can\'t expand to unknown register!");'), (3039, 1, u'+    assert(Reg && "Can\'t expand to unknown register!");'), (3047, 1, u'+    assert(TLI.isOperationLegalOrCustom(ISD::FADD, VT) &&'), (3057, 1, u'+    assert(TLI.isOperationLegalOrCustom(ISD::ADD, VT) &&'), (3127, 1, u'+    assert(TLI.isOperationLegalOrCustom(ExpandOpcode, VT) &&'), (3262, 1, u'+      assert(LC != RTLIB::UNKNOWN_LIBCALL && "Cannot expand this operation!");'), (3410, 1, u'+    assert(!Tmp2.getNode() && "Can\'t legalize SELECT_CC with legal condition!");'), (3427, 1, u'+    assert(!Tmp3.getNode() && "Can\'t legalize BR_CC with legal condition!");'), (3443, 1, u'+    assert(VT.isVector() && "Unable to legalize non-vector shift");'), (3444, 1, u'+    assert(TLI.isTypeLegal(VT.getScalarType())&& "Element type must be legal");'), (3549, 1, u'+      assert(OVT.isInteger()'), (3576, 1, u'+      assert(OVT.isInteger() && "Cannot promote logic operation");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(358, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_EXTEND!");'), (375, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_ROUND!");'), (392, 1, u'+  assert(N->getOperand(1).getValueType() == MVT::i32 &&'), (557, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported XINT_TO_FP!");'), (603, 1, u'+  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (618, 1, u'+  assert((VT == MVT::f32 || VT == MVT::f64) && "Unsupported setcc type!");'), (706, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_ROUND libcall");'), (734, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_TO_SINT!");'), (742, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_TO_UINT!");'), (780, 1, u'+    assert(NewLHS.getValueType() == N->getValueType(0) &&'), (792, 1, u'+  assert(ISD::isUNINDEXEDStore(N) && "Indexed store during type legalization!");'), (793, 1, u'+  assert(OpNo == 1 && "Can only soften the stored value!");'), (886, 1, u'+  assert(NVT.getSizeInBits() == integerPartWidth &&'), (897, 1, u'+  assert(N->getValueType(0) == MVT::ppcf128 &&'), (1140, 1, u'+  assert(ISD::isUNINDEXEDLoad(N) && "Indexed load during type legalization!");'), (1147, 1, u'+  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (1148, 1, u'+  assert(LD->getMemoryVT().bitsLE(NVT) && "Float type not round?");'), (1167, 1, u'+  assert(N->getValueType(0) == MVT::ppcf128 && "Unsupported XINT_TO_FP!");'), (1194, 1, u'+    assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported XINT_TO_FP!");'), (1284, 1, u'+  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (1301, 1, u'+  assert(NewLHS.getValueType() == MVT::ppcf128 && "Unsupported setcc type!");'), (1342, 1, u'+  assert(N->getOperand(0).getValueType() == MVT::ppcf128 &&'), (1358, 1, u'+    assert(N->getOperand(0).getValueType() == MVT::ppcf128 &&'), (1368, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_TO_SINT!");'), (1379, 1, u'+    assert(N->getOperand(0).getValueType() == MVT::ppcf128 &&'), (1400, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported FP_TO_UINT!");'), (1429, 1, u'+    assert(NewLHS.getValueType() == N->getValueType(0) &&'), (1443, 1, u'+  assert(ISD::isUNINDEXEDStore(N) && "Indexed store during type legalization!");'), (1444, 1, u'+  assert(OpNo == 1 && "Can only expand the stored value so far");'), (1452, 1, u'+  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (1453, 1, u'+  assert(ST->getMemoryVT().bitsLE(NVT) && "Float type not round?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 1, u'+  case ISD::AssertSext:  Res = PromoteIntRes_AssertSext(N); break;'), (52, 1, u'+  case ISD::AssertZext:  Res = PromoteIntRes_AssertZext(N); break;'), (153, 1, u'+SDValue DAGTypeLegalizer::PromoteIntRes_AssertSext(SDNode *N) {'), (156, 1, u'+  return DAG.getNode(ISD::AssertSext, N->getDebugLoc(),'), (160, 1, u'+SDValue DAGTypeLegalizer::PromoteIntRes_AssertZext(SDNode *N) {'), (163, 1, u'+  return DAG.getNode(ISD::AssertZext, N->getDebugLoc(),'), (293, 1, u'+  assert(isa<ConstantSDNode>(Result) && "Didn\'t constant fold ext?");'), (299, 1, u'+  assert ((CvtCode == ISD::CVT_SS || CvtCode == ISD::CVT_SU ||'), (371, 1, u'+                     ISD::AssertZext : ISD::AssertSext, dl, NVT, Res,'), (381, 1, u'+  return DAG.getNode(ISD::AssertZext, dl,'), (392, 1, u'+    assert(Res.getValueType().bitsLE(NVT) && "Extension doesn\'t make sense!");'), (404, 1, u'+      assert(N->getOpcode() == ISD::ANY_EXTEND && "Unknown integer extension!");'), (414, 1, u'+  assert(ISD::isUNINDEXEDLoad(N) && "Indexed load during type legalization!");'), (521, 1, u'+  assert(SVT.isVector() == N->getOperand(0).getValueType().isVector() &&'), (528, 1, u'+  assert(NVT.bitsLE(SVT) && "Integer type overpromoted?");'), (587, 1, u'+    assert(InVT.isVector() && "Cannot split scalar types");'), (589, 1, u'+    assert(NumElts == NVT.getVectorNumElements() &&'), (592, 1, u'+    assert(isPowerOf2_32(NumElts) &&'), (805, 1, u'+  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (862, 1, u'+  assert(OpNo == 2 && "Don\'t know how to promote this operand!");'), (876, 1, u'+  assert(OpNo == 1 && "only know how to promote condition");'), (892, 1, u'+  assert(Lo.getValueType() == N->getValueType(0) && "Operand over promoted?");'), (906, 1, u'+  assert(!(NumElts & 1) && "Legal vector of one illegal element?");'), (911, 1, u'+  assert(N->getOperand(0).getValueType().getSizeInBits() >='), (924, 1, u'+  assert ((CvtCode == ISD::CVT_SS || CvtCode == ISD::CVT_SU ||'), (941, 1, u'+    assert(N->getOperand(1).getValueType().getSizeInBits() >='), (950, 1, u'+  assert(OpNo == 2 && "Different operand and result vector types?");'), (977, 1, u'+  assert(OpNo == 0 && "Only know how to promote the condition!");'), (991, 1, u'+  assert(OpNo == 0 && "Don\'t know how to promote this operand!");'), (1003, 1, u'+  assert(OpNo == 0 && "Don\'t know how to promote this operand!");'), (1032, 1, u'+  assert(ISD::isUNINDEXEDStore(N) && "Indexed store during type legalization!");'), (1103, 1, u'+  case ISD::AssertSext:  ExpandIntRes_AssertSext(N, Lo, Hi); break;'), (1104, 1, u'+  case ISD::AssertZext:  ExpandIntRes_AssertZext(N, Lo, Hi); break;'), (1325, 1, u'+  assert(N->getOpcode() == ISD::SRA && "Unknown shift!");'), (1359, 1, u'+  assert(isPowerOf2_32(NVTBits) &&'), (1446, 1, u'+  assert(isPowerOf2_32(NVTBits) &&'), (1641, 1, u'+    assert(getTypeAction(Op.getValueType()) =='), (1645, 1, u'+    assert(Res.getValueType() == N->getValueType(0) &&'), (1652, 1, u'+void DAGTypeLegalizer::ExpandIntRes_AssertSext(SDNode *N,'), (1662, 1, u'+    Hi = DAG.getNode(ISD::AssertSext, dl, NVT, Hi,'), (1666, 1, u'+    Lo = DAG.getNode(ISD::AssertSext, dl, NVT, Lo, DAG.getValueType(EVT));'), (1673, 1, u'+void DAGTypeLegalizer::ExpandIntRes_AssertZext(SDNode *N,'), (1683, 1, u'+    Hi = DAG.getNode(ISD::AssertZext, dl, NVT, Hi,'), (1687, 1, u'+    Lo = DAG.getNode(ISD::AssertZext, dl, NVT, Lo, DAG.getValueType(EVT));'), (1765, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unexpected fp-to-sint conversion!");'), (1775, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unexpected fp-to-uint conversion!");'), (1786, 1, u'+  assert(ISD::isUNINDEXEDLoad(N) && "Indexed load during type legalization!");'), (1799, 1, u'+  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (1820, 1, u'+      assert(ExtType == ISD::EXTLOAD && "Unknown extload!");'), (1988, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported MUL!");'), (2050, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported SDIV!");'), (2078, 1, u'+    assert(N->getOpcode() == ISD::SRA && "Unknown shift!");'), (2123, 1, u'+    assert(N->getOpcode() == ISD::SRA && "Unknown shift!");'), (2160, 1, u'+    assert(getTypeAction(Op.getValueType()) =='), (2164, 1, u'+    assert(Res.getValueType() == N->getValueType(0) &&'), (2217, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported SREM!");'), (2294, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported XMULO!");'), (2353, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported UDIV!");'), (2373, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported UREM!");'), (2391, 1, u'+    assert(getTypeAction(Op.getValueType()) =='), (2395, 1, u'+    assert(Res.getValueType() == N->getValueType(0) &&'), (2477, 1, u'+  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (2629, 1, u'+    assert(NewLHS.getValueType() == N->getValueType(0) &&'), (2661, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL &&'), (2670, 1, u'+  assert(ISD::isUNINDEXEDStore(N) && "Indexed store during type legalization!");'), (2671, 1, u'+  assert(OpNo == 1 && "Can only expand the stored value so far");'), (2683, 1, u'+  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (2839, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL &&'), (2863, 1, u'+  assert(NOutVT.isVector() && "This type must be promoted to a vector type");'), (2911, 1, u'+  assert(NOutVT.isVector() && "This type must be promoted to a vector type");'), (2931, 1, u'+  assert(!N->getOperand(0).getValueType().isVector() &&'), (2936, 1, u'+  assert(NOutVT.isVector() && "This type must be promoted to a vector type");'), (2949, 1, u'+  assert(NOutVT.isVector() && "This type must be promoted to a vector type");'), (2957, 1, u'+  assert(NumElem * NumOperands == NumOutElem &&'), (2977, 1, u'+  assert(NOutVT.isVector() && "This type must be promoted to a vector type");')]
===========================================
Class:  class NodeUpdateListener : public SelectionDAG::DAGUpdateListener {   class NodeUpdateListener : public SelectionDAG::DAGUpdateListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 1, u'+            assert(UI->getNodeId() == NewNode &&'), (102, 1, u'+        assert(NewVal.getNode()->getNodeId() != NewNode &&'), (172, 1, u'+      assert(UI->getNodeId() == NewNode && "NewNode used by non-NewNode!");'), (214, 1, u'+    assert(N->getNodeId() == ReadyToProcess &&'), (317, 1, u'+      assert(N->getNodeId() == ReadyToProcess && "Node ID recalculated?");'), (328, 1, u'+      assert(N->getNumValues() == M->getNumValues() &&'), (333, 1, u'+      assert(N->getNodeId() == NewNode && "Unexpected node state!");'), (348, 1, u'+    assert(N->getNodeId() == ReadyToProcess && "Node ID recalculated?");'), (376, 1, u'+      assert(NodeId == Unanalyzed && "Unknown node ID!");'), (558, 1, u'+    assert(I->first.getNode() != N);'), (564, 1, u'+    assert(I->first.getNode() != N);'), (570, 1, u'+    assert(I->first.getNode() != N);'), (576, 1, u'+    assert(I->first.getNode() != N);'), (582, 1, u'+    assert(I->first.getNode() != N);'), (589, 1, u'+    assert(I->first.getNode() != N);'), (596, 1, u'+    assert(I->first.getNode() != N);'), (618, 1, u'+    assert(N.getNode()->getNodeId() != NewNode && "Mapped to new node!");'), (634, 1, u'+      assert(N->getNodeId() != DAGTypeLegalizer::ReadyToProcess &&'), (639, 1, u'+      assert(E && "Node not replaced?");'), (658, 1, u'+      assert(N->getNodeId() != DAGTypeLegalizer::ReadyToProcess &&'), (672, 1, u'+  assert(From.getNode() != To.getNode() && "Potential legalization loop!");'), (704, 1, u'+        assert(M->getNodeId() != NewNode && "Analysis resulted in NewNode!");'), (705, 1, u'+        assert(N->getNumValues() == M->getNumValues() &&'), (729, 1, u'+  assert(Result.getValueType() =='), (735, 1, u'+  assert(OpEntry.getNode() == 0 && "Node is already promoted!");'), (740, 1, u'+  assert(Result.getValueType() =='), (746, 1, u'+  assert(OpEntry.getNode() == 0 && "Node is already converted to integer!");'), (754, 1, u'+  assert(Result.getValueType().getSizeInBits() >='), (760, 1, u'+  assert(OpEntry.getNode() == 0 && "Node is already scalarized!");'), (769, 1, u'+  assert(Entry.first.getNode() && "Operand isn\'t expanded");'), (776, 1, u'+  assert(Lo.getValueType() =='), (786, 1, u'+  assert(Entry.first.getNode() == 0 && "Node already expanded");'), (796, 1, u'+  assert(Entry.first.getNode() && "Operand isn\'t expanded");'), (803, 1, u'+  assert(Lo.getValueType() =='), (813, 1, u'+  assert(Entry.first.getNode() == 0 && "Node already expanded");'), (823, 1, u'+  assert(Entry.first.getNode() && "Operand isn\'t split");'), (830, 1, u'+  assert(Lo.getValueType().getVectorElementType() =='), (842, 1, u'+  assert(Entry.first.getNode() == 0 && "Node already split");'), (848, 1, u'+  assert(Result.getValueType() =='), (854, 1, u'+  assert(OpEntry.getNode() == 0 && "Node already widened!");'), (873, 1, u'+  assert(Op.getValueType().isVector() && "Only applies to vectors!");'), (919, 1, u'+  assert(Results.size() == N->getNumValues() &&'), (942, 1, u'+  assert(Results.size() == N->getNumValues() &&'), (964, 1, u'+    assert(!(NumElements & 1) && "Splitting vector, but not in half!");'), (1114, 1, u'+  assert(LoVT.getSizeInBits() + HiVT.getSizeInBits() ==')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(78, 1, u'+      assert(!(InVT.getVectorNumElements() & 1) && "Unsupported BITCAST");'), (114, 1, u'+  assert(NOutVT.isByteSized() && "Expanded type not byte sized!");'), (161, 1, u'+  assert(Part.getValueType() == N->getValueType(0) &&'), (203, 1, u'+  assert(ISD::isNormalLoad(N) && "This routine only for normal loads!");'), (215, 1, u'+  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (305, 1, u'+  assert(OldVT == VecVT.getVectorElementType() &&'), (347, 1, u'+  assert(OldEVT == VecVT.getVectorElementType() &&'), (375, 1, u'+  assert(VT.getVectorElementType() == N->getOperand(0).getValueType() &&'), (387, 1, u'+  assert(ISD::isNormalStore(N) && "This routine only for normal stores!");'), (388, 1, u'+  assert(OpNo == 1 && "Can only expand the stored value so far");'), (400, 1, u'+  assert(NVT.isByteSized() && "Expanded type not byte sized!");'), (414, 1, u'+  assert(isTypeLegal(Ptr.getValueType()) && "Pointers must be legal!");'), (449, 1, u'+    assert(Cond.getValueType().getVectorElementType() == MVT::i1 &&')]
===========================================
Class:class VectorLegalizer { class VectorLegalizer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(95, 1, u'+  assert(LegalizedNodes.count(OldRoot) && "Root didn\'t get legalized?");'), (278, 1, u'+  assert(Op.getNode()->getNumValues() == 1 &&'), (406, 1, u'+  assert(VT.getSizeInBits() == Op.getOperand(1).getValueType().getSizeInBits()'), (434, 1, u'+  assert((SVT.getSizeInBits() == 64 || SVT.getSizeInBits() == 32) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(186, 1, u'+  assert(N->isUnindexed() && "Indexed vector load?");'), (241, 1, u'+        assert(VecBool == TargetLowering::UndefinedBooleanContent ||'), (248, 1, u'+        assert(VecBool == TargetLowering::UndefinedBooleanContent ||'), (277, 1, u'+  assert(N->getValueType(0).isVector() =='), (305, 1, u'+  assert(N->getValueType(0).isVector() &&'), (367, 1, u'+  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (406, 1, u'+  assert(N->isUnindexed() && "Indexed store of one-element vector?");'), (407, 1, u'+  assert(OpNo == 1 && "Do not know how to scalarize this operand!");'), (622, 1, u'+  assert(!(N->getNumOperands() & 1) && "Unsupported CONCAT_VECTORS");'), (740, 1, u'+  assert(ISD::isUNINDEXEDLoad(LD) && "Indexed load during type legalization!");'), (780, 1, u'+  assert(N->getValueType(0).isVector() &&'), (1017, 1, u'+  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (1069, 1, u'+    assert(IdxVal + SubVT.getVectorNumElements() <= LoElts &&'), (1085, 1, u'+    assert(IdxVal < VecVT.getVectorNumElements() && "Invalid vector index!");'), (1113, 1, u'+  assert(N->isUnindexed() && "Indexed store of vector?");'), (1114, 1, u'+  assert(OpNo == 1 && "Can only split the stored value");'), (1180, 1, u'+  assert(N->getValueType(0).isVector() &&'), (1944, 1, u'+  assert(InOp1.getValueType() == WidenVT && InOp2.getValueType() == WidenVT);'), (1958, 1, u'+  assert(N->getValueType(0).isVector() =='), (2001, 1, u'+  assert(N->getValueType(0).isVector() &&'), (2009, 1, u'+  assert(InVT.isVector() && "can not widen non vector type");'), (2017, 1, u'+  assert(InOp1.getValueType() == WidenInVT &&'), (2073, 1, u'+  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&'), (2311, 1, u'+  assert(LdVT.isVector() && WidenVT.isVector());'), (2312, 1, u'+  assert(LdVT.getVectorElementType() == WidenVT.getVectorElementType());'), (2344, 1, u'+    assert(WidenWidth % NewVTWidth == 0);'), (2465, 1, u'+  assert(LdVT.isVector() && WidenVT.isVector());'), (2524, 1, u'+  assert(StVT.getVectorElementType() == ValEltVT);'), (2591, 1, u'+  assert(StVT.isVector() && ValOp.getValueType().isVector());'), (2592, 1, u'+  assert(StVT.bitsLT(ValOp.getValueType()));'), (2625, 1, u'+  assert(InVT.getVectorElementType() == NVT.getVectorElementType() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 1, u'+   assert (ResourcesModel && "Unimplemented CreateTargetScheduleState.");'), (637, 1, u'+  assert(!Queue.empty() && "Queue is empty!");')]
===========================================
Class:class ScheduleDAGFast : public ScheduleDAGSDNodes { class ScheduleDAGFast : public ScheduleDAGSDNodes 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(181, 1, u'+  assert(CurCycle >= SU->getHeight() && "Node scheduled below its height!");'), (192, 1, u'+        assert(NumLiveRegs > 0 && "NumLiveRegs is already zero!");'), (193, 1, u'+        assert(LiveRegDefs[I->getReg()] == SU &&'), (237, 1, u'+    assert(NewNodes.size() == 2 && "Expected a load folding node!");'), (249, 1, u'+    assert(N->getNodeId() == -1 && "Node already inserted!");'), (426, 1, u'+  assert(MCID.ImplicitDefs && "Physical reg def must be in implicit def list!");'), (530, 1, u'+    assert(RootSU->Succs.empty() && "Graph root shouldn\'t have successors!");'), (566, 1, u'+        assert(LRegs.size() == 1 && "Can\'t handle this yet!");')]
===========================================
Class:class ScheduleDAGRRList : public ScheduleDAGSDNodes { class ScheduleDAGRRList : public ScheduleDAGSDNodes 
Class:class RegReductionPQBase;
Class: class RegReductionPQBase : public SchedulingPriorityQueue { class RegReductionPQBase : public SchedulingPriorityQueue 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 1, u'+  assert((Addr == 0 || Addr == &SUnits[0]) &&'), (191, 1, u'+  assert((N->getValueType(N->getNumValues() - 1) == MVT::Glue &&'), (356, 1, u'+      assert(N->getNodeId() == -1 && "Node already inserted!");'), (373, 1, u'+          assert(N->getNodeId() == -1 && "Node already inserted!");'), (396, 1, u'+    assert(N->getNodeId() == -1 && "Node already inserted!");'), (461, 1, u'+        assert(OpSU && "Node has no SUnit!");'), (465, 1, u'+        assert(OpVT != MVT::Glue && "Glued nodes should be in same sunit!");'), (472, 1, u'+        assert((PhysReg == 0 || !isChain) &&'), (577, 1, u'+  assert(SU->NumRegDefsLeft == 0 && "expect a new node");'), (579, 1, u'+    assert(SU->NumRegDefsLeft < USHRT_MAX && "overflow is ok but unexpected");'), (683, 1, u'+  assert(Sequence.size() - Noops == ScheduledNodes &&'), (762, 1, u'+      assert(VRI != VRBaseMap.end() && "Node emitted out of order - late");'), (777, 1, u'+      assert(I->getReg() && "Unknown physical register!");'), (781, 1, u'+      assert(isNew && "Node emitted out of order - early");')]
===========================================
Class:class ScheduleDAGVLIW : public ScheduleDAGSDNodes { class ScheduleDAGVLIW : public ScheduleDAGSDNodes 
Class:class RAUWUpdateListener : public SelectionDAG::DAGUpdateListener { class RAUWUpdateListener : public SelectionDAG::DAGUpdateListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 1, u'+  assert(VT.isFloatingPoint() && "Can only convert between FP types");'), (490, 1, u'+  assert((ConvType & 3) == ConvType &&'), (492, 1, u'+  assert((AM & 7) == AM &&'), (598, 1, u'+  assert(N != AllNodes.begin() && "Cannot delete the entry node!");'), (599, 1, u'+  assert(N->use_empty() && "Cannot delete a node that is not dead!");'), (635, 1, u'+    assert(CondCodeNodes[cast<CondCodeSDNode>(N)->get()] &&'), (662, 1, u'+    assert(N->getOpcode() != ISD::DELETED_NODE && "DELETED_NODE in CSEMap!");'), (663, 1, u'+    assert(N->getOpcode() != ISD::EntryToken && "EntryToken in CSEMap!");'), (774, 1, u'+    assert(N->getNumValues() == 1 && "Too many results!");'), (775, 1, u'+    assert(!VT.isVector() && (VT.isInteger() || VT.isFloatingPoint()) &&'), (777, 1, u'+    assert(N->getNumOperands() == 2 && "Wrong number of operands!");'), (778, 1, u'+    assert(N->getOperand(0).getValueType() == N->getOperand(1).getValueType() &&'), (780, 1, u'+    assert(N->getOperand(0).getValueType().isInteger() == VT.isInteger() &&'), (782, 1, u'+    assert(VT.getSizeInBits() == 2 * N->getOperand(0).getValueSizeInBits() &&'), (787, 1, u'+    assert(N->getNumValues() == 1 && "Too many results!");'), (788, 1, u'+    assert(N->getValueType(0).isVector() && "Wrong return type!");'), (789, 1, u'+    assert(N->getNumOperands() == N->getValueType(0).getVectorNumElements() &&'), (793, 1, u'+      assert((I->getValueType() == EltVT ||'), (797, 1, u'+      assert(I->getValueType() == N->getOperand(0).getValueType() &&'), (809, 1, u'+  assert(!isa<MemSDNode>(N) && "Bad MemSDNode!");'), (810, 1, u'+  assert(!isa<ShuffleVectorSDNode>(N) && "Bad ShuffleVectorSDNode!");'), (811, 1, u'+  assert(!isa<ConstantSDNode>(N) && "Bad ConstantSDNode!");'), (812, 1, u'+  assert(!isa<ConstantFPSDNode>(N) && "Bad ConstantFPSDNode!");'), (813, 1, u'+  assert(!isa<GlobalAddressSDNode>(N) && "Bad GlobalAddressSDNode!");'), (814, 1, u'+  assert(!isa<FrameIndexSDNode>(N) && "Bad FrameIndexSDNode!");'), (815, 1, u'+  assert(!isa<JumpTableSDNode>(N) && "Bad JumpTableSDNode!");'), (816, 1, u'+  assert(!isa<ConstantPoolSDNode>(N) && "Bad ConstantPoolSDNode!");'), (817, 1, u'+  assert(!isa<BasicBlockSDNode>(N) && "Bad BasicBlockSDNode!");'), (818, 1, u'+  assert(!isa<SrcValueSDNode>(N) && "Bad SrcValueSDNode!");'), (819, 1, u'+  assert(!isa<MDNodeSDNode>(N) && "Bad MDNodeSDNode!");'), (820, 1, u'+  assert(!isa<RegisterSDNode>(N) && "Bad RegisterSDNode!");'), (821, 1, u'+  assert(!isa<BlockAddressSDNode>(N) && "Bad BlockAddressSDNode!");'), (822, 1, u'+  assert(!isa<EHLabelSDNode>(N) && "Bad EHLabelSDNode!");'), (823, 1, u'+  assert(!isa<ExternalSymbolSDNode>(N) && "Bad ExternalSymbolSDNode!");'), (824, 1, u'+  assert(!isa<CondCodeSDNode>(N) && "Bad CondCodeSDNode!");'), (825, 1, u'+  assert(!isa<CvtRndSatSDNode>(N) && "Bad CvtRndSatSDNode!");'), (826, 1, u'+  assert(!isa<VTSDNode>(N) && "Bad VTSDNode!");'), (827, 1, u'+  assert(!isa<MachineSDNode>(N) && "Bad MachineSDNode!");'), (876, 1, u'+  assert(&*AllNodes.begin() == &EntryNode);'), (921, 1, u'+  assert(!VT.isVector() &&'), (943, 1, u'+  assert((EltVT.getSizeInBits() >= 64 ||'), (954, 1, u'+  assert(VT.isInteger() && "Cannot create FP integer constant!");'), (970, 1, u'+  assert(Elt->getBitWidth() == EltVT.getSizeInBits() &&'), (1007, 1, u'+  assert(VT.isFloatingPoint() && "Cannot create integer FP constant!");'), (1060, 1, u'+  assert((TargetFlags == 0 || isTargetGA) &&'), (1115, 1, u'+  assert((TargetFlags == 0 || isTarget) &&'), (1137, 1, u'+  assert((TargetFlags == 0 || isTarget) &&'), (1164, 1, u'+  assert((TargetFlags == 0 || isTarget) &&'), (1262, 1, u'+  assert(N1.getValueType() == N2.getValueType() && "Invalid VECTOR_SHUFFLE");'), (1263, 1, u'+  assert(VT.isVector() && N1.getValueType().isVector() &&'), (1265, 1, u'+  assert(VT.getVectorElementType() == N1.getValueType().getVectorElementType()'), (1277, 1, u'+    assert(Mask[i] < (int)(NElts * 2) && "Index out of range");'), (1438, 1, u'+  assert((!V || V->getType()->isPointerTy()) &&'), (1532, 1, u'+    assert(!N1.getValueType().isInteger() && "Illegal setcc for integer!");'), (1632, 1, u'+  assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1660, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1661, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1671, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1672, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1682, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1683, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1695, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1696, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1736, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1737, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1746, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1747, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1778, 1, u'+      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1795, 1, u'+      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1816, 1, u'+      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1851, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1913, 1, u'+    assert(!(SignBitKnownZero && SignBitKnownOne) &&'), (1942, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1947, 1, u'+  case ISD::AssertZext: {'), (1988, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1992, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (2030, 1, u'+        assert((KnownZero & KnownOne) == 0&&"Bits known to be one AND zero?");'), (2041, 1, u'+        assert((KnownZero & KnownOne) == 0&&"Bits known to be one AND zero?");'), (2086, 1, u'+  assert(VT.isInteger() && "Invalid VT!");'), (2096, 1, u'+  case ISD::AssertSext:'), (2099, 1, u'+  case ISD::AssertZext:'), (2443, 1, u'+        assert(integerPartWidth >= 64);'), (2471, 1, u'+    assert(VT.isFloatingPoint() &&'), (2474, 1, u'+    assert((!VT.isVector() ||'), (2482, 1, u'+    assert(VT.isInteger() && Operand.getValueType().isInteger() &&'), (2485, 1, u'+    assert(Operand.getValueType().getScalarType().bitsLT(VT.getScalarType()) &&'), (2487, 1, u'+    assert((!VT.isVector() ||'), (2498, 1, u'+    assert(VT.isInteger() && Operand.getValueType().isInteger() &&'), (2501, 1, u'+    assert(Operand.getValueType().getScalarType().bitsLT(VT.getScalarType()) &&'), (2503, 1, u'+    assert((!VT.isVector() ||'), (2515, 1, u'+    assert(VT.isInteger() && Operand.getValueType().isInteger() &&'), (2518, 1, u'+    assert(Operand.getValueType().getScalarType().bitsLT(VT.getScalarType()) &&'), (2520, 1, u'+    assert((!VT.isVector() ||'), (2540, 1, u'+    assert(VT.isInteger() && Operand.getValueType().isInteger() &&'), (2543, 1, u'+    assert(Operand.getValueType().getScalarType().bitsGT(VT.getScalarType()) &&'), (2545, 1, u'+    assert((!VT.isVector() ||'), (2566, 1, u'+    assert(VT.getSizeInBits() == Operand.getValueType().getSizeInBits()'), (2575, 1, u'+    assert(VT.isVector() && !Operand.getValueType().isVector() &&'), (2670, 1, u'+    assert(VT == MVT::Other && N1.getValueType() == MVT::Other &&'), (2689, 1, u'+    assert(VT.isInteger() && "This operator does not apply to FP types!");'), (2690, 1, u'+    assert(N1.getValueType() == N2.getValueType() &&'), (2703, 1, u'+    assert(VT.isInteger() && "This operator does not apply to FP types!");'), (2704, 1, u'+    assert(N1.getValueType() == N2.getValueType() &&'), (2718, 1, u'+    assert(VT.isInteger() && "This operator does not apply to FP types!");'), (2719, 1, u'+    assert(N1.getValueType() == N2.getValueType() &&'), (2744, 1, u'+    assert(VT.isFloatingPoint() && "This operator only applies to FP types!");'), (2745, 1, u'+    assert(N1.getValueType() == N2.getValueType() &&'), (2749, 1, u'+    assert(N1.getValueType() == VT &&'), (2759, 1, u'+    assert(VT == N1.getValueType() &&'), (2761, 1, u'+    assert(VT.isInteger() && N2.getValueType().isInteger() &&'), (2767, 1, u'+    assert(N2.getValueType().getSizeInBits() >='), (2781, 1, u'+    assert(VT == N1.getValueType() && "Not an inreg round!");'), (2782, 1, u'+    assert(VT.isFloatingPoint() && EVT.isFloatingPoint() &&'), (2784, 1, u'+    assert(EVT.isVector() == VT.isVector() &&'), (2787, 1, u'+    assert((!EVT.isVector() ||'), (2790, 1, u'+    assert(EVT.bitsLE(VT) && "Not rounding down!");'), (2796, 1, u'+    assert(VT.isFloatingPoint() &&'), (2802, 1, u'+  case ISD::AssertSext:'), (2803, 1, u'+  case ISD::AssertZext: {'), (2805, 1, u'+    assert(VT == N1.getValueType() && "Not an inreg extend!");'), (2806, 1, u'+    assert(VT.isInteger() && EVT.isInteger() &&'), (2808, 1, u'+    assert(!EVT.isVector() &&'), (2811, 1, u'+    assert(EVT.bitsLE(VT) && "Not extending!");'), (2817, 1, u'+    assert(VT == N1.getValueType() && "Not an inreg extend!");'), (2818, 1, u'+    assert(VT.isInteger() && EVT.isInteger() &&'), (2820, 1, u'+    assert(EVT.isVector() == VT.isVector() &&'), (2823, 1, u'+    assert((!EVT.isVector() ||'), (2826, 1, u'+    assert(EVT.bitsLE(VT) && "Not extending!");'), (2896, 1, u'+    assert(N2C && (unsigned)N2C->getZExtValue() < 2 && "Bad EXTRACT_ELEMENT!");'), (2897, 1, u'+    assert(!N1.getValueType().isVector() && !VT.isVector() &&'), (2919, 1, u'+      assert(VT.isVector() && N1.getValueType().isVector() &&'), (2921, 1, u'+      assert(VT.getVectorElementType() == N1.getValueType().getVectorElementType() &&'), (2923, 1, u'+      assert(VT.getSimpleVT() <= N1.getValueType().getSimpleVT() &&'), (2927, 1, u'+        assert((VT.getVectorNumElements() +'), (3146, 1, u'+      assert(VT.isVector() && N1.getValueType().isVector() &&'), (3149, 1, u'+      assert(VT == N1.getValueType() &&'), (3151, 1, u'+      assert(N2.getValueType().getSimpleVT() <= N1.getValueType().getSimpleVT() &&'), (3154, 1, u'+        assert((N2.getValueType().getVectorNumElements() +'), (3249, 1, u'+  assert(Value.getOpcode() != ISD::UNDEF);'), (3291, 1, u'+  assert(!VT.isVector() && "Can\'t handle vector type here!");'), (3346, 1, u'+  assert((SrcAlign == 0 || SrcAlign >= DstAlign) &&'), (3375, 1, u'+    assert(LVT.isInteger());'), (3484, 1, u'+      assert(NVT.bitsGE(VT));'), (3645, 1, u'+    assert(Value.getValueType() == VT && "Value with wrong type.");'), (3691, 1, u'+    assert(ConstantSize && "AlwaysInline requires a constant size!");'), (3867, 1, u'+  assert(Opcode == ISD::ATOMIC_CMP_SWAP && "Invalid Atomic Op");'), (3868, 1, u'+  assert(Cmp.getValueType() == Swp.getValueType() && "Invalid Atomic Op Types");'), (3927, 1, u'+  assert((Opcode == ISD::ATOMIC_LOAD_ADD ||'), (3998, 1, u'+  assert(Opcode == ISD::ATOMIC_LOAD && "Invalid Atomic Op");'), (4070, 1, u'+  assert((Opcode == ISD::INTRINSIC_VOID ||'), (4141, 1, u'+  assert(Chain.getValueType() == MVT::Other &&'), (4174, 1, u'+    assert(VT == MemVT && "Non-extending load from different memory type!");'), (4177, 1, u'+    assert(MemVT.getScalarType().bitsLT(VT.getScalarType()) &&'), (4179, 1, u'+    assert(VT.isInteger() == MemVT.isInteger() &&'), (4181, 1, u'+    assert(VT.isVector() == MemVT.isVector() &&'), (4183, 1, u'+    assert((!VT.isVector() ||'), (4189, 1, u'+  assert((Indexed || Offset.getOpcode() == ISD::UNDEF) &&'), (4242, 1, u'+  assert(LD->getOffset().getOpcode() == ISD::UNDEF &&'), (4254, 1, u'+  assert(Chain.getValueType() == MVT::Other &&'), (4279, 1, u'+  assert(Chain.getValueType() == MVT::Other &&'), (4307, 1, u'+  assert(Chain.getValueType() == MVT::Other &&'), (4334, 1, u'+  assert(Chain.getValueType() == MVT::Other &&'), (4339, 1, u'+  assert(SVT.getScalarType().bitsLT(VT.getScalarType()) &&'), (4341, 1, u'+  assert(VT.isInteger() == SVT.isInteger() &&'), (4343, 1, u'+  assert(VT.isVector() == SVT.isVector() &&'), (4345, 1, u'+  assert((!VT.isVector() ||'), (4373, 1, u'+  assert(ST->getOffset().getOpcode() == ISD::UNDEF &&'), (4431, 1, u'+    assert(NumOps == 5 && "SELECT_CC takes 5 operands!");'), (4432, 1, u'+    assert(Ops[0].getValueType() == Ops[1].getValueType() &&'), (4434, 1, u'+    assert(Ops[2].getValueType() == Ops[3].getValueType() &&'), (4436, 1, u'+    assert(Ops[2].getValueType() == VT &&'), (4441, 1, u'+    assert(NumOps == 5 && "BR_CC takes 5 operands!");'), (4442, 1, u'+    assert(Ops[2].getValueType() == Ops[3].getValueType() &&'), (4682, 1, u'+  assert(N->getNumOperands() == 1 && "Update with wrong number of operands");'), (4706, 1, u'+  assert(N->getNumOperands() == 2 && "Update with wrong number of operands");'), (4755, 1, u'+  assert(N->getNumOperands() == NumOps &&'), (5279, 1, u'+  assert(From->getNumValues() == 1 && FromN.getResNo() == 0 &&'), (5281, 1, u'+  assert(From != To.getNode() && "Cannot replace uses of with self");'), (5328, 1, u'+    assert((!From->hasAnyUseOfValue(i) ||'), (5574, 1, u'+      assert(SortedPos != AllNodes.end() && "Overran node list");'), (5593, 1, u'+      assert(Degree != 0 && "Invalid node degree");'), (5600, 1, u'+        assert(SortedPos != AllNodes.end() && "Overran node list");'), (5617, 1, u'+  assert(SortedPos == AllNodes.end() &&'), (5619, 1, u'+  assert(AllNodes.front().getOpcode() == ISD::EntryToken &&'), (5621, 1, u'+  assert(AllNodes.front().getNodeId() == 0 &&'), (5623, 1, u'+  assert(AllNodes.front().getNumOperands() == 0 &&'), (5625, 1, u'+  assert(AllNodes.back().getNodeId() == (int)DAGSize-1 &&'), (5627, 1, u'+  assert(AllNodes.back().use_empty() &&'), (5629, 1, u'+  assert(DAGSize == allnodes_size() && "Node count mismatch!");'), (5635, 1, u'+  assert(SD && "Trying to assign an order to a null node!");'), (5641, 1, u'+  assert(SD && "Trying to get the order of a null node!");'), (5696, 1, u'+  assert(isVolatile() == MMO->isVolatile() && "Volatile encoding error!");'), (5697, 1, u'+  assert(isNonTemporal() == MMO->isNonTemporal() &&'), (5699, 1, u'+  assert(memvt.getStoreSize() == MMO->getSize() && "Size mismatch!");'), (5709, 1, u'+  assert(isVolatile() == MMO->isVolatile() && "Volatile encoding error!");'), (5710, 1, u'+  assert(memvt.getStoreSize() == MMO->getSize() && "Size mismatch!");'), (5742, 1, u'+    assert(VT.getSimpleVT() < MVT::LAST_VALUETYPE &&'), (5752, 1, u'+  assert(Value < getNumValues() && "Bad value!");'), (5771, 1, u'+  assert(Value < getNumValues() && "Bad value!");'), (5880, 1, u'+  assert(Num < NumOperands && "Invalid child # of SDNode!");'), (5885, 1, u'+  assert(N->getNumValues() == 1 &&'), (6058, 1, u'+  assert(VT.isVector() && "Expected a vector type");'), (6071, 1, u'+  assert(nOps > 0 && "isConstantSplat has 0-size build vector");'), (6123, 1, u'+  assert(i != e && "VECTOR_SHUFFLE node with all undef indices!");'), (6160, 1, u'+  assert(N && "Checking nonexistant SDNode");')]
===========================================
Class:class SDISelAsmOperandInfo : public TargetLowering::AsmOperandInfo { class SDISelAsmOperandInfo : public TargetLowering::AsmOperandInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 1, u'+                                ISD::NodeType AssertOp = ISD::DELETED_NODE) {'), (104, 1, u'+  assert(NumParts > 0 && "No parts to assemble!");'), (160, 1, u'+      assert(ValueVT == EVT(MVT::ppcf128) && PartVT == EVT(MVT::f64) &&'), (170, 1, u'+      assert(ValueVT.isFloatingPoint() && PartVT.isInteger() &&'), (188, 1, u'+      if (AssertOp != ISD::DELETED_NODE)'), (189, 1, u'+        Val = DAG.getNode(AssertOp, DL, PartVT, Val,'), (219, 1, u'+  assert(ValueVT.isVector() && "Not a vector value");'), (220, 1, u'+  assert(NumParts > 0 && "No parts to assemble!");'), (231, 1, u'+    assert(NumRegs == NumParts && "Part count doesn\'t match vector breakdown!");'), (233, 1, u'+    assert(RegisterVT == PartVT && "Part type doesn\'t match vector breakdown!");'), (234, 1, u'+    assert(RegisterVT == Parts[0].getValueType() &&'), (248, 1, u'+      assert(NumParts % NumIntermediates == 0 &&'), (275, 1, u'+      assert(PartVT.getVectorNumElements() > ValueVT.getVectorNumElements() &&'), (285, 1, u'+    assert(PartVT.getVectorNumElements() == ValueVT.getVectorNumElements() &&'), (301, 1, u'+  assert(ValueVT.getVectorNumElements() == 1 &&'), (337, 1, u'+  assert(TLI.isTypeLegal(PartVT) && "Copying to an illegal type!");'), (342, 1, u'+  assert(!ValueVT.isVector() && "Vector case handled elsewhere");'), (344, 1, u'+    assert(NumParts == 1 && "No-op copy with multiple parts!");'), (352, 1, u'+      assert(NumParts == 1 && "Do not know what to promote to!");'), (355, 1, u'+      assert((PartVT.isInteger() || PartVT == MVT::x86mmx) &&'), (365, 1, u'+    assert(NumParts == 1 && PartVT != ValueVT);'), (369, 1, u'+    assert((PartVT.isInteger() || PartVT == MVT::x86mmx) &&'), (380, 1, u'+  assert(NumParts * PartBits == ValueVT.getSizeInBits() &&'), (384, 1, u'+    assert(PartVT == ValueVT && "Type conversion failed!");'), (392, 1, u'+    assert(PartVT.isInteger() && ValueVT.isInteger() &&'), (447, 1, u'+  assert(ValueVT.isVector() && "Not a vector");'), (488, 1, u'+      assert(ValueVT.getVectorNumElements() == 1 &&'), (510, 1, u'+  assert(NumRegs == NumParts && "Part count doesn\'t match vector breakdown!");'), (512, 1, u'+  assert(RegisterVT == PartVT && "Part type doesn\'t match vector breakdown!");'), (535, 1, u'+    assert(NumParts % NumIntermediates == 0 &&'), (717, 1, u'+      assert(FromVT != MVT::Other);'), (718, 1, u'+      Parts[i] = DAG.getNode(isSExt ? ISD::AssertSext : ISD::AssertZext, dl,'), (815, 1, u'+      assert(Reg < Regs.size() && "Mismatch in # registers expected");'), (893, 1, u'+      assert(PendingExports[i].getNode()->getNumOperands() > 1);'), (1044, 1, u'+      assert(N1.getNode() && "visit didn\'t populate the NodeMap!");'), (1083, 1, u'+      assert((isa<ConstantAggregateZero>(C) || isa<UndefValue>(C)) &&'), (1119, 1, u'+      assert(isa<ConstantAggregateZero>(C) && "Unknown vector constant!");'), (1247, 1, u'+  assert(Chain.getNode() && Chain.getValueType() == MVT::Other &&'), (1264, 1, u'+    assert(!V->use_empty() && "Unused value assigned virtual registers!");'), (1421, 1, u'+    assert(Opc == Instruction::And && "Unknown merge op!");'), (1526, 1, u'+      assert(SwitchCases[0].ThisBB == BrMBB && "Unexpected lowering!");'), (1581, 1, u'+    assert(CB.CC == ISD::SETLE && "Can handle only LE ranges now");'), (1635, 1, u'+  assert(JT.Reg != -1U && "Should lower JT Header first!");'), (1853, 1, u'+  assert(FuncInfo.MBB->isLandingPad() &&'), (1870, 1, u'+  assert(FuncInfo.MBB->isLandingPad() &&'), (1941, 1, u'+        assert((SmallValue | CommonBit) == BigValue &&'), (2186, 1, u'+    assert((Range - 2ULL).isNonNegative() &&'), (2214, 1, u'+    assert((FMetric > 0) && "Should handle dense range earlier!");'), (2352, 1, u'+      assert((count < 3) && "Too much destinations to test!");'), (3249, 1, u'+      assert(PendingLoads.empty() && "PendingLoads must be serialized first");'), (4387, 1, u'+  if (Ext.getOpcode() == ISD::AssertZext || Ext.getOpcode() == ISD::AssertSext){'), (4502, 1, u'+    assert(cast<PointerType>(I.getArgOperand(0)->getType())->getAddressSpace()'), (4520, 1, u'+    assert(cast<PointerType>(I.getArgOperand(0)->getType())->getAddressSpace()'), (4535, 1, u'+    assert(cast<PointerType>(I.getArgOperand(0)->getType())->getAddressSpace()'), (4739, 1, u'+    assert(CI && "Non-constant call site value in eh.sjlj.callsite!");'), (4740, 1, u'+    assert(MMI.getCurrentCallSite() == 0 && "Overlapping call sites!");'), (5012, 1, u'+    assert(CI && "Non-constant type in __builtin_object_size?");'), (5260, 1, u'+  assert((isTailCall || Result.second.getNode()) &&'), (5262, 1, u'+  assert((Result.second.getNode() || !Result.first.getNode()) &&'), (5273, 1, u'+    assert(PVTs.size() == 1 && "Pointers should fit in one register");'), (5300, 1, u'+    ISD::NodeType AssertOp = ISD::DELETED_NODE;'), (5310, 1, u'+                         RegisterVT, VT, AssertOp);'), (5822, 1, u'+        assert(I != RC->end() && "Didn\'t find reg!");'), (5827, 1, u'+        assert(I != RC->end() && "Ran out of registers to allocate!");'), (5887, 1, u'+      assert(!CS.getType()->isVoidTy() && "Bad inline asm!");'), (5891, 1, u'+        assert(ResNo == 0 && "Asm only has one result!");'), (5979, 1, u'+      assert((OpInfo.isMultipleAlternative ||'), (6075, 1, u'+        assert(OpInfo.isIndirect && "Memory output must be indirect operand");'), (6104, 1, u'+        assert(!CS.getType()->isVoidTy() && "Bad inline asm!");'), (6135, 1, u'+          assert((InlineAsm::isRegDefKind(OpFlag) ||'), (6173, 1, u'+        assert(InlineAsm::isMemKind(OpFlag) && "Unknown matching constraint!");'), (6174, 1, u'+        assert(InlineAsm::getNumOperandRegisters(OpFlag) == 1 &&'), (6213, 1, u'+        assert(OpInfo.isIndirect && "Operand must be indirect to be a mem!");'), (6214, 1, u'+        assert(InOperandVal.getValueType() == TLI.getPointerTy() &&'), (6225, 1, u'+      assert((OpInfo.ConstraintType == TargetLowering::C_RegisterClass ||'), (6228, 1, u'+      assert(!OpInfo.isIndirect &&'), (6295, 1, u'+      assert(ResultType == Val.getValueType() && "Asm result value mismatch!");'), (6477, 1, u'+  assert(Chain.getNode() && Chain.getValueType() == MVT::Other &&'), (6479, 1, u'+  assert((!isTailCall || InVals.empty()) &&'), (6481, 1, u'+  assert((isTailCall || InVals.size() == Ins.size()) &&'), (6494, 1, u'+          assert(InVals[i].getNode() &&'), (6496, 1, u'+          assert(EVT(Ins[i].VT) == InVals[i].getValueType() &&'), (6502, 1, u'+  ISD::NodeType AssertOp = ISD::DELETED_NODE;'), (6504, 1, u'+    AssertOp = ISD::AssertSext;'), (6506, 1, u'+    AssertOp = ISD::AssertZext;'), (6516, 1, u'+                                            AssertOp));'), (6547, 1, u'+  assert((Op.getOpcode() != ISD::CopyFromReg ||'), (6550, 1, u'+  assert(!TargetRegisterInfo::isPhysicalRegister(Reg) && "Is a physreg");'), (6668, 1, u'+  assert(NewRoot.getNode() && NewRoot.getValueType() == MVT::Other &&'), (6670, 1, u'+  assert(InVals.size() == Ins.size() &&'), (6674, 1, u'+        assert(InVals[i].getNode() &&'), (6676, 1, u'+        assert(EVT(Ins[i].VT) == InVals[i].getValueType() &&'), (6694, 1, u'+    ISD::NodeType AssertOp = ISD::DELETED_NODE;'), (6696, 1, u'+                                        RegVT, VT, AssertOp);'), (6729, 1, u'+        ISD::NodeType AssertOp = ISD::DELETED_NODE;'), (6731, 1, u'+          AssertOp = ISD::AssertSext;'), (6733, 1, u'+          AssertOp = ISD::AssertZext;'), (6737, 1, u'+                                             AssertOp));'), (6783, 1, u'+  assert(i == InVals.size() && "Argument register count mismatch!");'), (6844, 1, u'+          assert(isa<AllocaInst>(PHIOp) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(79, 1, u'+  case ISD::AssertSext:                 return "AssertSext";'), (80, 1, u'+  case ISD::AssertZext:                 return "AssertZext";')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(229, 1, u'+    assert(TLI.getSchedulingPreference() == Sched::ILP &&'), (257, 1, u'+  assert(!MI->hasPostISelHook() &&'), (340, 1, u'+  assert((!EnableFastISelVerbose || TM.Options.EnableFastISel) &&'), (342, 1, u'+  assert((!EnableFastISelAbort || TM.Options.EnableFastISel) &&'), (853, 1, u'+  assert(RI.getOperand().isUse() &&'), (887, 1, u'+  default: assert (0 && "<Invalid operator> ");'), (1170, 1, u'+      assert(PHI->isPHI() &&'), (1223, 1, u'+      assert(PHI->isPHI() &&'), (1284, 1, u'+      assert(PHI->isPHI() &&'), (1309, 1, u'+    assert(PHI->isPHI() &&'), (1356, 1, u'+            assert(pn != FuncInfo->PHINodesToUpdate.size() &&'), (1482, 1, u'+      assert(InlineAsm::getNumOperandRegisters(Flags) == 1 &&'), (1548, 1, u'+      assert(N != Root);'), (1658, 1, u'+  assert(Val >= 128 && "Not a VBR");'), (1688, 1, u'+    assert(InputChain.getNode() != 0 &&'), (1707, 1, u'+      assert(ChainVal.getValueType() == MVT::Other && "Not a chain?");'), (1728, 1, u'+      assert(FRN->getValueType(FRN->getNumValues()-1) == MVT::Glue &&'), (1902, 1, u'+      assert(InChain.getValueType() == MVT::Other && "Not a chain");'), (1988, 1, u'+  assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2201, 1, u'+  case ISD::AssertSext:'), (2202, 1, u'+  case ISD::AssertZext:'), (2210, 1, u'+  assert(!NodeToMatch->isMachineOpcode() && "Node already selected!");'), (2285, 1, u'+    assert(MatcherIndex < TableSize && "Invalid index");'), (2394, 1, u'+      assert(!NodeStack.empty() && "Node stack imbalance!");'), (2412, 1, u'+      assert(RecNo < RecordedNodes.size() && "Invalid CheckComplexPat");'), (2514, 1, u'+      assert(NodeStack.size() != 1 && "No parent node");'), (2570, 1, u'+      assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2588, 1, u'+      assert(InputChain.getNode() == 0 &&'), (2590, 1, u'+      assert(ChainNodesMatched.empty() &&'), (2595, 1, u'+      assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2615, 1, u'+      assert(InputChain.getNode() == 0 &&'), (2624, 1, u'+      assert(NumChains != 0 && "Can\'t TF zero chains");'), (2626, 1, u'+      assert(ChainNodesMatched.empty() &&'), (2632, 1, u'+        assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2659, 1, u'+      assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2676, 1, u'+      assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2720, 1, u'+        assert(RecNo < RecordedNodes.size() && "Invalid EmitNode");'), (2729, 1, u'+        assert(NodeToMatch->getNumOperands() >= FirstOpToCopy &&'), (2848, 1, u'+        assert(RecNo < RecordedNodes.size() && "Invalid CheckSame");'), (2865, 1, u'+        assert(ResSlot < RecordedNodes.size() && "Invalid CheckSame");'), (2868, 1, u'+        assert(i < NodeToMatch->getNumValues() &&'), (2872, 1, u'+        assert((NodeToMatch->getValueType(i) == Res.getValueType() ||'), (2889, 1, u'+      assert(NodeToMatch->use_empty() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(638, 1, u'+  assert(isTypeLegal(VT));'), (750, 1, u'+  assert(MVT::LAST_VALUETYPE <= MVT::MAX_ALLOWED_VALUETYPE &&'), (764, 1, u'+    assert(LargestIntReg != MVT::i1 && "No integer registers defined!");'), (919, 1, u'+  assert(!VT.isVector() && "No default SetCC type for vectors!");'), (1169, 1, u'+  assert(Op.getNumOperands() == 2 &&'), (1171, 1, u'+  assert(Op.getNode()->getNumValues() == 1 &&'), (1216, 1, u'+  assert(Op.getValueType().getScalarType().getSizeInBits() == BitWidth &&'), (1272, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1276, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1303, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1307, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1337, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1341, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1410, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1411, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1428, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1429, 1, u'+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");'), (1537, 1, u'+      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1574, 1, u'+      assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1636, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1671, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1711, 1, u'+      assert((KnownZero & NewBits) == 0);'), (1713, 1, u'+      assert((KnownOne & NewBits) == 0);'), (1714, 1, u'+      assert((KnownZero & NewBits) == 0);'), (1725, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1785, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1788, 1, u'+  case ISD::AssertZext: {'), (1797, 1, u'+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");'), (1868, 1, u'+  assert((Op.getOpcode() >= ISD::BUILTIN_OP_END ||'), (1882, 1, u'+  assert((Op.getOpcode() >= ISD::BUILTIN_OP_END ||'), (2202, 1, u'+            assert(N0.getOpcode() == ISD::AND &&'), (2514, 1, u'+            assert(N0.getOpcode() == ISD::SUB && "Unexpected operation!");'), (2537, 1, u'+          assert(N1.getOpcode() == ISD::SUB && "Unexpected operation!");'), (2788, 1, u'+  assert(*(Constraint.end()-1) == \'}\' && "Not a brace enclosed constraint?");'), (2820, 1, u'+  assert(!ConstraintCode.empty() && "No known constraint!");'), (2827, 1, u'+  assert(!ConstraintCode.empty() && "No known constraint!");'), (2873, 1, u'+      assert(!CS.getType()->isVoidTy() &&'), (2878, 1, u'+        assert(ResNo == 0 && "Asm only has one result!");'), (3134, 1, u'+  assert(OpInfo.Codes.size() > 1 && "Doesn\'t have multiple constraint options");'), (3149, 1, u'+      assert(OpInfo.Codes[i].size() == 1 &&'), (3185, 1, u'+  assert(!OpInfo.Codes.empty() && "Must have at least one constraint");'), (3259, 1, u'+  assert(d != 0 && "Division by zero!");'), (3372, 1, u'+    assert(magics.a == 0 && "Should use cheap fixup now");'), (3390, 1, u'+    assert(magics.s < N1C.getBitWidth() &&')]
===========================================
Class:  class ShadowStackGC : public GCStrategy {   class ShadowStackGC : public GCStrategy 
Class:  class EscapeEnumerator {   class EscapeEnumerator 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(326, 1, u'+  assert(Roots.empty() && "Not cleaned up?");'), (356, 1, u'+  assert(isa<GetElementPtrInst>(Val) && "Unexpected folded constant");'), (368, 1, u'+  assert(isa<GetElementPtrInst>(Val) && "Unexpected folded constant");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 1, u'+  assert(LP && "Machine loop is NULL.");'), (449, 1, u'+        assert(HDR->pred_size() > 0 && "Loop header has no predecessors?");'), (648, 1, u'+      assert(!loopSpills.empty() && "No CSRs used in loop?");'), (653, 1, u'+    assert(exitBlocks.size() > 0 && "Loop has no top level exit blocks?");')]
===========================================
Class:  class SjLjEHPrepare : public FunctionPass {   class SjLjEHPrepare : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(57, 1, u'+  assert(indexList.empty() && "Index list non-empty at initial numbering?");'), (58, 1, u'+  assert(idx2MBBMap.empty() &&'), (60, 1, u'+  assert(MBBRanges.empty() &&'), (62, 1, u'+  assert(mi2iMap.empty() &&'), (133, 1, u'+  assert((Space & 3) == 0 && "InstrDist must be a multiple of 2*NUM");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(175, 1, u'+  assert(!nodes && "Leaking node array");'), (358, 1, u'+  assert(ActiveNodes && "Call prepare() first");')]
===========================================
Class:class SpillerBase : public Spiller { class SpillerBase : public Spiller 
Class:class TrivialSpiller : public SpillerBase { class TrivialSpiller : public SpillerBase 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 1, u'+    assert(li->weight != HUGE_VALF &&'), (83, 1, u'+    assert(!TargetRegisterInfo::isStackSlot(li->reg) &&'), (131, 1, u'+      assert(hasUse || hasDef);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(123, 1, u'+  assert(UseSlots.empty() && "Call clear first");'), (161, 1, u'+    assert(fixed && "Couldn\'t fix broken live interval");'), (206, 1, u'+      assert(BI.FirstInstr >= Start);'), (210, 1, u'+      assert(BI.LastInstr < Stop);'), (217, 1, u'+        assert(LVI->start == LVI->valno->def && "Dangling LiveRange start");'), (218, 1, u'+        assert(LVI->start == BI.FirstInstr && "First instr should be a def");'), (249, 1, u'+        assert(LVI->start == LVI->valno->def && "Dangling LiveRange start");'), (272, 1, u'+  assert(getNumLiveBlocks() == countLiveBlocks(CurLI) && "Bad block count");'), (302, 1, u'+  assert(!Orig.empty() && "Splitting empty interval?");'), (371, 1, u'+  assert(ParentVNI && "Mapping  NULL value");'), (372, 1, u'+  assert(Idx.isValid() && "Invalid SlotIndex");'), (373, 1, u'+  assert(Edit->getParent().getVNInfoAt(Idx) == ParentVNI && "Bad Parent VNI");'), (405, 1, u'+  assert(ParentVNI && "Mapping  NULL value");'), (468, 1, u'+  assert(Idx != 0 && "Cannot select the complement interval");'), (469, 1, u'+  assert(Idx < Edit->size() && "Can only select previously opened interval");'), (475, 1, u'+  assert(OpenIdx && "openIntv not called before enterIntvBefore");'), (485, 1, u'+  assert(MI && "enterIntvBefore called with invalid index");'), (492, 1, u'+  assert(OpenIdx && "openIntv not called before enterIntvAfter");'), (502, 1, u'+  assert(MI && "enterIntvAfter called with invalid index");'), (510, 1, u'+  assert(OpenIdx && "openIntv not called before enterIntvAtEnd");'), (533, 1, u'+  assert(OpenIdx && "openIntv not called before useIntv");'), (540, 1, u'+  assert(OpenIdx && "openIntv not called before leaveIntvAfter");'), (552, 1, u'+  assert(MI && "No instruction at index");'), (571, 1, u'+  assert(OpenIdx && "openIntv not called before leaveIntvBefore");'), (584, 1, u'+  assert(MI && "No instruction at index");'), (590, 1, u'+  assert(OpenIdx && "openIntv not called before leaveIntvAtTop");'), (608, 1, u'+  assert(OpenIdx && "openIntv not called before overlapIntv");'), (610, 1, u'+  assert(ParentVNI == Edit->getParent().getVNInfoBefore(End) &&'), (612, 1, u'+  assert(LIS.getMBBFromIndex(Start) == LIS.getMBBFromIndex(End) &&'), (637, 1, u'+    assert(MI && "No instruction for back-copy");'), (676, 1, u'+  assert(MDT.dominates(DefMBB, MBB) && "MBB must be dominated by the def.");'), (741, 1, u'+    assert(ParentVNI && "Parent not live at complement def");'), (885, 1, u'+        assert(VNI && "Missing def for complex mapped value");'), (897, 1, u'+      assert(Start <= BlockStart && "Expected live-in block");'), (903, 1, u'+          assert(ParentVNI->isPHIDef() && "Non-phi defined at block start?");'), (905, 1, u'+          assert(VNI && "Missing def for complex mapped parent PHI");'), (954, 1, u'+        assert(RegAssign.lookup(LastUse) == RegIdx &&'), (1022, 1, u'+      assert(MI && "Missing instruction for dead def");'), (1121, 1, u'+  assert(!LRMap || LRMap->size() == Edit->size());'), (1184, 1, u'+  assert((IntvIn || IntvOut) && "Use splitSingleBlock for isolated blocks");'), (1186, 1, u'+  assert((!LeaveBefore || LeaveBefore < Stop) && "Interference after block");'), (1187, 1, u'+  assert((!IntvIn || !LeaveBefore || LeaveBefore > Start) && "Impossible intf");'), (1188, 1, u'+  assert((!EnterAfter || EnterAfter >= Start) && "Interference before block");'), (1201, 1, u'+    assert((!LeaveBefore || Idx <= LeaveBefore) && "Interference");'), (1215, 1, u'+    assert((!EnterAfter || Idx >= EnterAfter) && "Interference");'), (1233, 1, u'+  assert((!IntvOut || !EnterAfter || EnterAfter < LSP) && "Impossible intf");'), (1253, 1, u'+    assert((!LeaveBefore || Idx <= LeaveBefore) && "Interference");'), (1254, 1, u'+    assert((!EnterAfter || Idx >= EnterAfter) && "Interference");'), (1264, 1, u'+  assert(LeaveBefore <= EnterAfter && "Missed case");'), (1269, 1, u'+  assert((!EnterAfter || Idx >= EnterAfter) && "Interference");'), (1274, 1, u'+  assert((!LeaveBefore || Idx <= LeaveBefore) && "Interference");'), (1288, 1, u'+  assert(IntvIn && "Must have register in");'), (1289, 1, u'+  assert(BI.LiveIn && "Must be live-in");'), (1290, 1, u'+  assert((!LeaveBefore || LeaveBefore > Start) && "Bad interference");'), (1322, 1, u'+      assert((!LeaveBefore || Idx <= LeaveBefore) && "Interference");'), (1329, 1, u'+      assert((!LeaveBefore || Idx <= LeaveBefore) && "Interference");'), (1352, 1, u'+    assert((!LeaveBefore || From <= LeaveBefore) && "Interference");'), (1367, 1, u'+  assert((!LeaveBefore || From <= LeaveBefore) && "Interference");'), (1382, 1, u'+  assert(IntvOut && "Must have register out");'), (1383, 1, u'+  assert(BI.LiveOut && "Must be live-out");'), (1384, 1, u'+  assert((!EnterAfter || EnterAfter < LSP) && "Bad interference");'), (1408, 1, u'+    assert((!EnterAfter || Idx >= EnterAfter) && "Interference");'), (1424, 1, u'+  assert((!EnterAfter || Idx >= EnterAfter) && "Interference");')]
===========================================
Class:  class StackProtector : public FunctionPass {   class StackProtector : public FunctionPass 
Class:  class StackSlotColoring : public MachineFunctionPass {   class StackSlotColoring : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(232, 1, u'+    assert(NextColor != -1 && "No more spill slots?");'), (270, 1, u'+    assert(NewSS >= 0 && "Stack coloring failed?");')]
===========================================
Class:  class StrongPHIElimination : public MachineFunctionPass {   class StrongPHIElimination : public MachineFunctionPass 
Class:  class TailDuplicatePass : public MachineFunctionPass {   class TailDuplicatePass : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(385, 1, u'+  assert(SrcOpIdx && "Unable to find matching PHI source?");'), (462, 1, u'+      assert(Idx != 0);'), (719, 1, u'+    assert(NumSuccessors <= 1);'), (754, 1, u'+    assert(TailBB != PredBB &&'), (811, 1, u'+    assert(PredBB->succ_empty() &&'), (854, 1, u'+        assert(!MI->isBundle() && "Not expecting bundles before regalloc!");'), (870, 1, u'+    assert(PrevBB->succ_empty());'), (933, 1, u'+  assert(MBB->pred_empty() && "MBB must be dead!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+  assert(MI->getOperand(Idx1).isReg() && MI->getOperand(Idx2).isReg() &&'), (134, 1, u'+  assert(!MI->isBundle() &&'), (169, 1, u'+  assert(!MI->isBundle() &&'), (251, 1, u'+  assert(!Orig->isNotDuplicable() &&'), (260, 1, u'+  assert(MI->isCopy() && "MI must be a COPY instruction");'), (263, 1, u'+  assert(FoldIdx<2 && "FoldIdx refers no nonexistent operand");'), (274, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(FoldReg) &&'), (314, 1, u'+  assert(MBB && "foldMemoryOperand needs an inserted instruction");'), (320, 1, u'+    assert((!(Flags & MachineMemOperand::MOStore) ||'), (323, 1, u'+    assert((!(Flags & MachineMemOperand::MOLoad) ||'), (327, 1, u'+    assert(MFI.getObjectOffset(FI) != -1);'), (364, 1, u'+  assert(LoadMI->canFoldAsLoad() && "LoadMI isn\'t foldable!");'), (367, 1, u'+    assert(MI->getOperand(Ops[i]).isUse() && "Folding load into def!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(201, 1, u'+  assert(Kind.isReadOnlyWithRel() && "Unknown section kind");'), (257, 1, u'+      assert(Kind.isMergeable1ByteCString() && "unknown string width");'), (293, 1, u'+  assert(Kind.isReadOnlyWithRel() && "Unknown section kind");'), (312, 1, u'+  assert(Kind.isReadOnlyWithRel() && "Unknown section kind");')]
===========================================
Class:  class TwoAddressInstructionPass : public MachineFunctionPass {   class TwoAddressInstructionPass : public MachineFunctionPass 
Class:  class UnreachableBlockElim : public FunctionPass {   class UnreachableBlockElim : public FunctionPass 
Class:  class UnreachableMachineBlockElim : public MachineFunctionPass {   class UnreachableMachineBlockElim : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(virtReg));'), (91, 1, u'+  assert(Virt2StackSlotMap[virtReg] == NO_STACK_SLOT &&'), (98, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(virtReg));'), (99, 1, u'+  assert(Virt2StackSlotMap[virtReg] == NO_STACK_SLOT &&'), (101, 1, u'+  assert((SS >= 0 ||'), (139, 1, u'+        assert(PhysReg != NO_PHYS_REG && "Instruction uses unmapped VirtReg");'), (140, 1, u'+        assert(!Reserved.test(PhysReg) && "Reserved register assignment");'), (166, 1, u'+          assert(PhysReg && "Invalid SubReg for physical register");')]
===========================================
Class:  class DescriptorContainsAddress {   class DescriptorContainsAddress 
Class:  class CountArangeDescriptors {   class CountArangeDescriptors 
Class:   class AddArangeDescriptors {   class AddArangeDescriptors 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(104, 1, u'+  assert (fixed_form_sizes); // For best performance this should be specified!')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(381, 1, u'+          assert(opcode - 1U < prologue->StandardOpcodeLengths.size());')]
===========================================
Class:class GVMemoryBlock : public CallbackVH { class GVMemoryBlock : public CallbackVH 
Class:class ArgvArray { class ArgvArray 
Class:class IntelJITEventListener : public JITEventListener { class IntelJITEventListener : public JITEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(694, 1, u'+    assert(i != -1 && "PHINode doesn\'t contain entry for predecessor??");'), (735, 1, u'+  assert(Result.PointerVal != 0 && "Null pointer returned by malloc!");'), (747, 1, u'+  assert(Ptr->getType()->isPointerTy() &&'), (771, 1, u'+        assert(BitWidth == 64 && "Invalid index type for getelementptr");'), (945, 1, u'+  assert(SrcVal->getType()->isDoubleTy() && DstTy->isFloatTy() &&'), (954, 1, u'+  assert(SrcVal->getType()->isFloatTy() && DstTy->isDoubleTy() &&'), (965, 1, u'+  assert(SrcTy->isFloatingPointTy() && "Invalid FPToUI instruction");'), (979, 1, u'+  assert(SrcTy->isFloatingPointTy() && "Invalid FPToSI instruction");'), (991, 1, u'+  assert(DstTy->isFloatingPointTy() && "Invalid UIToFP instruction");'), (1003, 1, u'+  assert(DstTy->isFloatingPointTy() && "Invalid SIToFP instruction");'), (1017, 1, u'+  assert(SrcVal->getType()->isPointerTy() && "Invalid PtrToInt instruction");'), (1026, 1, u'+  assert(DstTy->isPointerTy() && "Invalid PtrToInt instruction");'), (1042, 1, u'+    assert(SrcTy->isPointerTy() && "Invalid BitCast");'), (1262, 1, u'+  assert((ECStack.empty() || ECStack.back().Caller.getInstruction() == 0 ||'), (1283, 1, u'+  assert((ArgVals.size() == F->arg_size() ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(304, 1, u'+  assert(Args.size() == 1);'), (429, 1, u'+  assert(args.size() < 10 && "Only handle up to 10 args to sscanf right now!");'), (445, 1, u'+  assert(args.size() < 10 && "Only handle up to 10 args to scanf right now!");'), (462, 1, u'+  assert(Args.size() >= 2);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(77, 1, u'+  assert (F && "Function *F was null at entry to run()");')]
===========================================
Class:class JitPool { class JitPool 
Class:  class MCIListener : public JITEventListener {   class MCIListener : public JITEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(42, 1, u'+  assert(MMI && "MachineModuleInfo not registered!");'), (200, 1, u'+  assert(MMI && "MachineModuleInfo not registered!");'), (257, 1, u'+        assert(Actions.size());'), (271, 1, u'+        assert(-1-TypeID < (int)FilterOffsets.size() && "Unknown filter id!");'), (303, 1, u'+      assert(!PadMap.count(BeginLabel) && "Duplicate landing pad labels!");'), (321, 1, u'+      assert(BeginLabel && "Invalid label!");'), (334, 1, u'+      assert(BeginLabel == LandingPad->BeginLabels[P.RangeIndex] &&'), (349, 1, u'+      assert(Site.BeginLabel && Site.EndLabel && Site.PadLabel &&')]
===========================================
Class:  class JITEmitter;
Class:   class JITResolverState {   class JITResolverState 
Class:         class JITResolver {   class JITResolver 
Class:   class StubToResolverMapTy {   class StubToResolverMapTy 
Class:         class JITEmitter : public JITCodeEmitter {   class JITEmitter : public JITCodeEmitter 
Class:  class DefaultJITMemoryManager;
Class:   class JITSlabAllocator : public SlabAllocator {   class JITSlabAllocator : public SlabAllocator 
Class:                     class DefaultJITMemoryManager : public JITMemoryManager {   class DefaultJITMemoryManager : public JITMemoryManager 
Class:class StatSymbols { class StatSymbols 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(121, 1, u'+  assert(F && "Function *F was null at entry to run()");'), (124, 1, u'+  assert(FPtr && "Pointer to fn\'s code was null after getPointerToFunction");'), (128, 1, u'+  assert((FTy->getNumParams() == ArgValues.size() ||'), (131, 1, u'+  assert(FTy->getNumParams() == ArgValues.size() &&')]
===========================================
Class:class OProfileJITEventListener : public JITEventListener { class OProfileJITEventListener : public JITEventListener 
Class:class GDBJITRegistrar : public JITRegistrar { class GDBJITRegistrar : public JITRegistrar 
Class:class DyldELFObject : public ELFObjectFile<target_endianness, is64Bits> { class DyldELFObject : public ELFObjectFile<target_endianness, is64Bits> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(248, 1, u'+    assert(si != se && "No section containing relocation!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 1, u'+  assert(Target && "Could not allocate target machine!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(52, 1, u'+        assert(!I->hasDLLImportLinkage()'), (64, 1, u'+        assert(!I->hasDLLImportLinkage()')]
===========================================
Class:class TypeMapTy : public ValueMapTypeRemapper { class TypeMapTy : public ValueMapTypeRemapper 
Class:  class ModuleLinker {   class ModuleLinker 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(215, 1, u'+    assert(!SrcSTy->isOpaque() && "Not resolving a definition?");'), (459, 1, u'+    assert(ConflictGV->getName() != Name && "forceRenaming didn\'t work");'), (498, 1, u'+  assert(Dest && "Must have two globals being queried");'), (499, 1, u'+  assert(!Src->hasLocalLinkage() &&'), (549, 1, u'+    assert((Dest->hasExternalLinkage()  || Dest->hasDLLImportLinkage() ||'), (922, 1, u'+  assert(Src && Dst && Dst->isDeclaration() && !Src->isDeclaration());'), (1002, 1, u'+    assert(Op->getNumOperands() == 3 && "Invalid module flag metadata!");'), (1003, 1, u'+    assert(isa<ConstantInt>(Op->getOperand(0)) &&'), (1005, 1, u'+    assert(isa<MDString>(Op->getOperand(1)) &&'), (1013, 1, u'+      assert(false && "Invalid behavior in module flag metadata!");'), (1127, 1, u'+      assert(isa<MDNode>(Node->getOperand(2)) &&'), (1155, 1, u'+  assert(DstM && "Null destination module");'), (1156, 1, u'+  assert(SrcM && "Null source module");')]
===========================================
Class:class ELFObjectWriter : public MCObjectWriter { class ELFObjectWriter : public MCObjectWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(555, 1, u'+  assert(!(Data.isCommon() && !Data.isExternal()));'), (577, 1, u'+  assert(StringTable.size() && "Missing string table");'), (611, 1, u'+    assert(((Data.getFlags() & ELF_STB_Global) ||'), (758, 1, u'+    assert(isInt<64>(Addend));'), (760, 1, u'+    assert(isInt<32>(Addend));'), (906, 1, u'+      assert(!Local);'), (921, 1, u'+      assert(MSD.SectionIndex && "Invalid section index!");'), (1274, 1, u'+    assert(sh_link && ".symtab not found");'), (1316, 1, u'+    assert(0 && "FIXME: sh_type value not supported!");'), (1335, 1, u'+    assert(F.getKind() == MCFragment::FT_Data);'), (1367, 1, u'+      assert(F.getKind() == MCFragment::FT_Data);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+  assert((size_t)Kind <= sizeof(Builtins) / sizeof(Builtins[0]) &&')]
===========================================
Class:class MCAsmStreamer : public MCStreamer { class MCAsmStreamer : public MCStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 1, u'+  assert(LastValid->getParent() == F->getParent());'), (100, 1, u'+  assert(F->Offset != ~UINT64_C(0) && "Address not set!");'), (132, 1, u'+  assert(SD->getFragment() && "Invalid getOffset() on undefined symbol!");'), (290, 1, u'+  assert((ShouldAlignPC ? IsPCRel : true) &&'), (360, 1, u'+  assert(!isFragmentUpToDate(F) && "Attempt to recompute up-to-date fragment!");'), (363, 1, u'+  assert((!Prev || isFragmentUpToDate(Prev)) &&'), (393, 1, u'+    assert(AF.getValueSize() && "Invalid virtual align in concrete fragment!");'), (430, 1, u'+    assert(FragmentSize == DF.getContents().size() && "Invalid size!");'), (438, 1, u'+    assert(FF.getValueSize() && "Invalid virtual align in concrete fragment!");'), (485, 1, u'+  assert(OW->getStream().tell() - Start == FragmentSize);'), (492, 1, u'+    assert(Layout.getSectionFileSize(SD) == 0 && "Invalid size for section!");'), (504, 1, u'+        assert(DF.fixup_begin() == DF.fixup_end() &&'), (507, 1, u'+          assert(DF.getContents()[i] == 0 &&'), (514, 1, u'+        assert((!cast<MCAlignFragment>(it)->getValueSize() ||'), (519, 1, u'+        assert(!cast<MCFillFragment>(it)->getValueSize() &&'), (535, 1, u'+  assert(getWriter().getStream().tell() - Start =='), (711, 1, u'+  assert(IsAbs);'), (729, 1, u'+  assert(IsAbs);'), (746, 1, u'+  assert(IsAbs);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(17, 1, u'+  assert(Type == TextAtom && "Trying to add MCInst to a non-text atom!");'), (19, 1, u'+  assert(Address < End+Size &&'), (28, 1, u'+  assert(Type == DataAtom && "Trying to add MCData to a non-data atom!");'), (35, 1, u'+  assert((SplitPt > Begin && SplitPt <= End) &&'), (55, 1, u'+    assert(I != Data.end() && "Split point not found in range!");'), (64, 1, u'+    assert(I != Text.end() && "Split point not found in disassembly!");'), (65, 1, u'+    assert(I->first == SplitPt &&'), (77, 1, u'+  assert((TruncPt >= Begin && TruncPt < End) &&'), (89, 1, u'+    assert(I != Text.end() && "Truncation point not found in disassembly!");'), (90, 1, u'+    assert(I->first == TruncPt+1 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 1, u'+  assert(!Name.empty() && "Normal symbols cannot be unnamed!");'), (94, 1, u'+    assert(isTemporary && "Cannot rename non temporary symbols");')]
===========================================
Class:class Target;
Class:class DisasmMemoryObject : public MemoryObject { class DisasmMemoryObject : public MemoryObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 1, u'+  assert(TheTarget && "Unable to create target!");'), (60, 1, u'+  assert(MAI && "Unable to create target asm info!");'), (63, 1, u'+  assert(MII && "Unable to create target instruction info!");'), (66, 1, u'+  assert(MRI && "Unable to create target register info!");'), (74, 1, u'+  assert(STI && "Unable to create subtarget info!");'), (78, 1, u'+  assert(Ctx && "Unable to create MCContext!");'), (82, 1, u'+  assert(DisAsm && "Unable to create disassembler!");'), (89, 1, u'+  assert(IP && "Unable to create instruction printer!");'), (95, 1, u'+  assert(DC && "Allocation failure!");'), (177, 1, u'+    assert(OutStringSize != 0 && "Output buffer cannot be zero size");')]
===========================================
Class:  class EDMemoryObject : public llvm::MemoryObject {   class EDMemoryObject : public llvm::MemoryObject 
Class:  class FrameEmitterImpl {   class FrameEmitterImpl 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(958, 1, u'+      assert(Dst.isReg() && "Machine move not supported yet.");'), (1454, 1, u'+    assert(isUInt<32>(AddrDelta));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(23, 1, u'+  assert(Binding == ELF::STB_LOCAL || Binding == ELF::STB_GLOBAL ||'), (31, 1, u'+  assert(Binding == ELF::STB_LOCAL || Binding == ELF::STB_GLOBAL ||'), (37, 1, u'+  assert(Type == ELF::STT_NOTYPE || Type == ELF::STT_OBJECT ||'), (48, 1, u'+  assert(Type == ELF::STT_NOTYPE || Type == ELF::STT_OBJECT ||'), (56, 1, u'+  assert(Visibility == ELF::STV_DEFAULT || Visibility == ELF::STV_INTERNAL ||'), (66, 1, u'+  assert(Visibility == ELF::STV_DEFAULT || Visibility == ELF::STV_INTERNAL ||')]
===========================================
Class:class MCELFStreamer : public MCObjectStreamer { class MCELFStreamer : public MCObjectStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(406, 1, u'+  assert((!Layout || Asm) &&')]
===========================================
Class:class MCMachOStreamer : public MCObjectStreamer { class MCMachOStreamer : public MCObjectStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(119, 1, u'+  assert(Symbol->isUndefined() && "Cannot define a symbol twice!");'), (270, 1, u'+  assert(DescValue == (DescValue & SF_DescFlagsMask) &&'), (279, 1, u'+  assert(Symbol->isUndefined() && "Cannot define a symbol twice!");'), (296, 1, u'+  assert(Symbol->isUndefined() && "Cannot define a symbol twice!");'), (389, 1, u'+      assert(it->getOffset() == 0 && "Invalid offset in atom defining symbol!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(17, 1, u'+  assert(Begin < End && "Creating MCAtom with endpoints reversed?");'), (21, 1, u'+  assert((!I.valid() || I.start() < End) && "Offset range already occupied!");'), (34, 1, u'+  assert(I.valid() && "Atom offset not found in module!");'), (35, 1, u'+  assert(*I == Atom && "Previous atom mapping was invalid!");')]
===========================================
Class:  class MCNullStreamer : public MCStreamer {   class MCNullStreamer : public MCStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+  assert(getCurrentSectionData() && "No current section!");'), (93, 1, u'+  assert(AddrSpace == 0 && "Address space must be 0!");'), (126, 1, u'+  assert(!SD.getFragment() && "Unexpected fragment on symbol data!");'), (157, 1, u'+  assert(Section && "Cannot switch to a null section!");')]
===========================================
Class:class AsmParser : public MCAsmParser { class AsmParser : public MCAsmParser 
Class:   class GenericAsmParser : public MCAsmParserExtension { class GenericAsmParser : public MCAsmParserExtension 
Class:class COFFAsmParser : public MCAsmParserExtension { class COFFAsmParser : public MCAsmParserExtension 
Class:class DarwinAsmParser : public MCAsmParserExtension { class DarwinAsmParser : public MCAsmParserExtension 
Class:class ELFAsmParser : public MCAsmParserExtension { class ELFAsmParser : public MCAsmParserExtension 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(27, 1, u'+  assert(!TargetParser && "Target parser is already initialized!");')]
===========================================
Class:class MCPureStreamer : public MCObjectStreamer { class MCPureStreamer : public MCObjectStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(115, 1, u'+  assert(Symbol->isUndefined() && "Cannot define a symbol twice!");'), (116, 1, u'+  assert(!Symbol->isVariable() && "Cannot emit a variable symbol!");'), (117, 1, u'+  assert(getCurrentSection() && "Cannot emit before setting section!");'), (133, 1, u'+  assert(!SD.getFragment() && "Unexpected fragment on symbol data!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(72, 1, u'+        assert (0 && "unsupported COFF selection type");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(125, 1, u'+    assert(Flags & ELF::SHF_MERGE);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(78, 1, u'+  assert(Segment.size() <= 16 && Section.size() <= 16 &&'), (105, 1, u'+  assert(SectionType <= MCSectionMachO::LAST_KNOWN_SECTION_TYPE &&'), (148, 1, u'+  assert(SectionAttrs == 0 && "Unknown section attributes!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 1, u'+  assert(Size <= 8 && "Invalid size");'), (83, 1, u'+  assert((isUIntN(8 * Size, Value) || isIntN(8 * Size, Value)) &&'), (180, 1, u'+  assert(!Symbol->isVariable() && "Cannot emit a variable symbol!");'), (181, 1, u'+  assert(getCurrentSection() && "Cannot emit before setting section!");'), (272, 1, u'+  assert(EH || Debug);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+  assert(ProcItins && "Instruction itineraries information not available!");'), (77, 1, u'+    assert(strcmp(ProcItins[i - 1].Key, ProcItins[i].Key) < 0 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(32, 1, u'+  assert(!Str.empty() && "Cannot create an empty MCSymbol");'), (55, 1, u'+  assert(!IsUsed && "Cannot set a variable that has already been used.");'), (56, 1, u'+  assert(Value && "Invalid variable value!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(174, 1, u'+    assert(frameInst.getOperation() == Win64EH::UOP_SetFPReg);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(136, 1, u'+  assert(OS.tell() - Start =='), (179, 1, u'+  assert(OS.tell() - Start == SegmentLoadCommandSize);'), (192, 1, u'+    assert(Layout.getSectionFileSize(&SD) == 0 && "Invalid file size!");'), (218, 1, u'+  assert(isPowerOf2_32(SD.getAlignment()) && "Invalid alignment!");'), (228, 1, u'+  assert(OS.tell() - Start == (is64Bit() ? macho::Section64Size :'), (248, 1, u'+  assert(OS.tell() - Start == macho::SymtabLoadCommandSize);'), (285, 1, u'+  assert(OS.tell() - Start == macho::DysymtabLoadCommandSize);'), (330, 1, u'+      assert((1U << Log2Size) == Align && "Invalid \'common\' alignment!");'), (430, 1, u'+  assert(Index <= 256 && "Too many sections!");'), (473, 1, u'+      assert(MSD.SectionIndex && "Invalid section index!");'), (506, 1, u'+      assert(MSD.SectionIndex && "Invalid section index!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+  assert(!Feature.empty() && "Empty string");'), (47, 1, u'+  assert(!Feature.empty() && "Empty string");'), (58, 1, u'+  assert(!Feature.empty() && "Empty string");'), (269, 1, u'+    assert(strcmp(CPUTable[i - 1].Key, CPUTable[i].Key) < 0 &&'), (273, 1, u'+    assert(strcmp(FeatureTable[i - 1].Key, FeatureTable[i].Key) < 0 &&'), (343, 1, u'+  assert(Table && "missing table");'), (346, 1, u'+    assert(strcmp(Table[i - 1].Key, Table[i].Key) < 0 && "Table is not sorted");')]
===========================================
Class:class COFFSymbol;
Class: class COFFSymbol { class COFFSymbol 
Class: class COFFSection { class COFFSection 
Class:  class StringTable { class StringTable 
Class: class WinCOFFObjectWriter : public MCObjectWriter { class WinCOFFObjectWriter : public MCObjectWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(238, 1, u'+    assert(Section->Number != -1 && "Sections with relocations must be real!");'), (367, 1, u'+  assert(SectionData.getSection().getVariant() == MCSection::SV_COFF'), (430, 1, u'+      assert(Value->getKind() == MCExpr::SymbolRef &&'), (637, 1, u'+  assert(Target.getSymA() != NULL && "Relocation must reference a symbol!");'), (645, 1, u'+  assert(SectionMap.find(&SectionData->getSection()) != SectionMap.end() &&'), (647, 1, u'+  assert(SymbolMap.find(&A_SD.getSymbol()) != SymbolMap.end() &&'), (732, 1, u'+      assert(coff_symbol->Section != NULL);'), (753, 1, u'+      assert(coff_symbol->Index != -1);'), (754, 1, u'+      assert(coff_symbol->Aux.size() == 1 &&'), (756, 1, u'+      assert(coff_symbol->Aux[0].AuxType == ATWeakExternal &&'), (807, 1, u'+        assert((*cr).Symb->Index != -1);'), (812, 1, u'+    assert(Sec->Symbol->Aux.size() == 1'), (815, 1, u'+    assert(Aux.AuxType == ATSectionDefinition &&'), (851, 1, u'+        assert(OS.tell() == (*i)->Header.PointerToRawData &&'), (858, 1, u'+        assert(OS.tell() == (*i)->Header.PointerToRelocations &&'), (877, 1, u'+        assert((*i)->Header.PointerToRelocations == 0 &&'), (882, 1, u'+  assert(OS.tell() == Header.PointerToSymbolTable &&')]
===========================================
Class:class WinCOFFStreamer : public MCObjectStreamer { class WinCOFFStreamer : public MCObjectStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+    assert(end <= sizeof(Name) && end > 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(66, 1, u'+  assert((offset - Header->PointerToSymbolTable) % sizeof(coff_symbol)'), (83, 1, u'+  assert(offset % sizeof(coff_section) == 0 &&')]
===========================================
Class:class _object_error_category : public _do_message { class _object_error_category : public _do_message 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(144, 1, u'+  assert(Index < getHeader().NumLoadCommands && "Invalid index!");'), (289, 1, u'+  assert(LCI.Command.Type == macho::LCT_Segment &&'), (312, 1, u'+  assert(LCI.Command.Type == macho::LCT_Segment64 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(448, 1, u'+  assert(loc != Sections.end() && "Sec is not a valid section!");'), (465, 1, u'+  assert(LCI.Command.Type == macho::LCT_Segment && "Unexpected Type.");'), (754, 1, u'+      assert(Sym.d.a < MachOObj->getHeader().NumLoadCommands &&'), (1257, 1, u'+      assert((MachOObj->getHeader().CPUType & llvm::MachO::CPUArchABI64) == 0 &&'), (1269, 1, u'+    assert((MachOObj->getHeader().CPUType & llvm::MachO::CPUArchABI64) == 1 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+  assert(Alignment && (Alignment & (Alignment - 1)) == 0 &&'), (119, 1, u'+    assert((uintptr_t)Ptr + Size <= (uintptr_t)NewSlab + NewSlab->Size);'), (127, 1, u'+  assert(CurPtr <= End && "Unable to allocate memory!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 1, u'+  assert(n <= d && "Probability must be less or equal to 1.");')]
===========================================
Class:class HelpPrinter { class HelpPrinter 
Class:class VersionPrinter { class VersionPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 1, u'+  assert(L.getBitWidth() == U.getBitWidth() &&'), (47, 1, u'+  assert((L != U || (L.isMaxValue() || L.isMinValue())) &&'), (244, 1, u'+  assert(Val.getBitWidth() == getBitWidth() && "Wrong bit width");'), (257, 1, u'+  assert(getBitWidth() == CR.getBitWidth() &&'), (338, 1, u'+  assert(getBitWidth() == CR.getBitWidth() &&'), (395, 1, u'+    assert(CR.Lower.ult(Upper) && CR.Upper.ult(Lower) &&'), (422, 1, u'+  assert(SrcTySize < DstTySize && "Not a value extension");'), (438, 1, u'+  assert(SrcTySize < DstTySize && "Not a value extension");'), (452, 1, u'+  assert(getBitWidth() > DstTySize && "Not a value truncation");')]
===========================================
Class:class DAGDeltaAlgorithmImpl { class DAGDeltaAlgorithmImpl 
Class:  class DeltaActiveSetHelper : public DeltaAlgorithm { class DeltaActiveSetHelper : public DeltaAlgorithm 
Class:class DataFileStreamer : public DataStreamer { class DataFileStreamer : public DataStreamer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+  assert(!llvm_is_multithreaded() &&'), (43, 1, u'+  assert(!ErrorHandler && "Error handler already registered!\\n");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(107, 1, u'+      assert(sys::isLittleEndianHost() && "Unexpected host endianness");'), (186, 1, u'+  assert((Ptr & 1) && "Not a bucket pointer");'), (210, 1, u'+  assert(5 < Log2InitSize && Log2InitSize < 32 &&'), (292, 1, u'+  assert(N->getNextInBucket() == 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(26, 1, u'+  assert(NumClasses == 0 && "grow() called after compress().");'), (33, 1, u'+  assert(NumClasses == 0 && "join() called after compress().");'), (47, 1, u'+  assert(NumClasses == 0 && "findLeader() called after compress().");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(20, 1, u'+  assert(!path.empty() && "Can\'t replace missing root");'), (49, 1, u'+  assert(Level != 0 && "Cannot move the root node");'), (56, 1, u'+      assert(l != 0 && "Cannot move beyond begin()");'), (99, 1, u'+  assert(Level != 0 && "Cannot move the root node");'), (123, 1, u'+  assert(Elements + Grow <= Nodes * Capacity && "Not enough room for elements");'), (124, 1, u'+  assert(Position <= Elements && "Invalid position");'), (138, 1, u'+  assert(Sum == Elements + Grow && "Bad distribution sum");'), (142, 1, u'+    assert(PosPair.first < Nodes && "Bad algebra");'), (143, 1, u'+    assert(NewSize[PosPair.first] && "Too few elements to need Grow");'), (150, 1, u'+    assert(NewSize[n] <= Capacity && "Overallocated node");'), (153, 1, u'+  assert(Sum == Elements && "Bad distribution sum");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(48, 1, u'+    assert(Ptr == 0 && DeleterFn == 0 && Next == 0 &&'), (60, 1, u'+  assert(DeleterFn && "ManagedStatic not initialized correctly!");'), (61, 1, u'+  assert(StaticList == this &&')]
===========================================
Class:class MemoryBufferMem : public MemoryBuffer { class MemoryBufferMem : public MemoryBuffer 
Class:class MemoryBufferMMapFile : public MemoryBufferMem { class MemoryBufferMMapFile : public MemoryBufferMem 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+  assert(errorcode == 0); (void)errorcode;'), (60, 1, u'+  assert(errorcode == 0);'), (65, 1, u'+  assert(errorcode == 0);'), (70, 1, u'+  assert(errorcode == 0);'), (74, 1, u'+  assert(errorcode == 0);'), (84, 1, u'+  assert(mutex != 0);'), (93, 1, u'+  assert(mutex != 0);'), (103, 1, u'+  assert(mutex != 0);'), (113, 1, u'+  assert(mutex != 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+  assert(magic && "Invalid magic number string");'), (44, 1, u'+  assert(length >=4 && "Invalid magic number length");'), (248, 1, u"+  assert(Sep[0] != '\\0' && Sep[1] == '\\0' &&")]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(169, 1, u'+  assert(Position < Path.size() && "Tried to increment past end!");'), (881, 1, u'+    assert(obviously_this_exists);'), (886, 1, u'+    assert(obviously_this_exists);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+  assert(Plugins.isConstructed() && num < Plugins->size() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(118, 1, u'+  assert(PrettyStackTraceHead.get() == this &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 1, u'+  assert(errorcode == 0);'), (71, 1, u'+  assert(rwlock != 0);'), (80, 1, u'+  assert(rwlock != 0);'), (90, 1, u'+  assert(rwlock != 0);'), (100, 1, u'+  assert(rwlock != 0);'), (110, 1, u'+  assert(rwlock != 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(85, 1, u'+      assert(pm[i].rm_eo >= pm[i].rm_so);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(24, 1, u'+  assert(!isSmall() && "Can\'t shrink a small set!");'), (33, 1, u'+  assert(CurArray && "Failed to allocate memory?");'), (143, 1, u'+  assert(CurArray && "Failed to allocate memory?");'), (184, 1, u'+    assert(CurArray && "Failed to allocate memory?");'), (201, 1, u'+    assert(CurArraySize == RHS.CurArraySize &&'), (215, 1, u'+    assert(CurArray && "Failed to allocate memory?");'), (271, 1, u'+  assert(this->isSmall() && RHS.isSmall());'), (272, 1, u'+  assert(this->CurArraySize == RHS.CurArraySize);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 1, u'+  assert(BufferID != -1 && "Invalid Location!");'), (128, 1, u'+  assert(CurBuf != -1 && "Invalid or unspecified location!");'), (150, 1, u'+  assert(CurBuf != -1 && "Invalid or unspecified location!");'), (209, 1, u'+  assert(CurBuf != -1 && "Invalid or unspecified location!");')]
===========================================
Class:class StatisticInfo { class StatisticInfo 
Class:class RawMemoryObject : public StreamableMemoryObject { class RawMemoryObject : public StreamableMemoryObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(23, 1, u'+    assert(LastChar > FirstChar && "Invalid start/end range");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+  assert((InitSize & (InitSize-1)) == 0 &&'), (161, 1, u'+  assert(V == V2 && "Didn\'t find key?");'), (174, 1, u'+  assert(NumItems + NumTombstones <= NumBuckets);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(22, 1, u'+  assert(InternTable.empty() && "PooledStringPtr leaked!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(362, 1, u'+  assert(Radix > 1 && Radix <= 36);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 1, u'+  assert(Name && ShortDesc && TQualityFn &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(46, 1, u'+  assert(errorcode == 0);'), (54, 1, u'+  assert(errorcode == 0);'), (62, 1, u'+  assert(errorcode == 0);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 1, u'+  assert(!multithreaded_mode && "Already multithreaded!");'), (43, 1, u'+  assert(multithreaded_mode && "Not currently multithreaded!");')]
===========================================
Class:class Name2PairMap { class Name2PairMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(461, 1, u'+      assert(Pos < Components.size() && Components[Pos] == Comp &&'), (507, 1, u'+  assert(!Str.empty() && Str[0] >= \'0\' && Str[0] <= \'9\' && "Not a number");')]
===========================================
Class:class Scanner { class Scanner 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(727, 1, u'+    assert(!TokenQueue.empty() &&'), (1164, 1, u'+    assert(i != e && "SimpleKey not in token queue!");'), (1194, 1, u'+  assert(Position - 1 >= First);'), (1257, 1, u'+  assert(Indent >= -1 && "Indent must be >= -1 !");'), (1646, 1, u'+    assert(!UnquotedValue.empty() && "Can\'t be empty!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(63, 1, u'+  assert(OutBufCur == OutBufStart &&'), (89, 1, u'+  assert(((Mode == Unbuffered && BufferStart == 0 && Size == 0) ||'), (94, 1, u'+  assert(GetNumBytesInBuffer() == 0 && "Current buffer is non-empty!");'), (103, 1, u'+  assert(OutBufStart <= OutBufEnd && "Invalid size!");'), (261, 1, u'+  assert(OutBufCur > OutBufStart && "Invalid call to flush_nonempty.");'), (325, 1, u'+  assert(Size <= size_t(OutBufEnd - OutBufCur) && "Buffer overrun!");'), (379, 1, u'+    assert(BytesUsed > NextBufferSize && "Didn\'t grow buffer!?");'), (424, 1, u'+  assert(Filename != 0 && "Filename is null");'), (426, 1, u'+  assert((!(Flags & F_Excl) || !(Flags & F_Append)) &&'), (519, 1, u'+  assert(FD >= 0 && "File already closed.");'), (568, 1, u'+  assert(ShouldClose);'), (590, 1, u'+  assert(FD >= 0 && "File not yet open!");'), (722, 1, u'+  assert(GetNumBytesInBuffer() == 0 && "Didn\'t flush before mutating vector");'), (734, 1, u'+    assert(OS.size() + Size <= OS.capacity() && "Invalid write_impl() call!");'), (737, 1, u'+    assert(GetNumBytesInBuffer() == 0 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(244, 1, u'+\t\tSETERROR(REG_ASSERT);'), (293, 1, u'+\tassert(!MORE() || SEE(stop));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(153, 1, u'+\tassert(!(g->iflags&REGEX_BAD));')]
===========================================
Class:class _generic_error_category : public _do_message { class _generic_error_category : public _do_message 
Class: class _system_error_category : public _do_message { class _system_error_category : public _do_message 
Class:class TableGenStringKey { class TableGenStringKey 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(119, 1, u'+    assert(BInit != 0);'), (769, 1, u'+  assert(Lex.getCode() == tgtok::Id && "Expected ID in ParseIDValue");'), (793, 1, u'+      assert(RV && "Template arg doesn\'t exist??");'), (804, 1, u'+      assert(RV && "Template arg doesn\'t exist??");'), (928, 1, u'+          assert(LHSt && "expected list type argument in unary operator");'), (1640, 1, u'+    assert(RV && "Template argument record not found??");'), (1657, 1, u'+      assert(RV && "Template argument record not found??");'), (1701, 1, u'+      assert(CurMultiClass);'), (1777, 1, u'+  assert(Lex.getCode() == tgtok::less && "Not a template arg list!");'), (1929, 1, u'+  assert(Lex.getCode() == tgtok::Def && "Unknown tok");'), (1967, 1, u'+  assert(CurRec->getTemplateArgs().empty() && "How\'d this get template args?");'), (1976, 1, u'+      assert(RV && "Template arg doesn\'t exist?");'), (1997, 1, u'+  assert(Lex.getCode() == tgtok::Foreach && "Unknown tok");'), (2046, 1, u'+  assert(Lex.getCode() == tgtok::Class && "Unexpected token!");'), (2125, 1, u'+  assert(Lex.getCode() == tgtok::Let && "Unexpected token");'), (2169, 1, u'+  assert(Lex.getCode() == tgtok::MultiClass && "Unexpected token");'), (2382, 1, u'+      assert(RV && "Template arg doesn\'t exist?");'), (2395, 1, u'+  assert(Lex.getCode() == tgtok::Defm && "Unexpected token!");'), (2426, 1, u'+    assert(MC && "Didn\'t lookup multiclass correctly?");')]
===========================================
Class:  class AttributeEmitter {   class AttributeEmitter 
Class:   class AsmAttributeEmitter : public AttributeEmitter {   class AsmAttributeEmitter : public AttributeEmitter 
Class:   class ObjectAttributeEmitter : public AttributeEmitter {   class ObjectAttributeEmitter : public AttributeEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(89, 1, u'+      assert(false && "Duplicated entries?");'), (407, 1, u'+  assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (408, 1, u'+  assert((Cond.size() == 2 || Cond.size() == 0) &&'), (540, 1, u'+  assert(JTI < JT.size());'), (610, 1, u'+    assert(MJTI != 0);'), (612, 1, u'+    assert(JTI < JT.size());'), (640, 1, u'+    assert(!I->isBundle() && "No nested bundle!");'), (714, 1, u'+      assert(Dst && Src && "Bad sub-register");'), (1126, 1, u'+  assert(MCPE.isMachineConstantPoolEntry() &&'), (1378, 1, u'+  assert(Offset2 > Offset1);'), (1588, 1, u'+    assert(ThisVal && "Didn\'t extract field correctly");'), (1593, 1, u'+    assert(ARM_AM::getSOImmVal(ThisVal) != -1 && "Bit extraction didn\'t work?");'), (1650, 1, u'+    assert(ARM_AM::getSOImmVal(ThisImmVal) != -1 &&'), (1699, 1, u'+    assert((Offset & (Scale-1)) == 0 && "Can\'t encode this offset!");'), (2436, 1, u'+  assert(II->isInsideBundle() && "Empty bundle?");'), (2447, 1, u'+  assert(Idx != -1 && "Cannot find bundled definition!");'), (2458, 1, u'+  assert(II->isInsideBundle() && "Empty bundle?");'), (3056, 1, u'+  assert(MI->getOpcode() == ARM::VMOVD && "Can only swizzle VMOVD");'), (3061, 1, u'+  assert(!isPredicated(MI) && "Cannot predicate a VORRd");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 1, u'+    assert(ARM::D31 == ARM::D16 + 15);'), (758, 1, u'+      assert(!AFI->isThumb1OnlyFunction() &&'), (774, 1, u'+        assert(Opc == ARM::ADJCALLSTACKUP || Opc == ARM::tADJCALLSTACKUP);'), (839, 1, u'+    assert(i < MI->getNumOperands() &&"Instr doesn\'t have FrameIndex operand!");'), (954, 1, u'+  assert(!AFI->isThumb1OnlyFunction() &&'), (959, 1, u'+    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (965, 1, u'+    assert(AFI->isThumb2Function());'), (968, 1, u'+  assert (Done && "Unable to resolve frame index!");'), (980, 1, u'+    assert(i < MI->getNumOperands() &&"Instr doesn\'t have FrameIndex operand!");'), (1050, 1, u'+  assert(!AFI->isThumb1OnlyFunction() &&'), (1055, 1, u'+    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (1069, 1, u'+    assert(TFI->hasReservedCallFrame(MF) &&'), (1072, 1, u'+    assert(!MF.getFrameInfo()->hasVarSizedObjects() &&'), (1090, 1, u'+    assert(AFI->isThumb2Function());'), (1099, 1, u'+  assert((Offset ||'), (1118, 1, u'+      assert(AFI->isThumb2Function());')]
===========================================
Class:  class ARMCodeEmitter : public MachineFunctionPass {   class ARMCodeEmitter : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(368, 1, u'+  assert((MF.getTarget().getRelocationModel() != Reloc::Default ||'), (418, 1, u'+  assert(((Reloc == ARM::reloc_arm_movt) || (Reloc == ARM::reloc_arm_movw))'), (637, 1, u'+    assert(ACPV->isGlobalValue() && "unsupported constant pool value");'), (722, 1, u'+  assert(MO1.isImm() && ARM_AM::isSOImmTwoPartVal(MO1.getImm()) &&'), (965, 1, u'+    assert(ARM_AM::getSORegOffset(MO2.getImm()) == 0);'), (975, 1, u'+  assert(SoImmVal != -1 && "Not a valid so_imm value!");'), (1159, 1, u'+  assert(TargetRegisterInfo::isPhysicalRegister(MO2.getReg()));'), (1291, 1, u'+    assert(TargetRegisterInfo::isPhysicalRegister(MO.getReg()) &&'), (1412, 1, u'+    assert(ShiftAmt != 0 && "PKHTB shift_imm is 0!");'), (1416, 1, u'+  assert(ShiftAmt < 32 && "shift_imm range is 0 to 31!");'), (1438, 1, u'+  assert((Pos < 16 || (Pos < 32 &&'), (1456, 1, u'+    assert(ShiftAmt < 32 && "shift_imm range is 0 to 31!");'), (1593, 1, u'+  assert((Binary & ARMII::D_BitShift) == 0 &&'), (1790, 1, u'+  assert((Binary & 0xfe000000) == 0xf2000000 &&'), (1830, 1, u'+  assert((Opc1 & 3) == 0 && "out-of-range lane number operand");')]
===========================================
Class:  class ARMConstantIslands : public MachineFunctionPass {   class ARMConstantIslands : public MachineFunctionPass 
Class:  class ARMExpandPseudo : public MachineFunctionPass {   class ARMExpandPseudo : public MachineFunctionPass 
Class:class ARMFastISel : public FastISel { class ARMFastISel : public FastISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(475, 1, u'+  assert(TargetRegisterInfo::isVirtualRegister(Op0) &&'), (881, 1, u'+  assert(VT.isSimple() && "Non-simple types are invalid here!");'), (985, 1, u'+  assert(VT.isSimple() && "Non-simple types are invalid here!");'), (1063, 1, u'+  assert (ResultReg > 255 && "Expected an allocated virtual register.");'), (1641, 1, u'+    assert (VT == MVT::i32 && "Expecting an i32.");'), (1705, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported SDIV!");'), (1727, 1, u'+  assert(LC != RTLIB::UNKNOWN_LIBCALL && "Unsupported SREM!");'), (1911, 1, u'+    assert((!ArgVT.isVector() && ArgVT.getSizeInBits() <= 64) &&'), (1920, 1, u'+        assert (Arg != 0 && "Failed to emit a sext");'), (1929, 1, u'+        assert (Arg != 0 && "Failed to emit a sext");'), (1936, 1, u'+        assert(BC != 0 && "Failed to emit a bitcast!");'), (1952, 1, u'+      assert(VA.getLocVT() == MVT::f64 &&'), (1957, 1, u'+      assert(VA.isRegLoc() && NextVA.isRegLoc() &&'), (1967, 1, u'+      assert(VA.isMemLoc());'), (1975, 1, u'+      assert(EmitRet && "Could not emit a store for argument!");'), (2015, 1, u'+      assert(RVLocs.size() == 1 &&"Can\'t handle non-double multi-reg retvals!");'), (2084, 1, u'+      assert(DestVT == MVT::i32 && "ARM should always ext to i32");'), (2361, 1, u'+      assert(Len == 1);'), (2368, 1, u'+    assert (RV == true && "Should be able to handle this load.");'), (2370, 1, u'+    assert (RV == true && "Should be able to handle this store.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(139, 1, u'+  assert(!AFI->isThumb1OnlyFunction() &&'), (287, 1, u'+    assert (!AFI->isThumb1OnlyFunction());'), (341, 1, u'+  assert(MBBI->isReturn() && "Can only insert epilog into returning blocks");'), (349, 1, u'+  assert(!AFI->isThumb1OnlyFunction() &&'), (392, 1, u'+          assert(MF.getRegInfo().isPhysRegUsed(ARM::R4) &&'), (440, 1, u'+        assert(JumpTarget.isSymbol());'), (504, 1, u'+    assert (hasFP(MF) && "dynamic stack realignment without a FP!");'), (509, 1, u'+      assert(RegInfo->hasBasePointer(MF) &&'), (524, 1, u'+      assert(RegInfo->hasBasePointer(MF) && "missing base pointer!");'), (757, 1, u'+  assert(!AFI->isThumb1OnlyFunction() && "Can\'t realign stack for thumb1");'), (853, 1, u'+  assert(MI->mayStore() && "Expecting spill instruction");'), (859, 1, u'+    assert(MI->mayStore() && "Expecting spill instruction");'), (862, 1, u'+    assert(MI->mayStore() && "Expecting spill instruction");'), (866, 1, u'+    assert(MI->killsRegister(ARM::R4) && "Missed kill flag");'), (899, 1, u'+  assert(!AFI->isThumb1OnlyFunction() && "Can\'t realign stack for thumb1");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+  assert(Stalls == 0 && "ARM hazards don\'t support scoreboard lookahead");')]
===========================================
Class:class ARMDAGToDAGISel : public SelectionDAGISel { class ARMDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(320, 1, u'+  assert(Scale > 0 && "Invalid scale!");'), (1602, 1, u'+  assert(NumVecs >= 1 && NumVecs <= 4 && "VLD NumVecs out-of-range");'), (1630, 1, u'+    assert(NumVecs == 1 && "v2i64 type only supported for VLD1");'), (1696, 1, u'+      assert(isa<ConstantSDNode>(Inc.getNode()) &&'), (1719, 1, u'+  assert(ARM::dsub_7 == ARM::dsub_0+7 &&'), (1734, 1, u'+  assert(NumVecs >= 1 && NumVecs <= 4 && "VST NumVecs out-of-range");'), (1766, 1, u'+    assert(NumVecs == 1 && "v2i64 type only supported for VST1");'), (1861, 1, u'+    assert(isa<ConstantSDNode>(Inc.getNode()) &&'), (1880, 1, u'+  assert(NumVecs >=2 && NumVecs <= 4 && "VLDSTLane NumVecs out-of-range");'), (1984, 1, u'+  assert(ARM::dsub_7 == ARM::dsub_0+7 &&'), (1998, 1, u'+  assert(NumVecs >=2 && NumVecs <= 4 && "VLDDup NumVecs out-of-range");'), (2068, 1, u'+  assert(ARM::dsub_7 == ARM::dsub_0+7 && "Unexpected subreg numbering");'), (2081, 1, u'+  assert(NumVecs >= 2 && NumVecs <= 4 && "VTBL NumVecs out-of-range");'), (2133, 1, u'+        assert(Srl_imm > 0 && Srl_imm < 32 && "bad amount in shift node!");'), (2152, 1, u'+    assert(Shl_imm > 0 && Shl_imm < 32 && "bad amount in shift node!");'), (2155, 1, u'+      assert(Srl_imm > 0 && Srl_imm < 32 && "bad amount in shift node!");'), (2289, 1, u'+  assert(CC.getOpcode() == ISD::Constant);'), (2290, 1, u'+  assert(CCR.getOpcode() == ISD::Register);'), (2376, 1, u'+  assert(CCR.getOpcode() == ISD::Register);'), (2795, 1, u'+    assert(N1.getOpcode() == ISD::BasicBlock);'), (2796, 1, u'+    assert(N2.getOpcode() == ISD::Constant);'), (2797, 1, u'+    assert(N3.getOpcode() == ISD::Register);'), (2884, 1, u'+      assert(NumElts == 2 && "unexpected type for BUILD_VECTOR");'), (2887, 1, u'+    assert(EltVT == MVT::f32 && "unexpected type for BUILD_VECTOR");'), (2890, 1, u'+    assert(NumElts == 4 && "unexpected type for BUILD_VECTOR");'), (3385, 1, u'+  assert(ConstraintCode == \'m\' && "unexpected asm memory constraint");')]
===========================================
Class:  class ARMCCState : public CCState {   class ARMCCState : public CCState 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(255, 1, u'+    assert((!ACPV->hasModifier() && !ACPV->mustAddCurrentAddress()) &&'), (312, 1, u'+      assert(ResultPtr >= -33554432 && ResultPtr <= 33554428);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(428, 1, u'+        assert(Idx >= 0 && "Cannot find killing operand");'), (1174, 1, u'+        assert(!TRI->regsOverlap(OddReg, BaseReg));'), (1411, 1, u'+      assert(((isThumb2 && Opcode == ARM::t2LDMIA_UPD) ||'), (1550, 1, u'+  assert(MI->memoperands_empty() && "expected a new machineinstr");'), (1640, 1, u'+      assert(LHS == RHS || LOffset != ROffset);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(74, 1, u'+    assert(!MO.getSubReg() && "Subregs should be eliminated!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(208, 1, u'+  assert(InstrItins.IssueWidth <= 2 && "itinerary bug, too many stage 1 units");')]
===========================================
Class:class ARMPassConfig : public TargetPassConfig { class ARMPassConfig : public TargetPassConfig 
Class:class ARMBaseAsmLexer : public MCTargetAsmLexer { class ARMBaseAsmLexer : public MCTargetAsmLexer 
Class: class ARMAsmLexer : public ARMBaseAsmLexer { class ARMAsmLexer : public ARMBaseAsmLexer 
Class: class ThumbAsmLexer : public ARMBaseAsmLexer { class ThumbAsmLexer : public ARMBaseAsmLexer 
Class:class ARMOperand;
Class: class ARMAsmParser : public MCTargetAsmParser { class ARMAsmParser : public MCTargetAsmParser 
Class:class ARMOperand : public MCParsedAsmOperand { class ARMOperand : public MCParsedAsmOperand 
Class:class ARMDisassembler : public MCDisassembler { class ARMDisassembler : public MCDisassembler 
Class:  class ThumbDisassembler : public MCDisassembler { class ThumbDisassembler : public MCDisassembler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 1, u'+    assert(ARM_AM::getSORegOffset(MO3.getImm()) == 0);'), (210, 1, u'+    assert(Op.isExpr() && "unknown operand kind in printOperand");'), (257, 1, u'+  assert(ARM_AM::getSORegOffset(MO3.getImm()) == 0);'), (562, 1, u'+  assert(MO.isImm() && "Not a valid bf_inv_mask_imm value!");'), (588, 1, u'+  assert(Imm > 0 && Imm < 32 && "Invalid PKH shift immediate value!");'), (598, 1, u'+  assert(Imm > 0 && Imm <= 32 && "Invalid PKH shift immediate value!");'), (711, 1, u'+    assert(MI->getOperand(OpNum).getReg() == ARM::CPSR &&'), (759, 1, u'+  assert(NumTZ <= 3 && "Invalid IT mask!");'), (839, 1, u'+  assert(MO2.isImm() && "Not a valid t2_so_reg value!");'), (959, 1, u'+  assert(MO2.getReg() && "Invalid so_reg load / store address!");'), (964, 1, u'+    assert(ShAmt <= 3 && "Not a valid Thumb2 addressing mode!");'), (998, 1, u'+  default: assert (0 && "illegal ror immediate!");')]
===========================================
Class:class ARMELFObjectWriter : public MCELFObjectTargetWriter { class ARMELFObjectWriter : public MCELFObjectTargetWriter 
Class: class ARMAsmBackend : public MCAsmBackend { class ARMAsmBackend : public MCAsmBackend 
Class:class ELFARMAsmBackend : public ARMAsmBackend { class ELFARMAsmBackend : public ARMAsmBackend 
Class:  class DarwinARMAsmBackend : public ARMAsmBackend { class DarwinARMAsmBackend : public ARMAsmBackend 
Class:  class ARMELFObjectWriter : public MCELFObjectTargetWriter {   class ARMELFObjectWriter : public MCELFObjectTargetWriter 
Class:class ARMMCCodeEmitter : public MCCodeEmitter { class ARMMCCodeEmitter : public MCCodeEmitter 
Class:class ARMMCInstrAnalysis : public MCInstrAnalysis { class ARMMCInstrAnalysis : public MCInstrAnalysis 
Class:class ARMMachObjectWriter : public MCMachObjectTargetWriter { class ARMMachObjectWriter : public MCMachObjectTargetWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(203, 1, u'+  assert((MBBI->getOpcode() == ARM::tBX_RET ||'), (243, 1, u'+        assert(MF.getRegInfo().isPhysRegUsed(ARM::R4) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 1, u'+  assert(ARM::GPRRegClass.contains(DestReg, SrcReg) &&'), (56, 1, u'+  assert((RC == ARM::tGPRRegisterClass ||'), (84, 1, u'+  assert((RC == ARM::tGPRRegisterClass ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(111, 1, u'+      assert(BaseReg == ARM::SP && "Unexpected!");'), (186, 1, u'+    assert(isMul4 && "Thumb sp inc / dec size must be multiple of 4!");'), (212, 1, u'+      assert(isMul4 && "Thumb sp inc / dec size must be multiple of 4!");'), (331, 1, u'+        assert(Opc == ARM::ADJCALLSTACKUP || Opc == ARM::tADJCALLSTACKUP);'), (408, 1, u'+      assert((Offset & 3) == 0 &&'), (490, 1, u'+    assert((Offset & (Scale - 1)) == 0 && "Can\'t encode this offset!");'), (538, 1, u'+    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (541, 1, u'+  assert (Done && "Unable to resolve frame index!");'), (608, 1, u'+    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (621, 1, u'+    assert(SPAdj == 0 && MF.getTarget().getFrameLowering()->hasFP(MF) &&'), (638, 1, u'+    assert(MF.getTarget().getFrameLowering()->hasReservedCallFrame(MF) &&'), (641, 1, u'+    assert(!MF.getFrameInfo()->hasVarSizedObjects() &&'), (655, 1, u'+  assert(AFI->isThumbFunction() &&'), (663, 1, u'+  assert(Offset && "This code isn\'t needed if offset already handled!");')]
===========================================
Class:  class Thumb2ITBlockPass : public MachineFunctionPass {   class Thumb2ITBlockPass : public MachineFunctionPass 
Class:  class Thumb2SizeReduce : public MachineFunctionPass {   class Thumb2SizeReduce : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(187, 1, u'+      assert(false && "Duplicated entries?");'), (463, 1, u'+    assert((!HasShift || OffsetReg) && "Invalid so_reg load / store address!");'), (833, 1, u'+    assert(LiveCPSR && "CPSR liveness tracking is wrong!");')]
===========================================
Class:  class SPUAsmPrinter : public AsmPrinter {   class SPUAsmPrinter : public AsmPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(86, 1, u'+      assert(value < (1 << 8) && "Invalid u7 argument");'), (126, 1, u'+      assert(value <= (1 << 19) - 1 && "Invalid u18 argument");'), (135, 1, u'+      assert((value >= -(1 << 9) && value <= (1 << 9) - 1)'), (145, 1, u'+      assert((value <= (1 << 10) - 1) && "Invalid u10 argument");'), (152, 1, u'+      assert(MI->getOperand(OpNo).isImm() &&'), (156, 1, u'+      assert((value16 >= -(1 << (9+4)) && value16 <= (1 << (9+4)) - 1)'), (225, 1, u'+        assert((value >= 0 && value < 16)'), (234, 1, u'+      assert(MI->getOperand(OpNo).isImm() &&'), (237, 1, u'+      assert((value >= 0 && value <= 32)')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(67, 1, u'+  assert(isPowerOf2_32(Align) && "Alignment is not power of 2");'), (111, 1, u'+  assert((FrameSize & 0xf) == 0'), (198, 1, u'+  assert(MBBI->getOpcode() == SPU::RET &&'), (200, 1, u'+  assert((FrameSize & 0xf) == 0 && "FrameSize not aligned");')]
===========================================
Class:  class SPUDAGToDAGISel :   class SPUDAGToDAGISel :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(597, 1, u'+    assert( false && "add a new case here" );')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 1, u'+  assert( isEvenPlace && "basic block start from odd address");'), (149, 1, u'+             assert( false && "got unknown FuncUnit\\n");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(266, 1, u'+    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (286, 1, u'+  assert((Offset & 0xf) == 0'), (335, 1, u'+    default: assert( false && "Unhandled D to X-form conversion");'), (350, 1, u'+  assert(RS && "Register scavenging must be on");'), (354, 1, u'+  assert( Reg && "Register scavenger failed");')]
===========================================
Class:class SPUPassConfig : public TargetPassConfig { class SPUPassConfig : public TargetPassConfig 
Class:  class CppWriter : public ModulePass {   class CppWriter : public ModulePass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(493, 1, u'+      assert(attrs == 0 && "Unhandled attribute!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 1, u'+    assert(0 && "<unknown operand type>");'), (231, 1, u'+  assert( (MO.getType() == MachineOperand::MO_GlobalAddress) &&'), (244, 1, u'+  assert( (MO.getType() == MachineOperand::MO_JumpTableIndex) &&'), (254, 1, u'+  assert( (MO.getType() == MachineOperand::MO_ConstantPoolIndex) &&')]
===========================================
Class:class HexagonCFGOptimizer : public MachineFunctionPass { class HexagonCFGOptimizer : public MachineFunctionPass 
Class:class HexagonExpandPredSpillCode : public MachineFunctionPass { class HexagonExpandPredSpillCode : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 1, u'+        assert(FP == QTM.getRegisterInfo()->getFrameRegister() &&'), (82, 1, u'+        assert(MI->getOperand(1).isImm() && "Not an offset");'), (85, 1, u'+        assert(Hexagon::PredRegsRegClass.contains(SrcReg) &&'), (122, 1, u'+        assert(Hexagon::PredRegsRegClass.contains(DstReg) &&'), (125, 1, u'+        assert(FP == QTM.getRegisterInfo()->getFrameRegister() &&'), (127, 1, u'+        assert(MI->getOperand(2).isImm() && "Not an offset");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(108, 1, u'+    assert((MI->getOpcode() == Hexagon::ADJDYNALLOC) &&'), (112, 1, u'+    assert(MO.isImm() && "Expected immediate");'), (241, 1, u'+    assert(SuperReg[0] && !SuperReg[1] && "Expected exactly one superreg");'), (247, 1, u'+      assert(SuperRegNext[0] && !SuperRegNext[1] &&'), (302, 1, u'+    assert(SuperReg[0] && !SuperReg[1] && "Expected exactly one superreg");'), (306, 1, u'+      assert(SuperRegNext[0] && !SuperRegNext[1] &&')]
===========================================
Class:  class CountValue;
Class:             class CountValue {   class CountValue 
Class:class HexagonDAGToDAGISel : public SelectionDAGISel { class HexagonDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 1, u'+  assert ( (NumNamedVarArgParams > 0) &&'), (100, 1, u'+    assert ((ArgFlags.getByValSize() > 8) &&'), (127, 1, u'+    assert ((ArgFlags.getByValSize() > 8) &&'), (853, 1, u'+        assert (0);'), (856, 1, u'+      assert (0 && "ByValSize must be bigger than 8 bytes");'), (859, 1, u'+      assert(VA.isMemLoc());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(129, 1, u'+    assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (1258, 1, u'+  assert (isPredicable(MI) && "Expected predicable instruction");'), (1400, 1, u'+    assert((Offset % 4 == 0) && "Offset has incorrect alignment");'), (1406, 1, u'+    assert((Offset % 8 == 0) && "Offset has incorrect alignment");'), (1414, 1, u'+    assert((Offset % 2 == 0) && "Offset has incorrect alignment");'), (1446, 1, u'+    assert ((Offset % 4) == 0 && "MEMOPw offset is not aligned correctly." );'), (1463, 1, u'+    assert ((Offset % 2) == 0 && "MEMOPh offset is not aligned correctly." );')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(52, 1, u'+      assert(0 && "unknown operand type");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(128, 1, u'+        assert (MI->getNumOperands() == 2);'), (146, 1, u'+        assert (MI->getNumOperands() == 2);'), (164, 1, u'+        assert (MI->getNumOperands() == 2);'), (256, 1, u'+  assert (&Dst != &Src && "Cannot duplicate into itself");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(138, 1, u'+  assert(SPAdj == 0 && "Unexpected");'), (145, 1, u'+    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 1, u'+            assert (EVT::getEVT(SI->getType()) ==')]
===========================================
Class:class HexagonSplitTFRCondSets : public MachineFunctionPass { class HexagonSplitTFRCondSets : public MachineFunctionPass 
Class:class HexagonPassConfig : public TargetPassConfig { class HexagonPassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 1, u'+    assert(false && "Unknown operand");'), (116, 1, u'+  assert(MI->getOperand(OpNo).isExpr() && "Expecting expression");'), (123, 1, u'+  assert(MI->getOperand(OpNo).isExpr() && "Expecting expression");'), (130, 1, u'+  assert(MI->getOperand(OpNo).isExpr() && "Expecting expression");'), (139, 1, u'+  assert("Unknown branch operand.");'), (163, 1, u'+    assert("Unknown symbol operand");')]
===========================================
Class:  class MBlazeBaseAsmLexer : public MCTargetAsmLexer {   class MBlazeBaseAsmLexer : public MCTargetAsmLexer 
Class:   class MBlazeAsmLexer : public MBlazeBaseAsmLexer {   class MBlazeAsmLexer : public MBlazeBaseAsmLexer 
Class:class MBlazeAsmParser : public MCTargetAsmParser { class MBlazeAsmParser : public MCTargetAsmParser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(140, 1, u'+    assert(Kind == Register && "Invalid access!");'), (145, 1, u'+    assert(Kind == Immediate && "Invalid access!");'), (150, 1, u'+    assert(Kind == Fsl && "Invalid access!");'), (155, 1, u'+    assert(Kind == Memory && "Invalid access!");'), (160, 1, u'+    assert(Kind == Memory && "Invalid access!");'), (165, 1, u'+    assert(Kind == Memory && "Invalid access!");'), (186, 1, u'+    assert(N == 1 && "Invalid number of operands!");'), (191, 1, u'+    assert(N == 1 && "Invalid number of operands!");'), (196, 1, u'+    assert(N == 1 && "Invalid number of operands!");'), (201, 1, u'+    assert(N == 2 && "Invalid number of operands!");'), (213, 1, u'+    assert(Kind == Token && "Invalid access!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+  assert((Modifier == 0 || Modifier[0] == 0) && "No modifiers supported");'), (43, 1, u'+    assert(Op.isExpr() && "unknown operand kind in printOperand");')]
===========================================
Class:  class MBlazeAsmPrinter : public AsmPrinter {   class MBlazeAsmPrinter : public AsmPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 1, u'+  assert((RelTy == ELF::R_MICROBLAZE_32_PCREL ||')]
===========================================
Class:class MBlazeDAGToDAGISel : public SelectionDAGISel { class MBlazeDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(746, 1, u'+      assert(VA.isMemLoc());'), (920, 1, u'+          Opcode = ISD::AssertSext;'), (922, 1, u'+          Opcode = ISD::AssertZext;'), (932, 1, u'+      assert(VA.isMemLoc());'), (1037, 1, u'+    assert(VA.isRegLoc() && "Can only return in registers!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(192, 1, u'+  assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (193, 1, u'+  assert((Cond.size() == 2 || Cond.size() == 0) &&'), (244, 1, u'+  assert(Cond.size() == 2 && "Invalid MBlaze branch opcode!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 1, u'+  assert(!isOverloaded(IntrID) && "MBlaze intrinsics are not overloaded");'), (52, 1, u'+  assert(IntrID < mblazeIntrinsic::num_mblaze_intrinsics &&'), (106, 1, u'+  assert(!isOverloaded(IntrID) && "MBlaze intrinsics are not overloaded");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(110, 1, u'+        assert(Old->getOpcode() == MBlaze::ADJCALLSTACKUP);'), (137, 1, u'+    assert(i < MI.getNumOperands() &&')]
===========================================
Class:class MBlazePassConfig : public TargetPassConfig { class MBlazePassConfig : public TargetPassConfig 
Class:class MBlazeAsmBackend : public MCAsmBackend { class MBlazeAsmBackend : public MCAsmBackend 
Class:class ELFMBlazeAsmBackend : public MBlazeAsmBackend { class ELFMBlazeAsmBackend : public MBlazeAsmBackend 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(136, 1, u'+  assert(Fixup.getOffset() + Size <= DataSize &&'), (163, 1, u'+    assert(0 && "Mac not supported on MBlaze");'), (166, 1, u'+    assert(0 && "Windows not supported on MBlaze");')]
===========================================
Class:  class MBlazeELFObjectWriter : public MCELFObjectTargetWriter {   class MBlazeELFObjectWriter : public MCELFObjectTargetWriter 
Class:class MBlazeMCCodeEmitter : public MCCodeEmitter { class MBlazeMCCodeEmitter : public MCCodeEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(40, 1, u'+    assert(Op.isExpr() && "unknown pcrel immediate operand");'), (47, 1, u'+  assert((Modifier == 0 || Modifier[0] == 0) && "No modifiers supported");'), (54, 1, u'+    assert(Op.isExpr() && "unknown operand kind in printOperand");'), (79, 1, u'+    assert(Disp.isImm() && "Expected immediate in displacement field");')]
===========================================
Class:  class MSP430AsmPrinter : public AsmPrinter {   class MSP430AsmPrinter : public AsmPrinter 
Class:  class MSP430DAGToDAGISel : public SelectionDAGISel {   class MSP430DAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(404, 1, u'+    assert(Node->getValueType(0) == MVT::i16);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(316, 1, u'+  assert(!isVarArg && "Varargs not supported yet");'), (342, 1, u'+          ArgValue = DAG.getNode(ISD::AssertSext, dl, RegVT, ArgValue,'), (345, 1, u'+          ArgValue = DAG.getNode(ISD::AssertZext, dl, RegVT, ArgValue,'), (355, 1, u'+      assert(VA.isMemLoc());'), (412, 1, u'+    assert(VA.isRegLoc() && "Can only return in registers!");'), (488, 1, u'+      assert(VA.isMemLoc());'), (663, 1, u'+  assert(!LHS.getValueType().isFloatingPoint() && "We don\'t handle FP yet");'), (865, 1, u'+  assert(VT == MVT::i16 && "Only support i16 for now!");'), (1134, 1, u'+  assert((Opc == MSP430::Select16 || Opc == MSP430::Select8) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(128, 1, u'+  assert(Cond.size() == 1 && "Invalid Xbranch condition!");'), (224, 1, u'+    assert(I->getOpcode() == MSP430::JCC && "Invalid conditional branch");'), (240, 1, u'+    assert(Cond.size() == 1);'), (241, 1, u'+    assert(TBB);'), (265, 1, u'+  assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (266, 1, u'+  assert((Cond.size() == 1 || Cond.size() == 0) &&'), (271, 1, u'+    assert(!FBB && "Unconditional branch with multiple successors!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(127, 1, u'+        assert(Old->getOpcode() == TII.getCallFrameDestroyOpcode());'), (166, 1, u'+  assert(SPAdj == 0 && "Unexpected");'), (176, 1, u'+    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (231, 1, u'+    assert(FrameIdx == MF.getFrameInfo()->getObjectIndexBegin() &&')]
===========================================
Class:class MSP430PassConfig : public TargetPassConfig { class MSP430PassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+  assert(!Str.empty() && "Cannot create an empty MCSymbol");'), (110, 1, u'+  assert(!Name.empty() && "getNameWithPrefix requires non-empty name");'), (152, 1, u'+  assert(Name.find_first_of("\\n\\"") != StringRef::npos);')]
===========================================
Class:class MipsAsmParser : public MCTargetAsmParser { class MipsAsmParser : public MCTargetAsmParser 
Class:  class MipsDisassembler : public MCDisassembler { class MipsDisassembler : public MCDisassembler 
Class:   class Mips64Disassembler : public MCDisassembler { class Mips64Disassembler : public MCDisassembler 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 1, u'+    assert(SRE && CE && "Binary expression must be sym+const.");'), (86, 1, u'+    assert(false && "Unexpected MCExpr type.");'), (141, 1, u'+  assert(Op.isExpr() && "unknown operand kind in printOperand");')]
===========================================
Class:class MipsAsmBackend : public MCAsmBackend { class MipsAsmBackend : public MCAsmBackend 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(165, 1, u'+    assert(unsigned(Kind - FirstTargetFixupKind) < getNumFixupKinds() &&'), (188, 1, u'+    assert(0 && "RelaxInstruction() unimplemented");')]
===========================================
Class:  class MipsELFObjectWriter : public MCELFObjectTargetWriter {   class MipsELFObjectWriter : public MCELFObjectTargetWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(79, 1, u'+  assert(Target.getSymA() && "SymA cannot be 0.");'), (236, 1, u'+  assert(Relocs.size() == RelocLs.size());')]
===========================================
Class:class MipsMCCodeEmitter : public MCCodeEmitter { class MipsMCCodeEmitter : public MCCodeEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(112, 1, u'+    assert(S->size() <= 7);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 1, u'+    assert(MO.isImm() && "CPRESTORE\'s operand must be an immediate.");'), (404, 1, u'+  assert(MO.isReg() && "unexpected inline asm memory operand");'), (544, 1, u'+  assert(MI->getNumOperands() == 4 && "Invalid no. of machine operands!");'), (545, 1, u'+  assert(MI->getOperand(0).isReg() && MI->getOperand(1).isImm() &&')]
===========================================
Class:class MipsCodeEmitter : public MachineFunctionPass { class MipsCodeEmitter : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(196, 1, u'+  assert(MI.getOperand(OpNo).isReg());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(191, 1, u'+  assert((!candidate->isCall() && !candidate->isReturn()) &&')]
===========================================
Class:class MipsDAGToDAGISel : public SelectionDAGISel { class MipsDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(180, 1, u'+      assert(Subtarget.isABI_O32());'), (264, 1, u'+      assert(TLI.allowsUnalignedMemoryAccesses(VT) &&'), (390, 1, u'+    assert(((Opc == ISD::ADDC || Opc == ISD::ADDE) ||'), (558, 1, u'+  assert(ConstraintCode == \'m\' && "unexpected asm memory constraint");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 1, u'+  assert(Offset > 0);'), (146, 1, u'+  assert(isInt<32>(Offset) && (Offset >= 0) &&'), (216, 1, u'+  assert(MI->getNumOperands() == 3);'), (217, 1, u'+  assert(MI->getOperand(0).isReg());'), (218, 1, u'+  assert(MI->getOperand(1).isReg());'), (281, 1, u'+    assert (Base.getReg() != Target.getReg());'), (328, 1, u'+  assert(MO.isReg());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(66, 1, u'+  assert(Subtarget.isABI_N64());'), (80, 1, u'+  assert(Subtarget.isABI_N64());'), (163, 1, u'+    assert(i < MI.getNumOperands() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+  assert(((!hasMips64() && (isABI_O32() || isABI_EABI())) ||')]
===========================================
Class:class MipsPassConfig : public TargetPassConfig { class MipsPassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(187, 1, u'+    assert(Op.isExpr() && "unknown operand kind in printOperand");'), (211, 1, u'+  assert (Op.isImm() && "Rounding modes must be immediate values");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 1, u'+  assert(SyntaxVariant == 0 && "We only have one syntax variant");')]
===========================================
Class:  class PTXFPRoundingModePass : public MachineFunctionPass {   class PTXFPRoundingModePass : public MachineFunctionPass 
Class:class PTXDAGToDAGISel : public SelectionDAGISel { class PTXDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(90, 1, u'+  assert(Node->getNumOperands() >= 3);'), (98, 1, u'+  assert(Target.getOpcode()  == ISD::BasicBlock);'), (99, 1, u'+  assert(Pred.getValueType() == MVT::i1);'), (114, 1, u'+  assert(VT.isSimple() && "READ_PARAM only implemented for MVT types");'), (129, 1, u'+    assert(Type == MVT::f64 && "Unexpected type!");'), (152, 1, u'+  assert(VT.isSimple() && "WRITE_PARAM only implemented for MVT types");'), (203, 1, u'+  assert(Addr.getValueType().isSimple() && "Type must be simple");'), (297, 1, u'+    assert(Addr.getValueType().isSimple() && "Type must be simple");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(155, 1, u'+  assert(Op.getValueType() == MVT::i1 && "SetCC type must be 1-bit integer");'), (191, 1, u'+  assert(PtrVT.isSimple() && "Pointer must be to primitive type.");'), (238, 1, u'+      assert((!MFI->isKernel() || Ins[i].VT != MVT::i1) &&'), (303, 1, u'+      assert(Outs.size() == 0 && "Kernel must return void.");'), (306, 1, u'+      assert(Outs.size() <= 1 && "Can at most return one value.");'), (318, 1, u'+    assert(Outs.size() < 2 && "Device functions can return at most one value");'), (398, 1, u'+  assert(getTargetMachine().getSubtarget<PTXSubtarget>().callsAreHandled() &&'), (408, 1, u'+  assert((isPrintf || function->getCallingConv() == CallingConv::PTX_Device) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 1, u'+      assert(MI.getNumOperands() >= 2 &&'), (278, 1, u'+  assert(TBB && "TBB is NULL");'), (357, 1, u'+  assert(target.isMBB() && "FIXME: detect branch target operand");')]
===========================================
Class:class PTXMCAsmStreamer : public MCStreamer { class PTXMCAsmStreamer : public MCStreamer 
Class:  class PTXMFInfoExtract : public MachineFunctionPass {   class PTXMFInfoExtract : public MachineFunctionPass 
Class:  class PTXRegAlloc : public MachineFunctionPass {   class PTXRegAlloc : public MachineFunctionPass 
Class:class PTXPassConfig : public TargetPassConfig { class PTXPassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(89, 1, u'+  assert(Modifier && "Must specify \'cc\' or \'reg\' as predicate op modifier!");'), (105, 1, u'+  assert(StringRef(Modifier) == "reg" &&'), (122, 1, u'+  assert(Value <= 31 && "Invalid u5imm argument!");'), (129, 1, u'+  assert(Value <= 63 && "Invalid u6imm argument!");'), (259, 1, u'+  assert(Op.isExpr() && "unknown operand kind in printOperand");')]
===========================================
Class:class PPCMachObjectWriter : public MCMachObjectTargetWriter { class PPCMachObjectWriter : public MCMachObjectTargetWriter 
Class: class PPCAsmBackend : public MCAsmBackend { class PPCAsmBackend : public MCAsmBackend 
Class:  class DarwinPPCAsmBackend : public PPCAsmBackend {   class DarwinPPCAsmBackend : public PPCAsmBackend 
Class:   class ELFPPCAsmBackend : public PPCAsmBackend {   class ELFPPCAsmBackend : public PPCAsmBackend 
Class:  class PPCELFObjectWriter : public MCELFObjectTargetWriter {   class PPCELFObjectWriter : public MCELFObjectTargetWriter 
Class:class PPCMCCodeEmitter : public MCCodeEmitter { class PPCMCCodeEmitter : public MCCodeEmitter 
Class:  class PPCAsmPrinter : public AsmPrinter {   class PPCAsmPrinter : public AsmPrinter 
Class:      class PPCLinuxAsmPrinter : public PPCAsmPrinter {   class PPCLinuxAsmPrinter : public PPCAsmPrinter 
Class:         class PPCDarwinAsmPrinter : public PPCAsmPrinter {   class PPCDarwinAsmPrinter : public PPCAsmPrinter 
Class:  class PPCCodeEmitter : public MachineFunctionPass {   class PPCCodeEmitter : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 1, u'+  assert((MF.getTarget().getRelocationModel() != Reloc::Default ||'), (129, 1, u'+      assert(TM.getRelocationModel() == Reloc::PIC_);'), (141, 1, u'+  assert((MI.getOpcode() == PPC::MTCRF || MI.getOpcode() == PPC::MTCRF8 ||'), (156, 1, u'+    assert(MovePCtoLROffset && "MovePCtoLR not seen yet?");'), (175, 1, u'+  assert(MO.isJTI());'), (218, 1, u'+  assert(MI.getOperand(OpNo+1).isReg());'), (234, 1, u'+  assert(MI.getOperand(OpNo+1).isReg());'), (252, 1, u'+    assert((MI.getOpcode() != PPC::MTCRF && MI.getOpcode() != PPC::MTCRF8 &&'), (258, 1, u'+  assert(MO.isImm() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(59, 1, u'+  assert(MBBI != Entry->end() && MBBI->getOpcode() == PPC::MTVRSAVE);'), (85, 1, u'+    assert(MBBI != Entry->begin() && "UPDATE_VRSAVE is first instr in block?");'), (87, 1, u'+    assert(MBBI->getOpcode() == PPC::MFVRSAVE && "VRSAVE instrs wandered?");'), (306, 1, u'+      assert(FPIndex && "No Frame Pointer Save Slot!");'), (357, 1, u'+      assert(isPowerOf2_32(MaxAlign) && isInt<16>(MaxAlign) &&'), (359, 1, u'+      assert(isInt<16>(NegFrameSize) && "Unhandled stack size and alignment!");'), (391, 1, u'+      assert(isPowerOf2_32(MaxAlign) && isInt<16>(MaxAlign) &&'), (393, 1, u'+      assert(isInt<16>(NegFrameSize) && "Unhandled stack size and alignment!");'), (508, 1, u'+  assert(MBBI != MBB.end() && "Returning block has no terminator");'), (515, 1, u'+  assert((RetOpcode == PPC::BLR ||'), (549, 1, u'+      assert(FPIndex && "No Frame Pointer Save Slot!");'), (566, 1, u'+    assert(StackAdjust.isImm() && "Expecting immediate value.");'), (570, 1, u'+    assert((Delta >= 0) && "Delta must be positive");'), (586, 1, u'+        assert(hasFP(MF) && "Expecting a valid the frame pointer.");'), (610, 1, u'+        assert(hasFP(MF) && "Expecting a valid the frame pointer.");'), (693, 1, u'+    assert(MBBI->getOperand(0).isReg() && "Expecting register operand.");'), (706, 1, u'+    assert(MBBI->getOperand(0).isReg() && "Expecting register operand.");'), (892, 1, u'+    assert(FI && "No Frame Pointer Save Slot!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(138, 1, u'+  assert(Stalls == 0 && "PPC hazards don\'t support scoreboard lookahead");'), (236, 1, u'+  assert(NumIssued < 5 && "Illegal dispatch group!");')]
===========================================
Class:  class PPCDAGToDAGISel : public SelectionDAGISel {   class PPCDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(537, 1, u'+    assert(LHS.getValueType() == MVT::f64 && "Unknown vt!");'), (716, 1, u'+    assert(OtherCondIdx == -1 && "Can\'t have split plus negation");'), (892, 1, u'+        assert((!isSExt || LoadedVT == MVT::i16) && "Invalid sext update load");'), (903, 1, u'+        assert(LD->getValueType(0) == MVT::i64 && "Unknown load result type!");'), (904, 1, u'+        assert((!isSExt || LoadedVT == MVT::i16) && "Invalid sext update load");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(577, 1, u'+  assert(N->getValueType(0) == MVT::v16i8 &&'), (579, 1, u'+  assert((UnitSize == 1 || UnitSize == 2 || UnitSize == 4) &&'), (615, 1, u'+  assert(N->getValueType(0) == MVT::v16i8 &&'), (651, 1, u'+  assert(N->getValueType(0) == MVT::v16i8 &&'), (697, 1, u'+  assert(isSplatShuffleMask(SVOp, EltSize));'), (716, 1, u'+    assert(Multiple > 1 && Multiple <= 4 && "How can this happen?");'), (780, 1, u'+    assert(CN->getValueType(0) == MVT::f32 && "Only one legal FP vector type!");'), (905, 1, u'+     assert(!cast<ConstantSDNode>(N.getOperand(1).getOperand(1))->getZExtValue()'), (908, 1, u'+      assert(Disp.getOpcode() == ISD::TargetGlobalAddress ||'), (1018, 1, u'+     assert(!cast<ConstantSDNode>(N.getOperand(1).getOperand(1))->getZExtValue()'), (1021, 1, u'+      assert(Disp.getOpcode() == ISD::TargetGlobalAddress ||'), (1311, 1, u'+  assert(!Subtarget.isPPC64() && "LowerVAARG is PPC32 only");'), (1747, 1, u'+      assert(VA.isMemLoc());'), (2087, 1, u'+            ArgVal = DAG.getNode(ISD::AssertSext, dl, MVT::i64, ArgVal,'), (2090, 1, u'+            ArgVal = DAG.getNode(ISD::AssertZext, dl, MVT::i64, ArgVal,'), (2753, 1, u'+    assert(VA.isRegLoc() && "Can only return in registers!");'), (2790, 1, u'+  assert(Mask && "Missing call preserved mask for calling convention");'), (2809, 1, u'+    assert(((Callee.getOpcode() == ISD::Register &&'), (2901, 1, u'+  assert((CallConv == CallingConv::C ||'), (3014, 1, u'+      assert((j < ByValArgLocs.size()) && "Index out of bounds!");'), (3016, 1, u'+      assert((VA.getValNo() == ByValVA.getValNo()) && "ValNo mismatch!");'), (3050, 1, u'+      assert(VA.isMemLoc());'), (3503, 1, u'+    assert(VA.isRegLoc() && "Can only return in registers!");'), (3695, 1, u'+  assert(Op.getOperand(0).getValueType().isFloatingPoint());'), (3745, 1, u'+  assert(Op.getOperand(0).getValueType() == MVT::i32 &&'), (3847, 1, u'+  assert(Op.getNumOperands() == 3 &&'), (3876, 1, u'+  assert(Op.getNumOperands() == 3 &&'), (3905, 1, u'+  assert(Op.getNumOperands() == 3 &&'), (3938, 1, u'+  assert(Val >= -16 && Val <= 15 && "vsplti is out of range!");'), (4006, 1, u'+  assert(BVN != 0 && "Expected a BuildVectorSDNode in LowerBUILD_VECTOR");'), (4187, 1, u'+    assert(LHSID == ((4*9+5)*9+6)*9+7 && "Illegal OP_COPY!");'), (4626, 1, u'+    assert(N->getValueType(0) == MVT::ppcf128);'), (4627, 1, u'+    assert(N->getOperand(0).getValueType() == MVT::ppcf128);'), (5419, 1, u'+        assert(UI != VCMPoNode->use_end() && "Didn\'t find user!");'), (5449, 1, u'+      assert(isDot && "Can\'t compare against a vector result!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(71, 1, u'+    assert(TII && "No InstrInfo?");'), (146, 1, u'+    assert(MI->getDesc().getOperandConstraint(0, MCOI::TIED_TO) &&'), (300, 1, u'+  assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (301, 1, u'+  assert((Cond.size() == 2 || Cond.size() == 0) &&'), (667, 1, u'+  assert(Cond.size() == 2 && "Invalid PPC branch opcode!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(327, 1, u'+  assert((*StubCallAddr >> 26) == 19 && "Call in stub is not indirect!");'), (422, 1, u'+      assert(ResultPtr >= -(1 << 23) && ResultPtr < (1 << 23) &&'), (430, 1, u'+      assert(ResultPtr >= -(1 << 13) && ResultPtr < (1 << 13) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+    assert(MO.isSymbol() && "Isn\'t a symbol reference");'), (86, 1, u'+      assert(MO.isGlobal() && "Extern symbol not handled yet");'), (145, 1, u'+      assert(!MO.getSubReg() && "Subregs should be eliminated!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(243, 1, u'+  assert(RS && "Register scavenging must be on");'), (436, 1, u'+  assert(MI.definesRegister(DestReg) &&'), (462, 1, u'+  assert(SPAdj == 0 && "Unexpected");'), (479, 1, u'+    assert(FIOperandNo != MI.getNumOperands() &&'), (590, 1, u'+    assert(ImmToIdxMap.count(OpC) &&')]
===========================================
Class:class PPCPassConfig : public TargetPassConfig { class PPCPassConfig : public TargetPassConfig 
Class:  class SparcAsmPrinter : public AsmPrinter {   class SparcAsmPrinter : public AsmPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(147, 1, u'+    assert(TargetRegisterInfo::isPhysicalRegister(MO.getReg()) &&'), (149, 1, u'+    assert(MO.getReg() != SP::O7 &&'), (248, 1, u'+  assert(MI->getNumOperands() == 4 && "Invalid number of operands!");'), (249, 1, u'+  assert(MI->getOperand(0).isReg() && MI->getOperand(1).isImm() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+  assert(MBBI->getOpcode() == SP::RETL &&')]
===========================================
Class:class SparcDAGToDAGISel : public SelectionDAGISel { class SparcDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 1, u'+  assert(SPAdj == 0 && "Unexpected");'), (82, 1, u'+    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");')]
===========================================
Class:class SparcPassConfig : public TargetPassConfig { class SparcPassConfig : public TargetPassConfig 
Class:class StructLayoutMap { class StructLayoutMap 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 1, u'+    assert(NumElts != 0 && "Can\'t have an empty CDS");'), (119, 1, u'+  assert(!GV->isDeclaration() && !GV->hasAvailableExternallyLinkage() &&'), (178, 1, u'+            assert(ITy->getBitWidth() == 32 && "Unknown width");'), (263, 1, u'+  assert(!Kind.isThreadLocal() && "Doesn\'t support TLS");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+  assert(isPhysicalRegister(reg) && "reg must be a physical register");'), (66, 1, u'+  assert(BestRC && "Couldn\'t find the register class");')]
===========================================
Class:class X86AsmLexer : public MCTargetAsmLexer { class X86AsmLexer : public MCTargetAsmLexer 
Class:class X86AsmParser : public MCTargetAsmParser { class X86AsmParser : public MCTargetAsmParser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(196, 1, u'+    assert(Kind == Token && "Invalid access!");'), (200, 1, u'+    assert(Kind == Token && "Invalid access!");'), (206, 1, u'+    assert(Kind == Register && "Invalid access!");'), (211, 1, u'+    assert(Kind == Immediate && "Invalid access!");'), (216, 1, u'+    assert(Kind == Memory && "Invalid access!");'), (220, 1, u'+    assert(Kind == Memory && "Invalid access!");'), (224, 1, u'+    assert(Kind == Memory && "Invalid access!");'), (228, 1, u'+    assert(Kind == Memory && "Invalid access!");'), (232, 1, u'+    assert(Kind == Memory && "Invalid access!");'), (350, 1, u'+    assert(N == 1 && "Invalid number of operands!");'), (355, 1, u'+    assert(N == 1 && "Invalid number of operands!");'), (382, 1, u'+    assert((N == 5) && "Invalid number of operands!");'), (391, 1, u'+    assert((N == 1) && "Invalid number of operands!");'), (439, 1, u'+    assert((SegReg || BaseReg || IndexReg) && "Invalid memory operand!");'), (442, 1, u'+    assert(((Scale == 1 || Scale == 2 || Scale == 4 || Scale == 8)) &&'), (482, 1, u'+    assert(TokPercent.is(AsmToken::Percent) && "Invalid token kind!");'), (701, 1, u'+    assert (Tok.getString() == "PTR" && "Unexpected token!");'), (1001, 1, u'+        assert(PatchedName.endswith("pd") && "Unexpected mnemonic!");'), (1479, 1, u'+  assert(!Operands.empty() && "Unexpect empty operand list!");'), (1481, 1, u'+  assert(Op->isToken() && "Leading operand should always be a mnemonic!");'), (1507, 1, u'+    assert(Repl && "Unknown wait-prefixed instruction");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 1, u'+    assert(Op.isExpr() && "unknown pcrel immediate operand");'), (131, 1, u'+    assert(Op.isExpr() && "unknown operand kind in printOperand");'), (154, 1, u'+    assert(DispSpec.isExpr() && "non-immediate displacement for LEA?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(93, 1, u'+    assert(Op.isExpr() && "unknown pcrel immediate operand");'), (122, 1, u'+    assert(Op.isExpr() && "unknown operand kind in printOperand");'), (160, 1, u'+    assert(DispSpec.isExpr() && "non-immediate displacement for LEA?");')]
===========================================
Class:class X86ELFObjectWriter : public MCELFObjectTargetWriter { class X86ELFObjectWriter : public MCELFObjectTargetWriter 
Class: class X86AsmBackend : public MCAsmBackend { class X86AsmBackend : public MCAsmBackend 
Class:class ELFX86AsmBackend : public X86AsmBackend { class ELFX86AsmBackend : public X86AsmBackend 
Class: class ELFX86_32AsmBackend : public ELFX86AsmBackend { class ELFX86_32AsmBackend : public ELFX86AsmBackend 
Class: class ELFX86_64AsmBackend : public ELFX86AsmBackend { class ELFX86_64AsmBackend : public ELFX86AsmBackend 
Class: class WindowsX86AsmBackend : public X86AsmBackend { class WindowsX86AsmBackend : public X86AsmBackend 
Class: class DarwinX86AsmBackend : public X86AsmBackend { class DarwinX86AsmBackend : public X86AsmBackend 
Class: class DarwinX86_32AsmBackend : public DarwinX86AsmBackend { class DarwinX86_32AsmBackend : public DarwinX86AsmBackend 
Class: class DarwinX86_64AsmBackend : public DarwinX86AsmBackend { class DarwinX86_64AsmBackend : public DarwinX86AsmBackend 
Class:  class X86ELFObjectWriter : public MCELFObjectTargetWriter {   class X86ELFObjectWriter : public MCELFObjectTargetWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 1, u'+        assert(Modifier == MCSymbolRefExpr::VK_None);'), (92, 1, u'+        assert(Modifier == MCSymbolRefExpr::VK_None);'), (96, 1, u'+        assert(Modifier == MCSymbolRefExpr::VK_None);')]
===========================================
Class:class X86MCCodeEmitter : public MCCodeEmitter { class X86MCCodeEmitter : public MCCodeEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(298, 1, u'+    assert((int(RegNo) > 0) && "Unknown physical register!");')]
===========================================
Class:class X86MachObjectWriter : public MCMachObjectTargetWriter { class X86MachObjectWriter : public MCMachObjectTargetWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(411, 1, u'+  assert(Target.getSymA()->getKind() == MCSymbolRefExpr::VK_TLVP &&')]
===========================================
Class:  class MCObjectWriter;
Class:  class X86WinCOFFObjectWriter : public MCWinCOFFObjectTargetWriter {   class X86WinCOFFObjectWriter : public MCWinCOFFObjectTargetWriter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(324, 1, u'+    assert(DispSpec.isGlobal() || DispSpec.isCPI() ||'), (333, 1, u'+    assert(IndexReg.getReg() != X86::ESP &&'), (353, 1, u'+  assert(isMem(MI, Op) && "Invalid memory reference!");'), (692, 1, u'+  assert (MI->getNumOperands() == 7 && "Invalid no. of machine operands!");'), (709, 1, u'+  assert(NOps==7);')]
===========================================
Class:  class Emitter : public MachineFunctionPass {   class Emitter : public MachineFunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(349, 1, u'+  assert(Mod < 4 && RegOpcode < 8 && RM < 8 && "ModRM Fields out of range!");'), (432, 1, u'+    assert(RelocOp->isJTI() && "Unexpected machine operand!");'), (476, 1, u'+    assert(IndexReg.getReg() == 0 && Is64BitMode &&'), (535, 1, u'+  assert(IndexReg.getReg() != X86::ESP &&'), (808, 1, u'+    assert(MO.isImm() && "Unknown RawFrm operand!");')]
===========================================
Class:class X86FastISel : public FastISel { class X86FastISel : public FastISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(178, 1, u'+        assert(RegMap[Stack[i]] == i && "Stack[] doesn\'t match RegMap[]!");'), (188, 1, u'+      assert(RegNo < NumFPRegs && "Regno out of range!");'), (226, 1, u'+      assert(Reg < NumFPRegs && "Register number out of range!");'), (328, 1, u'+  assert(MO.isReg() && "Expected an FP register!");'), (330, 1, u'+  assert(Reg >= X86::FP0 && Reg <= X86::FP6 && "Expected FP register!");'), (342, 1, u'+  assert(X86::FP6 == X86::FP0+6 && "Register enums aren\'t sorted right!");'), (388, 1, u'+  assert(LiveBundles.empty() && "Stale data in LiveBundles");'), (508, 1, u'+  assert(Bundle.isFixed() && "Reached block before any predecessors");'), (601, 1, u'+#define ASSERT_SORTED(TABLE)'), (603, 1, u'+#define ASSERT_SORTED(TABLE)                                              \\'), (606, 1, u'+       assert(TableIsSorted(TABLE, array_lengthof(TABLE)) &&              \\'), (784, 1, u'+  ASSERT_SORTED(OpcodeTable);'), (786, 1, u'+  assert(Opc != -1 && "FP Stack instruction not in OpcodeTable!");'), (830, 1, u'+  ASSERT_SORTED(PopTable);'), (890, 1, u'+  assert((Kills & Defs) == 0 && "Register needs killing and def\'ing?");'), (935, 1, u'+  assert(StackTop == CountPopulation_32(Mask) && "Live count mismatch");'), (984, 1, u'+  assert((NumOps == X86::AddrNumOperands + 1 || NumOps == 1) &&'), (1049, 1, u'+  assert(NumOps >= 2 && "FPRW instructions must have 2 ops!!");'), (1156, 1, u'+  ASSERT_SORTED(ForwardST0Table); ASSERT_SORTED(ReverseST0Table);'), (1157, 1, u'+  ASSERT_SORTED(ForwardSTiTable); ASSERT_SORTED(ReverseSTiTable);'), (1161, 1, u'+  assert(NumOperands == 3 && "Illegal TwoArgFP instruction!");'), (1204, 1, u'+  assert((TOS == Op0 || TOS == Op1) && (KillsOp0 || KillsOp1) &&'), (1226, 1, u'+  assert(Opcode != -1 && "Unknown TwoArgFP pseudo instruction!");'), (1238, 1, u'+    assert(!updateST0 && "Should have updated other operand!");'), (1245, 1, u'+  assert(UpdatedSlot < StackTop && Dest < 7);'), (1255, 1, u'+  ASSERT_SORTED(ForwardST0Table); ASSERT_SORTED(ReverseST0Table);'), (1256, 1, u'+  ASSERT_SORTED(ForwardSTiTable); ASSERT_SORTED(ReverseSTiTable);'), (1260, 1, u'+  assert(NumOperands == 2 && "Illegal FUCOM* instruction!");'), (1328, 1, u'+      assert(isLive(SrcFP) && "Cannot copy dead register");'), (1329, 1, u'+      assert(!MO0.isDead() && "Cannot copy to dead ST register");'), (1360, 1, u'+      assert(!isLive(DstFP) && "Cannot copy ST to live FP register");'), (1361, 1, u'+      assert(NumPendingSTs > SrcST && "Cannot copy from dead ST register");'), (1363, 1, u'+      assert(isScratchReg(SrcFP) && "Expected ST in a scratch register");'), (1364, 1, u'+      assert(isLive(SrcFP) && "Scratch holding ST is dead");'), (1381, 1, u'+    assert(isLive(SrcFP) && "Cannot copy dead register");'), (1419, 1, u'+    assert(StackTop < 8 && "Stack overflowed before FpPOP_RETVAL");'), (1587, 1, u'+    assert(NumPendingSTs >= NumSTUses && "Fixed registers should be assigned");'), (1650, 1, u'+    assert(Op.isUse() && Op.isReg() &&'), (1685, 1, u'+      assert(Op.isUse() &&'), (1694, 1, u'+        assert(SecondFPRegOp == ~0U && "More than two fp operands!");'), (1715, 1, u'+      assert(StackTop == 1 && FirstFPRegOp == getStackEntry(0) &&'), (1729, 1, u'+      assert(FirstFPRegOp == SecondFPRegOp && FirstFPRegOp == getStackEntry(0)&&'), (1740, 1, u'+    assert(StackTop == 2 && "Must have two values live!");'), (1745, 1, u'+      assert(getStackEntry(1) == FirstFPRegOp && "Unknown regs live");'), (1751, 1, u'+    assert(getStackEntry(0) == FirstFPRegOp && "Unknown regs live");'), (1752, 1, u'+    assert(getStackEntry(1) == SecondFPRegOp && "Unknown regs live");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(459, 1, u'+  assert((permutationEncoding & 0x3FF) == permutationEncoding &&'), (492, 1, u'+  assert((RegEnc & 0x3FFFF) == RegEnc && "Invalid compact register encoding!");'), (869, 1, u'+      assert(!Is64Bit && "EAX is livein in x64 case!");'), (954, 1, u'+  assert(MBBI != MBB.end() && "Returning block has no instructions");'), (1068, 1, u'+    assert(DestAddr.isReg() && "Offset should be in register!");'), (1081, 1, u'+    assert(StackAdjust.isImm() && "Expecting immediate value.");'), (1087, 1, u'+    assert(MaxTCDelta <= 0 && "MaxTCDelta should never be positive");'), (1091, 1, u'+    assert(Offset >= 0 && "Offset should never be negative");'), (1108, 1, u'+        assert(JumpTarget.isSymbol());'), (1156, 1, u'+      assert((-(Offset + StackSize)) % MFI->getObjectAlignment(FI) == 0);'), (1296, 1, u'+    assert((TailCallReturnAddrDelta <= 0) &&'), (1306, 1, u'+    assert(FrameIdx == MFI->getObjectIndexBegin() &&'), (1364, 1, u'+  assert(!MF.getRegInfo().isLiveIn(ScratchReg) &&'), (1472, 1, u'+      assert((!MF.getRegInfo().isLiveIn(ScratchReg2) || SaveScratch2) &&')]
===========================================
Class:  class X86DAGToDAGISel : public SelectionDAGISel {   class X86DAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(367, 1, u'+    assert(Chain.getOpcode() == ISD::TokenFactor &&'), (669, 1, u'+    assert(N.getOpcode() != X86ISD::WrapperRIP &&'), (907, 1, u'+    assert(X.getValueType() != VT);'), (1370, 1, u'+  assert (T == AM.Segment);'), (1422, 1, u'+  assert(N.getOpcode() == ISD::TargetGlobalTLSAddress);'), (1775, 1, u'+  assert(Opc != 0 && "Invalid arith lock transform!");'), (1932, 1, u'+    assert(Opc == X86ISD::INC && "unrecognized opcode");'), (2035, 1, u'+      assert(CstVT == MVT::i8);'), (2045, 1, u'+      assert(CstVT == MVT::i8 || CstVT == MVT::i32);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(70, 1, u'+  assert(VT.getSizeInBits() == 256 && "Unexpected vector size!");'), (114, 1, u'+    assert(VT.getSizeInBits() == 128 && "Unexpected vector size!");'), (1372, 1, u'+  assert(getTargetMachine().getRelocationModel() == Reloc::PIC_ &&'), (1500, 1, u'+    assert(VA.isRegLoc() && "Can only return in registers!");'), (1560, 1, u'+    assert(Reg &&'), (1823, 1, u'+  assert(!(isVarArg && IsTailCallConvention(CallConv)) &&'), (1844, 1, u'+    assert(VA.getValNo() != LastVal &&'), (1876, 1, u'+        ArgValue = DAG.getNode(ISD::AssertSext, dl, RegVT, ArgValue,'), (1879, 1, u'+        ArgValue = DAG.getNode(ISD::AssertZext, dl, RegVT, ArgValue,'), (1893, 1, u'+      assert(VA.isMemLoc());'), (1966, 1, u'+      assert(!(NumXMMRegs && !Subtarget->hasSSE1()) &&'), (1968, 1, u'+      assert(!(NumXMMRegs && MF.getTarget().Options.UseSoftFloat &&'), (2163, 1, u'+  assert(!(isVarArg && IsTailCallConvention(CallConv)) &&'), (2273, 1, u'+      assert(VA.isMemLoc());'), (2340, 1, u'+    assert((Subtarget->hasSSE1() || !NumXMMRegs)'), (2369, 1, u'+        assert(VA.isMemLoc());'), (2417, 1, u'+    assert(Is64Bit && "Large code model is only legal in 64-bit mode.");'), (2528, 1, u'+  assert(Mask && "Missing call preserved mask for calling convention");'), (2682, 1, u'+  assert(FI != INT_MAX);'), (3458, 1, u'+  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (3497, 1, u'+  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (3535, 1, u'+  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (3577, 1, u'+  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (3866, 1, u'+  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (3875, 1, u'+  assert((NumLaneElts == 2 || NumLaneElts == 4) &&'), (3942, 1, u'+  assert(Val - i > 0 && "PALIGNR imm should be positive");'), (3988, 1, u'+  assert((VT.is256BitVector() && NumElts == 4) &&'), (4161, 1, u'+  assert(VT.isVector() && "Expected a vector type");'), (4196, 1, u'+  assert(VT.isVector() && "Expected a vector type");'), (4197, 1, u'+  assert((VT.is128BitVector() || VT.is256BitVector())'), (4292, 1, u'+  assert((VT.getSizeInBits() == 128 || VT.getSizeInBits() == 256)'), (4325, 1, u'+  assert(((Size == 128 && NumElems > 4) || Size == 256) &&'), (4729, 1, u'+  assert(VT.getSizeInBits() == 128 && "Unknown type for VShift");'), (4957, 1, u'+    assert(!CVT.isVector() && "Must not broadcast a vector type");'), (4969, 1, u'+      assert(C && "Invalid constant type");'), (5088, 1, u'+        assert(VT == MVT::v2i64 && "Expected an SSE value type!");'), (5128, 1, u'+        assert(VT.getSizeInBits() == 128 && "Expected an SSE value type!");'), (5142, 1, u'+          assert(VT.getSizeInBits() == 128 && "Expected an SSE value type!");'), (5353, 1, u'+  assert(ResVT == MVT::v2i64 || ResVT == MVT::v4i32 ||'), (5379, 1, u'+  assert(ResVT.getSizeInBits() == 256 && "Value type must be 256-bit wide");'), (5395, 1, u'+  assert(Op.getNumOperands() == 2);'), (5396, 1, u'+  assert((ResVT.getSizeInBits() == 128 || ResVT.getSizeInBits() == 256) &&'), (5468, 1, u'+  assert(ISDNo && "Invalid Op Number");'), (6066, 1, u'+  assert(VT.getSizeInBits() == 128 && "Unsupported vector size");'), (6079, 1, u'+      assert(Idx < 8 && "Invalid VECTOR_SHUFFLE index!");'), (6246, 1, u'+  assert(VT != MVT::v2i64 && "unsupported shuffle type");'), (6264, 1, u'+  assert((VT == MVT::v4i32 || VT == MVT::v4f32) &&'), (6324, 1, u'+  assert(VT != MVT::v4i32 && "unsupported shuffle type");'), (6411, 1, u'+  assert(VT.getSizeInBits() != 64 && "Can\'t lower MMX shuffles");'), (6416, 1, u'+  assert(!V1IsUndef && "Op 1 of shuffle should not be undef");'), (6714, 1, u'+    SDValue Assert  = DAG.getNode(ISD::AssertZext, dl, MVT::i32, Extract,'), (6716, 1, u'+    return DAG.getNode(ISD::TRUNCATE, dl, VT, Assert);'), (6729, 1, u'+    SDValue Assert  = DAG.getNode(ISD::AssertZext, dl, MVT::i32, Extract,'), (6731, 1, u'+    return DAG.getNode(ISD::TRUNCATE, dl, VT, Assert);'), (6787, 1, u'+  assert(Vec.getValueSizeInBits() <= 128 && "Unexpected vector length");'), (6811, 1, u'+    SDValue Assert  = DAG.getNode(ISD::AssertZext, dl, EltVT, Extract,'), (6813, 1, u'+    return DAG.getNode(ISD::TRUNCATE, dl, VT, Assert);'), (6976, 1, u'+  assert(Op.getValueType().getSimpleVT().getSizeInBits() == 128 &&'), (7290, 1, u'+    assert(model == TLSModel::InitialExec);'), (7294, 1, u'+    assert(model == TLSModel::InitialExec);'), (7457, 1, u'+  assert(Op.getNumOperands() == 3 && "Not a double-shift!");'), (7507, 1, u'+  assert(SrcVT.getSimpleVT() <= MVT::i64 && SrcVT.getSimpleVT() >= MVT::i16 &&'), (7744, 1, u'+  assert(SrcVT == MVT::i64 && "Unexpected type in UINT_TO_FP");'), (7800, 1, u'+    assert(DstTy == MVT::i32 && "Unexpected FP_TO_UINT");'), (7804, 1, u'+  assert(DstTy.getSimpleVT() <= MVT::i64 &&'), (7841, 1, u'+    assert(DstTy == MVT::i64 && "Invalid FP_TO_SINT to lower!");'), (7912, 1, u'+  assert(FIST.getNode() && "Unexpected failure");'), (8298, 1, u'+  assert(Op.getValueType() == MVT::i8 && "SetCC type must be 8-bit integer");'), (8353, 1, u'+  assert(VT.getSizeInBits() == 256 && Op.getOpcode() == ISD::SETCC &&'), (8394, 1, u'+    assert(EltVT == MVT::f32 || EltVT == MVT::f64); (void)EltVT;'), (8874, 1, u'+            assert(NewBR == User);'), (8915, 1, u'+          assert(NewBR == User);'), (8945, 1, u'+          assert(NewBR == User);'), (8996, 1, u'+  assert((Subtarget->isTargetCygMing() || Subtarget->isTargetWindows() ||'), (9000, 1, u'+  assert(!Subtarget->isTargetEnvMacho() && "Not implemented");'), (9115, 1, u'+  assert(Subtarget->is64Bit() &&'), (9117, 1, u'+  assert((Subtarget->isTargetLinux() ||'), (9120, 1, u'+  assert(Op.getNode()->getNumOperands() == 4);'), (9147, 1, u'+    assert(!getTargetMachine().Options.UseSoftFloat &&'), (9182, 1, u'+  assert(Subtarget->is64Bit() && "This code only handles 64-bit va_copy!");'), (9201, 1, u'+  assert(ShAmt.getValueType() == MVT::i32 && "ShAmt is not i32");'), (9333, 1, u'+    assert(X86CC != X86::COND_INVALID && "Unexpected illegal condition!");'), (10152, 1, u'+  assert(VT.getSizeInBits() == 256 && VT.isInteger() &&'), (10179, 1, u'+  assert(Op.getValueType().getSizeInBits() == 256 &&'), (10186, 1, u'+  assert(Op.getValueType().getSizeInBits() == 256 &&'), (10199, 1, u'+  assert((VT == MVT::v2i64 || VT == MVT::v4i64) &&'), (10378, 1, u'+    assert(Subtarget->hasSSE2() && "Need SSE2 for pslli/pcmpeq.");'), (10692, 1, u'+    assert(Subtarget->is64Bit() && "Node not type legal!");'), (10714, 1, u'+  assert(Subtarget->is64Bit() && "Result not type legalized?");'), (10735, 1, u'+  assert(Subtarget->is64Bit() && !Subtarget->hasSSE2() &&'), (10737, 1, u'+  assert((DstVT == MVT::i64 ||'), (10920, 1, u'+  assert (Node->getValueType(0) == MVT::i64 &&'), (10993, 1, u'+    assert((T == MVT::i64 || T == MVT::i128) && "can only expand cmpxchg pair");'), (11381, 1, u'+  assert(bInstr->getNumOperands() < X86::AddrNumOperands + 4 &&'), (11400, 1, u'+  assert((argOpers[valArgIndx]->isReg() ||'), (11424, 1, u'+  assert(bInstr->hasOneMemOperand() && "Unexpected number of memoperand");'), (11495, 1, u'+  assert(bInstr->getNumOperands() < X86::AddrNumOperands + 14 &&'), (11543, 1, u'+  assert((argOpers[valArgIndx]->isReg() ||'), (11555, 1, u'+  assert(argOpers[valArgIndx + 1]->isReg() =='), (11557, 1, u'+  assert(argOpers[valArgIndx + 1]->isImm() =='), (11592, 1, u'+  assert(bInstr->hasOneMemOperand() && "Unexpected number of memoperand");'), (11653, 1, u'+  assert(mInstr->getNumOperands() < X86::AddrNumOperands + 4 &&'), (11671, 1, u'+  assert((argOpers[valArgIndx]->isReg() ||'), (11700, 1, u'+  assert(mInstr->hasOneMemOperand() && "Unexpected number of memoperand");'), (11720, 1, u'+  assert(Subtarget->hasSSE42() &&'), (11810, 1, u'+  assert(MI->getNumOperands() == 10 && "VAARG_64 should have 10 operands!");'), (11811, 1, u'+  assert(X86::AddrNumOperands == 5 && "VAARG_64 assumes 5 address operands");'), (11824, 1, u'+  assert(MI->hasOneMemOperand() && "Expected VAARG_64 to have one memoperand");'), (11941, 1, u'+    assert(OffsetReg != 0);'), (12004, 1, u'+    assert((Align & (Align-1)) == 0 && "Alignment must be a power of 2");'), (12237, 1, u'+  assert(getTargetMachine().Options.EnableSegmentedStacks);'), (12355, 1, u'+  assert(!Subtarget->isTargetEnvMacho());'), (12414, 1, u'+  assert(Subtarget->isTargetDarwin() && "Darwin only instr emitted?");'), (12415, 1, u'+  assert(MI->getOperand(3).isGlobal() && "This should be a global");'), (12783, 1, u'+  assert((Opc >= ISD::BUILTIN_OP_END ||'), (13565, 1, u'+    assert(BitWidth >= 8 && BitWidth <= 64 && "Invalid mask size");'), (13793, 1, u'+    assert(N0.getValueType().isVector() && "Invalid vector shift type");'), (14186, 1, u'+        assert((EltBits == 8 || EltBits == 16 || EltBits == 32) &&'), (14275, 1, u'+  assert(Subtarget->hasBMI() && "Creating BLSMSK requires BMI instructions");'), (14310, 1, u'+    assert(MemVT != RegVT && "Cannot extend to the same type");'), (14311, 1, u'+    assert(MemVT.isVector() && "Must load a vector from memory");'), (14316, 1, u'+    assert(RegSz > MemSz && "Register size must be greater than the mem size");'), (14419, 1, u'+    assert(StVT != VT && "Cannot truncate to the same type");'), (14431, 1, u'+    assert(SizeRatio * NumElems * ToSz == VT.getSizeInBits());'), (14437, 1, u'+    assert(WideVecVT.getSizeInBits() == VT.getSizeInBits());'), (14464, 1, u'+    assert(StoreVecVT.getSizeInBits() == VT.getSizeInBits());'), (14632, 1, u'+  assert((VT.is128BitVector() || VT.is256BitVector()) &&'), (14640, 1, u'+  assert((NumLaneElts % 2 == 0) &&'), (14758, 1, u'+  assert(N->getOpcode() == X86ISD::FOR || N->getOpcode() == X86ISD::FXOR);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(1132, 1, u'+      assert(!R2MTable.count(RegOp) && "Duplicate entry!");'), (1136, 1, u'+      assert(!M2RTable.count(MemOp) &&'), (1321, 1, u'+    assert(!isPICBase && "More than one PIC base?");'), (1378, 1, u'+          assert(!isPICBase && "More than one PIC base?");'), (1685, 1, u'+    assert(MI->getNumOperands() == 4 && "Unknown shufps instruction!");'), (1699, 1, u'+    assert(MI->getNumOperands() == 4 && "Unknown shufpd instruction!");'), (1717, 1, u'+    assert(MI->getNumOperands() >= 3 && "Unknown shift instruction!");'), (1736, 1, u'+    assert(MI->getNumOperands() >= 3 && "Unknown shift instruction!");'), (1755, 1, u'+    assert(MI->getNumOperands() >= 3 && "Unknown shift instruction!");'), (1782, 1, u'+      assert(MI->getNumOperands() >= 2 && "Unknown inc instruction!");'), (1803, 1, u'+      assert(MI->getNumOperands() >= 2 && "Unknown inc instruction!");'), (1812, 1, u'+      assert(MI->getNumOperands() >= 2 && "Unknown dec instruction!");'), (1832, 1, u'+      assert(MI->getNumOperands() >= 2 && "Unknown dec instruction!");'), (1842, 1, u'+      assert(MI->getNumOperands() >= 3 && "Unknown add instruction!");'), (1874, 1, u'+      assert(MI->getNumOperands() >= 3 && "Unknown add instruction!");'), (1889, 1, u'+      assert(MI->getNumOperands() >= 3 && "Unknown add instruction!");'), (1899, 1, u'+      assert(MI->getNumOperands() >= 3 && "Unknown add instruction!");'), (1913, 1, u'+      assert(MI->getNumOperands() >= 3 && "Unknown add instruction!");'), (2269, 1, u'+    assert(Cond.size() == 1);'), (2270, 1, u'+    assert(TBB);'), (2331, 1, u'+  assert(TBB && "InsertBranch must not be told to insert a fallthrough");'), (2332, 1, u'+  assert((Cond.size() == 1 || Cond.size() == 0) &&'), (2337, 1, u'+    assert(!FBB && "Unconditional branch with multiple successors!");'), (2438, 1, u'+      assert(X86::GR8_NOREXRegClass.contains(SrcReg, DestReg) &&'), (2498, 1, u'+    assert(X86::GR8RegClass.hasSubClassEq(RC) && "Unknown 1-byte regclass");'), (2506, 1, u'+    assert(X86::GR16RegClass.hasSubClassEq(RC) && "Unknown 2-byte regclass");'), (2531, 1, u'+    assert(X86::RFP80RegClass.hasSubClassEq(RC) && "Unknown 10-byte regclass");'), (2534, 1, u'+    assert(X86::VR128RegClass.hasSubClassEq(RC) && "Unknown 16-byte regclass");'), (2546, 1, u'+    assert(X86::VR256RegClass.hasSubClassEq(RC) && "Unknown 32-byte regclass");'), (2576, 1, u'+  assert(MF.getFrameInfo()->getObjectSize(FrameIdx) >= RC->getSize() &&'), (2648, 1, u'+  assert(Desc.getNumOperands() == 3 && "Expected two-addr instruction.");'), (2657, 1, u'+  assert(MI->getOperand(1).getReg() == Reg &&'), (2727, 1, u'+      assert(MO.isReg() && "Expected to fold into reg operand!");'), (3546, 1, u'+  assert(Offset2 > Offset1);'), (3594, 1, u'+  assert(Cond.size() == 1 && "Invalid X86 branch condition!");'), (3617, 1, u'+  assert(!TM.getSubtarget<X86Subtarget>().is64Bit() &&'), (3724, 1, u'+  assert(Domain>0 && Domain<4 && "Invalid execution domain");'), (3726, 1, u'+  assert(dom && "Not an SSE instruction");'), (3729, 1, u'+    assert((TM.getSubtarget<X86Subtarget>().hasAVX2() || Domain < 3) &&'), (3733, 1, u'+  assert(table && "Cannot change domain");'), (3815, 1, u'+      assert(!TM->getSubtarget<X86Subtarget>().is64Bit() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(354, 1, u'+  assert(*RetAddrLoc == RetAddr &&'), (376, 1, u'+  assert(((unsigned char*)RetAddr)[-2] == 0x41 &&"Not a call instr!");'), (377, 1, u'+  assert(((unsigned char*)RetAddr)[-1] == 0xFF &&"Not a call instr!");'), (379, 1, u'+  assert(((unsigned char*)RetAddr)[-1] == 0xE8 &&"Not a call instr!");'), (387, 1, u'+  assert(isStub &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(46, 1, u'+  assert((MO.isGlobal() || MO.isSymbol()) && "Isn\'t a symbol reference");'), (51, 1, u'+    assert(MO.isSymbol());'), (84, 1, u'+      assert(MO.isGlobal() && "Extern symbol not handled yet");'), (98, 1, u'+      assert(MO.isGlobal() && "Extern symbol not handled yet");'), (234, 1, u'+  assert(Inst.getOperand(0).isReg() &&'), (264, 1, u'+  assert(Inst.getNumOperands() == 6 && Inst.getOperand(RegOp).isReg() &&'), (358, 1, u'+    assert(OutMI.getNumOperands() == 1+X86::AddrNumOperands &&'), (360, 1, u'+    assert(OutMI.getOperand(1+X86::AddrSegmentReg).getReg() == 0 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(315, 1, u'+      assert(X86::XMM15 == X86::XMM8+7);'), (424, 1, u'+      assert(Opcode == TII.getCallFrameDestroyOpcode());'), (471, 1, u'+  assert(SPAdj == 0 && "Unexpected");'), (480, 1, u'+    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (512, 1, u'+    assert((!Is64Bit || isInt<32>((long long)FIOffset + Imm)) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 1, u'+      assert(isTargetELF() && "Unknown rip-relative target");'), (411, 1, u'+  assert((!In64BitMode || HasX86_64) &&')]
===========================================
Class:class X86PassConfig : public TargetPassConfig { class X86PassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(96, 1, u'+      assert(getRelocationModel() == Reloc::DynamicNoPIC);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(162, 1, u'+  assert(BBState.empty());')]
===========================================
Class:  class XCoreAsmPrinter : public AsmPrinter {   class XCoreAsmPrinter : public AsmPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 1, u'+  assert(((GV->hasExternalLinkage() ||'), (270, 1, u'+  assert(NOps == 4);'), (277, 1, u'+  assert(MI->getOperand(0).isReg() && MI->getOperand(1).isImm());'), (287, 1, u'+  assert(MI->getNumOperands() == 4 && "Invalid no. of machine operands!");'), (288, 1, u'+  assert(MI->getOperand(0).isReg() && MI->getOperand(1).isImm() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(49, 1, u'+  assert(Offset%4 == 0 && "Misaligned stack offset");'), (64, 1, u'+  assert(Offset%4 == 0 && "Misaligned stack offset");'), (111, 1, u'+  assert(FrameSize%4 == 0 && "Misaligned frame size");'), (232, 1, u'+  assert(FrameSize%4 == 0 && "Misaligned frame size");'), (261, 1, u'+      assert(MBBI->getOpcode() == XCore::RETSP_u6'), (324, 1, u'+    assert(MI != MBB.begin() &&')]
===========================================
Class:  class XCoreDAGToDAGISel : public SelectionDAGISel {   class XCoreDAGToDAGISel : public SelectionDAGISel 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(118, 1, u'+      assert(Amount%4 == 0);'), (137, 1, u'+        assert(Old->getOpcode() == XCore::ADJCALLSTACKUP);'), (154, 1, u'+  assert(SPAdj == 0 && "Unexpected");'), (161, 1, u'+    assert(i < MI.getNumOperands() && "Instr doesn\'t have FrameIndex operand!");'), (197, 1, u'+  assert(Offset%4 == 0 && "Misaligned stack offset");'), (208, 1, u'+  assert(XCore::GRRegsRegisterClass->contains(Reg) &&')]
===========================================
Class:class XCorePassConfig : public TargetPassConfig { class XCorePassConfig : public TargetPassConfig 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(231, 1, u'+    assert(CS && "Should only have direct calls!");'), (555, 1, u'+        assert(isa<LoadInst>(User) || isa<GetElementPtrInst>(User));'), (582, 1, u'+        assert(Params.back());'), (643, 1, u'+    assert(CS.getCalledFunction() == F);'), (829, 1, u'+        assert(ArgIndices.begin()->empty() &&'), (852, 1, u'+          assert(It != ArgIndices.end() && "GEP not handled??");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(221, 1, u'+      assert(Replacements[i].first->hasLocalLinkage() &&')]
===========================================
Class:  class DAE : public ModulePass {   class DAE : public ModulePass 
Class:  class GVExtractorPass : public ModulePass {   class GVExtractorPass : public ModulePass 
Class:  class ArgumentGraph {   class ArgumentGraph 
Class:class Evaluator { class Evaluator 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(132, 1, u'+  assert(NumNonconstant != ArgumentConstants.size());')]
===========================================
Class:  class AlwaysInliner : public Inliner {   class AlwaysInliner : public Inliner 
Class:  class SimpleInliner : public Inliner {   class SimpleInliner : public Inliner 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(327, 1, u'+    assert(unsigned(InlineHistoryID) < InlineHistory.size() &&')]
===========================================
Class:  class InternalizePass : public ModulePass {   class InternalizePass : public ModulePass 
Class:  class BlockExtractorPass : public ModulePass {   class BlockExtractorPass : public ModulePass 
Class:class ComparableFunction { class ComparableFunction 
Class:class FunctionComparator { class FunctionComparator 
Class:class MergeFunctions : public ModulePass { class MergeFunctions : public ModulePass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(112, 1, u'+    assert(Func &&'), (121, 1, u'+  AssertingVH<Function> Func;'), (440, 1, u'+      assert(F1I->getNumOperands() == F2I->getNumOperands());'), (491, 1, u'+  assert(F1->arg_size() == F2->arg_size() &&'), (523, 1, u'+    assert(F1TI->getNumSuccessors() == F2TI->getNumSuccessors());'), (675, 1, u'+  assert(LHS.getTD() == RHS.getTD() &&'), (777, 1, u'+    assert(G->mayBeOverridden());'), (821, 1, u'+  assert(!OldF.getFunc()->mayBeOverridden() ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(234, 1, u'+  assert(pred_begin(BB) == pred_end(BB) && "BB is not dead!");')]
===========================================
Class:class StripDeadPrototypesPass : public ModulePass { class StripDeadPrototypesPass : public ModulePass 
Class:  class StripSymbols : public ModulePass {   class StripSymbols : public ModulePass 
Class:   class StripNonDebugSymbols : public ModulePass {   class StripNonDebugSymbols : public ModulePass 
Class:   class StripDebugDeclare : public ModulePass {   class StripDebugDeclare : public ModulePass 
Class:   class StripDeadDebugInfo : public ModulePass {   class StripDeadDebugInfo : public ModulePass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(475, 1, u'+  assert(TD && "Must have target data info for this");')]
===========================================
Class:class InstCombineFortifiedLibCalls : public SimplifyFortifiedLibCalls { class InstCombineFortifiedLibCalls : public SimplifyFortifiedLibCalls 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(451, 1, u'+    assert(Res->getType() == DestTy);'), (765, 1, u'+    assert(BitsToClear < SrcTy->getScalarSizeInBits() &&'), (772, 1, u'+    assert(Res->getType() == DestTy);'), (986, 1, u'+  assert(V->getType()->getScalarSizeInBits() < Ty->getScalarSizeInBits() &&'), (1072, 1, u'+    assert(Res->getType() == DestTy);'), (1364, 1, u'+        assert(isa<PtrToIntInst>(CI));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(154, 1, u'+  assert(KnownZero.getBitWidth() == KnownOne.getBitWidth() &&'), (178, 1, u'+  assert(KnownZero.getBitWidth() == KnownOne.getBitWidth() &&'), (417, 1, u'+    assert(TrueRangeEnd != FirstTrueElement && "Should emit single compare");'), (432, 1, u'+    assert(FalseRangeEnd != FirstFalseElement && "Should emit single compare");'), (765, 1, u'+  assert(Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SGE);'), (973, 1, u'+    assert(TheDiv->getOpcode() == Instruction::SDiv ||'), (977, 1, u'+    assert(Res && "This div/cst should have folded!");'), (1649, 1, u'+  assert(ICI.getPredicate() == ICmpInst::ICMP_UGT && "ICmp should be folded!");'), (1932, 1, u'+      assert(!CI->isMaxValue(false));                 // A <=u MAX -> TRUE'), (1936, 1, u'+      assert(!CI->isMaxValue(true));                  // A <=s MAX -> TRUE'), (1940, 1, u'+      assert(!CI->isMinValue(false));                 // A >=u MIN -> TRUE'), (1944, 1, u'+      assert(!CI->isMinValue(true));                  // A >=s MIN -> TRUE'), (2140, 1, u'+      assert(!isa<ConstantInt>(Op1) && "ICMP_SGE with ConstantInt not folded!");'), (2147, 1, u'+      assert(!isa<ConstantInt>(Op1) && "ICMP_SLE with ConstantInt not folded!");'), (2154, 1, u'+      assert(!isa<ConstantInt>(Op1) && "ICMP_UGE with ConstantInt not folded!");'), (2161, 1, u'+      assert(!isa<ConstantInt>(Op1) && "ICMP_ULE with ConstantInt not folded!");'), (2658, 1, u'+  assert(!RHS.isNaN() && "NaN comparison not already folded!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(109, 1, u'+      assert(isa<AllocaInst>(AI) && "Unknown type of allocation inst!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(26, 1, u'+  assert(isa<BinaryOperator>(FirstInst) || isa<CmpInst>(FirstInst));'), (719, 1, u'+      assert(EltPHI->getType() != PN->getType() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(23, 1, u'+  assert(I.getOperand(1)->getType() == I.getOperand(0)->getType());'), (246, 1, u'+    assert(CI->getZExtValue() > NumBits);'), (286, 1, u'+    assert(CI->getZExtValue() > NumBits);'), (389, 1, u'+        assert(I.getOpcode() == Instruction::LShr && "Unknown logical shift");'), (535, 1, u'+    assert(ShiftAmt2 != 0 && "Should have been simplified earlier");'), (577, 1, u'+        assert(ShiftOp->getOpcode() == Instruction::LShr ||'), (627, 1, u'+      assert(ShiftAmt2 < ShiftAmt1);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(29, 1, u'+  assert(I && "No instruction?");'), (30, 1, u'+  assert(OpNo < I->getNumOperands() && "Operand index too large");'), (103, 1, u'+  assert(V != 0 && "Null pointer of Value???");'), (104, 1, u'+  assert(Depth <= 6 && "Limit Search Depth");'), (107, 1, u'+  assert((TD || !VTy->isPointerTy()) &&'), (109, 1, u'+  assert((!TD || TD->getTypeSizeInBits(VTy->getScalarType()) == BitWidth) &&'), (227, 1, u'+    assert(!(RHSKnownZero & RHSKnownOne) && "Bits known to be one AND zero?");'), (228, 1, u'+    assert(!(LHSKnownZero & LHSKnownOne) && "Bits known to be one AND zero?");'), (259, 1, u'+    assert(!(RHSKnownZero & RHSKnownOne) && "Bits known to be one AND zero?");'), (260, 1, u'+    assert(!(LHSKnownZero & LHSKnownOne) && "Bits known to be one AND zero?");'), (295, 1, u'+    assert(!(RHSKnownZero & RHSKnownOne) && "Bits known to be one AND zero?");'), (296, 1, u'+    assert(!(LHSKnownZero & LHSKnownOne) && "Bits known to be one AND zero?");'), (370, 1, u'+    assert(!(RHSKnownZero & RHSKnownOne) && "Bits known to be one AND zero?");'), (371, 1, u'+    assert(!(LHSKnownZero & LHSKnownOne) && "Bits known to be one AND zero?");'), (393, 1, u'+    assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (416, 1, u'+    assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (431, 1, u'+    assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (458, 1, u'+    assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (596, 1, u'+      assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (620, 1, u'+      assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (665, 1, u'+      assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (721, 1, u'+        assert(!(KnownZero & KnownOne) && "Bits known to be one AND zero?");'), (817, 1, u'+  assert((DemandedElts & ~EltMask) == 0 && "Invalid DemandedElts!");'), (936, 1, u'+          assert(MaskVal < LHSVWidth * 2 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(60, 1, u'+  assert(V->getType()->isVectorTy() && "Not looking at a vector?");'), (211, 1, u'+  assert(V->getType() == LHS->getType() && V->getType() == RHS->getType() &&'), (268, 1, u'+              assert(EI->getOperand(0) == RHS);'), (289, 1, u'+  assert(V->getType()->isVectorTy() &&'), (629, 1, u'+          assert(isa<UndefValue>(RHSShuffle->getOperand(1))')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 1, u'+  assert(From->isIntegerTy() && To->isIntegerTy());'), (755, 1, u'+      assert(Offset >= 0);'), (757, 1, u'+    assert((uint64_t)Offset < (uint64_t)TySize && "Out of range offset");'), (770, 1, u'+      assert(Offset < (int64_t)SL->getSizeInBytes() &&'), (781, 1, u'+      assert(EltSize && "Cannot index into a zero-sized array");'), (1255, 1, u'+          assert(isa<ConstantInt>(NewCaseVal) &&'), (1507, 1, u'+      assert(LI.isFilter(i) && "Unsupported landingpad clause!");'), (1527, 1, u'+        assert(NumTypeInfos > 0 && "Should have handled empty filter already!");'), (1593, 1, u'+        assert(MakeNewInstruction && "New filter but not a new instruction!");'), (1677, 1, u'+          assert(FElts <= LElts && "Should have handled this case earlier!");'), (1689, 1, u'+        assert(FElts > 0 && "Should have eliminated the empty filter earlier!");'), (1748, 1, u'+    assert(!CleanupFlag && "Adding a cleanup, not removing one?!");'), (1764, 1, u'+  assert(I->hasOneUse() && "Invariants didn\'t hold!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(307, 1, u'+  assert(OrigTy->isSized());'), (734, 1, u'+  assert(ShadowRZSize >= 1 && ShadowRZSize <= 4);'), (754, 1, u'+    assert(AlignedSize - SizeInBytes < RedzoneSize);'), (759, 1, u'+    assert(ShadowBase->getType() == IntptrTy);'), (857, 1, u'+  assert(MyAlloca->isStaticAlloca());'), (882, 1, u'+    assert((AlignedSize % RedzoneSize) == 0);'), (889, 1, u'+  assert(Pos == LocalStackSize);')]
===========================================
Class:  class EdgeProfiler : public ModulePass {   class EdgeProfiler : public ModulePass 
Class:  class GCOVProfiler : public ModulePass {   class GCOVProfiler : public ModulePass 
Class:  class GCOVRecord {   class GCOVRecord 
Class:            class GCOVLines : public GCOVRecord {   class GCOVLines : public GCOVRecord 
Class:            class GCOVBlock : public GCOVRecord {   class GCOVBlock : public GCOVRecord 
Class:            class GCOVFunction : public GCOVRecord {   class GCOVFunction : public GCOVRecord 
Class:  class OptimalEdgeProfiler : public ModulePass {   class OptimalEdgeProfiler : public ModulePass 
Class:class BLInstrumentationNode;
Class:     class BLInstrumentationNode : public BallLarusNode { class BLInstrumentationNode : public BallLarusNode 
Class:     class BLInstrumentationEdge : public BallLarusEdge { class BLInstrumentationEdge : public BallLarusEdge 
Class:     class BLInstrumentationDag : public BallLarusDag { class BLInstrumentationDag : public BallLarusDag 
Class:    class PathProfiler : public ModulePass { class PathProfiler : public ModulePass 
Class:  class PathProfilingFunctionTable 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(288, 1, u'+  assert(OrigTy->isSized());'), (305, 1, u'+  assert(Idx < kNumberOfAccessSizes);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(105, 1, u'+  assert(!PlacedBlocks.count(BB) && "Already placed this block!");')]
===========================================
Class:  class CodeGenPrepare : public FunctionPass {   class CodeGenPrepare : public FunctionPass 
Class:class CodeGenPrepareFortifiedLibCalls : public SimplifyFortifiedLibCalls { class CodeGenPrepareFortifiedLibCalls : public SimplifyFortifiedLibCalls 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(1006, 1, u'+    assert(isa<SExtInst>(I) && "Unexpected ext type!");')]
===========================================
Class:  class CorrelatedValuePropagation : public FunctionPass {   class CorrelatedValuePropagation : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(208, 1, u'+  assert(hasMemoryWrite(Inst) && "Unknown instruction case");')]
===========================================
Class:class EarlyCSE : public FunctionPass { class EarlyCSE : public FunctionPass 
Class:  class ValueTable {   class ValueTable 
Class:  class GVN : public FunctionPass {   class GVN : public FunctionPass 
Class:  class GlobalMerge : public FunctionPass {   class GlobalMerge : public FunctionPass 
Class:  class IndVarSimplify : public LoopPass {   class IndVarSimplify : public LoopPass 
Class:  class WideIVVisitor : public IVVisitor {   class WideIVVisitor : public IVVisitor 
Class:class WidenIV { class WidenIV 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(207, 1, u'+  assert(InsertPt && "Missing phi operand");'), (208, 1, u'+  assert((!isa<Instruction>(Def) ||'), (290, 1, u'+  assert(TheBr->isConditional() && "Can\'t use fcmp if not conditional");'), (479, 1, u'+  assert(L->isLCSSAForm(*DT));'), (696, 1, u'+    assert(L->getHeader() == OrigPhi->getParent() && "Phi must be an IV");'), (799, 1, u'+  assert(DU.NarrowUse->getOperand(1-ExtendOperIdx) == DU.NarrowDef && "bad DU");'), (915, 1, u'+  assert(DU.NarrowUse != DU.NarrowUse->getParent()->getTerminator() &&'), (981, 1, u'+  assert(SE->getEffectiveSCEVType(WideIVExpr->getType()) == WideType &&'), (992, 1, u'+  assert(SE->properlyDominates(AddRec->getStart(), L->getHeader()) &&'), (1017, 1, u'+  assert(Widened.empty() && NarrowIVUsers.empty() && "expect initial state" );'), (1221, 1, u'+  assert(L->getExitingBlock() && "expected loop exit");'), (1229, 1, u'+  assert(BI && "expected exit branch");'), (1303, 1, u'+  assert(LatchBlock && "needsLFTR should guarantee a loop latch");'), (1364, 1, u'+  assert(AR && AR->getLoop() == L && AR->isAffine() && "bad loop counter");'), (1378, 1, u'+    assert(SE->isLoopInvariant(IVOffset, L) &&'), (1384, 1, u'+    assert(AR->getStart() == SE->getSCEV(GEPBase) && "bad loop counter");'), (1387, 1, u'+    assert(SE->getSizeOfExpr('), (1411, 1, u'+      assert(AR->getStepRecurrence(*SE)->isOne() && "only handles unit stride");'), (1424, 1, u'+    assert(SE->isLoopInvariant(IVLimit, L) &&'), (1445, 1, u'+  assert(canExpandBackedgeTakenCount(L, SE) && "precondition");'), (1488, 1, u'+  assert(ExitCnt->getType()->isPointerTy() == IndVar->getType()->isPointerTy()'), (1715, 1, u'+  assert(L->isLCSSAForm(*DT) &&'), (1731, 1, u'+    assert(BackedgeTakenCount == NewBECount && "indvars must preserve SCEV");')]
===========================================
Class:  class JumpThreading : public FunctionPass {   class JumpThreading : public FunctionPass 
Class:  class LoopPromoter : public LoadAndStorePromoter {   class LoopPromoter : public LoadAndStorePromoter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(94, 1, u'+      assert(LoopToAliasSetMap.empty() && "Didn\'t free loop alias sets");'), (140, 1, u'+      assert(CurLoop->contains(BB) && "Only valid if BB is IN the loop");'), (214, 1, u'+    assert(InnerAST && "Where is my AST?");'), (285, 1, u'+  assert(N != 0 && "Null dominator tree node?");'), (332, 1, u'+  assert(N != 0 && "Null dominator tree node?");'), (690, 1, u'+  assert(!AS.empty() &&'), (739, 1, u'+        assert(!load->isVolatile() && "AST broken");'), (747, 1, u'+        assert(!store->isVolatile() && "AST broken");')]
===========================================
Class:  class LoopDeletion : public LoopPass {   class LoopDeletion : public LoopPass 
Class:  class LoopIdiomRecognize : public LoopPass {   class LoopIdiomRecognize : public LoopPass 
Class:  class LoopInstSimplify : public LoopPass {   class LoopInstSimplify : public LoopPass 
Class:  class LoopRotate : public LoopPass {   class LoopRotate : public LoopPass 
Class:class RegSortData { class RegSortData 
Class:class RegUseTracker { class RegUseTracker 
Class:class Cost { class Cost 
Class:class LSRUse { class LSRUse 
Class:class LSRInstance { class LSRInstance 
Class:class LoopStrengthReduce : public LoopPass { class LoopStrengthReduce : public LoopPass 
Class:  class LoopUnroll : public LoopPass {   class LoopUnroll : public LoopPass 
Class:  class LUAnalysisCache {   class LUAnalysisCache 
Class:   class LoopUnswitch : public LoopPass {   class LoopUnswitch : public LoopPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(321, 1, u'+    assert(NewInst && "All instructions that are in SrcBB must be in VMap.");'), (384, 1, u'+    assert(currentLoop->isLCSSAForm(*DT));'), (720, 1, u'+  assert(!L->contains(ExitBlock) && "Exit block is in the loop?");'), (839, 1, u'+    assert(NewExit->getTerminator()->getNumSuccessors() == 1 &&'), (876, 1, u'+  assert(OldBR->isUnconditional() && OldBR->getSuccessor(0) == LoopBlocks[0] &&'), (1069, 1, u'+  assert(!isa<Constant>(LIC) && "Why are we unswitching on a constant?");'), (1233, 1, u'+        assert(SinglePred == Pred && "CFG broken");')]
===========================================
Class:class MemsetRanges { class MemsetRanges 
Class:  class MemCpyOpt : public FunctionPass {   class MemCpyOpt : public FunctionPass 
Class:  class MapVector {   class MapVector 
Class:         Class == IC_RetainRV;
Class:         Class == IC_AutoreleaseRV;
Class:         Class == IC_RetainRV ||          Class == IC_RetainRV ||
Class:         Class == IC_RetainRV ||          Class == IC_RetainRV ||
Class:         Class == IC_RetainRV ||          Class == IC_RetainRV ||
Class:         Class == IC_RetainRV ||          Class == IC_RetainRV ||
Class:  class ObjCARCAliasAnalysis : public ImmutablePass,   class ObjCARCAliasAnalysis : public ImmutablePass,
Class:  class ObjCARCExpand : public FunctionPass {   class ObjCARCExpand : public FunctionPass 
Class:  class ObjCARCAPElim : public ModulePass {   class ObjCARCAPElim : public ModulePass 
Class:  class ProvenanceAnalysis {   class ProvenanceAnalysis 
Class:  class PtrState {   class PtrState 
Class:  class BBState {   class BBState 
Class:  class ObjCARCOpt : public FunctionPass {   class ObjCARCOpt : public FunctionPass 
Class:        Class = IC_Release;
Class:  class ObjCARCContract : public FunctionPass {   class ObjCARCContract : public FunctionPass 
Class:  class Reassociate : public FunctionPass {   class Reassociate : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(76, 1, u'+  assert(pred_begin(BBEntry) == pred_end(BBEntry) &&')]
===========================================
Class:class LatticeVal { class LatticeVal 
Class:class SCCPSolver : public InstVisitor<SCCPSolver> { class SCCPSolver : public InstVisitor<SCCPSolver> 
Class:class ConvertToScalarInfo { class ConvertToScalarInfo 
Class:class AllocaPromoter : public LoadAndStorePromoter { class AllocaPromoter : public LoadAndStorePromoter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(312, 1, u'+    assert(VectorTy && "Missing type for vector scalar.");'), (559, 1, u'+      assert(SI->getOperand(0) != Ptr && "Consistency error!");'), (576, 1, u'+      assert(MSI->getRawDest() == Ptr && "Consistency error!");'), (608, 1, u'+      assert(Offset == 0 && "must be store to start of alloca");'), (618, 1, u'+        assert(MTI->getRawDest() == Ptr && "Neither use is of pointer?");'), (634, 1, u'+        assert(MTI->getRawSource() == Ptr && "Neither use is of pointer?");'), (700, 1, u'+      assert(EltSize*Elt == Offset && "Invalid modulus in validity checking");'), (781, 1, u'+  assert(FromVal->getType() == ToType && "Didn\'t convert right?");'), (893, 1, u'+    assert(DestWidth > SrcWidth);'), (1856, 1, u'+      assert(Offset == 0 && NewElts[0] &&'), (2036, 1, u'+      assert(Inst == MTI->getRawSource());'), (2126, 1, u'+      assert(isa<MemSetInst>(MI));'), (2154, 1, u'+          assert(StoreVal->getType() == ValTy && "Type mismatch!");'), (2180, 1, u'+      assert(isa<MemTransferInst>(MI));'), (2551, 1, u'+        assert(II->use_empty() && "Lifetime markers have no result to use!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(184, 1, u'+  assert(Reachable.size() < F.size());')]
===========================================
Class:class LibCallOptimization { class LibCallOptimization 
Class:  class SimplifyLibCalls : public FunctionPass {   class SimplifyLibCalls : public FunctionPass 
Class:  class Sinking : public FunctionPass {   class Sinking : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(335, 1, u'+  assert(I->getNumOperands() == 2 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(564, 1, u'+    (void)Success; assert(Success && "Couldn\'t select *anything*?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+  assert((pred_begin(BB) == pred_end(BB) ||'), (217, 1, u'+  assert(I->getParent() == 0 &&'), (248, 1, u'+    assert(i != e && "Didn\'t find edge?");'), (270, 1, u'+    assert(SP == BB && "CFG broken");'), (277, 1, u'+  assert(BB->getTerminator()->getNumSuccessors() == 1 &&'), (469, 1, u'+    assert(!isa<IndirectBrInst>(Preds[i]->getTerminator()) &&'), (512, 1, u'+  assert(OrigBB->isLandingPad() && "Trying to split a non-landing pad!");'), (529, 1, u'+    assert(!isa<IndirectBrInst>(Preds[i]->getTerminator()) &&'), (547, 1, u'+    assert(!isa<IndirectBrInst>(Pred->getTerminator()) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(93, 1, u'+  assert(SuccNum < TI->getNumSuccessors() && "Illegal edge specification!");'), (100, 1, u'+  assert(I != E && "No preds, but we have an edge to the block?");'), (129, 1, u'+  assert((SplitBB->getFirstNonPHI() == SplitBB->getTerminator() ||'), (180, 1, u'+  assert(!isa<IndirectBrInst>(TI) &&'), (329, 1, u'+          assert(DestLoop->getHeader() == DestBB &&'), (340, 1, u'+        assert(!TIL->contains(NewBB) &&'), (400, 1, u'+      assert((!P->mustPreserveAnalysisID(LCSSAID) ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(82, 1, u'+  assert(NameSuffix && "NameSuffix cannot be null!");'), (87, 1, u'+    assert(VMap.count(I) && "No mapping from source argument specified!");'), (370, 1, u'+  assert(NameSuffix && "NameSuffix cannot be null!");'), (375, 1, u'+    assert(VMap.count(II) && "No mapping from source argument specified!");'), (439, 1, u'+          assert(InVal && "Unknown input value?");'), (457, 1, u'+      assert(NumPreds < PN->getNumIncomingValues());'), (492, 1, u'+        assert(VMap[OldI] == PN && "VMap mismatch");'), (545, 1, u'+    assert(!isa<PHINode>(Dest->begin()));')]
===========================================
Class:  class CodeExtractor {   class CodeExtractor 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(679, 1, u'+      assert(BlocksToExtract.count(*PI) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(84, 1, u'+    assert(II.getNormalDest()->getSinglePredecessor() &&'), (119, 1, u'+      assert(II->getParent() != P->getIncomingBlock(i) &&')]
===========================================
Class:  class InvokeInliningInfo {   class InvokeInliningInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(492, 1, u'+  assert(TheCall->getParent() && TheCall->getParent()->getParent() &&'), (571, 1, u'+    assert(CalledFunc->arg_size() == CS.arg_size() &&'), (784, 1, u'+  assert(Br && Br->getOpcode() == Instruction::Br &&'), (816, 1, u'+        assert(RI->getReturnValue()->getType() == PHI->getType() &&'), (862, 1, u'+  assert(cast<BranchInst>(Br)->isUnconditional() && "splitBasicBlock broken!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 1, u'+      assert(L->isLCSSAForm(*DT) && "LCSSA form not preserved!");'), (160, 1, u'+  assert(L->isLCSSAForm(*DT));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(91, 1, u'+      assert(BI->getParent() && "Terminator not inserted in block!");'), (364, 1, u'+  AssertingVH<Instruction> TerminatorVH(--BB->end());'), (368, 1, u'+    assert(!BI->isTerminator());'), (445, 1, u'+  assert(PredBB && "Block doesn\'t have a single predecessor!");'), (488, 1, u'+  assert(*succ_begin(BB) == Succ && "Succ is not successor of BB!");'), (546, 1, u'+  assert(BB != &BB->getParent()->getEntryBlock() &&'), (597, 1, u'+      assert(OldVal && "No entry in PHI for Pred BB!");'), (629, 1, u'+      assert(PN->use_empty() && "There shouldn\'t be any uses here!");'), (762, 1, u'+  assert(V->getType()->isPointerTy() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(337, 1, u'+      assert(pred_begin(ExitingBlock) == pred_end(ExitingBlock));'), (421, 1, u'+  assert(!LoopBlocks.empty() && "No edges coming in from outside the loop?");'), (546, 1, u'+  assert(!L->getHeader()->isLandingPad() &&'), (647, 1, u'+  assert(L->getNumBackEdges() > 1 && "Must have > 1 backedge!");'), (658, 1, u'+  assert(!Header->isLandingPad() && "Can\'t insert backedge to landing pad");'), (714, 1, u'+    assert(PreheaderIdx != ~0U && "PHI has no preheader entry??");'), (772, 1, u'+    assert(HasIndBrPred &&'), (789, 1, u'+    assert(HasIndBrExiting &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(190, 1, u'+  assert(Count > 0);'), (191, 1, u'+  assert(TripMultiple > 0);'), (192, 1, u'+  assert(TripCount == 0 || TripCount % TripMultiple == 0);'), (341, 1, u'+      assert(Latches.back() == LastValueMap[LatchBlock] && "bad last latch");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 1, u'+  assert(Latch != 0 && "Loop must have a latch");'), (113, 1, u'+  assert(Exit != 0 && "Loop must have a single exit block only");'), (294, 1, u'+  assert(PreHeaderBR->isUnconditional() &&')]
===========================================
Class:  class LowerExpectIntrinsic : public FunctionPass {   class LowerExpectIntrinsic : public FunctionPass 
Class:  class LowerInvoke : public FunctionPass {   class LowerInvoke : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(277, 1, u'+    assert(!isa<PHINode>(II->getNormalDest()) &&')]
===========================================
Class:  class LowerSwitch : public FunctionPass {   class LowerSwitch : public FunctionPass 
Class:  class RenamePassData {   class RenamePassData 
Class:                  class LargeBlockInfo {   class LargeBlockInfo 
Class:  class PHIiter {   class PHIiter 
Class:class SSAUpdaterTraits<SSAUpdater> { class SSAUpdaterTraits<SSAUpdater> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(65, 1, u'+  assert(ProtoType != 0 && "Need to initialize SSAUpdater");'), (66, 1, u'+  assert(ProtoType == V->getType() &&'), (470, 1, u'+    assert(StoredValue && "Already checked that there is a store in block");'), (502, 1, u'+      assert(NewVal && "not a replaced load?");')]
===========================================
Class:class SimplifyCFGOpt { class SimplifyCFGOpt 
Class:  class SimplifyIndvar {   class SimplifyIndvar 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(64, 1, u'+      assert(LI && "IV simplification requires LoopInfo");'), (114, 1, u'+    assert(SE->isSCEVable(IVSrc->getType()) && "Expect SCEVable IV operand");'), (140, 1, u'+  assert(SE->getSCEV(UseInst) == FoldedExpr && "bad SCEV with folded oper");'), (156, 1, u'+    assert(IVOperand == ICmp->getOperand(1) && "Can\'t find IVOperand");'), (344, 1, u'+      assert(N <= Simplified.size() && "runaway iteration");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(153, 1, u'+  assert(isa<ConstantPointerNull>(C));'), (169, 1, u'+      assert((Flags & RF_IgnoreMissingEntries) &&'), (181, 1, u'+        assert((Flags & RF_IgnoreMissingEntries) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(421, 1, u'+        assert(VTy == cast<PointerType>(JPtr->getType())->getElementType());'), (1703, 1, u'+    assert(cast<Instruction>(L) == J &&'), (1833, 1, u'+      assert(FP != ChosenPairs.end() && "Flipped pair not found in list");')]
===========================================
Class:class TypePrinting { class TypePrinting 
Class:class SlotTracker { class SlotTracker 
Class:class AssemblyWriter { class AssemblyWriter 
Class:  class AttributeListImpl;
Class:class AttributeListImpl : public FoldingSetNode { class AttributeListImpl : public FoldingSetNode 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(92, 1, u'+  assert(!Result.empty() && "Unknown attribute!");'), (178, 1, u'+    assert(Attrs[i].Attrs != Attribute::None &&'), (180, 1, u'+    assert((!i || Attrs[i-1].Index < Attrs[i].Index) &&'), (242, 1, u'+  assert(AttrList && Slot < AttrList->Attrs.size() && "Slot # out of range!");'), (280, 1, u'+  assert((!OldAlign || !NewAlign || OldAlign == NewAlign) &&'), (318, 1, u'+  assert(!(Attrs & Attribute::Alignment) && "Attempt to exclude alignment!");'), (336, 1, u'+  assert(OldAttrList[i].Index == Idx && "Attribute isn\'t set?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+  assert(F && "Illegal to upgrade a non-existent Function.");'), (101, 1, u'+  assert(F && "Intrinsic call is not direct?");'), (171, 1, u'+    assert(CI->getNumArgOperands() == 1 &&'), (186, 1, u'+  assert(F && "Illegal attempt to upgrade a non-existent intrinsic.");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+    assert(NewParent &&'), (69, 1, u'+    assert(!use_empty() && "There should be at least one blockaddress!");'), (80, 1, u'+  assert(getParent() == 0 && "BasicBlock still linked into the program!");'), (218, 1, u'+  assert((hasNUsesOrMore(16)||// Reduce cost of this assertion for complex CFGs.'), (239, 1, u'+  assert(max_idx != 0 && "PHI Node in block with 0 predecessors!?!?!");'), (299, 1, u'+  assert(getTerminator() && "Can\'t use splitBasicBlock on degenerate BB!");'), (300, 1, u'+  assert(I != InstList.end() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 1, u'+  assert(Op && Op->isCast() && "Can\'t fold cast of cast without a cast!");'), (82, 1, u'+  assert(DstTy && DstTy->isFirstClassType() && "Invalid cast destination type");'), (83, 1, u'+  assert(CastInst::isCast(opc) && "Invalid cast opcode");'), (136, 1, u'+      assert(DestPTy->getBitWidth() == SrcTy->getBitWidth() &&'), (195, 1, u'+  assert(C->getType()->isIntegerTy() &&'), (199, 1, u'+  assert(ByteSize && "Must be accessing some piece");'), (200, 1, u'+  assert(ByteStart+ByteSize <= CSize && "Extracting invalid piece from input");'), (201, 1, u'+  assert(ByteSize != CSize && "Should not extract everything");'), (313, 1, u'+      assert((SrcBitSize&7) && "Shouldn\'t get byte sized case here");'), (1011, 1, u'+          assert(CI2->equalsInt(1));'), (1047, 1, u'+        assert(!CI2->isNullValue() && "Div by zero handled above");'), (1050, 1, u'+        assert(!CI2->isNullValue() && "Div by zero handled above");'), (1055, 1, u'+        assert(!CI2->isNullValue() && "Div by zero handled above");'), (1058, 1, u'+        assert(!CI2->isNullValue() && "Div by zero handled above");'), (1265, 1, u'+  assert(V1->getType() == V2->getType() &&'), (1334, 1, u'+  assert(V1->getType() == V2->getType() &&'), (1388, 1, u'+      assert(isa<ConstantPointerNull>(V2) && "Canonicalization guarantee!");'), (1414, 1, u'+      assert((isa<ConstantPointerNull>(V2) || isa<GlobalValue>(V2)) &&'), (1491, 1, u'+            assert(CE1->getNumOperands() == 2 &&'), (1913, 1, u'+    assert(Ty != 0 && "Invalid indices for GEP!");'), (1927, 1, u'+      assert(Ty != 0 && "Invalid indices for GEP!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(183, 1, u'+  assert(isa<IntegerType>(Elt->getType()) && "Index must be an integer");'), (207, 1, u'+    assert(isa<Constant>(V) && "References remain to Constant being destroyed");'), (211, 1, u'+    assert((use_empty() || use_back() != V) && "Constant not removed!");'), (221, 1, u'+  assert(getType()->isFirstClassType() && "Cannot evaluate aggregate vals!");'), (376, 1, u'+  assert(V.getBitWidth() == Ty->getBitWidth() && "Invalid constant for type");'), (396, 1, u'+    assert(Ty->isIntegerTy(1) && "True must be i1 or vector of i1.");'), (399, 1, u'+  assert(VTy->getElementType()->isIntegerTy(1) &&'), (408, 1, u'+    assert(Ty->isIntegerTy(1) && "False must be i1 or vector of i1.");'), (411, 1, u'+  assert(VTy->getElementType()->isIntegerTy(1) &&'), (458, 1, u'+  assert(C->getType() == Ty->getScalarType() &&'), (489, 1, u'+  assert(Ty->isPPC_FP128Ty() && "Unknown FP format");'), (571, 1, u'+      assert(&V.getSemantics() == &APFloat::PPCDoubleDouble &&'), (589, 1, u'+  assert(&V.getSemantics() == TypeToFloatSemantics(Ty) &&'), (680, 1, u'+  assert(V.size() == T->getNumElements() &&'), (683, 1, u'+    assert(V[i]->getType() == T->getElementType() &&'), (694, 1, u'+    assert(V[i]->getType() == Ty->getElementType() &&'), (798, 1, u'+  assert(!V.empty() &&'), (808, 1, u'+  assert(V.size() == T->getNumElements() &&'), (811, 1, u'+    assert((T->isOpaque() || V[i]->getType() == T->getElementType(i)) &&'), (818, 1, u'+  assert((ST->isOpaque() || ST->getNumElements() == V.size()) &&'), (860, 1, u'+    assert(V[i]->getType() == T->getElementType() &&'), (867, 1, u'+  assert(!V.empty() && "Vectors can\'t be empty");'), (1026, 1, u'+  assert(isCompare());'), (1034, 1, u'+  assert(Op->getType() == getOperand(OpNo)->getType() &&'), (1051, 1, u'+  assert(Ops.size() == getNumOperands() && "Operand count mismatch!");'), (1092, 1, u'+    assert(getNumOperands() == 2 && "Must be binary operator?");'), (1174, 1, u'+  assert((Ty->isStructTy() || Ty->isArrayTy() || Ty->isVectorTy()) &&'), (1271, 1, u'+  assert(BB->getParent() != 0 && "Block must have a parent");'), (1281, 1, u'+  assert(BA->getFunction() == F && "Basic block moved between functions");'), (1333, 1, u'+  assert(NewBA != this && "I didn\'t contain From!");'), (1348, 1, u'+  assert(Ty->isFirstClassType() && "Cannot cast to an aggregate type!");'), (1364, 1, u'+  assert(Instruction::isCast(opc) && "opcode out of range");'), (1365, 1, u'+  assert(C && Ty && "Null arguments to getCast");'), (1366, 1, u'+  assert(CastInst::castIsValid(opc, C, Ty) && "Invalid constantexpr cast!");'), (1405, 1, u'+  assert(S->getType()->isPointerTy() && "Invalid cast");'), (1406, 1, u'+  assert((Ty->isIntegerTy() || Ty->isPointerTy()) && "Invalid cast");'), (1415, 1, u'+  assert(C->getType()->isIntOrIntVectorTy() &&'), (1427, 1, u'+  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&'), (1443, 1, u'+  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1444, 1, u'+  assert(C->getType()->isIntOrIntVectorTy() && "Trunc operand must be integer");'), (1445, 1, u'+  assert(Ty->isIntOrIntVectorTy() && "Trunc produces only integral");'), (1446, 1, u'+  assert(C->getType()->getScalarSizeInBits() > Ty->getScalarSizeInBits()&&'), (1457, 1, u'+  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1458, 1, u'+  assert(C->getType()->isIntOrIntVectorTy() && "SExt operand must be integral");'), (1459, 1, u'+  assert(Ty->isIntOrIntVectorTy() && "SExt produces only integer");'), (1460, 1, u'+  assert(C->getType()->getScalarSizeInBits() < Ty->getScalarSizeInBits()&&'), (1471, 1, u'+  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1472, 1, u'+  assert(C->getType()->isIntOrIntVectorTy() && "ZEXt operand must be integral");'), (1473, 1, u'+  assert(Ty->isIntOrIntVectorTy() && "ZExt produces only integer");'), (1474, 1, u'+  assert(C->getType()->getScalarSizeInBits() < Ty->getScalarSizeInBits()&&'), (1485, 1, u'+  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1486, 1, u'+  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&'), (1497, 1, u'+  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1498, 1, u'+  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&'), (1509, 1, u'+  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1510, 1, u'+  assert(C->getType()->isIntOrIntVectorTy() && Ty->isFPOrFPVectorTy() &&'), (1520, 1, u'+  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1521, 1, u'+  assert(C->getType()->isIntOrIntVectorTy() && Ty->isFPOrFPVectorTy() &&'), (1531, 1, u'+  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1532, 1, u'+  assert(C->getType()->isFPOrFPVectorTy() && Ty->isIntOrIntVectorTy() &&'), (1542, 1, u'+  assert((fromVec == toVec) && "Cannot convert from scalar to/from vector");'), (1543, 1, u'+  assert(C->getType()->isFPOrFPVectorTy() && Ty->isIntOrIntVectorTy() &&'), (1549, 1, u'+  assert(C->getType()->getScalarType()->isPointerTy() &&'), (1551, 1, u'+  assert(DstTy->getScalarType()->isIntegerTy() &&'), (1553, 1, u'+  assert(isa<VectorType>(C->getType()) == isa<VectorType>(DstTy));'), (1555, 1, u'+    assert(C->getType()->getVectorNumElements()==DstTy->getVectorNumElements()&&'), (1561, 1, u'+  assert(C->getType()->getScalarType()->isIntegerTy() &&'), (1563, 1, u'+  assert(DstTy->getScalarType()->isPointerTy() &&'), (1565, 1, u'+  assert(isa<VectorType>(C->getType()) == isa<VectorType>(DstTy));'), (1567, 1, u'+    assert(C->getType()->getVectorNumElements()==DstTy->getVectorNumElements()&&'), (1573, 1, u'+  assert(CastInst::castIsValid(Instruction::BitCast, C, DstTy) &&'), (1586, 1, u'+  assert(Opcode >= Instruction::BinaryOpsBegin &&'), (1589, 1, u'+  assert(C1->getType() == C2->getType() &&'), (1597, 1, u'+    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1598, 1, u'+    assert(C1->getType()->isIntOrIntVectorTy() &&'), (1604, 1, u'+    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1605, 1, u'+    assert(C1->getType()->isFPOrFPVectorTy() &&'), (1611, 1, u'+    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1612, 1, u'+    assert(C1->getType()->isIntOrIntVectorTy() &&'), (1616, 1, u'+    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1617, 1, u'+    assert(C1->getType()->isFPOrFPVectorTy() &&'), (1622, 1, u'+    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1623, 1, u'+    assert(C1->getType()->isIntOrIntVectorTy() &&'), (1627, 1, u'+    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1628, 1, u'+    assert(C1->getType()->isFPOrFPVectorTy() &&'), (1634, 1, u'+    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1635, 1, u'+    assert(C1->getType()->isIntOrIntVectorTy() &&'), (1641, 1, u'+    assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1642, 1, u'+    assert(C1->getType()->isIntOrIntVectorTy() &&'), (1705, 1, u'+  assert(C1->getType() == C2->getType() && "Op types should be identical!");'), (1726, 1, u'+  assert(!SelectInst::areInvalidOperands(C, V1, V2)&&"Invalid select operands");'), (1747, 1, u'+  assert(Ty && "GEP indices invalid!");'), (1751, 1, u'+  assert(C->getType()->isPointerTy() &&'), (1768, 1, u'+  assert(LHS->getType() == RHS->getType());'), (1769, 1, u'+  assert(pred >= ICmpInst::FIRST_ICMP_PREDICATE &&'), (1792, 1, u'+  assert(LHS->getType() == RHS->getType());'), (1793, 1, u'+  assert(pred <= FCmpInst::LAST_FCMP_PREDICATE && "Invalid FCmp Predicate");'), (1814, 1, u'+  assert(Val->getType()->isVectorTy() &&'), (1816, 1, u'+  assert(Idx->getType()->isIntegerTy(32) &&'), (1834, 1, u'+  assert(Val->getType()->isVectorTy() &&'), (1836, 1, u'+  assert(Elt->getType() == Val->getType()->getVectorElementType() &&'), (1838, 1, u'+  assert(Idx->getType()->isIntegerTy(32) &&'), (1855, 1, u'+  assert(ShuffleVectorInst::isValidOperands(V1, V2, Mask) &&'), (1877, 1, u'+  assert(ExtractValueInst::getIndexedType(Agg->getType(),'), (1880, 1, u'+  assert(Agg->getType()->isFirstClassType() &&'), (1883, 1, u'+  assert(FC && "insertvalue constant expr couldn\'t be folded!");'), (1889, 1, u'+  assert(Agg->getType()->isFirstClassType() &&'), (1894, 1, u'+  assert(ReqTy && "extractvalue indices invalid!");'), (1896, 1, u'+  assert(Agg->getType()->isFirstClassType() &&'), (1899, 1, u'+  assert(FC && "ExtractValue constant expr couldn\'t be folded!");'), (1904, 1, u'+  assert(C->getType()->isIntOrIntVectorTy() &&'), (1911, 1, u'+  assert(C->getType()->isFPOrFPVectorTy() &&'), (1917, 1, u'+  assert(C->getType()->isIntOrIntVectorTy() &&'), (2083, 1, u'+  assert(Elt < getNumElements() && "Invalid Elt");'), (2101, 1, u'+  assert(isElementTypeCompatible(Ty->getSequentialElementType()));'), (2126, 1, u'+  assert(isa<VectorType>(Ty));'), (2138, 1, u'+  assert(Slot != CDSConstants.end() && "CDS not found in uniquing table");'), (2146, 1, u'+    assert((*Entry) == this && "Hash mismatch in ConstantDataSequential");'), (2153, 1, u'+      assert(Node && "Didn\'t find entry in its uniquing hash table!");'), (2243, 1, u'+  assert(isElementTypeCompatible(V->getType()) &&'), (2258, 1, u'+    assert(CI->getType()->isIntegerTy(64) && "Unsupported ConstantData type");'), (2281, 1, u'+  assert(isa<IntegerType>(getElementType()) &&'), (2312, 1, u'+  assert(getElementType()->isFloatTy() &&'), (2320, 1, u'+  assert(getElementType()->isDoubleTy() &&'), (2386, 1, u'+  assert(isa<Constant>(To) && "Cannot make Constant refer to non-constant!");'), (2436, 1, u'+        assert(getOperand(OperandToUpdate) == From &&'), (2450, 1, u'+  assert(Replacement != this && "I didn\'t contain From!");'), (2461, 1, u'+  assert(isa<Constant>(To) && "Cannot make Constant refer to non-constant!");'), (2465, 1, u'+  assert(getOperand(OperandToUpdate) == From && "ReplaceAllUsesWith broken!");'), (2525, 1, u'+  assert(Replacement != this && "I didn\'t contain From!");'), (2536, 1, u'+  assert(isa<Constant>(To) && "Cannot make Constant refer to non-constant!");'), (2547, 1, u'+  assert(Replacement != this && "I didn\'t contain From!");'), (2558, 1, u'+  assert(isa<Constant>(ToV) && "Cannot make Constant refer to non-constant!");'), (2568, 1, u'+  assert(Replacement != this && "I didn\'t contain From!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 1, u'+    assert(unsigned(ScopeIdx) <= Ctx.pImpl->ScopeRecords.size() &&'), (31, 1, u'+  assert(unsigned(-ScopeIdx) <= Ctx.pImpl->ScopeInlinedAtRecords.size() &&'), (42, 1, u'+  assert(unsigned(-ScopeIdx) <= Ctx.pImpl->ScopeInlinedAtRecords.size() &&'), (58, 1, u'+    assert(unsigned(ScopeIdx) <= Ctx.pImpl->ScopeRecords.size() &&'), (66, 1, u'+  assert(unsigned(-ScopeIdx) <= Ctx.pImpl->ScopeInlinedAtRecords.size() &&'), (104, 1, u'+  assert(Scope && "If scope is null, this should be isUnknown()");'), (251, 1, u'+    assert(Ctx->ScopeRecordIdx[Cur] == Idx && "Mapping out of date!");'), (261, 1, u'+  assert(unsigned(-Idx-1) < Ctx->ScopeInlinedAtRecords.size());'), (263, 1, u'+  assert((this == &Entry.first || this == &Entry.second) &&'), (268, 1, u'+  assert(OldScope != 0 && OldInlinedAt != 0 &&'), (272, 1, u'+  assert(Ctx->ScopeInlinedAtIdx[std::make_pair(OldScope, OldInlinedAt)] == Idx&&'), (296, 1, u'+  assert(OldVal != NewVa && "Node replaced with self?");'), (300, 1, u'+    assert(Ctx->ScopeRecordIdx[OldVal] == Idx && "Mapping out of date!");'), (315, 1, u'+  assert(unsigned(-Idx-1) < Ctx->ScopeInlinedAtRecords.size());'), (317, 1, u'+  assert((this == &Entry.first || this == &Entry.second) &&'), (322, 1, u'+  assert(OldScope != 0 && OldInlinedAt != 0 &&'), (326, 1, u'+  assert(Ctx->ScopeInlinedAtIdx[std::make_pair(OldScope, OldInlinedAt)] == Idx&&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 1, u'+  assert(F && "Argument is not in a function");'), (86, 1, u'+  assert(getType()->isPointerTy() && "Only pointers have alignments");'), (168, 1, u'+  assert(FunctionType::isValidReturnType(getReturnType()) &&'), (203, 1, u'+    assert(!FT->getParamType(i)->isVoidTy() &&'), (272, 1, u'+  assert(hasGC() && "Function has no collector");'), (304, 1, u'+  assert(isa<Function>(Src) && "Expected a Function!");'), (340, 1, u'+  assert(id < num_intrinsics && "Invalid intrinsic ID!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(51, 1, u'+      assert (i < Functions.size() && ".gcda data does not match .gcno data");'), (116, 1, u'+  assert (Buff.readBlockTag() && "Block Tag not found!");'), (127, 1, u'+    assert (BlockNo < BlockCount && "Unexpected Block number!");'), (139, 1, u'+    assert (BlockNo < BlockCount && "Unexpected Block number!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(58, 1, u'+  assert((Align & (Align-1)) == 0 && "Alignment is not a power of 2!");'), (59, 1, u'+  assert(Align <= MaximumAlignment &&'), (62, 1, u'+  assert(getAlignment() == Align && "Alignment representation error!");'), (75, 1, u'+  assert(isa<GlobalAlias>(this));'), (92, 1, u'+    assert(InitVal->getType() == Ty &&'), (111, 1, u'+    assert(InitVal->getType() == Ty &&'), (144, 1, u'+  assert(getNumOperands() == 1 &&'), (149, 1, u'+  assert(getOperand(0) == From &&'), (153, 1, u'+  assert(isa<Constant>(To) &&'), (167, 1, u'+    assert(InitVal->getType() == getType()->getElementType() &&'), (178, 1, u'+  assert(isa<GlobalVariable>(Src) && "Expected a GlobalVariable!");'), (196, 1, u'+    assert(aliasee->getType() == Ty && "Alias and aliasee types should match!");'), (220, 1, u'+  assert((!Aliasee || Aliasee->getType() == getType()) &&'), (234, 1, u'+  assert((CE->getOpcode() == Instruction::BitCast ||')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(38, 1, u'+  assert(BB && BB->getParent() && "No current function!");'), (122, 1, u'+  assert(isa<PointerType>(Ptr->getType()) &&'), (128, 1, u'+    assert(Size->getType() == getInt64Ty() &&'), (137, 1, u'+  assert(isa<PointerType>(Ptr->getType()) &&'), (143, 1, u'+    assert(Size->getType() == getInt64Ty() &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 1, u'+  assert(Verify(getFunctionType(), constraints) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+    assert(InsertBefore->getParent() &&'), (44, 1, u'+  assert(InsertAtEnd && "Basic block to append to may not be NULL!");'), (51, 1, u'+  assert(Parent == 0 && "Instruction still linked in the program!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(247, 1, u'+  assert(OpNo < ReservedSpace && "Growing didn\'t work!");'), (260, 1, u'+  assert(NumOperands == Args.size() + 1 && "NumOperands not set up?");'), (267, 1, u'+  assert((Args.size() == FTy->getNumParams() ||'), (272, 1, u'+    assert((i >= FTy->getNumParams() ||'), (282, 1, u'+  assert(NumOperands == 1 && "NumOperands not set up?");'), (289, 1, u'+  assert(FTy->getNumParams() == 0 && "Calling a function with bad signature");'), (349, 1, u'+  assert(val && "IsConstantOne does not work with NULL val");'), (358, 1, u'+  assert(((!InsertBefore && InsertAtEnd) || (InsertBefore && !InsertAtEnd)) &&'), (395, 1, u'+  assert(AllocSize->getType() == IntPtrTy && "malloc arg is wrong size");'), (427, 1, u'+  assert(!MCall->getType()->isVoidTy() && "Malloc has void return type");'), (465, 1, u'+  assert(((!InsertBefore && InsertAtEnd) || (InsertBefore && !InsertAtEnd)) &&'), (467, 1, u'+  assert(Source->getType()->isPointerTy() &&'), (505, 1, u'+  assert(FreeCall && "CreateFree did not create a CallInst");'), (515, 1, u'+  assert(NumOperands == 3 + Args.size() && "NumOperands not set up?");'), (524, 1, u'+  assert(((Args.size() == FTy->getNumParams()) ||'), (529, 1, u'+    assert((i >= FTy->getNumParams() ||'), (697, 1, u'+void BranchInst::AssertOK() {'), (699, 1, u'+    assert(getCondition()->getType()->isIntegerTy(1) &&'), (707, 1, u'+  assert(IfTrue != 0 && "Branch destination may not be null!");'), (719, 1, u'+  AssertOK();'), (727, 1, u'+  assert(IfTrue != 0 && "Branch destination may not be null!");'), (740, 1, u'+  AssertOK();'), (751, 1, u'+    assert(BI.getNumOperands() == 3 && "BR can have 1 or 3 operands!");'), (759, 1, u'+  assert(isConditional() &&'), (798, 1, u'+    assert(!isa<BasicBlock>(Amt) &&'), (800, 1, u'+    assert(Amt->getType()->isIntegerTy() &&'), (811, 1, u'+  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (820, 1, u'+  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (829, 1, u'+  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (838, 1, u'+  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (847, 1, u'+  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (856, 1, u'+  assert(!Ty->isVoidTy() && "Cannot allocate void!");'), (865, 1, u'+  assert((Align & (Align-1)) == 0 && "Alignment is not a power of 2!");'), (866, 1, u'+  assert(Align <= MaximumAlignment &&'), (869, 1, u'+  assert(getAlignment() == Align && "Alignment representation error!");'), (898, 1, u'+void LoadInst::AssertOK() {'), (899, 1, u'+  assert(getOperand(0)->getType()->isPointerTy() &&'), (901, 1, u'+  assert(!(isAtomic() && getAlignment() == 0) &&'), (911, 1, u'+  AssertOK();'), (921, 1, u'+  AssertOK();'), (932, 1, u'+  AssertOK();'), (943, 1, u'+  AssertOK();'), (954, 1, u'+  AssertOK();'), (965, 1, u'+  AssertOK();'), (978, 1, u'+  AssertOK();'), (991, 1, u'+  AssertOK();'), (1001, 1, u'+  AssertOK();'), (1011, 1, u'+  AssertOK();'), (1022, 1, u'+  AssertOK();'), (1033, 1, u'+  AssertOK();'), (1038, 1, u'+  assert((Align & (Align-1)) == 0 && "Alignment is not a power of 2!");'), (1039, 1, u'+  assert(Align <= MaximumAlignment &&'), (1043, 1, u'+  assert(getAlignment() == Align && "Alignment representation error!");'), (1050, 1, u'+void StoreInst::AssertOK() {'), (1051, 1, u'+  assert(getOperand(0) && getOperand(1) && "Both operands must be non-null!");'), (1052, 1, u'+  assert(getOperand(1)->getType()->isPointerTy() &&'), (1054, 1, u'+  assert(getOperand(0)->getType() =='), (1057, 1, u'+  assert(!(isAtomic() && getAlignment() == 0) &&'), (1072, 1, u'+  AssertOK();'), (1085, 1, u'+  AssertOK();'), (1099, 1, u'+  AssertOK();'), (1113, 1, u'+  AssertOK();'), (1129, 1, u'+  AssertOK();'), (1143, 1, u'+  AssertOK();'), (1157, 1, u'+  AssertOK();'), (1173, 1, u'+  AssertOK();'), (1177, 1, u'+  assert((Align & (Align-1)) == 0 && "Alignment is not a power of 2!");'), (1178, 1, u'+  assert(Align <= MaximumAlignment &&'), (1182, 1, u'+  assert(getAlignment() == Align && "Alignment representation error!");'), (1198, 1, u'+  assert(getOperand(0) && getOperand(1) && getOperand(2) &&'), (1200, 1, u'+  assert(getOperand(0)->getType()->isPointerTy() &&'), (1202, 1, u'+  assert(getOperand(1)->getType() =='), (1205, 1, u'+  assert(getOperand(2)->getType() =='), (1208, 1, u'+  assert(Ordering != NotAtomic &&'), (1247, 1, u'+  assert(getOperand(0) && getOperand(1) &&'), (1249, 1, u'+  assert(getOperand(0)->getType()->isPointerTy() &&'), (1251, 1, u'+  assert(getOperand(1)->getType() =='), (1254, 1, u'+  assert(Ordering != NotAtomic &&'), (1306, 1, u'+  assert(NumOperands == 1 + IdxList.size() && "NumOperands not initialized?");'), (1333, 1, u'+    assert(IdxList.size() == 1 &&'), (1337, 1, u'+    assert(PTy && "Gep with invalid vector pointer found");'), (1434, 1, u'+  assert(isValidOperands(Val, Index) &&'), (1448, 1, u'+  assert(isValidOperands(Val, Index) &&'), (1474, 1, u'+  assert(isValidOperands(Vec, Elt, Index) &&'), (1488, 1, u'+  assert(isValidOperands(Vec, Elt, Index) &&'), (1524, 1, u'+  assert(isValidOperands(V1, V2, Mask) &&'), (1541, 1, u'+  assert(isValidOperands(V1, V2, Mask) &&'), (1602, 1, u'+  assert(i < Mask->getType()->getVectorNumElements() && "Index out of range");'), (1636, 1, u'+  assert(NumOperands == 2 && "NumOperands not initialized?");'), (1642, 1, u'+  assert(Idxs.size() > 0 && "InsertValueInst must have at least one index");'), (1644, 1, u'+  assert(ExtractValueInst::getIndexedType(Agg->getType(), Idxs) =='), (1667, 1, u'+  assert(NumOperands == 1 && "NumOperands not initialized?");'), (1671, 1, u'+  assert(Idxs.size() > 0 && "ExtractValueInst must have at least one index");'), (1749, 1, u'+  assert(LHS->getType() == RHS->getType() &&'), (1755, 1, u'+    assert(getType() == LHS->getType() &&'), (1757, 1, u'+    assert(getType()->isIntOrIntVectorTy() &&'), (1762, 1, u'+    assert(getType() == LHS->getType() &&'), (1764, 1, u'+    assert(getType()->isFPOrFPVectorTy() &&'), (1770, 1, u'+    assert(getType() == LHS->getType() &&'), (1772, 1, u'+    assert((getType()->isIntegerTy() || (getType()->isVectorTy() &&'), (1777, 1, u'+    assert(getType() == LHS->getType() &&'), (1779, 1, u'+    assert(getType()->isFPOrFPVectorTy() &&'), (1784, 1, u'+    assert(getType() == LHS->getType() &&'), (1786, 1, u'+    assert((getType()->isIntegerTy() || (getType()->isVectorTy() &&'), (1791, 1, u'+    assert(getType() == LHS->getType() &&'), (1793, 1, u'+    assert(getType()->isFPOrFPVectorTy() &&'), (1799, 1, u'+    assert(getType() == LHS->getType() &&'), (1801, 1, u'+    assert((getType()->isIntegerTy() ||'), (1808, 1, u'+    assert(getType() == LHS->getType() &&'), (1810, 1, u'+    assert((getType()->isIntegerTy() ||'), (1824, 1, u'+  assert(S1->getType() == S2->getType() &&'), (1954, 1, u'+  assert(isNot(BinOp) && "getNotArgument on non-\'not\' instruction!");'), (1960, 1, u'+  assert(isConstantAllOnes(Op1));'), (2273, 1, u'+  assert(castIsValid(op, S, Ty) && "Invalid cast!");'), (2294, 1, u'+  assert(castIsValid(op, S, Ty) && "Invalid cast!");'), (2364, 1, u'+  assert(S->getType()->isPointerTy() && "Invalid cast");'), (2365, 1, u'+  assert((Ty->isIntegerTy() || Ty->isPointerTy()) &&'), (2377, 1, u'+  assert(S->getType()->isPointerTy() && "Invalid cast");'), (2378, 1, u'+  assert((Ty->isIntegerTy() || Ty->isPointerTy()) &&'), (2389, 1, u'+  assert(C->getType()->isIntOrIntVectorTy() && Ty->isIntOrIntVectorTy() &&'), (2403, 1, u'+  assert(C->getType()->isIntOrIntVectorTy() && Ty->isIntOrIntVectorTy() &&'), (2417, 1, u'+  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&'), (2430, 1, u'+  assert(C->getType()->isFPOrFPVectorTy() && Ty->isFPOrFPVectorTy() &&'), (2515, 1, u'+  assert(SrcTy->isFirstClassType() && DestTy->isFirstClassType() &&'), (2553, 1, u'+      assert(DestBits == SrcBits &&'), (2557, 1, u'+      assert(SrcTy->isPointerTy() &&'), (2576, 1, u'+      assert(DestBits == SrcBits &&'), (2582, 1, u'+    assert(DestBits == SrcBits &&'), (2594, 1, u'+      assert(DestBits == SrcBits && "Casting vector of wrong width to X86_MMX");'), (2689, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal Trunc");'), (2695, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal Trunc");'), (2701, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal ZExt");'), (2707, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal ZExt");'), (2712, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal SExt");'), (2718, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal SExt");'), (2724, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPTrunc");'), (2730, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPTrunc");'), (2736, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPExt");'), (2742, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPExt");'), (2748, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal UIToFP");'), (2754, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal UIToFP");'), (2760, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal SIToFP");'), (2766, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal SIToFP");'), (2772, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPToUI");'), (2778, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPToUI");'), (2784, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPToSI");'), (2790, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal FPToSI");'), (2796, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal PtrToInt");'), (2802, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal PtrToInt");'), (2808, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal IntToPtr");'), (2814, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal IntToPtr");'), (2820, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal BitCast");'), (2826, 1, u'+  assert(castIsValid(getOpcode(), S, Ty) && "Illegal BitCast");'), (3121, 1, u'+  assert(Value && Default && NumReserved);'), (3177, 1, u'+  assert(OpNo+1 < ReservedSpace && "Growing didn\'t work!");'), (3189, 1, u'+  assert(2 + idx*2 < getNumOperands() && "Case index out of range!!!");'), (3239, 1, u'+  assert(Address && Address->getType()->isPointerTy() &&'), (3300, 1, u'+  assert(OpNo < ReservedSpace && "Growing didn\'t work!");'), (3308, 1, u'+  assert(idx < getNumOperands()-1 && "Successor index out of range!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+  assert(DbgID == MD_dbg && "dbg kind id drifted"); (void)DbgID;'), (41, 1, u'+  assert(TBAAID == MD_tbaa && "tbaa kind id drifted"); (void)TBAAID;'), (45, 1, u'+  assert(ProfID == MD_prof && "prof kind id drifted"); (void)ProfID;'), (49, 1, u'+  assert(FPAccuracyID == MD_fpmath && "fpmath kind id drifted");'), (54, 1, u'+  assert(RangeID == MD_range && "range kind id drifted");'), (142, 1, u'+  assert(isValidName(Name) && "Invalid MDNode name");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(108, 1, u'+  assert(MDNodeSet.empty() && NonUniquedMDNodes.empty() &&')]
===========================================
Class:class MDNodeOperand : public CallbackVH { class MDNodeOperand : public CallbackVH 
Class:  class TypeFinder {   class TypeFinder 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(378, 1, u'+  assert(Node->getNumOperands() == 3 &&'), (380, 1, u'+  assert(isa<ConstantInt>(Node->getOperand(0)) &&'), (390, 1, u'+  assert(!Materializer &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 1, u'+  assert(!Resolver && "Resolver is already set");'), (200, 1, u'+  assert((!isAnalysisGroup() || NormalCtor) &&'), (202, 1, u'+  assert(NormalCtor &&')]
===========================================
Class:class BBPassManager : public PMDataManager, public FunctionPass { class BBPassManager : public PMDataManager, public FunctionPass 
Class:class FunctionPassManagerImpl : public Pass, class FunctionPassManagerImpl : public Pass,
Class:       class MPPassManager : public Pass, public PMDataManager { class MPPassManager : public Pass, public PMDataManager 
Class:     class PassManagerImpl : public Pass,                         public PMDataManager,                         public PMTopLevelManager {                         public PMTopLevelManager 
Class:class TimingInfo { class TimingInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(110, 1, u'+  assert(Inserted && "Pass registered multiple times!");'), (127, 1, u'+  assert(I != Impl->PassInfoMap.end() && "Pass registered but not in map!");'), (155, 1, u'+  assert(Registeree.isAnalysisGroup() &&'), (160, 1, u'+    assert(ImplementationInfo &&'), (172, 1, u'+    assert(AGI.Implementations.count(ImplementationInfo) == 0 &&'), (176, 1, u'+      assert(InterfaceInfo->getNormalCtor() == 0 &&'), (178, 1, u'+      assert(ImplementationInfo->getNormalCtor() &&'), (206, 1, u'+  assert(I != Impl->Listeners.end() &&')]
===========================================
Class:  class PrintModulePass : public ModulePass {   class PrintModulePass : public ModulePass 
Class:   class PrintFunctionPass : public FunctionPass {   class PrintFunctionPass : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(162, 1, u'+  assert(isFloatingPointTy() && "Not a floating point type!");'), (168, 1, u'+  assert(getTypeID() == PPC_FP128TyID && "unknown fp type");'), (327, 1, u'+  assert(NumBits >= MIN_INT_BITS && "bitwidth too small");'), (328, 1, u'+  assert(NumBits <= MAX_INT_BITS && "bitwidth too large");'), (366, 1, u'+  assert(isValidReturnType(Result) && "invalid return type for function");'), (372, 1, u'+    assert(isValidArgumentType(Params[i]) &&'), (450, 1, u'+  assert(isOpaque() && "Struct body already set!");'), (519, 1, u'+  assert(type != 0 && "Cannot create a struct type with no elements with this");'), (549, 1, u'+  assert(!Elements.empty() &&'), (555, 1, u'+  assert(!Elements.empty() &&'), (561, 1, u'+  assert(type != 0 && "Cannot create a struct type with no elements with this");'), (595, 1, u'+  assert(!isLiteral() && "Literal structs never have names");'), (602, 1, u'+  assert(type != 0 && "Cannot create a struct type with no elements with this");'), (649, 1, u'+    assert(indexValid(Idx) && "Invalid structure index!");'), (657, 1, u'+    assert(indexValid(Idx) && "Invalid structure index!");'), (696, 1, u'+  assert(isValidElementType(ElementType) && "Invalid type for array element!");'), (723, 1, u'+  assert(NumElements > 0 && "#Elements of a VectorType must be greater than 0");'), (724, 1, u'+  assert(isValidElementType(ElementType) &&'), (747, 1, u'+  assert(EltTy && "Can\'t get a pointer to <null> type!");'), (748, 1, u'+  assert(isValidElementType(EltTy) && "Invalid type for pointer element!");'), (769, 1, u'+  assert(oldNCT == NumContainedTys && "bitfield written out of bounds?");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 1, u'+  assert((!isa<Constant>(this) || isa<GlobalValue>(this)) &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(39, 1, u'+  assert(Ty && "Value defined with a null type: Error!");'), (49, 1, u'+    assert((VTy->isFirstClassType() || VTy->isVoidTy() || VTy->isStructTy()) &&'), (52, 1, u'+    assert((VTy->isFirstClassType() || VTy->isVoidTy()) &&'), (75, 1, u'+  assert(use_empty() && "Uses remain when a value is destroyed!");'), (158, 1, u'+    assert(isa<Constant>(V) && "Unknown value type!");'), (173, 1, u'+  assert(SubclassID != MDStringVal &&'), (187, 1, u'+  assert(!getType()->isVoidTy() && "Cannot assign a name to void values!");'), (234, 1, u'+  assert(SubclassID != MDStringVal && "Cannot take the name of an MDString!");'), (271, 1, u'+  assert(!Failure && "V has a name, so it should have a ST!"); (void)Failure;'), (298, 1, u'+  assert(New && "Value::replaceAllUsesWith(<null>) is invalid!");'), (299, 1, u'+  assert(New != this && "this->replaceAllUsesWith(this) is NOT valid!");'), (300, 1, u'+  assert(New->getType() == getType() &&'), (369, 1, u'+    assert(V->getType()->isPointerTy() && "Unexpected operand type!");'), (477, 1, u'+  assert(List && "Handle list is null?");'), (485, 1, u'+    assert(VP.getPointer() == Next->VP.getPointer() && "Added to wrong list?");'), (490, 1, u'+  assert(List && "Must insert after existing node");'), (501, 1, u'+  assert(VP.getPointer() && "Null pointer doesn\'t have a use list!");'), (509, 1, u'+    assert(Entry != 0 && "Value doesn\'t have any handles?");'), (523, 1, u'+  assert(Entry == 0 && "Value really did already have handles?");'), (537, 1, u'+    assert(I->second && I->first == I->second->VP.getPointer() &&'), (545, 1, u'+  assert(VP.getPointer() && VP.getPointer()->HasValueHandle &&'), (550, 1, u'+  assert(*PrevPtr == this && "List invariant broken");'), (554, 1, u'+    assert(Next->getPrevPtr() == &Next && "List invariant broken");'), (572, 1, u'+  assert(V->HasValueHandle && "Should only be called if ValueHandles present");'), (578, 1, u'+  assert(Entry && "Value bit set but no entries exist");'), (589, 1, u'+  for (ValueHandleBase Iterator(Assert, *Entry); Entry; Entry = Iterator.Next) {'), (592, 1, u'+    assert(Entry->Next == &Iterator && "Loop invariant broken.");'), (595, 1, u'+    case Assert:'), (618, 1, u'+    if (pImpl->ValueHandles[V]->getKind() == Assert)'), (629, 1, u'+  assert(Old->HasValueHandle &&"Should only be called if ValueHandles present");'), (630, 1, u'+  assert(Old != New && "Changing value into itself!");'), (637, 1, u'+  assert(Entry && "Value bit set but no entries exist");'), (643, 1, u'+  for (ValueHandleBase Iterator(Assert, *Entry); Entry; Entry = Iterator.Next) {'), (646, 1, u'+    assert(Entry->Next == &Iterator && "Loop invariant broken.");'), (649, 1, u'+    case Assert:')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+  assert(vmap.empty() && "Values remain in symbol table!");'), (37, 1, u'+  assert(V->hasName() && "Can\'t insert nameless Value into symbol table");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+  assert(VT.isExtended() && "Type is not extended!");'), (39, 1, u'+  assert(ResultVT.isExtended() && "Type is not extended!");'), (44, 1, u'+  assert(isExtended() && "Type is not extended!");'), (49, 1, u'+  assert(isExtended() && "Type is not extended!");'), (54, 1, u'+  assert(isExtended() && "Type is not extended!");'), (75, 1, u'+  assert(isExtended() && "Type is not extended!");'), (80, 1, u'+  assert(isExtended() && "Type is not extended!");'), (85, 1, u'+  assert(isExtended() && "Type is not extended!");'), (152, 1, u'+    assert(isExtended() && "Type is not extended!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(360, 1, u'+#define Assert(C, M) \\'), (362, 1, u'+#define Assert1(C, M, V1) \\'), (364, 1, u'+#define Assert2(C, M, V1, V2) \\'), (366, 1, u'+#define Assert3(C, M, V1, V2, V3) \\'), (368, 1, u'+#define Assert4(C, M, V1, V2, V3, V4) \\'), (373, 1, u'+    Assert1(I.getOperand(i) != 0, "Operand is null", &I);'), (379, 1, u'+  Assert1(!GV.isDeclaration() ||'), (389, 1, u'+  Assert1(!GV.hasDLLImportLinkage() || GV.isDeclaration(),'), (392, 1, u'+  Assert1(!GV.hasAppendingLinkage() || isa<GlobalVariable>(GV),'), (397, 1, u'+    Assert1(GVar && GVar->getType()->getElementType()->isArrayTy(),'), (401, 1, u'+  Assert1(!GV.hasLinkerPrivateWeakDefAutoLinkage() || GV.hasDefaultVisibility(),'), (408, 1, u'+    Assert1(GV.getInitializer()->getType() == GV.getType()->getElementType(),'), (415, 1, u'+      Assert1(GV.getInitializer()->isNullValue(),'), (417, 1, u'+      Assert1(!GV.isConstant(), "\'common\' global may not be marked constant!",'), (421, 1, u'+    Assert1(GV.hasExternalLinkage() || GV.hasDLLImportLinkage() ||'), (428, 1, u'+    Assert1(!GV.hasInitializer() || GV.hasAppendingLinkage(),'), (436, 1, u'+      Assert1(STy && STy->getNumElements() == 2 &&'), (447, 1, u'+  Assert1(!GA.getName().empty(),'), (449, 1, u'+  Assert1(GA.hasExternalLinkage() || GA.hasLocalLinkage() ||'), (452, 1, u'+  Assert1(GA.getAliasee(),'), (454, 1, u'+  Assert1(GA.getType() == GA.getAliasee()->getType(),'), (456, 1, u'+  Assert1(!GA.hasUnnamedAddr(), "Alias cannot have unnamed_addr!", &GA);'), (460, 1, u'+    Assert1(CE &&'), (469, 1, u'+  Assert1(Aliasee,'), (481, 1, u'+    Assert1(!MD->isFunctionLocal(),'), (500, 1, u'+      Assert2(MD.isFunctionLocal() || !N->isFunctionLocal(),'), (505, 1, u'+    Assert2(MD.isFunctionLocal(), "Invalid operand for global metadata!", &MD, Op);'), (516, 1, u'+    assert(ActualF && "Unimplemented function local metadata case!");'), (518, 1, u'+    Assert2(ActualF == F, "function-local metadata used in wrong function",'), (531, 1, u'+  Assert1(!FnCheckAttr, "Attribute " + Attribute::getAsString(FnCheckAttr) +'), (536, 1, u'+    Assert1(!RetI, "Attribute " + Attribute::getAsString(RetI) +'), (543, 1, u'+    Assert1(MutI.isEmptyOrSingleton(), "Attributes " +'), (548, 1, u'+  Assert1(!TypeI, "Wrong type for attribute " +'), (553, 1, u'+    Assert1(!ByValI || PTy->getElementType()->isSized(),'), (557, 1, u'+    Assert1(!ByValI,'), (587, 1, u'+      Assert1(!SawNest, "More than one parameter has attribute nest!", V);'), (592, 1, u'+      Assert1(Attr.Index == 1, "Attribute sret not on first parameter!", V);'), (597, 1, u'+  Assert1(!NotFn, "Attribute " + Attribute::getAsString(NotFn) +'), (603, 1, u'+    Assert1(MutI.isEmptyOrSingleton(), "Attributes " +'), (629, 1, u'+  Assert1(Context == &F.getContext(),'), (632, 1, u'+  Assert1(!F.hasCommonLinkage(), "Functions may not have common linkage", &F);'), (633, 1, u'+  Assert2(FT->getNumParams() == NumArgs,'), (636, 1, u'+  Assert1(F.getReturnType()->isFirstClassType() ||'), (641, 1, u'+  Assert1(!F.hasStructRetAttr() || F.getReturnType()->isVoidTy(),'), (646, 1, u'+  Assert1(VerifyAttributeCount(Attrs, FT->getNumParams()),'), (664, 1, u'+    Assert1(!F.isVarArg(),'), (676, 1, u'+    Assert2(I->getType() == FT->getParamType(i),'), (679, 1, u'+    Assert1(I->getType()->isFirstClassType(),'), (682, 1, u'+      Assert2(!I->getType()->isMetadataTy(),'), (689, 1, u'+    Assert1(F.hasExternalLinkage() || F.hasDLLImportLinkage() ||'), (695, 1, u'+    Assert1(!isLLVMdotName, "llvm intrinsics cannot be defined!", &F);'), (699, 1, u'+    Assert1(pred_begin(Entry) == pred_end(Entry),'), (704, 1, u'+      Assert1(!BlockAddress::get(Entry)->isConstantUsed(),'), (714, 1, u'+      Assert1(0, "Invalid user of intrinsic instruction!", U);'), (724, 1, u'+  Assert1(BB.getTerminator(), "Basic Block does not have terminator!", &BB);'), (735, 1, u'+      Assert1(PN->getNumIncomingValues() != 0,'), (738, 1, u'+      Assert1(PN->getNumIncomingValues() == Preds.size(),'), (755, 1, u'+        Assert4(i == 0 || Values[i].first  != Values[i-1].first ||'), (763, 1, u'+        Assert3(Values[i].first == Preds[i],'), (773, 1, u'+  Assert1(&I == I.getParent()->getTerminator(),'), (780, 1, u'+    Assert2(BI.getCondition()->getType()->isIntegerTy(1),'), (790, 1, u'+    Assert2(N == 0,'), (794, 1, u'+    Assert2(N == 1 && F->getReturnType() == RI.getOperand(0)->getType(),'), (809, 1, u'+    Assert1(i.getCaseValue()->getType() == SwitchTy,'), (811, 1, u'+    Assert2(Constants.insert(i.getCaseValue()),'), (819, 1, u'+  Assert1(BI.getAddress()->getType()->isPointerTy(),'), (822, 1, u'+    Assert1(BI.getDestination(i)->getType()->isLabelTy(),'), (829, 1, u'+  Assert1(!SelectInst::areInvalidOperands(SI.getOperand(0), SI.getOperand(1),'), (833, 1, u'+  Assert1(SI.getTrueValue()->getType() == SI.getType(),'), (842, 1, u'+  Assert1(0, "User-defined operators should not live outside of a pass!", &I);'), (854, 1, u'+  Assert1(SrcTy->isIntOrIntVectorTy(), "Trunc only operates on integer", &I);'), (855, 1, u'+  Assert1(DestTy->isIntOrIntVectorTy(), "Trunc only produces integer", &I);'), (856, 1, u'+  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (858, 1, u'+  Assert1(SrcBitSize > DestBitSize,"DestTy too big for Trunc", &I);'), (869, 1, u'+  Assert1(SrcTy->isIntOrIntVectorTy(), "ZExt only operates on integer", &I);'), (870, 1, u'+  Assert1(DestTy->isIntOrIntVectorTy(), "ZExt only produces an integer", &I);'), (871, 1, u'+  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (876, 1, u'+  Assert1(SrcBitSize < DestBitSize,"Type too small for ZExt", &I);'), (890, 1, u'+  Assert1(SrcTy->isIntOrIntVectorTy(), "SExt only operates on integer", &I);'), (891, 1, u'+  Assert1(DestTy->isIntOrIntVectorTy(), "SExt only produces an integer", &I);'), (892, 1, u'+  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (894, 1, u'+  Assert1(SrcBitSize < DestBitSize,"Type too small for SExt", &I);'), (907, 1, u'+  Assert1(SrcTy->isFPOrFPVectorTy(),"FPTrunc only operates on FP", &I);'), (908, 1, u'+  Assert1(DestTy->isFPOrFPVectorTy(),"FPTrunc only produces an FP", &I);'), (909, 1, u'+  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (911, 1, u'+  Assert1(SrcBitSize > DestBitSize,"DestTy too big for FPTrunc", &I);'), (925, 1, u'+  Assert1(SrcTy->isFPOrFPVectorTy(),"FPExt only operates on FP", &I);'), (926, 1, u'+  Assert1(DestTy->isFPOrFPVectorTy(),"FPExt only produces an FP", &I);'), (927, 1, u'+  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (929, 1, u'+  Assert1(SrcBitSize < DestBitSize,"DestTy too small for FPExt", &I);'), (942, 1, u'+  Assert1(SrcVec == DstVec,'), (944, 1, u'+  Assert1(SrcTy->isIntOrIntVectorTy(),'), (946, 1, u'+  Assert1(DestTy->isFPOrFPVectorTy(),'), (950, 1, u'+    Assert1(cast<VectorType>(SrcTy)->getNumElements() =='), (965, 1, u'+  Assert1(SrcVec == DstVec,'), (967, 1, u'+  Assert1(SrcTy->isIntOrIntVectorTy(),'), (969, 1, u'+  Assert1(DestTy->isFPOrFPVectorTy(),'), (973, 1, u'+    Assert1(cast<VectorType>(SrcTy)->getNumElements() =='), (988, 1, u'+  Assert1(SrcVec == DstVec,'), (990, 1, u'+  Assert1(SrcTy->isFPOrFPVectorTy(), "FPToUI source must be FP or FP vector",'), (992, 1, u'+  Assert1(DestTy->isIntOrIntVectorTy(),'), (996, 1, u'+    Assert1(cast<VectorType>(SrcTy)->getNumElements() =='), (1011, 1, u'+  Assert1(SrcVec == DstVec,'), (1013, 1, u'+  Assert1(SrcTy->isFPOrFPVectorTy(),'), (1015, 1, u'+  Assert1(DestTy->isIntOrIntVectorTy(),'), (1019, 1, u'+    Assert1(cast<VectorType>(SrcTy)->getNumElements() =='), (1031, 1, u'+  Assert1(SrcTy->getScalarType()->isPointerTy(),'), (1033, 1, u'+  Assert1(DestTy->getScalarType()->isIntegerTy(),'), (1035, 1, u'+  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (1041, 1, u'+    Assert1(VSrc->getNumElements() == VDest->getNumElements(),'), (1053, 1, u'+  Assert1(SrcTy->getScalarType()->isIntegerTy(),'), (1055, 1, u'+  Assert1(DestTy->getScalarType()->isPointerTy(),'), (1057, 1, u'+  Assert1(SrcTy->isVectorTy() == DestTy->isVectorTy(),'), (1062, 1, u'+    Assert1(VSrc->getNumElements() == VDest->getNumElements(),'), (1079, 1, u'+  Assert1(DestTy->isPointerTy() == DestTy->isPointerTy(),'), (1081, 1, u'+  Assert1(SrcBitSize == DestBitSize, "Bitcast requires types of same width",&I);'), (1084, 1, u'+  Assert1(!SrcTy->isAggregateType(),'), (1086, 1, u'+  Assert1(!DestTy->isAggregateType(),'), (1099, 1, u'+  Assert2(&PN == &PN.getParent()->front() ||'), (1107, 1, u'+    Assert1(PN.getType() == PN.getIncomingValue(i)->getType(),'), (1119, 1, u'+  Assert1(CS.getCalledValue()->getType()->isPointerTy(),'), (1123, 1, u'+  Assert1(FPTy->getElementType()->isFunctionTy(),'), (1129, 1, u'+    Assert1(CS.arg_size() >= FTy->getNumParams(),'), (1132, 1, u'+    Assert1(CS.arg_size() == FTy->getNumParams(),'), (1137, 1, u'+    Assert3(CS.getArgument(i)->getType() == FTy->getParamType(i),'), (1143, 1, u'+  Assert1(VerifyAttributeCount(Attrs, CS.arg_size()),'), (1157, 1, u'+      Assert1(!VArgI, "Attribute " + Attribute::getAsString(VArgI) +'), (1166, 1, u'+      Assert1(!(*PI)->isMetadataTy(),'), (1186, 1, u'+  Assert1(II.getUnwindDest()->isLandingPad(),'), (1196, 1, u'+  Assert1(B.getOperand(0)->getType() == B.getOperand(1)->getType(),'), (1209, 1, u'+    Assert1(B.getType()->isIntOrIntVectorTy(),'), (1211, 1, u'+    Assert1(B.getType() == B.getOperand(0)->getType(),'), (1222, 1, u'+    Assert1(B.getType()->isFPOrFPVectorTy(),'), (1225, 1, u'+    Assert1(B.getType() == B.getOperand(0)->getType(),'), (1233, 1, u'+    Assert1(B.getType()->isIntOrIntVectorTy(),'), (1235, 1, u'+    Assert1(B.getType() == B.getOperand(0)->getType(),'), (1242, 1, u'+    Assert1(B.getType()->isIntOrIntVectorTy(),'), (1244, 1, u'+    Assert1(B.getType() == B.getOperand(0)->getType(),'), (1258, 1, u'+  Assert1(Op0Ty == Op1Ty,'), (1261, 1, u'+  Assert1(Op0Ty->isIntOrIntVectorTy() || Op0Ty->getScalarType()->isPointerTy(),'), (1264, 1, u'+  Assert1(IC.getPredicate() >= CmpInst::FIRST_ICMP_PREDICATE &&'), (1275, 1, u'+  Assert1(Op0Ty == Op1Ty,'), (1278, 1, u'+  Assert1(Op0Ty->isFPOrFPVectorTy(),'), (1281, 1, u'+  Assert1(FC.getPredicate() >= CmpInst::FIRST_FCMP_PREDICATE &&'), (1289, 1, u'+  Assert1(ExtractElementInst::isValidOperands(EI.getOperand(0),'), (1296, 1, u'+  Assert1(InsertElementInst::isValidOperands(IE.getOperand(0),'), (1304, 1, u'+  Assert1(ShuffleVectorInst::isValidOperands(SV.getOperand(0), SV.getOperand(1),'), (1313, 1, u'+  Assert1(isa<PointerType>(TargetTy),'), (1315, 1, u'+  Assert1(cast<PointerType>(TargetTy)->getElementType()->isSized(),'), (1321, 1, u'+  Assert1(ElTy, "Invalid indices for GEP pointer type!", &GEP);'), (1325, 1, u'+    Assert2(GEP.getType()->isPointerTy() &&'), (1330, 1, u'+    Assert1(Idxs.size() == 1, "Invalid number of indices!", &GEP);'), (1333, 1, u'+    Assert1(IndexTy->isVectorTy(),'), (1335, 1, u'+    Assert1(GEP.getType()->isVectorTy(),'), (1338, 1, u'+    Assert1(ElemPtr->isPointerTy(),'), (1342, 1, u'+    Assert1(IndexWidth == GepWidth, "Invalid GEP index vector width", &GEP);'), (1343, 1, u'+    Assert1(ElTy == cast<PointerType>(ElemPtr)->getElementType(),'), (1351, 1, u'+  Assert1(PTy, "Load operand must be a pointer.", &LI);'), (1353, 1, u'+  Assert2(ElTy == LI.getType(),'), (1356, 1, u'+    Assert1(LI.getOrdering() != Release && LI.getOrdering() != AcquireRelease,'), (1358, 1, u'+    Assert1(LI.getAlignment() != 0,'), (1361, 1, u'+    Assert1(LI.getSynchScope() == CrossThread,'), (1367, 1, u'+    Assert1(NumOperands % 2 == 0, "Unfinished range!", Range);'), (1369, 1, u'+    Assert1(NumRanges >= 1, "It should have at least one range!", Range);'), (1372, 1, u'+      Assert1(Low, "The lower limit must be an integer!", Low);'), (1374, 1, u'+      Assert1(High, "The upper limit must be an integer!", High);'), (1375, 1, u'+      Assert1(High->getType() == Low->getType() &&'), (1378, 1, u'+      Assert1(High->getValue() != Low->getValue(), "Range must not be empty!",'), (1388, 1, u'+  Assert1(PTy, "Store operand must be a pointer.", &SI);'), (1390, 1, u'+  Assert2(ElTy == SI.getOperand(0)->getType(),'), (1394, 1, u'+    Assert1(SI.getOrdering() != Acquire && SI.getOrdering() != AcquireRelease,'), (1396, 1, u'+    Assert1(SI.getAlignment() != 0,'), (1399, 1, u'+    Assert1(SI.getSynchScope() == CrossThread,'), (1407, 1, u'+  Assert1(PTy->getAddressSpace() == 0,'), (1410, 1, u'+  Assert1(PTy->getElementType()->isSized(), "Cannot allocate unsized type",'), (1412, 1, u'+  Assert1(AI.getArraySize()->getType()->isIntegerTy(),'), (1418, 1, u'+  Assert1(CXI.getOrdering() != NotAtomic,'), (1420, 1, u'+  Assert1(CXI.getOrdering() != Unordered,'), (1423, 1, u'+  Assert1(PTy, "First cmpxchg operand must be a pointer.", &CXI);'), (1425, 1, u'+  Assert2(ElTy == CXI.getOperand(1)->getType(),'), (1428, 1, u'+  Assert2(ElTy == CXI.getOperand(2)->getType(),'), (1435, 1, u'+  Assert1(RMWI.getOrdering() != NotAtomic,'), (1437, 1, u'+  Assert1(RMWI.getOrdering() != Unordered,'), (1440, 1, u'+  Assert1(PTy, "First atomicrmw operand must be a pointer.", &RMWI);'), (1442, 1, u'+  Assert2(ElTy == RMWI.getOperand(1)->getType(),'), (1445, 1, u'+  Assert1(AtomicRMWInst::FIRST_BINOP <= RMWI.getOperation() &&'), (1453, 1, u'+  Assert1(Ordering == Acquire || Ordering == Release ||'), (1461, 1, u'+  Assert1(ExtractValueInst::getIndexedType(EVI.getAggregateOperand()->getType(),'), (1470, 1, u'+  Assert1(ExtractValueInst::getIndexedType(IVI.getAggregateOperand()->getType(),'), (1483, 1, u'+  Assert1(LPI.getNumClauses() > 0 || LPI.isCleanup(),'), (1490, 1, u'+    Assert1(II && II->getUnwindDest() == BB,'), (1497, 1, u'+  Assert1(LPI.getParent()->getLandingPadInst() == &LPI,'), (1504, 1, u'+    Assert1(LPI.getPersonalityFn() == PersonalityFn,'), (1509, 1, u'+  Assert1(isa<Constant>(PersonalityFn), "Personality function is not constant!",'), (1513, 1, u'+    Assert1(isa<Constant>(Clause), "Clause is not constant!", &LPI);'), (1515, 1, u'+      Assert1(isa<PointerType>(Clause->getType()),'), (1518, 1, u'+      Assert1(LPI.isFilter(i), "Clause is neither catch nor filter!", &LPI);'), (1519, 1, u'+      Assert1(isa<ConstantArray>(Clause) || isa<ConstantAggregateZero>(Clause),'), (1536, 1, u'+    Assert2(InstsInThisBlock.count(Op) || !DT->isReachableFromEntry(BB) ||'), (1554, 1, u'+    Assert2(UseBlock, "Invoke operand is PHI node with bad incoming-BB",'), (1560, 1, u'+      Assert2(BB == NormalDest || !DT->isReachableFromEntry(UseBlock),'), (1564, 1, u'+      Assert2(DT->dominates(II, UseBlock) ||'), (1574, 1, u'+  Assert2(PredBB && (DT->dominates(OpBlock, PredBB) ||'), (1583, 1, u'+  Assert1(BB, "Instruction not embedded in basic block!", &I);'), (1588, 1, u'+      Assert1(*UI != (User*)&I || !DT->isReachableFromEntry(BB),'), (1593, 1, u'+  Assert1(!I.getType()->isVoidTy() || !I.hasName(),'), (1598, 1, u'+  Assert1(I.getType()->isVoidTy() ||'), (1604, 1, u'+  Assert1(!I.getType()->isMetadataTy() ||'), (1614, 1, u'+      Assert2(Used->getParent() != 0, "Instruction referencing instruction not"'), (1623, 1, u'+    Assert1(I.getOperand(i) != 0, "Instruction has null operand!", &I);'), (1628, 1, u'+      Assert1(0, "Instruction operands must be first-class values!", &I);'), (1634, 1, u'+      Assert1(!F->isIntrinsic() || (i + 1 == e && isa<CallInst>(I)),'), (1636, 1, u'+      Assert1(F->getParent() == Mod, "Referencing function in another module!",'), (1639, 1, u'+      Assert1(OpBB->getParent() == BB->getParent(),'), (1642, 1, u'+      Assert1(OpArg->getParent() == BB->getParent(),'), (1645, 1, u'+      Assert1(GV->getParent() == Mod, "Referencing global in another module!",'), (1650, 1, u'+      Assert1((i + 1 == e && isa<CallInst>(I)) ||'), (1657, 1, u'+    Assert1(I.getType()->isFPOrFPVectorTy(),'), (1659, 1, u'+    Assert1(MD->getNumOperands() == 1, "fpmath takes one operand!", &I);'), (1663, 1, u'+      Assert1(Accuracy.isNormal() && !Accuracy.isNegative(),'), (1666, 1, u'+      Assert1(false, "invalid fpmath accuracy!", &I);'), (1671, 1, u'+  Assert1(!MD || isa<LoadInst>(I), "Ranges are only for loads!", &I);'), (1685, 1, u'+  Assert1(IF->isDeclaration(), "Intrinsic functions should never be defined!",'), (1703, 1, u'+    Assert1(isa<ConstantInt>(CI.getArgOperand(1)),'), (1708, 1, u'+    Assert1(CI.getArgOperand(0) && isa<MDNode>(CI.getArgOperand(0)),'), (1711, 1, u'+    Assert1(MD->getNumOperands() == 1,'), (1717, 1, u'+    Assert1(isa<ConstantInt>(CI.getArgOperand(3)),'), (1720, 1, u'+    Assert1(isa<ConstantInt>(CI.getArgOperand(4)),'), (1730, 1, u'+      Assert1(AI, "llvm.gcroot parameter #1 must be an alloca.", &CI);'), (1731, 1, u'+      Assert1(isa<Constant>(CI.getArgOperand(1)),'), (1734, 1, u'+        Assert1(!isa<ConstantPointerNull>(CI.getArgOperand(1)),'), (1740, 1, u'+    Assert1(CI.getParent()->getParent()->hasGC(),'), (1744, 1, u'+    Assert1(isa<Function>(CI.getArgOperand(1)->stripPointerCasts()),'), (1749, 1, u'+    Assert1(isa<ConstantInt>(CI.getArgOperand(1)) &&'), (1757, 1, u'+    Assert1(isa<AllocaInst>(CI.getArgOperand(1)->stripPointerCasts()),'), (1764, 1, u'+    Assert1(isa<ConstantInt>(CI.getArgOperand(0)),'), (1769, 1, u'+    Assert1(isa<ConstantInt>(CI.getArgOperand(1)),'), (2025, 1, u'+  Assert1(F->getAttributes() == Intrinsic::getAttributes(ID),'), (2044, 1, u'+  assert(!F.isDeclaration() && "Cannot verify external functions");')]
===========================================
Class:  class CrashOnCalls : public BasicBlockPass {   class CrashOnCalls : public BasicBlockPass 
Class:  class DeleteCalls : public BasicBlockPass {   class DeleteCalls : public BasicBlockPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(115, 1, u'+  assert(Program == 0 && "Cannot call addSources multiple times!");'), (116, 1, u'+  assert(!Filenames.empty() && "Must specify at least on input filename!");')]
===========================================
Class:  class ReducePassList : public ListReducer<std::string> {   class ReducePassList : public ListReducer<std::string> 
Class:  class ReduceCrashingGlobalVariables : public ListReducer<GlobalVariable*> {   class ReduceCrashingGlobalVariables : public ListReducer<GlobalVariable*> 
Class:  class ReduceCrashingFunctions : public ListReducer<Function*> {   class ReduceCrashingFunctions : public ListReducer<Function*> 
Class:  class ReduceCrashingBlocks : public ListReducer<const BasicBlock*> {   class ReduceCrashingBlocks : public ListReducer<const BasicBlock*> 
Class:  class ReduceCrashingInstructions : public ListReducer<const Instruction*> {   class ReduceCrashingInstructions : public ListReducer<const Instruction*> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(300, 1, u'+  assert(AI && "Interpreter should have been created already!");'), (382, 1, u'+  assert(Interpreter && "Interpreter should have been created already!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(184, 1, u'+    assert(M->size() < NewM->size() && "Loop extract removed functions?");'), (200, 1, u'+  assert(F->isDeclaration() && "This didn\'t make the function external!");'), (206, 1, u'+  assert(!TorList.empty() && "Don\'t create empty tor list!");'), (273, 1, u'+  assert(GV && "Not a clone of M1?");'), (274, 1, u'+  assert(GV->use_empty() && "llvm.ctors shouldn\'t have uses!");')]
===========================================
Class:  class ReduceMiscompilingPasses : public ListReducer<std::string> {   class ReduceMiscompilingPasses : public ListReducer<std::string> 
Class:  class ReduceMiscompilingFunctions : public ListReducer<Function*> {   class ReduceMiscompilingFunctions : public ListReducer<Function*> 
Class:  class ReduceMiscompiledBlocks : public ListReducer<BasicBlock*> {   class ReduceMiscompiledBlocks : public ListReducer<BasicBlock*> 
Class:  class LLI : public AbstractInterpreter {   class LLI : public AbstractInterpreter 
Class:  class CustomCompiler : public AbstractInterpreter {   class CustomCompiler : public AbstractInterpreter 
Class:  class CustomExecutor : public AbstractInterpreter {   class CustomExecutor : public AbstractInterpreter 
Class:  class JIT : public AbstractInterpreter {   class JIT : public AbstractInterpreter 
Class:  class AddToDriver : public FunctionPassManager {   class AddToDriver : public FunctionPassManager 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(369, 1, u'+  assert(code_gen);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(456, 1, u'+  assert(target.get() && "Could not allocate target machine!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(738, 1, u'+    assert(TheArchive && "Unable to instantiate the archive");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(61, 1, u'+  assert(AC && "Invalid component name!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+  assert(!Numbering.empty() && "asked for numbering but numbering was no-op");'), (174, 1, u"+    assert(format[percent] == '%');")]
===========================================
Class:template <class T, class Sorter, unsigned InlineCapacity> template <class T, class Sorter, unsigned InlineCapacity>
Class:class PriorityQueue { class PriorityQueue 
Class:  class FunctionDifferenceEngine { class FunctionDifferenceEngine 
Class:class CommentWriter : public AssemblyAnnotationWriter { class CommentWriter : public AssemblyAnnotationWriter 
Class:class VectorMemoryObject : public MemoryObject { class VectorMemoryObject : public MemoryObject 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(389, 1, u'+  assert(MAI && "Unable to create target asm info!");'), (392, 1, u'+  assert(MRI && "Unable to create target register info!");'), (445, 1, u'+    assert(FileType == OFT_ObjectFile && "Invalid file type!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(145, 1, u'+  assert(bytes.size() <= 15')]
===========================================
Class:  class ProfileAnnotator : public AssemblyAnnotationWriter {   class ProfileAnnotator : public AssemblyAnnotationWriter 
Class:  class ProfileInfoPrinterPass : public ModulePass {   class ProfileInfoPrinterPass : public ModulePass 
Class:     class TrivialMemoryManager : public RTDyldMemoryManager { class TrivialMemoryManager : public RTDyldMemoryManager 
Class:     class Random { class Random 
Class:  class RecordStreamer : public MCStreamer {   class RecordStreamer : public MCStreamer 
Class:  class DomInfoPrinter : public FunctionPass {   class DomInfoPrinter : public FunctionPass 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(336, 1, u'+  ASSERT_EQ("10", convertToString(10.0, 6, 3));'), (337, 1, u'+  ASSERT_EQ("1.0E+1", convertToString(10.0, 6, 0));'), (338, 1, u'+  ASSERT_EQ("10100", convertToString(1.01E+4, 5, 2));'), (339, 1, u'+  ASSERT_EQ("1.01E+4", convertToString(1.01E+4, 4, 2));'), (340, 1, u'+  ASSERT_EQ("1.01E+4", convertToString(1.01E+4, 5, 1));'), (341, 1, u'+  ASSERT_EQ("0.0101", convertToString(1.01E-2, 5, 2));'), (342, 1, u'+  ASSERT_EQ("0.0101", convertToString(1.01E-2, 4, 2));'), (343, 1, u'+  ASSERT_EQ("1.01E-2", convertToString(1.01E-2, 5, 1));'), (344, 1, u'+  ASSERT_EQ("0.7853981633974483", convertToString(0.78539816339744830961, 0, 3));'), (345, 1, u'+  ASSERT_EQ("4.940656458412465E-324", convertToString(4.9406564584124654e-324, 0, 3));'), (346, 1, u'+  ASSERT_EQ("873.1834", convertToString(873.1834, 0, 1));'), (347, 1, u'+  ASSERT_EQ("8.731834E+2", convertToString(873.1834, 0, 0));'), (408, 1, u'+  ASSERT_EQ(0x7fc00000, nanbits(APFloat::IEEEsingle, false, false, 0));'), (409, 1, u'+  ASSERT_EQ(0xffc00000, nanbits(APFloat::IEEEsingle, false, true, 0));'), (410, 1, u'+  ASSERT_EQ(0x7fc0ae72, nanbits(APFloat::IEEEsingle, false, false, 0xae72));'), (411, 1, u'+  ASSERT_EQ(0x7fffae72, nanbits(APFloat::IEEEsingle, false, false, 0xffffae72));'), (412, 1, u'+  ASSERT_EQ(0x7fa00000, nanbits(APFloat::IEEEsingle, true, false, 0));'), (413, 1, u'+  ASSERT_EQ(0xffa00000, nanbits(APFloat::IEEEsingle, true, true, 0));'), (414, 1, u'+  ASSERT_EQ(0x7f80ae72, nanbits(APFloat::IEEEsingle, true, false, 0xae72));'), (415, 1, u'+  ASSERT_EQ(0x7fbfae72, nanbits(APFloat::IEEEsingle, true, false, 0xffffae72));'), (417, 1, u'+  ASSERT_EQ(0x7ff8000000000000ULL, nanbits(APFloat::IEEEdouble, false, false, 0));'), (418, 1, u'+  ASSERT_EQ(0xfff8000000000000ULL, nanbits(APFloat::IEEEdouble, false, true, 0));'), (419, 1, u'+  ASSERT_EQ(0x7ff800000000ae72ULL, nanbits(APFloat::IEEEdouble, false, false, 0xae72));'), (420, 1, u'+  ASSERT_EQ(0x7fffffffffffae72ULL, nanbits(APFloat::IEEEdouble, false, false, 0xffffffffffffae72ULL));'), (421, 1, u'+  ASSERT_EQ(0x7ff4000000000000ULL, nanbits(APFloat::IEEEdouble, true, false, 0));'), (422, 1, u'+  ASSERT_EQ(0xfff4000000000000ULL, nanbits(APFloat::IEEEdouble, true, true, 0));'), (423, 1, u'+  ASSERT_EQ(0x7ff000000000ae72ULL, nanbits(APFloat::IEEEdouble, true, false, 0xae72));'), (424, 1, u'+  ASSERT_EQ(0x7ff7ffffffffae72ULL, nanbits(APFloat::IEEEdouble, true, false, 0xffffffffffffae72ULL));')]
===========================================
Class:class FixedDAGDeltaAlgorithm : public DAGDeltaAlgorithm { class FixedDAGDeltaAlgorithm : public DAGDeltaAlgorithm 
Class:class FixedDeltaAlgorithm : public DeltaAlgorithm { class FixedDeltaAlgorithm : public DeltaAlgorithm 
Class:class DenseMapTest : public testing::Test { class DenseMapTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(163, 1, u'+    ASSERT_TRUE(visited[i]) << "Entry #" << i << " was never visited";')]
===========================================
Class:class DenseSetTest : public testing::Test { class DenseSetTest : public testing::Test 
Class:class ImmutableSetTest : public testing::Test { class ImmutableSetTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(149, 1, u'+  ASSERT_STREQ("aeiou", buffer);'), (161, 1, u'+  ASSERT_STREQ("bcdfgh", buffer);'), (162, 1, u'+  ASSERT_EQ(6, obj.counter);'), (166, 1, u'+  ASSERT_STREQ("bcd", buffer);'), (167, 1, u'+  ASSERT_EQ(3, obj2.counter);'), (171, 1, u'+  ASSERT_STREQ("", buffer);'), (172, 1, u'+  ASSERT_EQ(0, obj3.counter);'), (184, 1, u'+    ASSERT_EQ(i++, *I);'), (186, 1, u'+  ASSERT_EQ(0, i);'), (190, 1, u'+    ASSERT_EQ(i++, *I);'), (192, 1, u'+  ASSERT_EQ(3, i);'), (196, 1, u'+    ASSERT_EQ(i++, *I);'), (198, 1, u'+  ASSERT_EQ(6, i);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(81, 1, u'+  ASSERT_TRUE(I.valid());'), (94, 1, u'+  ASSERT_TRUE(I.valid());'), (103, 1, u'+  ASSERT_TRUE(I.valid());'), (110, 1, u'+  ASSERT_TRUE(I.valid());'), (116, 1, u'+  ASSERT_TRUE(I.valid());'), (123, 1, u'+  ASSERT_TRUE(I.valid());'), (129, 1, u'+  ASSERT_TRUE(I.valid());'), (204, 1, u'+  ASSERT_TRUE(I.valid());'), (241, 1, u'+  ASSERT_TRUE(I.valid());'), (246, 1, u'+  ASSERT_TRUE(I.valid());'), (260, 1, u'+  ASSERT_TRUE(I.valid());'), (264, 1, u'+  ASSERT_TRUE(I.valid());'), (268, 1, u'+  ASSERT_TRUE(I.valid());'), (272, 1, u'+  ASSERT_TRUE(I.valid());'), (282, 1, u'+  ASSERT_TRUE(I.valid());'), (286, 1, u'+  ASSERT_TRUE(I.valid());'), (290, 1, u'+  ASSERT_TRUE(I.valid());'), (294, 1, u'+  ASSERT_TRUE(I.valid());'), (304, 1, u'+  ASSERT_TRUE(I.valid());'), (308, 1, u'+  ASSERT_TRUE(I.valid());'), (312, 1, u'+  ASSERT_TRUE(I.valid());'), (353, 1, u'+    ASSERT_TRUE(I.valid());'), (365, 1, u'+    ASSERT_TRUE(I.valid());'), (374, 1, u'+  ASSERT_TRUE(I.valid());'), (380, 1, u'+  ASSERT_TRUE(I.valid());'), (387, 1, u'+  ASSERT_TRUE(I.valid());'), (394, 1, u'+  ASSERT_TRUE(I.valid());'), (401, 1, u'+  ASSERT_TRUE(I.valid());'), (408, 1, u'+  ASSERT_TRUE(I.valid());'), (410, 1, u'+  ASSERT_TRUE(I.valid());'), (417, 1, u'+  ASSERT_TRUE(I.valid());'), (423, 1, u'+  ASSERT_TRUE(I.valid());'), (430, 1, u'+  ASSERT_TRUE(I.valid());'), (437, 1, u'+  ASSERT_TRUE(I.valid());'), (444, 1, u'+  ASSERT_TRUE(I.valid());'), (446, 1, u'+  ASSERT_TRUE(I.valid());'), (492, 1, u'+    ASSERT_TRUE(I.valid());'), (504, 1, u'+    ASSERT_TRUE(I.valid());'), (513, 1, u'+  ASSERT_TRUE(I.valid());'), (519, 1, u'+  ASSERT_TRUE(I.valid());'), (525, 1, u'+  ASSERT_TRUE(I.valid());'), (593, 1, u'+  ASSERT_TRUE(AB.valid());'), (600, 1, u'+  ASSERT_TRUE(BA.valid());'), (636, 1, u'+  ASSERT_TRUE(AB.valid());'), (640, 1, u'+  ASSERT_TRUE(AB.valid());'), (644, 1, u'+  ASSERT_TRUE(AB.valid());'), (648, 1, u'+  ASSERT_TRUE(AB.valid());'), (652, 1, u'+  ASSERT_TRUE(AB.valid());'), (656, 1, u'+  ASSERT_TRUE(AB.valid());'), (665, 1, u'+  ASSERT_TRUE(AB2.valid());'), (671, 1, u'+  ASSERT_TRUE(AB2.valid());'), (677, 1, u'+  ASSERT_TRUE(BA.valid());'), (681, 1, u'+  ASSERT_TRUE(BA.valid());'), (685, 1, u'+  ASSERT_TRUE(BA.valid());'), (689, 1, u'+  ASSERT_TRUE(BA.valid());'), (693, 1, u'+  ASSERT_TRUE(BA.valid());'), (697, 1, u'+  ASSERT_TRUE(BA.valid());'), (706, 1, u'+  ASSERT_TRUE(BA2.valid());'), (711, 1, u'+  ASSERT_TRUE(BA2.valid());')]
===========================================
Class:class Graph { class Graph 
Class:  class NodeSubset {   class NodeSubset 
Class:      class ChildIterator {   class ChildIterator 
Class:class SmallStringTest : public testing::Test { class SmallStringTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(31, 1, u'+  void assertEmpty(StringType & v) {'), (43, 1, u'+  assertEmpty(theString);')]
===========================================
Class:class Constructable { class Constructable 
Class:  class SmallVectorTest : public testing::Test { class SmallVectorTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(174, 1, u'+  ASSERT_TRUE(I == Set.begin());'), (180, 1, u'+  ASSERT_TRUE(I == Set.begin());')]
===========================================
Class:class StringMapTest : public testing::Test { class StringMapTest : public testing::Test 
Class:class StringMapEntryInitializer<uint32_t> { class StringMapEntryInitializer<uint32_t> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(28, 1, u'+  void assertEmptyMap() {'), (46, 1, u'+  void assertSingleItemMap() {'), (79, 1, u'+  assertEmptyMap();'), (107, 1, u'+  assertSingleItemMap();'), (115, 1, u'+  assertEmptyMap();'), (123, 1, u'+  assertEmptyMap();'), (131, 1, u'+  assertEmptyMap();'), (140, 1, u'+  assertSingleItemMap();'), (160, 1, u'+    ASSERT_STREQ(ss.str().c_str(), it->first().data());'), (166, 1, u'+    ASSERT_TRUE(visited[i]) << "Entry #" << i << " was never visited";'), (204, 1, u'+  assertSingleItemMap();')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(366, 1, u'+      ASSERT_FALSE(U8Success);'), (369, 1, u'+      ASSERT_TRUE(U8Success);'), (373, 1, u'+      ASSERT_FALSE(U16Success);'), (376, 1, u'+      ASSERT_TRUE(U16Success);'), (380, 1, u'+      ASSERT_FALSE(U32Success);'), (383, 1, u'+      ASSERT_TRUE(U32Success);'), (387, 1, u'+      ASSERT_FALSE(U64Success);'), (390, 1, u'+      ASSERT_TRUE(U64Success);'), (402, 1, u'+      ASSERT_FALSE(S8Success);'), (405, 1, u'+      ASSERT_TRUE(S8Success);'), (409, 1, u'+      ASSERT_FALSE(S16Success);'), (412, 1, u'+      ASSERT_TRUE(S16Success);'), (416, 1, u'+      ASSERT_FALSE(S32Success);'), (419, 1, u'+      ASSERT_TRUE(S32Success);'), (423, 1, u'+      ASSERT_FALSE(S64Success);'), (426, 1, u'+      ASSERT_TRUE(S64Success);')]
===========================================
Class:class ScalarEvolutionsTest : public testing::Test { class ScalarEvolutionsTest : public testing::Test 
Class:class ExecutionEngineTest : public testing::Test { class ExecutionEngineTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(30, 1, u'+    ASSERT_TRUE(Engine.get() != NULL) << "EngineBuilder returned error: \'"')]
===========================================
Class: class IntelJITEventListenerTest   : public JITEventListenerTestBase<IntelJITEventsWrapper> {   : public JITEventListenerTestBase<IntelJITEventsWrapper> 
Class:class JITEventListenerTest : public testing::Test { class JITEventListenerTest : public testing::Test 
Class: class JITEnvironment : public testing::Environment { class JITEnvironment : public testing::Environment 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 1, u'+  ASSERT_EQ(2U, Listener.EmittedEvents.size());'), (102, 1, u'+  ASSERT_EQ(2U, Listener.FreedEvents.size());'), (154, 1, u'+  ASSERT_EQ(1U, Listener1.EmittedEvents.size());'), (155, 1, u'+  ASSERT_EQ(1U, Listener1.FreedEvents.size());'), (168, 1, u'+  ASSERT_EQ(2U, Listener2.EmittedEvents.size());'), (169, 1, u'+  ASSERT_EQ(1U, Listener2.FreedEvents.size());'), (189, 1, u'+  ASSERT_EQ(1U, Listener3.EmittedEvents.size());'), (190, 1, u'+  ASSERT_EQ(1U, Listener3.FreedEvents.size());'), (216, 1, u'+  ASSERT_EQ(1U, Listener.EmittedEvents.size());'), (217, 1, u'+  ASSERT_EQ(1U, Listener.FreedEvents.size());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(87, 1, u'+  ASSERT_LE(bigFuncSize, size);'), (95, 1, u'+  ASSERT_LE(bigFuncSize, size);'), (103, 1, u'+  ASSERT_LE(bigFuncSize, size);'), (115, 1, u'+  ASSERT_LE(smallFuncSize, size);'), (124, 1, u'+  ASSERT_LE(smallFuncSize, size);'), (133, 1, u'+  ASSERT_LE(smallFuncSize, size);')]
===========================================
Class:class RecordingJITMemoryManager : public JITMemoryManager { class RecordingJITMemoryManager : public JITMemoryManager 
Class: class JITTest : public testing::Test { class JITTest : public testing::Test 
Class:class JITEnvironment : public testing::Environment { class JITEnvironment : public testing::Environment 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(214, 1, u'+    ASSERT_TRUE(TheJIT.get() != NULL) << Error;'), (248, 1, u'+  ASSERT_EQ(Error, "");'), (270, 1, u'+  ASSERT_NE((int32_t*)NULL, GPtr);'), (519, 1, u'+  ASSERT_EQ(stubsBefore, RJMM->stubsAllocated);'), (729, 1, u'+  ASSERT_FALSE(Bitcode.empty()) << "Assembling failed";'), (732, 1, u'+  ASSERT_TRUE(TheJIT.get()) << "Failed to create JIT.";'), (768, 1, u'+  ASSERT_FALSE(Bitcode.empty()) << "Assembling failed";'), (771, 1, u'+  ASSERT_TRUE(TheJIT.get()) << "Failed to create JIT.";')]
===========================================
Class: class OProfileJITEventListenerTest : public JITEventListenerTestBase<OProfileWrapper> { 
Class:class MockSlabAllocator : public SlabAllocator { class MockSlabAllocator : public SlabAllocator 
Class:class TempEnvVar { class TempEnvVar 
Class:class ConstantRangeTest : public ::testing::Test { class ConstantRangeTest : public ::testing::Test 
Class:class IRBuilderTest : public testing::Test { class IRBuilderTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(68, 1, u'+  ASSERT_TRUE(II_Start1 != NULL);'), (70, 1, u'+  ASSERT_TRUE(II_End1 != NULL);')]
===========================================
Class:class MDBuilderTest : public testing::Test { class MDBuilderTest : public testing::Test 
Class:class FileSystemTest : public testing::Test { class FileSystemTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(20, 1, u'+#define ASSERT_NO_ERROR(x) \\'), (21, 1, u'+  if (error_code ASSERT_NO_ERROR_ec = x) { \\'), (96, 1, u'+      ASSERT_FALSE(ci->empty());'), (129, 1, u'+    ASSERT_NO_ERROR(fs::make_absolute(temp_store));'), (152, 1, u'+    ASSERT_NO_ERROR('), (164, 1, u'+    ASSERT_NO_ERROR(fs::remove_all(TestDirectory.str(), removed));'), (172, 1, u'+  ASSERT_NO_ERROR('), (177, 1, u'+  ASSERT_NO_ERROR(sys::fs::exists(Twine(TempPath), TempFileExists));'), (183, 1, u'+  ASSERT_NO_ERROR(fs::unique_file("%%-%%-%%-%%.temp", FD2, TempPath2));'), (184, 1, u'+  ASSERT_NE(TempPath.str(), TempPath2.str());'), (187, 1, u'+  ASSERT_NO_ERROR(fs::status(Twine(TempPath), A));'), (188, 1, u'+  ASSERT_NO_ERROR(fs::status(Twine(TempPath2), B));'), (197, 1, u'+  ASSERT_NO_ERROR(fs::copy_file(Twine(TempPath), Twine(TempPath2),'), (200, 1, u'+  ASSERT_NO_ERROR(fs::remove(Twine(TempPath2), TempFileExists));'), (204, 1, u'+  ASSERT_NO_ERROR(fs::exists(Twine(TempPath2), TempFileExists));'), (208, 1, u'+  ASSERT_NO_ERROR(fs::create_hard_link(Twine(TempPath), Twine(TempPath2)));'), (210, 1, u'+  ASSERT_NO_ERROR(fs::equivalent(Twine(TempPath), Twine(TempPath2), equal));'), (212, 1, u'+  ASSERT_NO_ERROR(fs::status(Twine(TempPath), A));'), (213, 1, u'+  ASSERT_NO_ERROR(fs::status(Twine(TempPath2), B));'), (218, 1, u'+  ASSERT_NO_ERROR(fs::remove(Twine(TempPath), TempFileExists));'), (222, 1, u'+  ASSERT_NO_ERROR(fs::remove(Twine(TempPath2), TempFileExists));'), (226, 1, u'+  ASSERT_NO_ERROR(fs::exists(Twine(TempPath), TempFileExists));'), (233, 1, u'+    ASSERT_NO_ERROR(ec);'), (237, 1, u'+  ASSERT_NO_ERROR(fs::create_directories(Twine(TestDirectory)'), (239, 1, u'+  ASSERT_NO_ERROR(fs::create_directories(Twine(TestDirectory)'), (241, 1, u'+  ASSERT_NO_ERROR(fs::create_directories(Twine(TestDirectory)'), (243, 1, u'+  ASSERT_NO_ERROR(fs::create_directories(Twine(TestDirectory)'), (245, 1, u'+  ASSERT_NO_ERROR(fs::create_directories(Twine(TestDirectory)'), (251, 1, u'+    ASSERT_NO_ERROR(ec);'), (273, 1, u'+  ASSERT_NE(a0, visited.end());'), (274, 1, u'+  ASSERT_NE(aa1, visited.end());'), (275, 1, u'+  ASSERT_NE(ab1, visited.end());'), (276, 1, u'+  ASSERT_NE(dontlookhere, visited.end());'), (277, 1, u'+  ASSERT_EQ(da1, visited.end()); // Not visited.'), (278, 1, u'+  ASSERT_NE(z0, visited.end());'), (279, 1, u'+  ASSERT_NE(za1, visited.end());'), (280, 1, u'+  ASSERT_NE(pop, visited.end());'), (281, 1, u'+  ASSERT_EQ(p1, visited.end()); // Not visited.'), (285, 1, u'+  ASSERT_LT(a0, aa1);'), (286, 1, u'+  ASSERT_LT(a0, ab1);'), (287, 1, u'+  ASSERT_LT(z0, za1);'), (305, 1, u'+    ASSERT_FALSE(file.has_error());'), (310, 1, u'+    ASSERT_NO_ERROR(fs::has_magic(file_pathname.c_str(), magic, res));')]
===========================================
Class:class RegexTest : public ::testing::Test { class RegexTest : public ::testing::Test 
Class:class MyType { class MyType 
Class: class MyPortableType { class MyPortableType 
Class:class ValueHandle : public testing::Test { class ValueHandle : public testing::Test 
Class: class ConcreteCallbackVH : public CallbackVH { class ConcreteCallbackVH : public CallbackVH 
Class:  class RecordingVH : public CallbackVH {   class RecordingVH : public CallbackVH 
Class:  class RecordingVH : public CallbackVH {   class RecordingVH : public CallbackVH 
Class:  class RecoveringVH : public CallbackVH {   class RecoveringVH : public CallbackVH 
Class:  class DestroyingVH : public CallbackVH {   class DestroyingVH : public CallbackVH 
Class:  class ClearingVH : public CallbackVH {   class ClearingVH : public CallbackVH 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(33, 1, u'+  assert(BytesLeftInBuffer < 256 && "Invalid buffer count!");')]
===========================================
Class:class CloneInstruction : public ::testing::Test { class CloneInstruction : public ::testing::Test 
Class:class MetadataTest : public testing::Test { class MetadataTest : public testing::Test 
Class:class ValueMapTest : public testing::Test { class ValueMapTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(75, 1, u'+  ASSERT_TRUE(I != VM.end());'), (84, 1, u'+  ASSERT_TRUE(CI != CVM.end());'), (120, 1, u'+void CompileAssertHasType(VarType) {'), (121, 1, u'+  typedef char assert[is_same<ExpectedType, VarType>::value ? 1 : -1];'), (133, 1, u'+    CompileAssertHasType<TypeParam*>(I->first);'), (155, 1, u'+    CompileAssertHasType<TypeParam*>(I->first);')]
===========================================
Class:     class Pattern { class Pattern 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(336, 1, u'+  assert(!MatchInfo.empty() && "Didn\'t get any match");'), (341, 1, u'+    assert(VariableDefs[i].second < MatchInfo.size() &&'), (712, 1, u'+      assert(LastMatch != F->getBufferStart() &&')]
===========================================
Class:  class ScopedHandle {   class ScopedHandle 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(116, 1, u'+    assert(TheOperators.back() == this);'), (138, 1, u'+        assert(SrcElt == 8 && "Bad src elt!");'), (153, 1, u'+    assert(0 && "bad zero cost operation");'), (395, 1, u'+    assert(OpNum < 16 && "Too few bits to encode operation!");')]
===========================================
Class:class AsmMatcherInfo;
Class:  class AsmMatcherInfo { class AsmMatcherInfo 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(218, 1, u'+    assert(isUserClass() && RHS.isUserClass() && "Unexpected class!");'), (630, 1, u'+    assert(Def->isSubClassOf("Predicate") && "Invalid predicate type!");'), (706, 1, u'+      assert(i != String.size() && "Invalid quoted character");'), (724, 1, u'+      assert(End != String.end() && "Missing brace in operand reference!");'), (923, 1, u'+  assert(Rec->isSubClassOf("Operand") && "Unexpected operand!");'), (1046, 1, u'+    assert(CI && "Missing singleton register class info!");'), (1095, 1, u'+      assert(dynamic_cast<UnsetInit*>(PMName) &&'), (1105, 1, u'+      assert(dynamic_cast<UnsetInit*>(RMName) &&'), (1175, 1, u'+    assert(FeatureNo < 32 && "Too many subtarget features!");'), (1289, 1, u'+        assert(Op.Class && Op.Class->Registers.size() == 1 &&'), (1363, 1, u'+    assert(Rec->isSubClassOf("Operand") && "Unexpected operand!");'), (1461, 1, u'+      assert(AsmOperands[SrcOperand+AI].SubOpIdx == (int)AI &&'), (1612, 1, u'+        assert(i > TiedOp && "Tied operand precedes its target!");'), (2018, 1, u'+  assert(Range < 0xFFFFFFFFULL && "Enum too large");')]
===========================================
Class:class IAPrinter { class IAPrinter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(370, 1, u'+          assert(NumOps <= Inst->Operands.size() &&'), (412, 1, u'+    assert(NumBits <= BitsLeft && "consistency error");'), (796, 1, u'+            assert(Rec->isSubClassOf("Operand") && "Unexpected operand!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(111, 1, u'+    assert(!CGI.Operands.isFlatOperandNotEmitted(OpIdx) &&')]
===========================================
Class:     class InstAnalyzer { class InstAnalyzer 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(145, 1, u'+  assert(!Name.empty() && "Cannot search for operand with no name!");'), (221, 1, u'+  assert(pos != std::string::npos && "Unrecognized constraint");'), (344, 1, u'+  assert(FirstImplicitDef->isSubClassOf("Register"));'), (392, 1, u'+    assert(VariantsEnd != Cur.size() &&')]
===========================================
Class:class RegUnitIterator { class RegUnitIterator 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(112, 1, u'+  unsigned operator* () const { assert(isValid()); return *UnitI; };'), (114, 1, u'+  const CodeGenRegister *getReg() const { assert(isValid()); return *RegI; }'), (118, 1, u'+    assert(isValid() && "Cannot advance beyond the last operand");'), (320, 1, u'+  assert(RegUnits.empty() && "Should only initialize RegUnits once");'), (331, 1, u'+  assert(SubRegsComplete && "Must precompute sub-registers");'), (480, 1, u'+  assert(!VTs.empty() && "RegisterClass must contain at least one ValueType!");'), (558, 1, u'+  assert(!getDef() && "Only synthesized classes can inherit properties");'), (559, 1, u'+  assert(!SuperClasses.empty() && "Synthesized class without super class");'), (599, 1, u'+  assert(Members && B.Members);'), (953, 1, u'+  assert(Registers.size() == Registers[Registers.size()-1]->EnumValue &&'), (970, 1, u'+    assert(USetID && "register number 0 is invalid");'), (1117, 1, u'+  assert(RegUnitWeights.empty() && "Only initialize RegUnitWeights once");'), (1133, 1, u'+    assert(NumIters <= NumNativeRegUnits && "Runaway register unit weights");'), (1166, 1, u'+  assert(RegClassUnitSets.empty() && "this invalidates RegClassUnitSets");'), (1236, 1, u'+    assert(Idx < (2*NumRegUnitSubSets) && "runaway unit set inference");'), (1293, 1, u'+    assert(!RegClassUnitSets[RCIdx].empty() && "missing unit set for regclass");'), (1330, 1, u'+  assert(Map.empty());'), (1490, 1, u'+      assert(Sub && "Missing sub-register");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(298, 1, u'+    assert(Instr && "Missing target independent instruction");'), (299, 1, u'+    assert(Instr->Namespace == "TargetOpcode" && "Bad namespace");'), (311, 1, u'+  assert(InstrsByEnum.size() == Insts.size() && "Missing predefined instr");'), (431, 1, u'+    assert(TyEl->isSubClassOf("LLVMType") && "Expected a type!");'), (435, 1, u'+      assert(MatchTy < OverloadedVTs.size() &&'), (441, 1, u'+      assert(((!TyEl->isSubClassOf("LLVMExtendedElementVectorType") &&'), (465, 1, u'+    assert(TyEl->isSubClassOf("LLVMType") && "Expected a type!");'), (469, 1, u'+      assert(MatchTy < OverloadedVTs.size() &&'), (475, 1, u'+      assert(((!TyEl->isSubClassOf("LLVMExtendedElementVectorType") &&'), (499, 1, u'+    assert(Property->isSubClassOf("IntrinsicProperty") &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(103, 1, u'+    assert(LHS == RHS || LHS->ID != RHS->ID);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(57, 1, u'+    assert(Other && "Other didn\'t come before \'this\'?");')]
===========================================
Class:class MatcherTableEmitter { class MatcherTableEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(145, 1, u'+    assert(SM->getNext() == 0 && "Shouldn\'t have next after scope");'), (180, 1, u'+      assert(ChildSize != 0 && "Should not have a zero-sized child!");'), (315, 1, u'+      assert(ChildSize != 0 && "Should not have a zero-sized child!");'), (354, 1, u'+    assert(cast<CheckTypeMatcher>(N)->getResNo() == 0 &&'), (626, 1, u'+      assert(!PredFn.isAlwaysTrue() && "No code in this predicate");')]
===========================================
Class:  class MatcherGen {   class MatcherGen 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(449, 1, u'+      assert(Opcodes.insert(COM->getOpcode().getEnumName()) &&')]
===========================================
Class:class State { class State 
Class:class DFA { class DFA 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(226, 1, u'+  assert(!states.count(S) && "State already exists");'), (300, 1, u'+      assert (((*SI)->stateNum == (int) i) && "Mismatch in state numbers");'), (392, 1, u'+      assert(NameToBitsMap.count(UnitName));')]
===========================================
Class:  class EnumEmitter {   class EnumEmitter 
Class:   class ConstantEmitter {   class ConstantEmitter 
Class:   class LiteralConstantEmitter : public ConstantEmitter {   class LiteralConstantEmitter : public ConstantEmitter 
Class:   class CompoundConstantEmitter : public ConstantEmitter {   class CompoundConstantEmitter : public ConstantEmitter 
Class:   class FlagsConstantEmitter : public ConstantEmitter {   class FlagsConstantEmitter : public ConstantEmitter 
Class:class ImmPredicateSet { class ImmPredicateSet 
Class:  class OpKind {   class OpKind 
Class: class FastISelMap { class FastISelMap 
Class:                                     class Filter { class Filter 
Class:                class FilterChooser { class FilterChooser 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(113, 1, u'+      assert(!Inst.Operands[i].OperandType.empty() && "Invalid operand type.");'), (126, 1, u'+        assert(Constraint.isTied());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(203, 1, u'+    assert(false && "Unsupported ValueType!");'), (236, 1, u'+    assert(Number < ArgNo && "Invalid matching number!");'), (358, 1, u'+        assert(Number < OverloadedTypeIndices.size() &&'), (386, 1, u'+        assert(Number < OverloadedTypeIndices.size() &&'), (532, 1, u'+    assert(AttrNum < 256 && "Too many unique attributes for table!");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(45, 1, u'+      assert(BaseIdx == 0 && "Named subargument in pseudo expansion?!");'), (81, 1, u'+  assert(Dag && "Missing result instruction in pseudo expansion!");'), (225, 1, u'+  assert(ExpansionClass && "PseudoInstExpansion class definition missing!");'), (226, 1, u'+  assert(InstructionClass && "Instruction class definition missing!");')]
===========================================
Class:  class BitVectorEmitter { class BitVectorEmitter 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(37, 1, u'+  assert(Registers.size() <= 0xffff && "Too many regs to fit in tables");'), (59, 1, u'+  assert(Registers.size() == Registers[Registers.size()-1]->EnumValue &&'), (70, 1, u'+    assert(RegisterClasses.size() <= 0xffff &&'), (409, 1, u'+  assert(Width <= 32 && "Width too large");'), (574, 1, u'+    assert((RC.SpillSize/8) <= 0xffff && "SpillSize too large.");'), (575, 1, u'+    assert((RC.SpillAlignment/8) <= 0xffff && "SpillAlignment too large.");'), (576, 1, u'+    assert(RC.CopyCost >= -128 && RC.CopyCost <= 127 && "Copy cost too large.");'), (760, 1, u'+          assert(RC2 && "Invalid register class in SubRegClasses");'), (1083, 1, u'+    assert(Regs && "Cannot expand CalleeSavedRegs instance");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(25, 1, u'+  assert(!Matches.empty());'), (46, 1, u'+  assert(!Matches.empty() && "Must have at least one string to match!");'), (52, 1, u'+    assert(Matches.size() == 1 && "Had duplicate keys to match on");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(511, 1, u'+    assert(ItinList.size() == ItinClassList.size() && "bad itinerary");')]
===========================================
Class:class Type { class Type 
Class: class ExtendedVectorType : public Type { class ExtendedVectorType : public Type 
Class:  class LLVMTableGenAction : public TableGenAction {   class LLVMTableGenAction : public TableGenAction 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(174, 1, u'+          assert(Elts && "Couldn\'t expand Set instance");')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(180, 1, u'+  assert(width <= 8 && "Field is too large for uint8_t!");'), (522, 1, u'+    assert(physicalOperandIndex < numPhysicalOperands);'), (576, 1, u'+  assert(numOperands <= X86_MAX_OPERANDS && "X86_MAX_OPERANDS is not large enough");'), (632, 1, u'+    assert(numPhysicalOperands <= 2 &&'), (640, 1, u'+    assert(numPhysicalOperands >= 1 && numPhysicalOperands <= 2 &&'), (651, 1, u'+      assert(numPhysicalOperands >= 3 && numPhysicalOperands <= 4 &&'), (654, 1, u'+      assert(numPhysicalOperands >= 2 && numPhysicalOperands <= 3 &&'), (673, 1, u'+      assert(numPhysicalOperands >= 3 && numPhysicalOperands <= 4 &&'), (676, 1, u'+      assert(numPhysicalOperands >= 2 && numPhysicalOperands <= 3 &&'), (695, 1, u'+      assert(numPhysicalOperands >= 3 && numPhysicalOperands <= 5 &&'), (698, 1, u'+      assert(numPhysicalOperands >= 2 && numPhysicalOperands <= 3 &&'), (727, 1, u'+      assert(numPhysicalOperands >= 3 && numPhysicalOperands <= 5 &&'), (730, 1, u'+      assert(numPhysicalOperands >= 2 && numPhysicalOperands <= 3 &&'), (763, 1, u'+      assert(numPhysicalOperands <= 3 &&'), (766, 1, u'+      assert(numPhysicalOperands <= 2 &&'), (784, 1, u'+      assert(numPhysicalOperands >= 2 && numPhysicalOperands <= 3 &&'), (787, 1, u'+      assert(numPhysicalOperands >= 1 && numPhysicalOperands <= 2 &&'), (797, 1, u'+    assert(numPhysicalOperands == 2 &&'), (952, 1, u'+    assert(Opcode >= 0xc0 && "Unexpected opcode for an escape opcode");'), (1017, 1, u'+  assert(opcodeType != (OpcodeType)-1 &&'), (1019, 1, u'+  assert(filter && "Filter not set");'), (1023, 1, u'+      assert(opcodeToSet < 0xf9 &&')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(36, 1, u'+    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);'), (37, 1, u'+    _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);')]
===========================================
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class:    class     class
Class:  template <class T, class SlotPolicy>   template <class T, class SlotPolicy>
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(164, 1, u'+          assert(p != visited.end());')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(197, 1, u'+          assert(entries().invariants());'), (212, 1, u'+      assert(slot->m_to_python == 0); // we have a problem otherwise')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(130, 1, u'+          assert(status != -3); // invalid argument error')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(306, 1, u'+    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self)), &class_metatype_object));'), (551, 1, u'+      assert(num_types >= 1);'), (576, 1, u'+      assert(PyType_IsSubtype(Py_TYPE(result.ptr()), &PyType_Type));'), (731, 1, u'+    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self_)), &class_metatype_object));'), (739, 1, u'+        assert(holder_offset >= offsetof(objects::instance<>,storage));'), (756, 1, u'+    assert(PyType_IsSubtype(Py_TYPE(Py_TYPE(self_)), &class_metatype_object));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(169, 1, u'+                        assert(max_arity <= static_cast<std::size_t>(ssize_t_max));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(217, 1, u'+      assert(v == v2);'), (482, 1, u'+        assert(added);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(147, 1, u'+   BOOST_ASSERT(std::size_t(idx+1) < sizeof(masks) / sizeof(masks[0]));')]
===========================================
Class:class RegExData class RegExData
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(131, 1, u'+      BOOST_REGEX_NOEH_ASSERT(hfile != INVALID_HANDLE_VALUE);'), (242, 1, u'+   BOOST_ASSERT(node >= _first);'), (243, 1, u'+   BOOST_ASSERT(node <= _last);'), (275, 1, u'+        BOOST_REGEX_NOEH_ASSERT((0 == std::ferror(hfile)) && (read_size != 0));'), (293, 1, u'+   BOOST_ASSERT(node >= _first);'), (294, 1, u'+   BOOST_ASSERT(node <= _last);'), (422, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (424, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)'), (429, 1, u'+   BOOST_REGEX_NOEH_ASSERT(ref)'), (452, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (454, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)'), (475, 1, u'+   BOOST_REGEX_NOEH_ASSERT(ref)'), (510, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (512, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)'), (600, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (602, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)'), (607, 1, u'+   BOOST_REGEX_NOEH_ASSERT(ref)'), (630, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (632, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)'), (654, 1, u'+   BOOST_REGEX_NOEH_ASSERT(ref)'), (700, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_root)'), (702, 1, u'+   BOOST_REGEX_NOEH_ASSERT(_path)')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(426, 1, u'+   BOOST_ASSERT(std::size_t(idx+1) < sizeof(masks) / sizeof(masks[0]));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(47, 1, u'+   BOOST_REGEX_NOEH_ASSERT(ptr)'), (61, 1, u'+   BOOST_ASSERT(pos <= size_type(end - start));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(373, 1, u'+      regex_constants::escape_type_not_word_assert,  /*B*/'), (405, 1, u'+      regex_constants::escape_type_word_assert,        /*b*/')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(73, 1, u'+BOOST_STATIC_ASSERT(sizeof(LONG) == sizeof(boost::int32_t));'), (137, 1, u'+   BOOST_ASSERT(0 == r);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(123, 1, u'+   BOOST_ASSERT(r != 0);'), (126, 1, u'+   BOOST_ASSERT(code_page != 0);'), (130, 1, u'+   BOOST_ASSERT(conv_r != 0);'), (134, 1, u'+   BOOST_ASSERT(r != 0);'), (137, 1, u'+   BOOST_ASSERT(conv_r != 0);'), (152, 1, u'+   BOOST_ASSERT(0 != r);')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(187, 1, u'+   BOOST_ASSERT(idx+1 < static_cast<int>(sizeof(masks) / sizeof(masks[0])));')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(96, 1, u'+        BOOST_ASSERT(false);')]
===========================================
Class:class basic_iarchive_impl { class basic_iarchive_impl 
Class:    class cobject_id     class cobject_id
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(303, 1, u'+        BOOST_ASSERT(cobject_info_set.size() == cobject_id_vector.size());'), (436, 1, u'+        BOOST_ASSERT(NULL != bpis_ptr);'), (440, 1, u'+        BOOST_ASSERT(new_cid == cid);'), (487, 1, u'+        BOOST_ASSERT(NULL != t);')]
===========================================
Class:class basic_oarchive_impl { class basic_oarchive_impl 
Class:    class bosarg :     class bosarg :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(62, 1, u'+            BOOST_ASSERT(NULL != address);'), (63, 1, u'+            BOOST_ASSERT(NULL != rhs.address);'), (181, 1, u'+            BOOST_ASSERT(false);'), (186, 1, u'+            BOOST_ASSERT(false);'), (191, 1, u'+            BOOST_ASSERT(false);'), (196, 1, u'+            BOOST_ASSERT(false);'), (202, 1, u'+            BOOST_ASSERT(false);')]
===========================================
Class:        class extended_type_info;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 1, u'+        BOOST_ASSERT(false);')]
===========================================
Class:template class basic_binary_iprimitive< template class basic_binary_iprimitive<
Class:template class binary_iarchive_impl< template class binary_iarchive_impl<
Class:template class basic_binary_oprimitive< template class basic_binary_oprimitive<
Class:template class binary_oarchive_impl< template class binary_oarchive_impl<
Class:template class basic_binary_iprimitive< template class basic_binary_iprimitive<
Class:template class binary_iarchive_impl< template class binary_iarchive_impl<
Class:template class basic_binary_oprimitive< template class basic_binary_oprimitive<
Class:template class binary_oarchive_impl< template class binary_oarchive_impl<
Class:class extended_type_info_arg : public extended_type_info class extended_type_info_arg : public extended_type_info
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 1, u'+    BOOST_ASSERT(NULL != l);'), (56, 1, u'+    BOOST_ASSERT(NULL != r);'), (69, 1, u'+    BOOST_ASSERT(NULL != l);'), (73, 1, u'+    BOOST_ASSERT(NULL != r);')]
===========================================
Class:class extended_type_info_typeid_arg : class extended_type_info_typeid_arg :
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(106, 1, u'+        BOOST_ASSERT(result.second);')]
===========================================
Class:class void_caster_shortcut : public void_caster class void_caster_shortcut : public void_caster
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+            BOOST_ASSERT(false);')]
===========================================
Class:    class X;
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(38, 1, u'+\t\t\t\tBOOST_ASSERT(current_thread_tls_key!=0xFFFFFFFF);'), (40, 1, u'+\t\t\t\tBOOST_ASSERT(current_thread_tls_key!=TLS_OUT_OF_INDEXES);')]
===========================================
Class:class Water { class Water 
Class:     class LeakChecker : public EmptyTestEventListener { class LeakChecker : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 2, u'-    ASSERT_EQ(q->Size(), new_q->Size());'), (134, 2, u'-  ASSERT_TRUE(n != NULL);'), (140, 2, u'-  ASSERT_TRUE(n != NULL);')]
===========================================
Class:     class IntegerFunctionTest : public QuickTest { class IntegerFunctionTest : public QuickTest 
Class:        class QueueTest : public QuickTest { class QueueTest : public QuickTest 
Class:  template <class T> class PrimeTableTest : public testing::Test { class PrimeTableTest : public testing::Test 
Class:                 template <class T> class PrimeTableTest2 : public PrimeTableTest<T> { class PrimeTableTest2 : public PrimeTableTest<T> 
Class:     class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> { class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> 
Class:      class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > { class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > 
Class:class TersePrinter : public EmptyTestEventListener { class TersePrinter : public EmptyTestEventListener 
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class TestNameIs { class TestNameIs 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class: class TestException : public std::exception { class TestException : public std::exception 
Class:class ReplaceDeathTestFactory { class ReplaceDeathTestFactory 
Class:   class TestForDeathTest : public testing::Test { class TestForDeathTest : public testing::Test 
Class:  class MayDie { class MayDie 
Class:  class MockDeathTestFactory : public DeathTestFactory { class MockDeathTestFactory : public DeathTestFactory 
Class:      class MockDeathTest : public DeathTest { class MockDeathTest : public DeathTest 
Class:    class MacroLogicDeathTest : public testing::Test { class MacroLogicDeathTest : public testing::Test 
Class:class DirectoryCreationTest : public Test { class DirectoryCreationTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(98, 2, u'-  ASSERT_TRUE(cwd_without_drive != NULL);')]
===========================================
Class:class A { class A 
Class:  class B : public A { class B : public A 
Class: class LinkedPtrTest : public testing::Test { class LinkedPtrTest : public testing::Test 
Class:class EventRecordingListener : public TestEventListener { class EventRecordingListener : public TestEventListener 
Class:class XmlOutputChangeDirTest : public Test { class XmlOutputChangeDirTest : public Test 
Class:   class DogAdder { class DogAdder 
Class: class IntWrapper { class IntWrapper 
Class:          template <int kExpectedCalls> class TestGenerationEnvironment : public ::testing::Environment { class TestGenerationEnvironment : public ::testing::Environment 
Class: class TestGenerationTest : public TestWithParam<int> { class TestGenerationTest : public TestWithParam<int> 
Class:           class GeneratorEvaluationTest : public TestWithParam<int> { class GeneratorEvaluationTest : public TestWithParam<int> 
Class:class ExternalGeneratorTest : public TestWithParam<int> 
Class:class MultipleInstantiationTest : public TestWithParam<int> 
Class:   class SeparateInstanceTest : public TestWithParam<int> { class SeparateInstanceTest : public TestWithParam<int> 
Class:class NamingTest : public TestWithParam<int> 
Class:     class Unstreamable { class Unstreamable 
Class:class CommentTest : public TestWithParam<Unstreamable> 
Class:     class NonParameterizedBaseTest : public ::testing::Test { class NonParameterizedBaseTest : public ::testing::Test 
Class: class ParameterizedDerivedTest : public NonParameterizedBaseTest,                                  public ::testing::WithParamInterface<int> {                                  public ::testing::WithParamInterface<int> 
Class:class Base { class Base 
Class:  class BiggestIntConvertible { class BiggestIntConvertible 
Class:  template <typename T> class UnprintableTemplateInGlobal { class UnprintableTemplateInGlobal 
Class:  class StreamableInGlobal { class StreamableInGlobal 
Class:class UnprintableInFoo { class UnprintableInFoo 
Class:  template <typename T> class PrintableViaPrintToTemplate { class PrintableViaPrintToTemplate 
Class:  template <typename T> class StreamableTemplateInFoo { class StreamableTemplateInFoo 
Class:class AllowsGenericStreaming 
Class:class AllowsGenericStreamingTemplate 
Class:    template <typename T> class AllowsGenericStreamingAndImplicitConversionTemplate { class AllowsGenericStreamingAndImplicitConversionTemplate 
Class:class TestPartResultTest : public Test { class TestPartResultTest : public Test 
Class:   class TestPartResultArrayTest : public Test { class TestPartResultArrayTest : public Test 
Class:class BigTupleTest : public testing::Test { class BigTupleTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 2, u'-using ::testing::StaticAssertTypeEq;'), (47, 2, u'-  StaticAssertTypeEq<int, tuple_element<0, tuple<int, char> >::type>();'), (48, 2, u'-  StaticAssertTypeEq<int&, tuple_element<1, tuple<double, int&> >::type>();'), (49, 2, u'-  StaticAssertTypeEq<bool, tuple_element<2, tuple<double, int, bool> >::type>();')]
===========================================
Class:    template <typename T> class CommonTest : public Test { class CommonTest : public Test 
Class:    template <typename T> class TypedTest1 : public Test { class TypedTest1 : public Test 
Class: template <typename T> class TypedTest2 : public Test { class TypedTest2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
Class:   class TypedTestCasePStateTest : public Test { class TypedTestCasePStateTest : public Test 
Class:    template <typename T> class DerivedTest : public CommonTest<T> { class DerivedTest : public CommonTest<T> 
Class:    template <typename T> class TypedTestP1 : public Test { class TypedTestP1 : public Test 
Class: template <typename T> class TypedTestP2 : public Test { class TypedTestP2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(120, 2, u'-  ASSERT_TRUE(this->shared_ != NULL);'), (257, 2, u'-  ASSERT_TRUE(this->shared_ != NULL);')]
===========================================
Class:class UnitTestHelper { class UnitTestHelper 
Class:class FinalSuccessChecker : public Environment { class FinalSuccessChecker : public Environment 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 2, u'-  ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (140, 2, u'-AssertionResult IsNull(const char* str) {'), (142, 2, u'-    return testing::AssertionFailure() << "argument is " << str;'), (144, 2, u'-  return AssertionSuccess();'), (149, 2, u'-  ASSERT_TRUE(test_case != NULL);'), (156, 2, u'-  ASSERT_EQ(4, test_case->total_test_count());'), (189, 2, u'-  ASSERT_TRUE(test_case != NULL);'), (196, 2, u'-  ASSERT_EQ(1, test_case->total_test_count());'), (212, 2, u'-  ASSERT_TRUE(test_case != NULL);'), (219, 2, u'-  ASSERT_EQ(1, test_case->total_test_count());'), (245, 2, u'-    ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (253, 2, u'-    ASSERT_EQ(4, test_cases[0]->total_test_count());'), (263, 2, u'-    ASSERT_EQ(1, test_cases[1]->total_test_count());'), (272, 2, u'-    ASSERT_EQ(1, test_cases[2]->total_test_count());')]
===========================================
Class: class SehExceptionInDestructorTest : public Test { class SehExceptionInDestructorTest : public Test 
Class: class SehExceptionInSetUpTestCaseTest : public Test { class SehExceptionInSetUpTestCaseTest : public Test 
Class: class SehExceptionInTearDownTestCaseTest : public Test { class SehExceptionInTearDownTestCaseTest : public Test 
Class: class SehExceptionInSetUpTest : public Test { class SehExceptionInSetUpTest : public Test 
Class: class SehExceptionInTearDownTest : public Test { class SehExceptionInTearDownTest : public Test 
Class: class CxxExceptionInDestructorTest : public Test { class CxxExceptionInDestructorTest : public Test 
Class: class CxxExceptionInSetUpTestCaseTest : public Test { class CxxExceptionInSetUpTestCaseTest : public Test 
Class: class CxxExceptionInTearDownTestCaseTest : public Test { class CxxExceptionInTearDownTestCaseTest : public Test 
Class: class CxxExceptionInSetUpTest : public Test { class CxxExceptionInSetUpTest : public Test 
Class: class CxxExceptionInTearDownTest : public Test { class CxxExceptionInTearDownTest : public Test 
Class: class CxxExceptionInTestBodyTest : public Test { class CxxExceptionInTestBodyTest : public Test 
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 2, u'-  ASSERT_TRUE(false) << "Tests shouldn\'t be run when --help is specified.";')]
===========================================
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
Class:class FailingParamTest : public testing::TestWithParam<int> 
Class:  class NonFatalFailureInFixtureConstructorTest : public testing::Test { class NonFatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class FatalFailureInFixtureConstructorTest : public testing::Test { class FatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class NonFatalFailureInSetUpTest : public testing::Test { class NonFatalFailureInSetUpTest : public testing::Test 
Class:  class FatalFailureInSetUpTest : public testing::Test { class FatalFailureInSetUpTest : public testing::Test 
Class:    class DeathTestAndMultiThreadsTest : public testing::Test { class DeathTestAndMultiThreadsTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class: class TEST_before_TEST_F_in_same_test_case : public testing::Test { class TEST_before_TEST_F_in_same_test_case : public testing::Test 
Class:    class FooEnvironment : public testing::Environment { class FooEnvironment : public testing::Environment 
Class: class BarEnvironment : public testing::Environment { class BarEnvironment : public testing::Environment 
Class:   class Predicate1Test : public testing::Test { class Predicate1Test : public testing::Test 
Class:   class Predicate2Test : public testing::Test { class Predicate2Test : public testing::Test 
Class:   class Predicate3Test : public testing::Test { class Predicate3Test : public testing::Test 
Class:   class Predicate4Test : public testing::Test { class Predicate4Test : public testing::Test 
Class:   class Predicate5Test : public testing::Test { class Predicate5Test : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 2, u'-testing::AssertionResult PredFormatFunction1(const char* e1,'), (104, 2, u'-    return testing::AssertionSuccess();'), (106, 2, u'-  return testing::AssertionFailure()'), (115, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (161, 2, u'-typedef Predicate1Test ASSERT_PRED_FORMAT1Test;'), (163, 2, u'-typedef Predicate1Test ASSERT_PRED1Test;'), (239, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeSuccess) {'), (240, 2, u'-  ASSERT_PRED1(PredFunction1Int,'), (247, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeSuccess) {'), (248, 2, u'-  ASSERT_PRED1(PredFunction1Bool,'), (255, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeSuccess) {'), (256, 2, u'-  ASSERT_PRED1(PredFunctor1(),'), (263, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeSuccess) {'), (264, 2, u'-  ASSERT_PRED1(PredFunctor1(),'), (271, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeFailure) {'), (274, 2, u'-    ASSERT_PRED1(PredFunction1Int,'), (282, 2, u'-TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeFailure) {'), (285, 2, u'-    ASSERT_PRED1(PredFunction1Bool,'), (293, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeFailure) {'), (296, 2, u'-    ASSERT_PRED1(PredFunctor1(),'), (304, 2, u'-TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeFailure) {'), (307, 2, u'-    ASSERT_PRED1(PredFunctor1(),'), (387, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeSuccess) {'), (388, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (395, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeSuccess) {'), (396, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (403, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeSuccess) {'), (404, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (411, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeSuccess) {'), (412, 2, u'-  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (419, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeFailure) {'), (422, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (430, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeFailure) {'), (433, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (441, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeFailure) {'), (444, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (452, 2, u'-TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeFailure) {'), (455, 2, u'-    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (489, 2, u'-testing::AssertionResult PredFormatFunction2(const char* e1,'), (494, 2, u'-    return testing::AssertionSuccess();'), (496, 2, u'-  return testing::AssertionFailure()'), (505, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (558, 2, u'-typedef Predicate2Test ASSERT_PRED_FORMAT2Test;'), (560, 2, u'-typedef Predicate2Test ASSERT_PRED2Test;'), (644, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeSuccess) {'), (645, 2, u'-  ASSERT_PRED2(PredFunction2Int,'), (653, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeSuccess) {'), (654, 2, u'-  ASSERT_PRED2(PredFunction2Bool,'), (662, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeSuccess) {'), (663, 2, u'-  ASSERT_PRED2(PredFunctor2(),'), (671, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeSuccess) {'), (672, 2, u'-  ASSERT_PRED2(PredFunctor2(),'), (680, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeFailure) {'), (683, 2, u'-    ASSERT_PRED2(PredFunction2Int,'), (692, 2, u'-TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeFailure) {'), (695, 2, u'-    ASSERT_PRED2(PredFunction2Bool,'), (704, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeFailure) {'), (707, 2, u'-    ASSERT_PRED2(PredFunctor2(),'), (716, 2, u'-TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeFailure) {'), (719, 2, u'-    ASSERT_PRED2(PredFunctor2(),'), (808, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeSuccess) {'), (809, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (817, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeSuccess) {'), (818, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (826, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeSuccess) {'), (827, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (835, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeSuccess) {'), (836, 2, u'-  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (844, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeFailure) {'), (847, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (856, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeFailure) {'), (859, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (868, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeFailure) {'), (871, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (880, 2, u'-TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeFailure) {'), (883, 2, u'-    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (919, 2, u'-testing::AssertionResult PredFormatFunction3(const char* e1,'), (926, 2, u'-    return testing::AssertionSuccess();'), (928, 2, u'-  return testing::AssertionFailure()'), (937, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (997, 2, u'-typedef Predicate3Test ASSERT_PRED_FORMAT3Test;'), (999, 2, u'-typedef Predicate3Test ASSERT_PRED3Test;'), (1091, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeSuccess) {'), (1092, 2, u'-  ASSERT_PRED3(PredFunction3Int,'), (1101, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeSuccess) {'), (1102, 2, u'-  ASSERT_PRED3(PredFunction3Bool,'), (1111, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeSuccess) {'), (1112, 2, u'-  ASSERT_PRED3(PredFunctor3(),'), (1121, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeSuccess) {'), (1122, 2, u'-  ASSERT_PRED3(PredFunctor3(),'), (1131, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeFailure) {'), (1134, 2, u'-    ASSERT_PRED3(PredFunction3Int,'), (1144, 2, u'-TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeFailure) {'), (1147, 2, u'-    ASSERT_PRED3(PredFunction3Bool,'), (1157, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeFailure) {'), (1160, 2, u'-    ASSERT_PRED3(PredFunctor3(),'), (1170, 2, u'-TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeFailure) {'), (1173, 2, u'-    ASSERT_PRED3(PredFunctor3(),'), (1271, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeSuccess) {'), (1272, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1281, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeSuccess) {'), (1282, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1291, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeSuccess) {'), (1292, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1301, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeSuccess) {'), (1302, 2, u'-  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1311, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeFailure) {'), (1314, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1324, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeFailure) {'), (1327, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1337, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeFailure) {'), (1340, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1350, 2, u'-TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeFailure) {'), (1353, 2, u'-    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1391, 2, u'-testing::AssertionResult PredFormatFunction4(const char* e1,'), (1400, 2, u'-    return testing::AssertionSuccess();'), (1402, 2, u'-  return testing::AssertionFailure()'), (1411, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (1478, 2, u'-typedef Predicate4Test ASSERT_PRED_FORMAT4Test;'), (1480, 2, u'-typedef Predicate4Test ASSERT_PRED4Test;'), (1580, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeSuccess) {'), (1581, 2, u'-  ASSERT_PRED4(PredFunction4Int,'), (1591, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeSuccess) {'), (1592, 2, u'-  ASSERT_PRED4(PredFunction4Bool,'), (1602, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeSuccess) {'), (1603, 2, u'-  ASSERT_PRED4(PredFunctor4(),'), (1613, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeSuccess) {'), (1614, 2, u'-  ASSERT_PRED4(PredFunctor4(),'), (1624, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeFailure) {'), (1627, 2, u'-    ASSERT_PRED4(PredFunction4Int,'), (1638, 2, u'-TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeFailure) {'), (1641, 2, u'-    ASSERT_PRED4(PredFunction4Bool,'), (1652, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeFailure) {'), (1655, 2, u'-    ASSERT_PRED4(PredFunctor4(),'), (1666, 2, u'-TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeFailure) {'), (1669, 2, u'-    ASSERT_PRED4(PredFunctor4(),'), (1776, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeSuccess) {'), (1777, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1787, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeSuccess) {'), (1788, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1798, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeSuccess) {'), (1799, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1809, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeSuccess) {'), (1810, 2, u'-  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1820, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeFailure) {'), (1823, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1834, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeFailure) {'), (1837, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1848, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeFailure) {'), (1851, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1862, 2, u'-TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeFailure) {'), (1865, 2, u'-    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1905, 2, u'-testing::AssertionResult PredFormatFunction5(const char* e1,'), (1916, 2, u'-    return testing::AssertionSuccess();'), (1918, 2, u'-  return testing::AssertionFailure()'), (1927, 2, u'-  testing::AssertionResult operator()(const char* e1,'), (2001, 2, u'-typedef Predicate5Test ASSERT_PRED_FORMAT5Test;'), (2003, 2, u'-typedef Predicate5Test ASSERT_PRED5Test;'), (2111, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeSuccess) {'), (2112, 2, u'-  ASSERT_PRED5(PredFunction5Int,'), (2123, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeSuccess) {'), (2124, 2, u'-  ASSERT_PRED5(PredFunction5Bool,'), (2135, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeSuccess) {'), (2136, 2, u'-  ASSERT_PRED5(PredFunctor5(),'), (2147, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeSuccess) {'), (2148, 2, u'-  ASSERT_PRED5(PredFunctor5(),'), (2159, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeFailure) {'), (2162, 2, u'-    ASSERT_PRED5(PredFunction5Int,'), (2174, 2, u'-TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeFailure) {'), (2177, 2, u'-    ASSERT_PRED5(PredFunction5Bool,'), (2189, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeFailure) {'), (2192, 2, u'-    ASSERT_PRED5(PredFunctor5(),'), (2204, 2, u'-TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeFailure) {'), (2207, 2, u'-    ASSERT_PRED5(PredFunctor5(),'), (2323, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeSuccess) {'), (2324, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2335, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeSuccess) {'), (2336, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2347, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeSuccess) {'), (2348, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2359, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeSuccess) {'), (2360, 2, u'-  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2371, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeFailure) {'), (2374, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2386, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeFailure) {'), (2389, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2401, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeFailure) {'), (2404, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2416, 2, u'-TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeFailure) {'), (2419, 2, u'-    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),')]
===========================================
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class MyParamTest : public testing::TestWithParam<int> 
Class:class A : public Test 
Class:   class TestNamePrinter : public EmptyTestEventListener { class TestNamePrinter : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 2, u'-TEST(NoFatalFailureTest, AssertNoFatalFailure) {'), (51, 2, u'-  ASSERT_NO_FATAL_FAILURE(;);'), (52, 2, u'-  ASSERT_NO_FATAL_FAILURE(SUCCEED());'), (53, 2, u'-  ASSERT_NO_FATAL_FAILURE(Subroutine());'), (54, 2, u'-  ASSERT_NO_FATAL_FAILURE({ SUCCEED(); });')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 2, u'-  ASSERT_TRUE(property != properties.end())'), (90, 2, u'-void ManyAsserts(int id) {'), (100, 2, u'-    ASSERT_FALSE(false) << "This shouldn\'t fail.";'), (102, 2, u'-    ASSERT_LE(5, 6);'), (128, 2, u'-TEST(StressTest, CanUseScopedTraceAndAssertionsInManyThreads) {'), (133, 2, u'-      threads[i].reset(new ThreadWithParam<int>(&ManyAsserts,'), (186, 2, u'-void AssertNoFatalFailureIgnoresFailuresInOtherThreads() {'), (187, 2, u'-  ASSERT_NO_FATAL_FAILURE(GenerateFatalFailureInAnotherThread(true));'), (189, 2, u'-TEST(NoFatalFailureTest, AssertNoFatalFailureIgnoresFailuresInOtherThreads) {'), (191, 2, u'-  AssertNoFatalFailureIgnoresFailuresInOtherThreads();')]
===========================================
Class:class TestEventListenersAccessor { class TestEventListenersAccessor 
Class:class SubClassOfTest : public Test 
Class:class AnotherSubClassOfTest : public Test 
Class:       class FormatEpochTimeInMillisAsIso8601Test : public Test { class FormatEpochTimeInMillisAsIso8601Test : public Test 
Class: class VectorShuffleTest : public Test { class VectorShuffleTest : public Test 
Class: class ScopedFakeTestPartResultReporterTest : public Test { class ScopedFakeTestPartResultReporterTest : public Test 
Class:    class TestResultTest : public Test { class TestResultTest : public Test 
Class:   class GTestFlagSaverTest : public Test { class GTestFlagSaverTest : public Test 
Class: class ShouldShardTest : public testing::Test { class ShouldShardTest : public testing::Test 
Class:   class DisabledTestsTest : public Test { class DisabledTestsTest : public Test 
Class: template <typename T> class DISABLED_TypedTest : public Test { class DISABLED_TypedTest : public Test 
Class: template <typename T> class DISABLED_TypedTestP : public Test { class DISABLED_TypedTestP : public Test 
Class:  class Uncopyable { class Uncopyable 
Class:class UnprintableChar { class UnprintableChar 
Class:     class Foo { class Foo 
Class:  class FRIEND_TEST_Test2 : public Test { class FRIEND_TEST_Test2 : public Test 
Class:       class TestLifeCycleTest : public Test { class TestLifeCycleTest : public Test 
Class:   class Base { class Base 
Class:class MyTypeInUnnamedNameSpace : public Base { class MyTypeInUnnamedNameSpace : public Base 
Class:class MyTypeInNameSpace1 : public Base { class MyTypeInNameSpace1 : public Base 
Class:class MyTypeInNameSpace2 : public ::Base { class MyTypeInNameSpace2 : public ::Base 
Class:class TestInfoTest : public Test { class TestInfoTest : public Test 
Class:   class SetUpTestCaseTest : public Test { class SetUpTestCaseTest : public Test 
Class:  class InitGoogleTestTest : public Test { class InitGoogleTestTest : public Test 
Class:class Test 
Class:class Message 
Class:class AssertionResult 
Class:   template <typename T> class StaticAssertTypeEqTestHelper { class StaticAssertTypeEqTestHelper 
Class: class TestListener : public EmptyTestEventListener { class TestListener : public EmptyTestEventListener 
Class:    class SequenceTestingListener : public EmptyTestEventListener { class SequenceTestingListener : public EmptyTestEventListener 
Class:class ConversionHelperBase 
Class:class ConversionHelperDerived : public ConversionHelperBase 
Class:class NonContainer 
Class: class SuccessfulTest : public Test { class SuccessfulTest : public Test 
Class: class FailedTest : public Test { class FailedTest : public Test 
Class: class DisabledTest : public Test { class DisabledTest : public Test 
Class: class PropertyRecordingTest : public Test { class PropertyRecordingTest : public Test 
Class:class ValueParamTest : public TestWithParam<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 2, u'-  ASSERT_EQ(1, 1);'), (62, 2, u'-  ASSERT_EQ(1, 2);'), (74, 2, u'-  ASSERT_EQ(1, 1);'), (79, 2, u'-  ASSERT_EQ(2, 3);')]
===========================================
Class:class BetweenCardinalityImpl : public CardinalityInterface { class BetweenCardinalityImpl : public CardinalityInterface 
Class:class GoogleTestFailureReporter : public FailureReporterInterface { class GoogleTestFailureReporter : public FailureReporterInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 2, u'-    AssertHelper(type == FATAL ?')]
===========================================
Class:class MockObjectRegistry { class MockObjectRegistry 
Class:class MyActionImpl : public ActionInterface<MyFunction> { class MyActionImpl : public ActionInterface<MyFunction> 
Class:    class IsNotZero : public ActionInterface<bool(int)> {   class IsNotZero : public ActionInterface<bool(int)> 
Class:   class ReturnZeroFromNullaryFunctionAction { class ReturnZeroFromNullaryFunctionAction 
Class:     class FromType { class FromType 
Class: class ToType { class ToType 
Class:class DestinationType 
Class: class SourceType { class SourceType 
Class:class MyClass 
Class: class MockClass { class MockClass 
Class: class NullaryFunctor { class NullaryFunctor 
Class: class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:class MockFoo { class MockFoo 
Class:    class EvenCardinality : public CardinalityInterface { class EvenCardinality : public CardinalityInterface 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class SubstractAction : public ActionInterface<int(int, int)> {   class SubstractAction : public ActionInterface<int(int, int)> 
Class: class NullaryConstructorClass { class NullaryConstructorClass 
Class: class UnaryConstructorClass { class UnaryConstructorClass 
Class: class TenArgConstructorClass { class TenArgConstructorClass 
Class:  class BoolResetter { class BoolResetter 
Class:class FooInterface { class FooInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 2, u'-using ::testing::internal::CompileAssertTypesEqual;'), (52, 2, u'-  CompileAssertTypesEqual<tuple<>, MatcherTuple<tuple<> >::type>();'), (56, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<int> >,'), (61, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char> >,'), (66, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char>, Matcher<bool>,'), (76, 2, u'-  CompileAssertTypesEqual<int, F::Result>();'), (77, 2, u'-  CompileAssertTypesEqual<tuple<>, F::ArgumentTuple>();'), (78, 2, u'-  CompileAssertTypesEqual<tuple<>, F::ArgumentMatcherTuple>();'), (79, 2, u'-  CompileAssertTypesEqual<void(), F::MakeResultVoid>();'), (80, 2, u'-  CompileAssertTypesEqual<IgnoredValue(), F::MakeResultIgnoredValue>();'), (85, 2, u'-  CompileAssertTypesEqual<int, F::Result>();'), (86, 2, u'-  CompileAssertTypesEqual<bool, F::Argument1>();'), (87, 2, u'-  CompileAssertTypesEqual<tuple<bool>, F::ArgumentTuple>();'), (88, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<bool> >, F::ArgumentMatcherTuple>();'), (89, 2, u'-  CompileAssertTypesEqual<void(bool), F::MakeResultVoid>();  // NOLINT'), (90, 2, u'-  CompileAssertTypesEqual<IgnoredValue(bool),  // NOLINT'), (96, 2, u'-  CompileAssertTypesEqual<int, F::Result>();'), (97, 2, u'-  CompileAssertTypesEqual<bool, F::Argument1>();'), (98, 2, u'-  CompileAssertTypesEqual<const long&, F::Argument2>();  // NOLINT'), (99, 2, u'-  CompileAssertTypesEqual<tuple<bool, const long&>, F::ArgumentTuple>();  // NOLINT'), (100, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<const long&> >,  // NOLINT'), (102, 2, u'-  CompileAssertTypesEqual<void(bool, const long&), F::MakeResultVoid>();  // NOLINT'), (103, 2, u'-  CompileAssertTypesEqual<IgnoredValue(bool, const long&),  // NOLINT'), (109, 2, u'-  CompileAssertTypesEqual<char, F::Result>();'), (110, 2, u'-  CompileAssertTypesEqual<bool, F::Argument1>();'), (111, 2, u'-  CompileAssertTypesEqual<int, F::Argument2>();'), (112, 2, u'-  CompileAssertTypesEqual<char*, F::Argument3>();'), (113, 2, u'-  CompileAssertTypesEqual<int&, F::Argument4>();'), (114, 2, u'-  CompileAssertTypesEqual<const long&, F::Argument5>();  // NOLINT'), (115, 2, u'-  CompileAssertTypesEqual<tuple<bool, int, char*, int&, const long&>,  // NOLINT'), (117, 2, u'-  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<int>, Matcher<char*>,'), (120, 2, u'-  CompileAssertTypesEqual<void(bool, int, char*, int&, const long&),  // NOLINT'), (122, 2, u'-  CompileAssertTypesEqual<')]
===========================================
Class:class LessThanMatcher : public MatcherInterface<tuple<char, int> > { class LessThanMatcher : public MatcherInterface<tuple<char, int> > 
Class:  class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class: class NativeArrayPassedAsPointerAndSize { class NativeArrayPassedAsPointerAndSize 
Class:    class UncopyableFoo { class UncopyableFoo 
Class:class Message;
Class:class Base 
Class:class Derived : public Base 
Class:class LogIsVisibleTest : public ::testing::Test { class LogIsVisibleTest : public ::testing::Test 
Class: class DummyMock { class DummyMock 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 2, u'-  CompileAssertTypesEqual<const char,'), (105, 2, u'-  CompileAssertTypesEqual<int, PointeeOf<int*>::type>();'), (106, 2, u'-  CompileAssertTypesEqual<const char, PointeeOf<const char*>::type>();'), (107, 2, u'-  CompileAssertTypesEqual<void, PointeeOf<void*>::type>();'), (308, 2, u'-TEST(AssertTest, SucceedsOnTrue) {'), (309, 2, u'-  Assert(true, __FILE__, __LINE__, "This should succeed.");'), (310, 2, u'-  Assert(true, __FILE__, __LINE__);  // This should succeed too.'), (314, 2, u'-TEST(AssertTest, FailsFatallyOnFalse) {'), (316, 2, u'-    Assert(false, __FILE__, __LINE__, "This should fail.");'), (320, 2, u'-    Assert(false, __FILE__, __LINE__);'), (583, 2, u'-  StaticAssertTypeEq<std::vector<int>,'), (585, 2, u'-  StaticAssertTypeEq<const std::vector<double>&,'), (599, 2, u'-  StaticAssertTypeEq<NativeArray<int>,'), (601, 2, u'-  StaticAssertTypeEq<NativeArray<double>,'), (603, 2, u'-  StaticAssertTypeEq<NativeArray<char[3]>,'), (606, 2, u'-  StaticAssertTypeEq<const NativeArray<int>,'), (615, 2, u'-  ASSERT_EQ(3U, a3.size());'), (626, 2, u'-  StaticAssertTypeEq<NativeArray<int>,'), (628, 2, u'-  StaticAssertTypeEq<NativeArray<double>,'), (631, 2, u'-  StaticAssertTypeEq<const NativeArray<int>,'), (643, 2, u'-  ASSERT_EQ(3U, a3.size());')]
===========================================
Class:class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:   class DeletionTester { class DeletionTester 
Class:class MyException 
Class:class Foo { class Foo 
Class:class ExpectationTester { class ExpectationTester 
Class:class Incomplete;
Class: class MockIncomplete { class MockIncomplete 
Class:class Result 
Class: class MockA { class MockA 
Class: class MockB { class MockB 
Class: class ReferenceHoldingMock { class ReferenceHoldingMock 
Class:class MockCC : public CC { class MockCC : public CC 
Class: class EvenNumberCardinality : public CardinalityInterface { class EvenNumberCardinality : public CardinalityInterface 
Class: class MockC { class MockC 
Class: class VerboseFlagPreservingFixture : public testing::Test { class VerboseFlagPreservingFixture : public testing::Test 
Class:   class GMockVerboseFlagTest : public VerboseFlagPreservingFixture { class GMockVerboseFlagTest : public VerboseFlagPreservingFixture 
Class:class PrintMeNot 
Class: class LogTestHelper { class LogTestHelper 
Class: class GMockLogTest : public VerboseFlagPreservingFixture { class GMockLogTest : public VerboseFlagPreservingFixture 
Class:class FooInterface { class FooInterface 
Class: class MockFoo : public FooInterface { class MockFoo : public FooInterface 
Class: class MockFoo { class MockFoo 
Class: class GMockOutputTest : public testing::Test { class GMockOutputTest : public testing::Test 
Class:class MockFoo { class MockFoo 
Class:class Base { class Base 
Class: class Derived1 : public Base { class Derived1 : public Base 
Class: class Derived2 : public Base { class Derived2 : public Base 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 2, u'-  ASSERT_EQ(N, argc) << "The new argv has wrong number of elements.";')]
===========================================
Class:class Water { class Water 
Class:     class LeakChecker : public EmptyTestEventListener { class LeakChecker : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 1, u'+    ASSERT_EQ(q->Size(), new_q->Size());'), (134, 1, u'+  ASSERT_TRUE(n != NULL);'), (140, 1, u'+  ASSERT_TRUE(n != NULL);')]
===========================================
Class:     class IntegerFunctionTest : public QuickTest { class IntegerFunctionTest : public QuickTest 
Class:        class QueueTest : public QuickTest { class QueueTest : public QuickTest 
Class:  template <class T> class PrimeTableTest : public testing::Test { class PrimeTableTest : public testing::Test 
Class:                 template <class T> class PrimeTableTest2 : public PrimeTableTest<T> { class PrimeTableTest2 : public PrimeTableTest<T> 
Class:     class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> { class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> 
Class:      class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > { class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > 
Class:class TersePrinter : public EmptyTestEventListener { class TersePrinter : public EmptyTestEventListener 
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class TestNameIs { class TestNameIs 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class: class TestException : public std::exception { class TestException : public std::exception 
Class:class ReplaceDeathTestFactory { class ReplaceDeathTestFactory 
Class:   class TestForDeathTest : public testing::Test { class TestForDeathTest : public testing::Test 
Class:  class MayDie { class MayDie 
Class:  class MockDeathTestFactory : public DeathTestFactory { class MockDeathTestFactory : public DeathTestFactory 
Class:      class MockDeathTest : public DeathTest { class MockDeathTest : public DeathTest 
Class:    class MacroLogicDeathTest : public testing::Test { class MacroLogicDeathTest : public testing::Test 
Class:class DirectoryCreationTest : public Test { class DirectoryCreationTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(98, 1, u'+  ASSERT_TRUE(cwd_without_drive != NULL);')]
===========================================
Class:class A { class A 
Class:  class B : public A { class B : public A 
Class: class LinkedPtrTest : public testing::Test { class LinkedPtrTest : public testing::Test 
Class:class EventRecordingListener : public TestEventListener { class EventRecordingListener : public TestEventListener 
Class:class XmlOutputChangeDirTest : public Test { class XmlOutputChangeDirTest : public Test 
Class:   class DogAdder { class DogAdder 
Class: class IntWrapper { class IntWrapper 
Class:          template <int kExpectedCalls> class TestGenerationEnvironment : public ::testing::Environment { class TestGenerationEnvironment : public ::testing::Environment 
Class: class TestGenerationTest : public TestWithParam<int> { class TestGenerationTest : public TestWithParam<int> 
Class:           class GeneratorEvaluationTest : public TestWithParam<int> { class GeneratorEvaluationTest : public TestWithParam<int> 
Class:class ExternalGeneratorTest : public TestWithParam<int> 
Class:class MultipleInstantiationTest : public TestWithParam<int> 
Class:   class SeparateInstanceTest : public TestWithParam<int> { class SeparateInstanceTest : public TestWithParam<int> 
Class:class NamingTest : public TestWithParam<int> 
Class:     class Unstreamable { class Unstreamable 
Class:class CommentTest : public TestWithParam<Unstreamable> 
Class:     class NonParameterizedBaseTest : public ::testing::Test { class NonParameterizedBaseTest : public ::testing::Test 
Class: class ParameterizedDerivedTest : public NonParameterizedBaseTest,                                  public ::testing::WithParamInterface<int> {                                  public ::testing::WithParamInterface<int> 
Class:class Base { class Base 
Class:  class BiggestIntConvertible { class BiggestIntConvertible 
Class:  template <typename T> class UnprintableTemplateInGlobal { class UnprintableTemplateInGlobal 
Class:  class StreamableInGlobal { class StreamableInGlobal 
Class:class UnprintableInFoo { class UnprintableInFoo 
Class:  template <typename T> class PrintableViaPrintToTemplate { class PrintableViaPrintToTemplate 
Class:  template <typename T> class StreamableTemplateInFoo { class StreamableTemplateInFoo 
Class:class AllowsGenericStreaming 
Class:class AllowsGenericStreamingTemplate 
Class:    template <typename T> class AllowsGenericStreamingAndImplicitConversionTemplate { class AllowsGenericStreamingAndImplicitConversionTemplate 
Class:class TestPartResultTest : public Test { class TestPartResultTest : public Test 
Class:   class TestPartResultArrayTest : public Test { class TestPartResultArrayTest : public Test 
Class:class BigTupleTest : public testing::Test { class BigTupleTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+using ::testing::StaticAssertTypeEq;'), (47, 1, u'+  StaticAssertTypeEq<int, tuple_element<0, tuple<int, char> >::type>();'), (48, 1, u'+  StaticAssertTypeEq<int&, tuple_element<1, tuple<double, int&> >::type>();'), (49, 1, u'+  StaticAssertTypeEq<bool, tuple_element<2, tuple<double, int, bool> >::type>();')]
===========================================
Class:    template <typename T> class CommonTest : public Test { class CommonTest : public Test 
Class:    template <typename T> class TypedTest1 : public Test { class TypedTest1 : public Test 
Class: template <typename T> class TypedTest2 : public Test { class TypedTest2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
Class:   class TypedTestCasePStateTest : public Test { class TypedTestCasePStateTest : public Test 
Class:    template <typename T> class DerivedTest : public CommonTest<T> { class DerivedTest : public CommonTest<T> 
Class:    template <typename T> class TypedTestP1 : public Test { class TypedTestP1 : public Test 
Class: template <typename T> class TypedTestP2 : public Test { class TypedTestP2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(120, 1, u'+  ASSERT_TRUE(this->shared_ != NULL);'), (257, 1, u'+  ASSERT_TRUE(this->shared_ != NULL);')]
===========================================
Class:class UnitTestHelper { class UnitTestHelper 
Class:class FinalSuccessChecker : public Environment { class FinalSuccessChecker : public Environment 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 1, u'+  ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (140, 1, u'+AssertionResult IsNull(const char* str) {'), (142, 1, u'+    return testing::AssertionFailure() << "argument is " << str;'), (144, 1, u'+  return AssertionSuccess();'), (149, 1, u'+  ASSERT_TRUE(test_case != NULL);'), (156, 1, u'+  ASSERT_EQ(4, test_case->total_test_count());'), (189, 1, u'+  ASSERT_TRUE(test_case != NULL);'), (196, 1, u'+  ASSERT_EQ(1, test_case->total_test_count());'), (212, 1, u'+  ASSERT_TRUE(test_case != NULL);'), (219, 1, u'+  ASSERT_EQ(1, test_case->total_test_count());'), (245, 1, u'+    ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (253, 1, u'+    ASSERT_EQ(4, test_cases[0]->total_test_count());'), (263, 1, u'+    ASSERT_EQ(1, test_cases[1]->total_test_count());'), (272, 1, u'+    ASSERT_EQ(1, test_cases[2]->total_test_count());')]
===========================================
Class: class SehExceptionInDestructorTest : public Test { class SehExceptionInDestructorTest : public Test 
Class: class SehExceptionInSetUpTestCaseTest : public Test { class SehExceptionInSetUpTestCaseTest : public Test 
Class: class SehExceptionInTearDownTestCaseTest : public Test { class SehExceptionInTearDownTestCaseTest : public Test 
Class: class SehExceptionInSetUpTest : public Test { class SehExceptionInSetUpTest : public Test 
Class: class SehExceptionInTearDownTest : public Test { class SehExceptionInTearDownTest : public Test 
Class: class CxxExceptionInDestructorTest : public Test { class CxxExceptionInDestructorTest : public Test 
Class: class CxxExceptionInSetUpTestCaseTest : public Test { class CxxExceptionInSetUpTestCaseTest : public Test 
Class: class CxxExceptionInTearDownTestCaseTest : public Test { class CxxExceptionInTearDownTestCaseTest : public Test 
Class: class CxxExceptionInSetUpTest : public Test { class CxxExceptionInSetUpTest : public Test 
Class: class CxxExceptionInTearDownTest : public Test { class CxxExceptionInTearDownTest : public Test 
Class: class CxxExceptionInTestBodyTest : public Test { class CxxExceptionInTestBodyTest : public Test 
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+  ASSERT_TRUE(false) << "Tests shouldn\'t be run when --help is specified.";')]
===========================================
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
Class:class FailingParamTest : public testing::TestWithParam<int> 
Class:  class NonFatalFailureInFixtureConstructorTest : public testing::Test { class NonFatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class FatalFailureInFixtureConstructorTest : public testing::Test { class FatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class NonFatalFailureInSetUpTest : public testing::Test { class NonFatalFailureInSetUpTest : public testing::Test 
Class:  class FatalFailureInSetUpTest : public testing::Test { class FatalFailureInSetUpTest : public testing::Test 
Class:    class DeathTestAndMultiThreadsTest : public testing::Test { class DeathTestAndMultiThreadsTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class: class TEST_before_TEST_F_in_same_test_case : public testing::Test { class TEST_before_TEST_F_in_same_test_case : public testing::Test 
Class:    class FooEnvironment : public testing::Environment { class FooEnvironment : public testing::Environment 
Class: class BarEnvironment : public testing::Environment { class BarEnvironment : public testing::Environment 
Class:   class Predicate1Test : public testing::Test { class Predicate1Test : public testing::Test 
Class:   class Predicate2Test : public testing::Test { class Predicate2Test : public testing::Test 
Class:   class Predicate3Test : public testing::Test { class Predicate3Test : public testing::Test 
Class:   class Predicate4Test : public testing::Test { class Predicate4Test : public testing::Test 
Class:   class Predicate5Test : public testing::Test { class Predicate5Test : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 1, u'+testing::AssertionResult PredFormatFunction1(const char* e1,'), (104, 1, u'+    return testing::AssertionSuccess();'), (106, 1, u'+  return testing::AssertionFailure()'), (115, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (161, 1, u'+typedef Predicate1Test ASSERT_PRED_FORMAT1Test;'), (163, 1, u'+typedef Predicate1Test ASSERT_PRED1Test;'), (239, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeSuccess) {'), (240, 1, u'+  ASSERT_PRED1(PredFunction1Int,'), (247, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeSuccess) {'), (248, 1, u'+  ASSERT_PRED1(PredFunction1Bool,'), (255, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeSuccess) {'), (256, 1, u'+  ASSERT_PRED1(PredFunctor1(),'), (263, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeSuccess) {'), (264, 1, u'+  ASSERT_PRED1(PredFunctor1(),'), (271, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeFailure) {'), (274, 1, u'+    ASSERT_PRED1(PredFunction1Int,'), (282, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeFailure) {'), (285, 1, u'+    ASSERT_PRED1(PredFunction1Bool,'), (293, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeFailure) {'), (296, 1, u'+    ASSERT_PRED1(PredFunctor1(),'), (304, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeFailure) {'), (307, 1, u'+    ASSERT_PRED1(PredFunctor1(),'), (387, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeSuccess) {'), (388, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (395, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeSuccess) {'), (396, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (403, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeSuccess) {'), (404, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (411, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeSuccess) {'), (412, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (419, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeFailure) {'), (422, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (430, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeFailure) {'), (433, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (441, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeFailure) {'), (444, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (452, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeFailure) {'), (455, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (489, 1, u'+testing::AssertionResult PredFormatFunction2(const char* e1,'), (494, 1, u'+    return testing::AssertionSuccess();'), (496, 1, u'+  return testing::AssertionFailure()'), (505, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (558, 1, u'+typedef Predicate2Test ASSERT_PRED_FORMAT2Test;'), (560, 1, u'+typedef Predicate2Test ASSERT_PRED2Test;'), (644, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeSuccess) {'), (645, 1, u'+  ASSERT_PRED2(PredFunction2Int,'), (653, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeSuccess) {'), (654, 1, u'+  ASSERT_PRED2(PredFunction2Bool,'), (662, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeSuccess) {'), (663, 1, u'+  ASSERT_PRED2(PredFunctor2(),'), (671, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeSuccess) {'), (672, 1, u'+  ASSERT_PRED2(PredFunctor2(),'), (680, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeFailure) {'), (683, 1, u'+    ASSERT_PRED2(PredFunction2Int,'), (692, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeFailure) {'), (695, 1, u'+    ASSERT_PRED2(PredFunction2Bool,'), (704, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeFailure) {'), (707, 1, u'+    ASSERT_PRED2(PredFunctor2(),'), (716, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeFailure) {'), (719, 1, u'+    ASSERT_PRED2(PredFunctor2(),'), (808, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeSuccess) {'), (809, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (817, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeSuccess) {'), (818, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (826, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeSuccess) {'), (827, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (835, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeSuccess) {'), (836, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (844, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeFailure) {'), (847, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (856, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeFailure) {'), (859, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (868, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeFailure) {'), (871, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (880, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeFailure) {'), (883, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (919, 1, u'+testing::AssertionResult PredFormatFunction3(const char* e1,'), (926, 1, u'+    return testing::AssertionSuccess();'), (928, 1, u'+  return testing::AssertionFailure()'), (937, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (997, 1, u'+typedef Predicate3Test ASSERT_PRED_FORMAT3Test;'), (999, 1, u'+typedef Predicate3Test ASSERT_PRED3Test;'), (1091, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeSuccess) {'), (1092, 1, u'+  ASSERT_PRED3(PredFunction3Int,'), (1101, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeSuccess) {'), (1102, 1, u'+  ASSERT_PRED3(PredFunction3Bool,'), (1111, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeSuccess) {'), (1112, 1, u'+  ASSERT_PRED3(PredFunctor3(),'), (1121, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeSuccess) {'), (1122, 1, u'+  ASSERT_PRED3(PredFunctor3(),'), (1131, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeFailure) {'), (1134, 1, u'+    ASSERT_PRED3(PredFunction3Int,'), (1144, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeFailure) {'), (1147, 1, u'+    ASSERT_PRED3(PredFunction3Bool,'), (1157, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeFailure) {'), (1160, 1, u'+    ASSERT_PRED3(PredFunctor3(),'), (1170, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeFailure) {'), (1173, 1, u'+    ASSERT_PRED3(PredFunctor3(),'), (1271, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeSuccess) {'), (1272, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1281, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeSuccess) {'), (1282, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1291, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeSuccess) {'), (1292, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1301, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeSuccess) {'), (1302, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1311, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeFailure) {'), (1314, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1324, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeFailure) {'), (1327, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1337, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeFailure) {'), (1340, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1350, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeFailure) {'), (1353, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1391, 1, u'+testing::AssertionResult PredFormatFunction4(const char* e1,'), (1400, 1, u'+    return testing::AssertionSuccess();'), (1402, 1, u'+  return testing::AssertionFailure()'), (1411, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (1478, 1, u'+typedef Predicate4Test ASSERT_PRED_FORMAT4Test;'), (1480, 1, u'+typedef Predicate4Test ASSERT_PRED4Test;'), (1580, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeSuccess) {'), (1581, 1, u'+  ASSERT_PRED4(PredFunction4Int,'), (1591, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeSuccess) {'), (1592, 1, u'+  ASSERT_PRED4(PredFunction4Bool,'), (1602, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeSuccess) {'), (1603, 1, u'+  ASSERT_PRED4(PredFunctor4(),'), (1613, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeSuccess) {'), (1614, 1, u'+  ASSERT_PRED4(PredFunctor4(),'), (1624, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeFailure) {'), (1627, 1, u'+    ASSERT_PRED4(PredFunction4Int,'), (1638, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeFailure) {'), (1641, 1, u'+    ASSERT_PRED4(PredFunction4Bool,'), (1652, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeFailure) {'), (1655, 1, u'+    ASSERT_PRED4(PredFunctor4(),'), (1666, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeFailure) {'), (1669, 1, u'+    ASSERT_PRED4(PredFunctor4(),'), (1776, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeSuccess) {'), (1777, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1787, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeSuccess) {'), (1788, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1798, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeSuccess) {'), (1799, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1809, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeSuccess) {'), (1810, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1820, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeFailure) {'), (1823, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1834, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeFailure) {'), (1837, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1848, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeFailure) {'), (1851, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1862, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeFailure) {'), (1865, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1905, 1, u'+testing::AssertionResult PredFormatFunction5(const char* e1,'), (1916, 1, u'+    return testing::AssertionSuccess();'), (1918, 1, u'+  return testing::AssertionFailure()'), (1927, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (2001, 1, u'+typedef Predicate5Test ASSERT_PRED_FORMAT5Test;'), (2003, 1, u'+typedef Predicate5Test ASSERT_PRED5Test;'), (2111, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeSuccess) {'), (2112, 1, u'+  ASSERT_PRED5(PredFunction5Int,'), (2123, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeSuccess) {'), (2124, 1, u'+  ASSERT_PRED5(PredFunction5Bool,'), (2135, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeSuccess) {'), (2136, 1, u'+  ASSERT_PRED5(PredFunctor5(),'), (2147, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeSuccess) {'), (2148, 1, u'+  ASSERT_PRED5(PredFunctor5(),'), (2159, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeFailure) {'), (2162, 1, u'+    ASSERT_PRED5(PredFunction5Int,'), (2174, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeFailure) {'), (2177, 1, u'+    ASSERT_PRED5(PredFunction5Bool,'), (2189, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeFailure) {'), (2192, 1, u'+    ASSERT_PRED5(PredFunctor5(),'), (2204, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeFailure) {'), (2207, 1, u'+    ASSERT_PRED5(PredFunctor5(),'), (2323, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeSuccess) {'), (2324, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2335, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeSuccess) {'), (2336, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2347, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeSuccess) {'), (2348, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2359, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeSuccess) {'), (2360, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2371, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeFailure) {'), (2374, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2386, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeFailure) {'), (2389, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2401, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeFailure) {'), (2404, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2416, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeFailure) {'), (2419, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),')]
===========================================
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class MyParamTest : public testing::TestWithParam<int> 
Class:class A : public Test 
Class:   class TestNamePrinter : public EmptyTestEventListener { class TestNamePrinter : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+TEST(NoFatalFailureTest, AssertNoFatalFailure) {'), (51, 1, u'+  ASSERT_NO_FATAL_FAILURE(;);'), (52, 1, u'+  ASSERT_NO_FATAL_FAILURE(SUCCEED());'), (53, 1, u'+  ASSERT_NO_FATAL_FAILURE(Subroutine());'), (54, 1, u'+  ASSERT_NO_FATAL_FAILURE({ SUCCEED(); });')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 1, u'+  ASSERT_TRUE(property != properties.end())'), (90, 1, u'+void ManyAsserts(int id) {'), (100, 1, u'+    ASSERT_FALSE(false) << "This shouldn\'t fail.";'), (102, 1, u'+    ASSERT_LE(5, 6);'), (128, 1, u'+TEST(StressTest, CanUseScopedTraceAndAssertionsInManyThreads) {'), (133, 1, u'+      threads[i].reset(new ThreadWithParam<int>(&ManyAsserts,'), (186, 1, u'+void AssertNoFatalFailureIgnoresFailuresInOtherThreads() {'), (187, 1, u'+  ASSERT_NO_FATAL_FAILURE(GenerateFatalFailureInAnotherThread(true));'), (189, 1, u'+TEST(NoFatalFailureTest, AssertNoFatalFailureIgnoresFailuresInOtherThreads) {'), (191, 1, u'+  AssertNoFatalFailureIgnoresFailuresInOtherThreads();')]
===========================================
Class:class TestEventListenersAccessor { class TestEventListenersAccessor 
Class:class SubClassOfTest : public Test 
Class:class AnotherSubClassOfTest : public Test 
Class:       class FormatEpochTimeInMillisAsIso8601Test : public Test { class FormatEpochTimeInMillisAsIso8601Test : public Test 
Class: class VectorShuffleTest : public Test { class VectorShuffleTest : public Test 
Class: class ScopedFakeTestPartResultReporterTest : public Test { class ScopedFakeTestPartResultReporterTest : public Test 
Class:    class TestResultTest : public Test { class TestResultTest : public Test 
Class:   class GTestFlagSaverTest : public Test { class GTestFlagSaverTest : public Test 
Class: class ShouldShardTest : public testing::Test { class ShouldShardTest : public testing::Test 
Class:   class DisabledTestsTest : public Test { class DisabledTestsTest : public Test 
Class: template <typename T> class DISABLED_TypedTest : public Test { class DISABLED_TypedTest : public Test 
Class: template <typename T> class DISABLED_TypedTestP : public Test { class DISABLED_TypedTestP : public Test 
Class:  class Uncopyable { class Uncopyable 
Class:class UnprintableChar { class UnprintableChar 
Class:     class Foo { class Foo 
Class:  class FRIEND_TEST_Test2 : public Test { class FRIEND_TEST_Test2 : public Test 
Class:       class TestLifeCycleTest : public Test { class TestLifeCycleTest : public Test 
Class:   class Base { class Base 
Class:class MyTypeInUnnamedNameSpace : public Base { class MyTypeInUnnamedNameSpace : public Base 
Class:class MyTypeInNameSpace1 : public Base { class MyTypeInNameSpace1 : public Base 
Class:class MyTypeInNameSpace2 : public ::Base { class MyTypeInNameSpace2 : public ::Base 
Class:class TestInfoTest : public Test { class TestInfoTest : public Test 
Class:   class SetUpTestCaseTest : public Test { class SetUpTestCaseTest : public Test 
Class:  class InitGoogleTestTest : public Test { class InitGoogleTestTest : public Test 
Class:class Test 
Class:class Message 
Class:class AssertionResult 
Class:   template <typename T> class StaticAssertTypeEqTestHelper { class StaticAssertTypeEqTestHelper 
Class: class TestListener : public EmptyTestEventListener { class TestListener : public EmptyTestEventListener 
Class:    class SequenceTestingListener : public EmptyTestEventListener { class SequenceTestingListener : public EmptyTestEventListener 
Class:class ConversionHelperBase 
Class:class ConversionHelperDerived : public ConversionHelperBase 
Class:class NonContainer 
Class: class SuccessfulTest : public Test { class SuccessfulTest : public Test 
Class: class FailedTest : public Test { class FailedTest : public Test 
Class: class DisabledTest : public Test { class DisabledTest : public Test 
Class: class PropertyRecordingTest : public Test { class PropertyRecordingTest : public Test 
Class:class ValueParamTest : public TestWithParam<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(55, 1, u'+  ASSERT_EQ(1, 1);'), (62, 1, u'+  ASSERT_EQ(1, 2);'), (74, 1, u'+  ASSERT_EQ(1, 1);'), (79, 1, u'+  ASSERT_EQ(2, 3);')]
===========================================
Class:class BetweenCardinalityImpl : public CardinalityInterface { class BetweenCardinalityImpl : public CardinalityInterface 
Class:class GoogleTestFailureReporter : public FailureReporterInterface { class GoogleTestFailureReporter : public FailureReporterInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 1, u'+    AssertHelper(type == FATAL ?')]
===========================================
Class:class MockObjectRegistry { class MockObjectRegistry 
Class:class MyActionImpl : public ActionInterface<MyFunction> { class MyActionImpl : public ActionInterface<MyFunction> 
Class:    class IsNotZero : public ActionInterface<bool(int)> {   class IsNotZero : public ActionInterface<bool(int)> 
Class:   class ReturnZeroFromNullaryFunctionAction { class ReturnZeroFromNullaryFunctionAction 
Class:     class FromType { class FromType 
Class: class ToType { class ToType 
Class:class DestinationType 
Class: class SourceType { class SourceType 
Class:class MyClass 
Class: class MockClass { class MockClass 
Class: class NullaryFunctor { class NullaryFunctor 
Class: class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:class MockFoo { class MockFoo 
Class:    class EvenCardinality : public CardinalityInterface { class EvenCardinality : public CardinalityInterface 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class SubstractAction : public ActionInterface<int(int, int)> {   class SubstractAction : public ActionInterface<int(int, int)> 
Class: class NullaryConstructorClass { class NullaryConstructorClass 
Class: class UnaryConstructorClass { class UnaryConstructorClass 
Class: class TenArgConstructorClass { class TenArgConstructorClass 
Class:  class BoolResetter { class BoolResetter 
Class:class FooInterface { class FooInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+using ::testing::internal::CompileAssertTypesEqual;'), (52, 1, u'+  CompileAssertTypesEqual<tuple<>, MatcherTuple<tuple<> >::type>();'), (56, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<int> >,'), (61, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char> >,'), (66, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char>, Matcher<bool>,'), (76, 1, u'+  CompileAssertTypesEqual<int, F::Result>();'), (77, 1, u'+  CompileAssertTypesEqual<tuple<>, F::ArgumentTuple>();'), (78, 1, u'+  CompileAssertTypesEqual<tuple<>, F::ArgumentMatcherTuple>();'), (79, 1, u'+  CompileAssertTypesEqual<void(), F::MakeResultVoid>();'), (80, 1, u'+  CompileAssertTypesEqual<IgnoredValue(), F::MakeResultIgnoredValue>();'), (85, 1, u'+  CompileAssertTypesEqual<int, F::Result>();'), (86, 1, u'+  CompileAssertTypesEqual<bool, F::Argument1>();'), (87, 1, u'+  CompileAssertTypesEqual<tuple<bool>, F::ArgumentTuple>();'), (88, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<bool> >, F::ArgumentMatcherTuple>();'), (89, 1, u'+  CompileAssertTypesEqual<void(bool), F::MakeResultVoid>();  // NOLINT'), (90, 1, u'+  CompileAssertTypesEqual<IgnoredValue(bool),  // NOLINT'), (96, 1, u'+  CompileAssertTypesEqual<int, F::Result>();'), (97, 1, u'+  CompileAssertTypesEqual<bool, F::Argument1>();'), (98, 1, u'+  CompileAssertTypesEqual<const long&, F::Argument2>();  // NOLINT'), (99, 1, u'+  CompileAssertTypesEqual<tuple<bool, const long&>, F::ArgumentTuple>();  // NOLINT'), (100, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<const long&> >,  // NOLINT'), (102, 1, u'+  CompileAssertTypesEqual<void(bool, const long&), F::MakeResultVoid>();  // NOLINT'), (103, 1, u'+  CompileAssertTypesEqual<IgnoredValue(bool, const long&),  // NOLINT'), (109, 1, u'+  CompileAssertTypesEqual<char, F::Result>();'), (110, 1, u'+  CompileAssertTypesEqual<bool, F::Argument1>();'), (111, 1, u'+  CompileAssertTypesEqual<int, F::Argument2>();'), (112, 1, u'+  CompileAssertTypesEqual<char*, F::Argument3>();'), (113, 1, u'+  CompileAssertTypesEqual<int&, F::Argument4>();'), (114, 1, u'+  CompileAssertTypesEqual<const long&, F::Argument5>();  // NOLINT'), (115, 1, u'+  CompileAssertTypesEqual<tuple<bool, int, char*, int&, const long&>,  // NOLINT'), (117, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<int>, Matcher<char*>,'), (120, 1, u'+  CompileAssertTypesEqual<void(bool, int, char*, int&, const long&),  // NOLINT'), (122, 1, u'+  CompileAssertTypesEqual<')]
===========================================
Class:class LessThanMatcher : public MatcherInterface<tuple<char, int> > { class LessThanMatcher : public MatcherInterface<tuple<char, int> > 
Class:  class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class: class NativeArrayPassedAsPointerAndSize { class NativeArrayPassedAsPointerAndSize 
Class:    class UncopyableFoo { class UncopyableFoo 
Class:class Message;
Class:class Base 
Class:class Derived : public Base 
Class:class LogIsVisibleTest : public ::testing::Test { class LogIsVisibleTest : public ::testing::Test 
Class: class DummyMock { class DummyMock 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 1, u'+  CompileAssertTypesEqual<const char,'), (105, 1, u'+  CompileAssertTypesEqual<int, PointeeOf<int*>::type>();'), (106, 1, u'+  CompileAssertTypesEqual<const char, PointeeOf<const char*>::type>();'), (107, 1, u'+  CompileAssertTypesEqual<void, PointeeOf<void*>::type>();'), (308, 1, u'+TEST(AssertTest, SucceedsOnTrue) {'), (309, 1, u'+  Assert(true, __FILE__, __LINE__, "This should succeed.");'), (310, 1, u'+  Assert(true, __FILE__, __LINE__);  // This should succeed too.'), (314, 1, u'+TEST(AssertTest, FailsFatallyOnFalse) {'), (316, 1, u'+    Assert(false, __FILE__, __LINE__, "This should fail.");'), (320, 1, u'+    Assert(false, __FILE__, __LINE__);'), (583, 1, u'+  StaticAssertTypeEq<std::vector<int>,'), (585, 1, u'+  StaticAssertTypeEq<const std::vector<double>&,'), (599, 1, u'+  StaticAssertTypeEq<NativeArray<int>,'), (601, 1, u'+  StaticAssertTypeEq<NativeArray<double>,'), (603, 1, u'+  StaticAssertTypeEq<NativeArray<char[3]>,'), (606, 1, u'+  StaticAssertTypeEq<const NativeArray<int>,'), (615, 1, u'+  ASSERT_EQ(3U, a3.size());'), (626, 1, u'+  StaticAssertTypeEq<NativeArray<int>,'), (628, 1, u'+  StaticAssertTypeEq<NativeArray<double>,'), (631, 1, u'+  StaticAssertTypeEq<const NativeArray<int>,'), (643, 1, u'+  ASSERT_EQ(3U, a3.size());')]
===========================================
Class:class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:   class DeletionTester { class DeletionTester 
Class:class MyException 
Class:class Foo { class Foo 
Class:class ExpectationTester { class ExpectationTester 
Class:class Incomplete;
Class: class MockIncomplete { class MockIncomplete 
Class:class Result 
Class: class MockA { class MockA 
Class: class MockB { class MockB 
Class: class ReferenceHoldingMock { class ReferenceHoldingMock 
Class:class MockCC : public CC { class MockCC : public CC 
Class: class EvenNumberCardinality : public CardinalityInterface { class EvenNumberCardinality : public CardinalityInterface 
Class: class MockC { class MockC 
Class: class VerboseFlagPreservingFixture : public testing::Test { class VerboseFlagPreservingFixture : public testing::Test 
Class:   class GMockVerboseFlagTest : public VerboseFlagPreservingFixture { class GMockVerboseFlagTest : public VerboseFlagPreservingFixture 
Class:class PrintMeNot 
Class: class LogTestHelper { class LogTestHelper 
Class: class GMockLogTest : public VerboseFlagPreservingFixture { class GMockLogTest : public VerboseFlagPreservingFixture 
Class:class FooInterface { class FooInterface 
Class: class MockFoo : public FooInterface { class MockFoo : public FooInterface 
Class: class MockFoo { class MockFoo 
Class: class GMockOutputTest : public testing::Test { class GMockOutputTest : public testing::Test 
Class:class MockFoo { class MockFoo 
Class:class Base { class Base 
Class: class Derived1 : public Base { class Derived1 : public Base 
Class: class Derived2 : public Base { class Derived2 : public Base 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+  ASSERT_EQ(N, argc) << "The new argv has wrong number of elements.";')]
===========================================
Class:class CompleterTest : public ::testing::Test { 
Class:class GTEST_API_ ScopedFakeTestPartResultReporter class GTEST_API_ ScopedFakeTestPartResultReporter
Class:class GTEST_API_ SingleFailureChecker { class GTEST_API_ SingleFailureChecker 
Class:    class GTestExpectFatalFailureHelper {\     class GTestExpectFatalFailureHelper 
Class:    class GTestExpectFatalFailureHelper {\     class GTestExpectFatalFailureHelper 
Class:class GTestFlagSaver { class GTestFlagSaver 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class TestNameIs { class TestNameIs 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class BetweenCardinalityImpl : public CardinalityInterface { class BetweenCardinalityImpl : public CardinalityInterface 
Class:class GoogleTestFailureReporter : public FailureReporterInterface { class GoogleTestFailureReporter : public FailureReporterInterface 
Class:class MockObjectRegistry { class MockObjectRegistry 
Class:class GTEST_API_ ScopedFakeTestPartResultReporter class GTEST_API_ ScopedFakeTestPartResultReporter
Class:class GTEST_API_ SingleFailureChecker { class GTEST_API_ SingleFailureChecker 
Class:    class GTestExpectFatalFailureHelper {\     class GTestExpectFatalFailureHelper 
Class:    class GTestExpectFatalFailureHelper {\     class GTestExpectFatalFailureHelper 
Class:class GTestFlagSaver { class GTestFlagSaver 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class TestNameIs { class TestNameIs 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(11, 1, u'+  ASSERT_EQ(0, setitimer(ITIMER_PROF, &timer, NULL));'), (17, 1, u'+  ASSERT_EQ(0, sigaction(SIGPROF, &signal_action, NULL));'), (26, 1, u'+  ASSERT_EQ(0, setitimer(ITIMER_PROF, &timer, NULL));'), (31, 1, u'+  ASSERT_EQ(0, sigaction(SIGPROF, &signal_action, old_signal_action));')]
===========================================
===========================================
Total add: 52
Total del: 0
Header: TEST_F
Functions:
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(11, 1, u'+  ASSERT_EQ(0, setitimer(ITIMER_PROF, &timer, NULL));'), (17, 1, u'+  ASSERT_EQ(0, sigaction(SIGPROF, &signal_action, NULL));'), (26, 1, u'+  ASSERT_EQ(0, setitimer(ITIMER_PROF, &timer, NULL));'), (31, 1, u'+  ASSERT_EQ(0, sigaction(SIGPROF, &signal_action, old_signal_action));')]
===========================================
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(11, 1, u'+  ASSERT_EQ(0, setitimer(ITIMER_PROF, &timer, NULL));'), (17, 1, u'+  ASSERT_EQ(0, sigaction(SIGPROF, &signal_action, NULL));'), (26, 1, u'+  ASSERT_EQ(0, setitimer(ITIMER_PROF, &timer, NULL));'), (31, 1, u'+  ASSERT_EQ(0, sigaction(SIGPROF, &signal_action, old_signal_action));')]
===========================================
Class:      class FormatEpochTimeInMillisAsIso8601Test : public Test { class FormatEpochTimeInMillisAsIso8601Test : public Test 
Class:class ReferenceHoldingMock { class ReferenceHoldingMock 
Class:class MockFoo { class MockFoo 
Class:class Base { class Base 
Class: class Derived1 : public Base { class Derived1 : public Base 
Class: class Derived2 : public Base { class Derived2 : public Base 
Class:class CompleterTest : public ::testing::Test class CompleterTest : public ::testing::Test
Class:class GTEST_API_ ScopedFakeTestPartResultReporter class GTEST_API_ ScopedFakeTestPartResultReporter
Class:class GTEST_API_ SingleFailureChecker { class GTEST_API_ SingleFailureChecker 
Class:    class GTestExpectFatalFailureHelper {\     class GTestExpectFatalFailureHelper 
Class:    class GTestExpectFatalFailureHelper {\     class GTestExpectFatalFailureHelper 
Class:class GTestFlagSaver { class GTestFlagSaver 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class TestNameIs { class TestNameIs 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class BetweenCardinalityImpl : public CardinalityInterface { class BetweenCardinalityImpl : public CardinalityInterface 
Class:class GoogleTestFailureReporter : public FailureReporterInterface { class GoogleTestFailureReporter : public FailureReporterInterface 
Class:class MockObjectRegistry { class MockObjectRegistry 
Class:class GTEST_API_ ScopedFakeTestPartResultReporter class GTEST_API_ ScopedFakeTestPartResultReporter
Class:class GTEST_API_ SingleFailureChecker { class GTEST_API_ SingleFailureChecker 
Class:    class GTestExpectFatalFailureHelper {\     class GTestExpectFatalFailureHelper 
Class:    class GTestExpectFatalFailureHelper {\     class GTestExpectFatalFailureHelper 
Class:class GTestFlagSaver { class GTestFlagSaver 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class TestNameIs { class TestNameIs 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class Water { class Water 
Class:     class LeakChecker : public EmptyTestEventListener { class LeakChecker : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(102, 1, u'+    ASSERT_EQ(q->Size(), new_q->Size());'), (134, 1, u'+  ASSERT_TRUE(n != NULL);'), (140, 1, u'+  ASSERT_TRUE(n != NULL);')]
===========================================
Class:     class IntegerFunctionTest : public QuickTest { class IntegerFunctionTest : public QuickTest 
Class:        class QueueTest : public QuickTest { class QueueTest : public QuickTest 
Class:  template <class T> class PrimeTableTest : public testing::Test { class PrimeTableTest : public testing::Test 
Class:                 template <class T> class PrimeTableTest2 : public PrimeTableTest<T> { class PrimeTableTest2 : public PrimeTableTest<T> 
Class:     class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> { class PrimeTableTest : public TestWithParam<CreatePrimeTableFunc*> 
Class:      class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > { class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > 
Class:class TersePrinter : public EmptyTestEventListener { class TersePrinter : public EmptyTestEventListener 
Class:class DeathTestImpl : public DeathTest { class DeathTestImpl : public DeathTest 
Class:class CapturedStream { class CapturedStream 
Class:class GoogleTestFailureException : public ::std::runtime_error { class GoogleTestFailureException : public ::std::runtime_error 
Class:class TestNameIs { class TestNameIs 
Class:class PrettyUnitTestResultPrinter : public TestEventListener { class PrettyUnitTestResultPrinter : public TestEventListener 
Class:      class TestEventRepeater : public TestEventListener { class TestEventRepeater : public TestEventListener 
Class:    class XmlUnitTestResultPrinter : public EmptyTestEventListener { class XmlUnitTestResultPrinter : public EmptyTestEventListener 
Class:class TestCaseNameIs { class TestCaseNameIs 
Class:class ClassUniqueToAlwaysTrue 
Class: class TestException : public std::exception { class TestException : public std::exception 
Class:class ReplaceDeathTestFactory { class ReplaceDeathTestFactory 
Class:   class TestForDeathTest : public testing::Test { class TestForDeathTest : public testing::Test 
Class:  class MayDie { class MayDie 
Class:  class MockDeathTestFactory : public DeathTestFactory { class MockDeathTestFactory : public DeathTestFactory 
Class:      class MockDeathTest : public DeathTest { class MockDeathTest : public DeathTest 
Class:    class MacroLogicDeathTest : public testing::Test { class MacroLogicDeathTest : public testing::Test 
Class:class DirectoryCreationTest : public Test { class DirectoryCreationTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(98, 1, u'+  ASSERT_TRUE(cwd_without_drive != NULL);')]
===========================================
Class:class A { class A 
Class:  class B : public A { class B : public A 
Class: class LinkedPtrTest : public testing::Test { class LinkedPtrTest : public testing::Test 
Class:class EventRecordingListener : public TestEventListener { class EventRecordingListener : public TestEventListener 
Class:class XmlOutputChangeDirTest : public Test { class XmlOutputChangeDirTest : public Test 
Class:   class DogAdder { class DogAdder 
Class: class IntWrapper { class IntWrapper 
Class:          template <int kExpectedCalls> class TestGenerationEnvironment : public ::testing::Environment { class TestGenerationEnvironment : public ::testing::Environment 
Class: class TestGenerationTest : public TestWithParam<int> { class TestGenerationTest : public TestWithParam<int> 
Class:           class GeneratorEvaluationTest : public TestWithParam<int> { class GeneratorEvaluationTest : public TestWithParam<int> 
Class:class ExternalGeneratorTest : public TestWithParam<int> 
Class:class MultipleInstantiationTest : public TestWithParam<int> 
Class:   class SeparateInstanceTest : public TestWithParam<int> { class SeparateInstanceTest : public TestWithParam<int> 
Class:class NamingTest : public TestWithParam<int> 
Class:     class Unstreamable { class Unstreamable 
Class:class CommentTest : public TestWithParam<Unstreamable> 
Class:     class NonParameterizedBaseTest : public ::testing::Test { class NonParameterizedBaseTest : public ::testing::Test 
Class: class ParameterizedDerivedTest : public NonParameterizedBaseTest,                                  public ::testing::WithParamInterface<int> {                                  public ::testing::WithParamInterface<int> 
Class:class Base { class Base 
Class:  class BiggestIntConvertible { class BiggestIntConvertible 
Class:  template <typename T> class UnprintableTemplateInGlobal { class UnprintableTemplateInGlobal 
Class:  class StreamableInGlobal { class StreamableInGlobal 
Class:class UnprintableInFoo { class UnprintableInFoo 
Class:  template <typename T> class PrintableViaPrintToTemplate { class PrintableViaPrintToTemplate 
Class:  template <typename T> class StreamableTemplateInFoo { class StreamableTemplateInFoo 
Class:class AllowsGenericStreaming 
Class:class AllowsGenericStreamingTemplate 
Class:    template <typename T> class AllowsGenericStreamingAndImplicitConversionTemplate { class AllowsGenericStreamingAndImplicitConversionTemplate 
Class:class TestPartResultTest : public Test { class TestPartResultTest : public Test 
Class:   class TestPartResultArrayTest : public Test { class TestPartResultArrayTest : public Test 
Class:class BigTupleTest : public testing::Test { class BigTupleTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(43, 1, u'+using ::testing::StaticAssertTypeEq;'), (47, 1, u'+  StaticAssertTypeEq<int, tuple_element<0, tuple<int, char> >::type>();'), (48, 1, u'+  StaticAssertTypeEq<int&, tuple_element<1, tuple<double, int&> >::type>();'), (49, 1, u'+  StaticAssertTypeEq<bool, tuple_element<2, tuple<double, int, bool> >::type>();')]
===========================================
Class:    template <typename T> class CommonTest : public Test { class CommonTest : public Test 
Class:    template <typename T> class TypedTest1 : public Test { class TypedTest1 : public Test 
Class: template <typename T> class TypedTest2 : public Test { class TypedTest2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
Class:   class TypedTestCasePStateTest : public Test { class TypedTestCasePStateTest : public Test 
Class:    template <typename T> class DerivedTest : public CommonTest<T> { class DerivedTest : public CommonTest<T> 
Class:    template <typename T> class TypedTestP1 : public Test { class TypedTestP1 : public Test 
Class: template <typename T> class TypedTestP2 : public Test { class TypedTestP2 : public Test 
Class:class NumericTest : public Test { class NumericTest : public Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(120, 1, u'+  ASSERT_TRUE(this->shared_ != NULL);'), (257, 1, u'+  ASSERT_TRUE(this->shared_ != NULL);')]
===========================================
Class:class UnitTestHelper { class UnitTestHelper 
Class:class FinalSuccessChecker : public Environment { class FinalSuccessChecker : public Environment 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(117, 1, u'+  ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (140, 1, u'+AssertionResult IsNull(const char* str) {'), (142, 1, u'+    return testing::AssertionFailure() << "argument is " << str;'), (144, 1, u'+  return AssertionSuccess();'), (149, 1, u'+  ASSERT_TRUE(test_case != NULL);'), (156, 1, u'+  ASSERT_EQ(4, test_case->total_test_count());'), (189, 1, u'+  ASSERT_TRUE(test_case != NULL);'), (196, 1, u'+  ASSERT_EQ(1, test_case->total_test_count());'), (212, 1, u'+  ASSERT_TRUE(test_case != NULL);'), (219, 1, u'+  ASSERT_EQ(1, test_case->total_test_count());'), (245, 1, u'+    ASSERT_EQ(2 + kTypedTestCases, unit_test->total_test_case_count());'), (253, 1, u'+    ASSERT_EQ(4, test_cases[0]->total_test_count());'), (263, 1, u'+    ASSERT_EQ(1, test_cases[1]->total_test_count());'), (272, 1, u'+    ASSERT_EQ(1, test_cases[2]->total_test_count());')]
===========================================
Class: class SehExceptionInDestructorTest : public Test { class SehExceptionInDestructorTest : public Test 
Class: class SehExceptionInSetUpTestCaseTest : public Test { class SehExceptionInSetUpTestCaseTest : public Test 
Class: class SehExceptionInTearDownTestCaseTest : public Test { class SehExceptionInTearDownTestCaseTest : public Test 
Class: class SehExceptionInSetUpTest : public Test { class SehExceptionInSetUpTest : public Test 
Class: class SehExceptionInTearDownTest : public Test { class SehExceptionInTearDownTest : public Test 
Class: class CxxExceptionInDestructorTest : public Test { class CxxExceptionInDestructorTest : public Test 
Class: class CxxExceptionInSetUpTestCaseTest : public Test { class CxxExceptionInSetUpTestCaseTest : public Test 
Class: class CxxExceptionInTearDownTestCaseTest : public Test { class CxxExceptionInTearDownTestCaseTest : public Test 
Class: class CxxExceptionInSetUpTest : public Test { class CxxExceptionInSetUpTest : public Test 
Class: class CxxExceptionInTearDownTest : public Test { class CxxExceptionInTearDownTest : public Test 
Class: class CxxExceptionInTestBodyTest : public Test { class CxxExceptionInTestBodyTest : public Test 
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(41, 1, u'+  ASSERT_TRUE(false) << "Tests shouldn\'t be run when --help is specified.";')]
===========================================
Class:class FooTest : public testing::Test { class FooTest : public testing::Test 
Class:class FailingParamTest : public testing::TestWithParam<int> 
Class:  class NonFatalFailureInFixtureConstructorTest : public testing::Test { class NonFatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class FatalFailureInFixtureConstructorTest : public testing::Test { class FatalFailureInFixtureConstructorTest : public testing::Test 
Class:  class NonFatalFailureInSetUpTest : public testing::Test { class NonFatalFailureInSetUpTest : public testing::Test 
Class:  class FatalFailureInSetUpTest : public testing::Test { class FatalFailureInSetUpTest : public testing::Test 
Class:    class DeathTestAndMultiThreadsTest : public testing::Test { class DeathTestAndMultiThreadsTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class:class MixedUpTestCaseTest : public testing::Test { class MixedUpTestCaseTest : public testing::Test 
Class: class MixedUpTestCaseWithSameTestNameTest : public testing::Test { class MixedUpTestCaseWithSameTestNameTest : public testing::Test 
Class: class TEST_before_TEST_F_in_same_test_case : public testing::Test { class TEST_before_TEST_F_in_same_test_case : public testing::Test 
Class:    class FooEnvironment : public testing::Environment { class FooEnvironment : public testing::Environment 
Class: class BarEnvironment : public testing::Environment { class BarEnvironment : public testing::Environment 
Class:   class Predicate1Test : public testing::Test { class Predicate1Test : public testing::Test 
Class:   class Predicate2Test : public testing::Test { class Predicate2Test : public testing::Test 
Class:   class Predicate3Test : public testing::Test { class Predicate3Test : public testing::Test 
Class:   class Predicate4Test : public testing::Test { class Predicate4Test : public testing::Test 
Class:   class Predicate5Test : public testing::Test { class Predicate5Test : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(101, 1, u'+testing::AssertionResult PredFormatFunction1(const char* e1,'), (104, 1, u'+    return testing::AssertionSuccess();'), (106, 1, u'+  return testing::AssertionFailure()'), (115, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (161, 1, u'+typedef Predicate1Test ASSERT_PRED_FORMAT1Test;'), (163, 1, u'+typedef Predicate1Test ASSERT_PRED1Test;'), (239, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeSuccess) {'), (240, 1, u'+  ASSERT_PRED1(PredFunction1Int,'), (247, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeSuccess) {'), (248, 1, u'+  ASSERT_PRED1(PredFunction1Bool,'), (255, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeSuccess) {'), (256, 1, u'+  ASSERT_PRED1(PredFunctor1(),'), (263, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeSuccess) {'), (264, 1, u'+  ASSERT_PRED1(PredFunctor1(),'), (271, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnBuiltInTypeFailure) {'), (274, 1, u'+    ASSERT_PRED1(PredFunction1Int,'), (282, 1, u'+TEST_F(ASSERT_PRED1Test, FunctionOnUserTypeFailure) {'), (285, 1, u'+    ASSERT_PRED1(PredFunction1Bool,'), (293, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnBuiltInTypeFailure) {'), (296, 1, u'+    ASSERT_PRED1(PredFunctor1(),'), (304, 1, u'+TEST_F(ASSERT_PRED1Test, FunctorOnUserTypeFailure) {'), (307, 1, u'+    ASSERT_PRED1(PredFunctor1(),'), (387, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeSuccess) {'), (388, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (395, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeSuccess) {'), (396, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (403, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeSuccess) {'), (404, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (411, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeSuccess) {'), (412, 1, u'+  ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (419, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnBuiltInTypeFailure) {'), (422, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (430, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctionOnUserTypeFailure) {'), (433, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunction1,'), (441, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnBuiltInTypeFailure) {'), (444, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (452, 1, u'+TEST_F(ASSERT_PRED_FORMAT1Test, FunctorOnUserTypeFailure) {'), (455, 1, u'+    ASSERT_PRED_FORMAT1(PredFormatFunctor1(),'), (489, 1, u'+testing::AssertionResult PredFormatFunction2(const char* e1,'), (494, 1, u'+    return testing::AssertionSuccess();'), (496, 1, u'+  return testing::AssertionFailure()'), (505, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (558, 1, u'+typedef Predicate2Test ASSERT_PRED_FORMAT2Test;'), (560, 1, u'+typedef Predicate2Test ASSERT_PRED2Test;'), (644, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeSuccess) {'), (645, 1, u'+  ASSERT_PRED2(PredFunction2Int,'), (653, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeSuccess) {'), (654, 1, u'+  ASSERT_PRED2(PredFunction2Bool,'), (662, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeSuccess) {'), (663, 1, u'+  ASSERT_PRED2(PredFunctor2(),'), (671, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeSuccess) {'), (672, 1, u'+  ASSERT_PRED2(PredFunctor2(),'), (680, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnBuiltInTypeFailure) {'), (683, 1, u'+    ASSERT_PRED2(PredFunction2Int,'), (692, 1, u'+TEST_F(ASSERT_PRED2Test, FunctionOnUserTypeFailure) {'), (695, 1, u'+    ASSERT_PRED2(PredFunction2Bool,'), (704, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnBuiltInTypeFailure) {'), (707, 1, u'+    ASSERT_PRED2(PredFunctor2(),'), (716, 1, u'+TEST_F(ASSERT_PRED2Test, FunctorOnUserTypeFailure) {'), (719, 1, u'+    ASSERT_PRED2(PredFunctor2(),'), (808, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeSuccess) {'), (809, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (817, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeSuccess) {'), (818, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (826, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeSuccess) {'), (827, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (835, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeSuccess) {'), (836, 1, u'+  ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (844, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnBuiltInTypeFailure) {'), (847, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (856, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctionOnUserTypeFailure) {'), (859, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunction2,'), (868, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnBuiltInTypeFailure) {'), (871, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (880, 1, u'+TEST_F(ASSERT_PRED_FORMAT2Test, FunctorOnUserTypeFailure) {'), (883, 1, u'+    ASSERT_PRED_FORMAT2(PredFormatFunctor2(),'), (919, 1, u'+testing::AssertionResult PredFormatFunction3(const char* e1,'), (926, 1, u'+    return testing::AssertionSuccess();'), (928, 1, u'+  return testing::AssertionFailure()'), (937, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (997, 1, u'+typedef Predicate3Test ASSERT_PRED_FORMAT3Test;'), (999, 1, u'+typedef Predicate3Test ASSERT_PRED3Test;'), (1091, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeSuccess) {'), (1092, 1, u'+  ASSERT_PRED3(PredFunction3Int,'), (1101, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeSuccess) {'), (1102, 1, u'+  ASSERT_PRED3(PredFunction3Bool,'), (1111, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeSuccess) {'), (1112, 1, u'+  ASSERT_PRED3(PredFunctor3(),'), (1121, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeSuccess) {'), (1122, 1, u'+  ASSERT_PRED3(PredFunctor3(),'), (1131, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnBuiltInTypeFailure) {'), (1134, 1, u'+    ASSERT_PRED3(PredFunction3Int,'), (1144, 1, u'+TEST_F(ASSERT_PRED3Test, FunctionOnUserTypeFailure) {'), (1147, 1, u'+    ASSERT_PRED3(PredFunction3Bool,'), (1157, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnBuiltInTypeFailure) {'), (1160, 1, u'+    ASSERT_PRED3(PredFunctor3(),'), (1170, 1, u'+TEST_F(ASSERT_PRED3Test, FunctorOnUserTypeFailure) {'), (1173, 1, u'+    ASSERT_PRED3(PredFunctor3(),'), (1271, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeSuccess) {'), (1272, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1281, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeSuccess) {'), (1282, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1291, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeSuccess) {'), (1292, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1301, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeSuccess) {'), (1302, 1, u'+  ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1311, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnBuiltInTypeFailure) {'), (1314, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1324, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctionOnUserTypeFailure) {'), (1327, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunction3,'), (1337, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnBuiltInTypeFailure) {'), (1340, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1350, 1, u'+TEST_F(ASSERT_PRED_FORMAT3Test, FunctorOnUserTypeFailure) {'), (1353, 1, u'+    ASSERT_PRED_FORMAT3(PredFormatFunctor3(),'), (1391, 1, u'+testing::AssertionResult PredFormatFunction4(const char* e1,'), (1400, 1, u'+    return testing::AssertionSuccess();'), (1402, 1, u'+  return testing::AssertionFailure()'), (1411, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (1478, 1, u'+typedef Predicate4Test ASSERT_PRED_FORMAT4Test;'), (1480, 1, u'+typedef Predicate4Test ASSERT_PRED4Test;'), (1580, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeSuccess) {'), (1581, 1, u'+  ASSERT_PRED4(PredFunction4Int,'), (1591, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeSuccess) {'), (1592, 1, u'+  ASSERT_PRED4(PredFunction4Bool,'), (1602, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeSuccess) {'), (1603, 1, u'+  ASSERT_PRED4(PredFunctor4(),'), (1613, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeSuccess) {'), (1614, 1, u'+  ASSERT_PRED4(PredFunctor4(),'), (1624, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnBuiltInTypeFailure) {'), (1627, 1, u'+    ASSERT_PRED4(PredFunction4Int,'), (1638, 1, u'+TEST_F(ASSERT_PRED4Test, FunctionOnUserTypeFailure) {'), (1641, 1, u'+    ASSERT_PRED4(PredFunction4Bool,'), (1652, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnBuiltInTypeFailure) {'), (1655, 1, u'+    ASSERT_PRED4(PredFunctor4(),'), (1666, 1, u'+TEST_F(ASSERT_PRED4Test, FunctorOnUserTypeFailure) {'), (1669, 1, u'+    ASSERT_PRED4(PredFunctor4(),'), (1776, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeSuccess) {'), (1777, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1787, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeSuccess) {'), (1788, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1798, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeSuccess) {'), (1799, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1809, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeSuccess) {'), (1810, 1, u'+  ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1820, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnBuiltInTypeFailure) {'), (1823, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1834, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctionOnUserTypeFailure) {'), (1837, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunction4,'), (1848, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnBuiltInTypeFailure) {'), (1851, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1862, 1, u'+TEST_F(ASSERT_PRED_FORMAT4Test, FunctorOnUserTypeFailure) {'), (1865, 1, u'+    ASSERT_PRED_FORMAT4(PredFormatFunctor4(),'), (1905, 1, u'+testing::AssertionResult PredFormatFunction5(const char* e1,'), (1916, 1, u'+    return testing::AssertionSuccess();'), (1918, 1, u'+  return testing::AssertionFailure()'), (1927, 1, u'+  testing::AssertionResult operator()(const char* e1,'), (2001, 1, u'+typedef Predicate5Test ASSERT_PRED_FORMAT5Test;'), (2003, 1, u'+typedef Predicate5Test ASSERT_PRED5Test;'), (2111, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeSuccess) {'), (2112, 1, u'+  ASSERT_PRED5(PredFunction5Int,'), (2123, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeSuccess) {'), (2124, 1, u'+  ASSERT_PRED5(PredFunction5Bool,'), (2135, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeSuccess) {'), (2136, 1, u'+  ASSERT_PRED5(PredFunctor5(),'), (2147, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeSuccess) {'), (2148, 1, u'+  ASSERT_PRED5(PredFunctor5(),'), (2159, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnBuiltInTypeFailure) {'), (2162, 1, u'+    ASSERT_PRED5(PredFunction5Int,'), (2174, 1, u'+TEST_F(ASSERT_PRED5Test, FunctionOnUserTypeFailure) {'), (2177, 1, u'+    ASSERT_PRED5(PredFunction5Bool,'), (2189, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnBuiltInTypeFailure) {'), (2192, 1, u'+    ASSERT_PRED5(PredFunctor5(),'), (2204, 1, u'+TEST_F(ASSERT_PRED5Test, FunctorOnUserTypeFailure) {'), (2207, 1, u'+    ASSERT_PRED5(PredFunctor5(),'), (2323, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeSuccess) {'), (2324, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2335, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeSuccess) {'), (2336, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2347, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeSuccess) {'), (2348, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2359, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeSuccess) {'), (2360, 1, u'+  ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2371, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnBuiltInTypeFailure) {'), (2374, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2386, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctionOnUserTypeFailure) {'), (2389, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunction5,'), (2401, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnBuiltInTypeFailure) {'), (2404, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),'), (2416, 1, u'+TEST_F(ASSERT_PRED_FORMAT5Test, FunctorOnUserTypeFailure) {'), (2419, 1, u'+    ASSERT_PRED_FORMAT5(PredFormatFunctor5(),')]
===========================================
Class:class MyEnvironment : public testing::Environment { class MyEnvironment : public testing::Environment 
Class:class MyParamTest : public testing::TestWithParam<int> 
Class:class A : public Test 
Class:   class TestNamePrinter : public EmptyTestEventListener { class TestNamePrinter : public EmptyTestEventListener 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(50, 1, u'+TEST(NoFatalFailureTest, AssertNoFatalFailure) {'), (51, 1, u'+  ASSERT_NO_FATAL_FAILURE(;);'), (52, 1, u'+  ASSERT_NO_FATAL_FAILURE(SUCCEED());'), (53, 1, u'+  ASSERT_NO_FATAL_FAILURE(Subroutine());'), (54, 1, u'+  ASSERT_NO_FATAL_FAILURE({ SUCCEED(); });')]
===========================================
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(83, 1, u'+  ASSERT_TRUE(property != properties.end())'), (90, 1, u'+void ManyAsserts(int id) {'), (100, 1, u'+    ASSERT_FALSE(false) << "This shouldn\'t fail.";'), (102, 1, u'+    ASSERT_LE(5, 6);'), (128, 1, u'+TEST(StressTest, CanUseScopedTraceAndAssertionsInManyThreads) {'), (133, 1, u'+      threads[i].reset(new ThreadWithParam<int>(&ManyAsserts,'), (186, 1, u'+void AssertNoFatalFailureIgnoresFailuresInOtherThreads() {'), (187, 1, u'+  ASSERT_NO_FATAL_FAILURE(GenerateFatalFailureInAnotherThread(true));'), (189, 1, u'+TEST(NoFatalFailureTest, AssertNoFatalFailureIgnoresFailuresInOtherThreads) {'), (191, 1, u'+  AssertNoFatalFailureIgnoresFailuresInOtherThreads();')]
===========================================
Class:class TestEventListenersAccessor { class TestEventListenersAccessor 
Class:class SubClassOfTest : public Test 
Class:class AnotherSubClassOfTest : public Test 
Class: class VectorShuffleTest : public Test { class VectorShuffleTest : public Test 
Class: class ScopedFakeTestPartResultReporterTest : public Test { class ScopedFakeTestPartResultReporterTest : public Test 
Class:    class TestResultTest : public Test { class TestResultTest : public Test 
Class:   class GTestFlagSaverTest : public Test { class GTestFlagSaverTest : public Test 
Class: class ShouldShardTest : public testing::Test { class ShouldShardTest : public testing::Test 
Class:   class DisabledTestsTest : public Test { class DisabledTestsTest : public Test 
Class: template <typename T> class DISABLED_TypedTest : public Test { class DISABLED_TypedTest : public Test 
Class: template <typename T> class DISABLED_TypedTestP : public Test { class DISABLED_TypedTestP : public Test 
Class:  class Uncopyable { class Uncopyable 
Class:class UnprintableChar { class UnprintableChar 
Class:     class Foo { class Foo 
Class:  class FRIEND_TEST_Test2 : public Test { class FRIEND_TEST_Test2 : public Test 
Class:       class TestLifeCycleTest : public Test { class TestLifeCycleTest : public Test 
Class:   class Base { class Base 
Class:class MyTypeInUnnamedNameSpace : public Base { class MyTypeInUnnamedNameSpace : public Base 
Class:class MyTypeInNameSpace1 : public Base { class MyTypeInNameSpace1 : public Base 
Class:class MyTypeInNameSpace2 : public ::Base { class MyTypeInNameSpace2 : public ::Base 
Class:class TestInfoTest : public Test { class TestInfoTest : public Test 
Class:   class SetUpTestCaseTest : public Test { class SetUpTestCaseTest : public Test 
Class:  class InitGoogleTestTest : public Test { class InitGoogleTestTest : public Test 
Class:class Test 
Class:class Message 
Class:class AssertionResult 
Class:   template <typename T> class StaticAssertTypeEqTestHelper { class StaticAssertTypeEqTestHelper 
Class: class TestListener : public EmptyTestEventListener { class TestListener : public EmptyTestEventListener 
Class:    class SequenceTestingListener : public EmptyTestEventListener { class SequenceTestingListener : public EmptyTestEventListener 
Class:class ConversionHelperBase 
Class:class ConversionHelperDerived : public ConversionHelperBase 
Class:class NonContainer 
Class: class SuccessfulTest : public Test { class SuccessfulTest : public Test 
Class: class FailedTest : public Test { class FailedTest : public Test 
Class: class DisabledTest : public Test { class DisabledTest : public Test 
Class: class PropertyRecordingTest : public Test { class PropertyRecordingTest : public Test 
Class:class ValueParamTest : public TestWithParam<int> 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(56, 1, u'+  ASSERT_EQ(1, 1);'), (63, 1, u'+  ASSERT_EQ(1, 2);'), (75, 1, u'+  ASSERT_EQ(1, 1);'), (80, 1, u'+  ASSERT_EQ(2, 3);')]
===========================================
Class:class BetweenCardinalityImpl : public CardinalityInterface { class BetweenCardinalityImpl : public CardinalityInterface 
Class:class GoogleTestFailureReporter : public FailureReporterInterface { class GoogleTestFailureReporter : public FailureReporterInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(80, 1, u'+    AssertHelper(type == FATAL ?')]
===========================================
Class:class MockObjectRegistry { class MockObjectRegistry 
Class:class MyActionImpl : public ActionInterface<MyFunction> { class MyActionImpl : public ActionInterface<MyFunction> 
Class:    class IsNotZero : public ActionInterface<bool(int)> {   class IsNotZero : public ActionInterface<bool(int)> 
Class:   class ReturnZeroFromNullaryFunctionAction { class ReturnZeroFromNullaryFunctionAction 
Class:     class FromType { class FromType 
Class: class ToType { class ToType 
Class:class DestinationType 
Class: class SourceType { class SourceType 
Class:class MyClass 
Class: class MockClass { class MockClass 
Class: class NullaryFunctor { class NullaryFunctor 
Class: class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:class MockFoo { class MockFoo 
Class:    class EvenCardinality : public CardinalityInterface { class EvenCardinality : public CardinalityInterface 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class SubstractAction : public ActionInterface<int(int, int)> {   class SubstractAction : public ActionInterface<int(int, int)> 
Class: class NullaryConstructorClass { class NullaryConstructorClass 
Class: class UnaryConstructorClass { class UnaryConstructorClass 
Class: class TenArgConstructorClass { class TenArgConstructorClass 
Class:  class BoolResetter { class BoolResetter 
Class:class FooInterface { class FooInterface 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(44, 1, u'+using ::testing::internal::CompileAssertTypesEqual;'), (52, 1, u'+  CompileAssertTypesEqual<tuple<>, MatcherTuple<tuple<> >::type>();'), (56, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<int> >,'), (61, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char> >,'), (66, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<int>, Matcher<char>, Matcher<bool>,'), (76, 1, u'+  CompileAssertTypesEqual<int, F::Result>();'), (77, 1, u'+  CompileAssertTypesEqual<tuple<>, F::ArgumentTuple>();'), (78, 1, u'+  CompileAssertTypesEqual<tuple<>, F::ArgumentMatcherTuple>();'), (79, 1, u'+  CompileAssertTypesEqual<void(), F::MakeResultVoid>();'), (80, 1, u'+  CompileAssertTypesEqual<IgnoredValue(), F::MakeResultIgnoredValue>();'), (85, 1, u'+  CompileAssertTypesEqual<int, F::Result>();'), (86, 1, u'+  CompileAssertTypesEqual<bool, F::Argument1>();'), (87, 1, u'+  CompileAssertTypesEqual<tuple<bool>, F::ArgumentTuple>();'), (88, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<bool> >, F::ArgumentMatcherTuple>();'), (89, 1, u'+  CompileAssertTypesEqual<void(bool), F::MakeResultVoid>();  // NOLINT'), (90, 1, u'+  CompileAssertTypesEqual<IgnoredValue(bool),  // NOLINT'), (96, 1, u'+  CompileAssertTypesEqual<int, F::Result>();'), (97, 1, u'+  CompileAssertTypesEqual<bool, F::Argument1>();'), (98, 1, u'+  CompileAssertTypesEqual<const long&, F::Argument2>();  // NOLINT'), (99, 1, u'+  CompileAssertTypesEqual<tuple<bool, const long&>, F::ArgumentTuple>();  // NOLINT'), (100, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<const long&> >,  // NOLINT'), (102, 1, u'+  CompileAssertTypesEqual<void(bool, const long&), F::MakeResultVoid>();  // NOLINT'), (103, 1, u'+  CompileAssertTypesEqual<IgnoredValue(bool, const long&),  // NOLINT'), (109, 1, u'+  CompileAssertTypesEqual<char, F::Result>();'), (110, 1, u'+  CompileAssertTypesEqual<bool, F::Argument1>();'), (111, 1, u'+  CompileAssertTypesEqual<int, F::Argument2>();'), (112, 1, u'+  CompileAssertTypesEqual<char*, F::Argument3>();'), (113, 1, u'+  CompileAssertTypesEqual<int&, F::Argument4>();'), (114, 1, u'+  CompileAssertTypesEqual<const long&, F::Argument5>();  // NOLINT'), (115, 1, u'+  CompileAssertTypesEqual<tuple<bool, int, char*, int&, const long&>,  // NOLINT'), (117, 1, u'+  CompileAssertTypesEqual<tuple<Matcher<bool>, Matcher<int>, Matcher<char*>,'), (120, 1, u'+  CompileAssertTypesEqual<void(bool, int, char*, int&, const long&),  // NOLINT'), (122, 1, u'+  CompileAssertTypesEqual<')]
===========================================
Class:class LessThanMatcher : public MatcherInterface<tuple<char, int> > { class LessThanMatcher : public MatcherInterface<tuple<char, int> > 
Class:  class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class: class NativeArrayPassedAsPointerAndSize { class NativeArrayPassedAsPointerAndSize 
Class:    class UncopyableFoo { class UncopyableFoo 
Class:class Message;
Class:class Base 
Class:class Derived : public Base 
Class:class LogIsVisibleTest : public ::testing::Test { class LogIsVisibleTest : public ::testing::Test 
Class: class DummyMock { class DummyMock 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(100, 1, u'+  CompileAssertTypesEqual<const char,'), (105, 1, u'+  CompileAssertTypesEqual<int, PointeeOf<int*>::type>();'), (106, 1, u'+  CompileAssertTypesEqual<const char, PointeeOf<const char*>::type>();'), (107, 1, u'+  CompileAssertTypesEqual<void, PointeeOf<void*>::type>();'), (308, 1, u'+TEST(AssertTest, SucceedsOnTrue) {'), (309, 1, u'+  Assert(true, __FILE__, __LINE__, "This should succeed.");'), (310, 1, u'+  Assert(true, __FILE__, __LINE__);  // This should succeed too.'), (314, 1, u'+TEST(AssertTest, FailsFatallyOnFalse) {'), (316, 1, u'+    Assert(false, __FILE__, __LINE__, "This should fail.");'), (320, 1, u'+    Assert(false, __FILE__, __LINE__);'), (583, 1, u'+  StaticAssertTypeEq<std::vector<int>,'), (585, 1, u'+  StaticAssertTypeEq<const std::vector<double>&,'), (599, 1, u'+  StaticAssertTypeEq<NativeArray<int>,'), (601, 1, u'+  StaticAssertTypeEq<NativeArray<double>,'), (603, 1, u'+  StaticAssertTypeEq<NativeArray<char[3]>,'), (606, 1, u'+  StaticAssertTypeEq<const NativeArray<int>,'), (615, 1, u'+  ASSERT_EQ(3U, a3.size());'), (626, 1, u'+  StaticAssertTypeEq<NativeArray<int>,'), (628, 1, u'+  StaticAssertTypeEq<NativeArray<double>,'), (631, 1, u'+  StaticAssertTypeEq<const NativeArray<int>,'), (643, 1, u'+  ASSERT_EQ(3U, a3.size());')]
===========================================
Class:class GreaterThanMatcher : public MatcherInterface<int> { class GreaterThanMatcher : public MatcherInterface<int> 
Class:class NullaryFunctor { class NullaryFunctor 
Class:class VoidNullaryFunctor { class VoidNullaryFunctor 
Class: class Foo { class Foo 
Class:   class DeletionTester { class DeletionTester 
Class:class MyException 
Class:class Foo { class Foo 
Class:class ExpectationTester { class ExpectationTester 
Class:class Incomplete;
Class: class MockIncomplete { class MockIncomplete 
Class:class Result 
Class: class MockA { class MockA 
Class: class MockB { class MockB 
Class:class MockCC : public CC { class MockCC : public CC 
Class: class EvenNumberCardinality : public CardinalityInterface { class EvenNumberCardinality : public CardinalityInterface 
Class: class MockC { class MockC 
Class: class VerboseFlagPreservingFixture : public testing::Test { class VerboseFlagPreservingFixture : public testing::Test 
Class:   class GMockVerboseFlagTest : public VerboseFlagPreservingFixture { class GMockVerboseFlagTest : public VerboseFlagPreservingFixture 
Class:class PrintMeNot 
Class: class LogTestHelper { class LogTestHelper 
Class: class GMockLogTest : public VerboseFlagPreservingFixture { class GMockLogTest : public VerboseFlagPreservingFixture 
Class:class FooInterface { class FooInterface 
Class: class MockFoo : public FooInterface { class MockFoo : public FooInterface 
Class: class MockFoo { class MockFoo 
Class: class GMockOutputTest : public testing::Test { class GMockOutputTest : public testing::Test 
===========================================
Mock_Function_For_Asserts
0
0
0
0
[(54, 1, u'+  ASSERT_EQ(N, argc) << "The new argv has wrong number of elements.";')]
===========================================
201
Mismatch count:23332
Normal count:394206
